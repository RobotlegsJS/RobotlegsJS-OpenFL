/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./example/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./example/Game.ts":
/*!*************************!*\
  !*** ./example/Game.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var src_1 = __webpack_require__(/*! ../src */ "./src/index.ts");
var MyConfig_1 = __webpack_require__(/*! ./config/MyConfig */ "./example/config/MyConfig.ts");
var GameView_1 = __webpack_require__(/*! ./view/GameView */ "./example/view/GameView.ts");
var Stage_1 = __webpack_require__(/*! openfl/display/Stage */ "./node_modules/openfl/lib/openfl/display/Stage.js");
var Game = /** @class */ (function () {
    function Game() {
        this.init();
    }
    Game.prototype.init = function () {
        // remove loader
        this._loading = document.getElementById("loading");
        this._loading.remove();
        // create stage
        this._stage = new Stage_1.default(960, 400, 0xffffff, GameView_1.GameView);
        // create robotlegs context
        this._context = new core_1.Context();
        this._context
            .install(core_1.MVCSBundle, src_1.OpenFLBundle)
            .configure(new src_1.ContextView(this._stage))
            .configure(MyConfig_1.MyConfig)
            .initialize();
        // add stage to html body
        this._canvas = document.getElementById("canvas");
        this._canvas.appendChild(this._stage.element);
    };
    return Game;
}());
exports.Game = Game;


/***/ }),

/***/ "./example/config/MyConfig.ts":
/*!************************************!*\
  !*** ./example/config/MyConfig.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var src_1 = __webpack_require__(/*! ../../src */ "./src/index.ts");
var RobotlegsMediator_1 = __webpack_require__(/*! ../mediator/RobotlegsMediator */ "./example/mediator/RobotlegsMediator.ts");
var SmileyMediator_1 = __webpack_require__(/*! ../mediator/SmileyMediator */ "./example/mediator/SmileyMediator.ts");
var RobotlegsView_1 = __webpack_require__(/*! ../view/RobotlegsView */ "./example/view/RobotlegsView.ts");
var SmileyView_1 = __webpack_require__(/*! ../view/SmileyView */ "./example/view/SmileyView.ts");
var MyConfig = /** @class */ (function () {
    function MyConfig() {
    }
    MyConfig.prototype.configure = function () {
        this._mediatorMap.map(RobotlegsView_1.RobotlegsView).toMediator(RobotlegsMediator_1.RobotlegsMediator);
        this._mediatorMap.map(SmileyView_1.SmileyView).toMediator(SmileyMediator_1.SmileyMediator);
    };
    __decorate([
        core_1.inject(src_1.IMediatorMap),
        __metadata("design:type", Object)
    ], MyConfig.prototype, "_mediatorMap", void 0);
    MyConfig = __decorate([
        core_1.injectable()
    ], MyConfig);
    return MyConfig;
}());
exports.MyConfig = MyConfig;


/***/ }),

/***/ "./example/index.ts":
/*!**************************!*\
  !*** ./example/index.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var Game_1 = __webpack_require__(/*! ./Game */ "./example/Game.ts");
window.initGame = function () {
    var game = new Game_1.Game();
    window.game = game;
};


/***/ }),

/***/ "./example/mediator/RobotlegsMediator.ts":
/*!***********************************************!*\
  !*** ./example/mediator/RobotlegsMediator.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var src_1 = __webpack_require__(/*! ../../src */ "./src/index.ts");
var SmileyView_1 = __webpack_require__(/*! ../view/SmileyView */ "./example/view/SmileyView.ts");
var MouseEvent_1 = __webpack_require__(/*! openfl/events/MouseEvent */ "./node_modules/openfl/lib/openfl/events/MouseEvent.js");
var RobotlegsMediator = /** @class */ (function (_super) {
    __extends(RobotlegsMediator, _super);
    function RobotlegsMediator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onClick = function (event) {
            var radius = 50 + Math.random() * 50;
            _this.view.stage.addChild(new SmileyView_1.SmileyView(radius));
        };
        return _this;
    }
    RobotlegsMediator.prototype.initialize = function () {
        console.log("RobotlegsMediator initialized!");
        this.view.addEventListener(MouseEvent_1.default.CLICK, this.onClick);
    };
    RobotlegsMediator.prototype.destroy = function () {
        console.log("RobotlegsMediator destroyed!");
    };
    return RobotlegsMediator;
}(src_1.Mediator));
exports.RobotlegsMediator = RobotlegsMediator;


/***/ }),

/***/ "./example/mediator/SmileyMediator.ts":
/*!********************************************!*\
  !*** ./example/mediator/SmileyMediator.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var src_1 = __webpack_require__(/*! ../../src */ "./src/index.ts");
var MouseEvent_1 = __webpack_require__(/*! openfl/events/MouseEvent */ "./node_modules/openfl/lib/openfl/events/MouseEvent.js");
var SmileyMediator = /** @class */ (function (_super) {
    __extends(SmileyMediator, _super);
    function SmileyMediator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onClick = function (event) {
            _this.view.parent.removeChild(_this.view);
        };
        return _this;
    }
    SmileyMediator.prototype.initialize = function () {
        console.log("SmileyMediator initialized!");
        this.view.addEventListener(MouseEvent_1.default.CLICK, this.onClick);
    };
    SmileyMediator.prototype.destroy = function () {
        console.log("SmileyMediator destroyed!");
    };
    return SmileyMediator;
}(src_1.Mediator));
exports.SmileyMediator = SmileyMediator;


/***/ }),

/***/ "./example/view/GameView.ts":
/*!**********************************!*\
  !*** ./example/view/GameView.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var RobotlegsView_1 = __webpack_require__(/*! ./RobotlegsView */ "./example/view/RobotlegsView.ts");
var Sprite_1 = __webpack_require__(/*! openfl/display/Sprite */ "./node_modules/openfl/lib/openfl/display/Sprite.js");
var Event_1 = __webpack_require__(/*! openfl/events/Event */ "./node_modules/openfl/lib/openfl/events/Event.js");
var GameView = /** @class */ (function (_super) {
    __extends(GameView, _super);
    function GameView() {
        var _this = _super.call(this) || this;
        _this.onAddedToStage = function (event) {
            if (event.target === _this) {
                var robotlegs = new RobotlegsView_1.RobotlegsView();
                _this.addChild(robotlegs);
            }
        };
        _this.addEventListener(Event_1.default.ADDED_TO_STAGE, _this.onAddedToStage);
        return _this;
    }
    return GameView;
}(Sprite_1.default));
exports.GameView = GameView;


/***/ }),

/***/ "./example/view/RobotlegsView.ts":
/*!***************************************!*\
  !*** ./example/view/RobotlegsView.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Sprite_1 = __webpack_require__(/*! openfl/display/Sprite */ "./node_modules/openfl/lib/openfl/display/Sprite.js");
var Loader_1 = __webpack_require__(/*! openfl/display/Loader */ "./node_modules/openfl/lib/openfl/display/Loader.js");
var URLRequest_1 = __webpack_require__(/*! openfl/net/URLRequest */ "./node_modules/openfl/lib/openfl/net/URLRequest.js");
var Event_1 = __webpack_require__(/*! openfl/events/Event */ "./node_modules/openfl/lib/openfl/events/Event.js");
var RobotlegsView = /** @class */ (function (_super) {
    __extends(RobotlegsView, _super);
    function RobotlegsView() {
        var _this = _super.call(this) || this;
        _this.onAddedToStage = function (event) {
            if (event.target === _this) {
                _this.loadLogo();
                _this.enableButtonMode();
            }
        };
        _this.logoLoaded = function (event) {
            var bitmap = event.target.loader.content;
            bitmap.x = (_this.stage.stageWidth - bitmap.width) / 2;
            bitmap.y = (_this.stage.stageHeight - bitmap.height) / 2;
            _this.addChild(bitmap);
        };
        _this.addEventListener(Event_1.default.ADDED_TO_STAGE, _this.onAddedToStage);
        return _this;
    }
    RobotlegsView.prototype.loadLogo = function () {
        var loader = new Loader_1.default();
        loader.contentLoaderInfo.addEventListener(Event_1.default.COMPLETE, this.logoLoaded);
        loader.load(new URLRequest_1.default("images/robotlegs.png"));
    };
    RobotlegsView.prototype.enableButtonMode = function () {
        this.useHandCursor = true;
        this.mouseEnabled = true;
        this.mouseChildren = false;
        this.buttonMode = true;
    };
    return RobotlegsView;
}(Sprite_1.default));
exports.RobotlegsView = RobotlegsView;


/***/ }),

/***/ "./example/view/SmileyView.ts":
/*!************************************!*\
  !*** ./example/view/SmileyView.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Sprite_1 = __webpack_require__(/*! openfl/display/Sprite */ "./node_modules/openfl/lib/openfl/display/Sprite.js");
var Event_1 = __webpack_require__(/*! openfl/events/Event */ "./node_modules/openfl/lib/openfl/events/Event.js");
var SmileyView = /** @class */ (function (_super) {
    __extends(SmileyView, _super);
    function SmileyView(radius) {
        var _this = _super.call(this) || this;
        _this.onAddedToStage = function (event) {
            if (event.target === _this) {
                _this.drawSmiley();
                _this.move();
                _this.enableButtonMode();
            }
        };
        _this._radius = Math.max(radius, 50);
        _this.addEventListener(Event_1.default.ADDED_TO_STAGE, _this.onAddedToStage);
        return _this;
    }
    SmileyView.prototype.drawSmiley = function () {
        var graphics = this.graphics;
        // Head
        graphics.lineStyle(10, 0x000000);
        graphics.beginFill(0xffcc00);
        graphics.drawCircle(0, 0, this._radius);
        graphics.endFill();
        // Mouth
        graphics.lineStyle(10, 0x000000);
        graphics.beginFill(0xffcc00);
        this.drawArc(graphics, 0, 0, this._radius * 0.6, 0, 180, 1);
        graphics.endFill();
        // Right eye
        graphics.lineStyle(10, 0x000000);
        graphics.beginFill(0x000);
        graphics.drawCircle(-(this._radius / 3), -(this._radius / 4), this._radius / 8);
        graphics.endFill();
        // Left eye
        graphics.lineStyle(10, 0x000000);
        graphics.beginFill(0x000);
        graphics.drawCircle(this._radius / 3, -(this._radius / 4), this._radius / 8);
        graphics.endFill();
    };
    SmileyView.prototype.drawArc = function (graphics, centerX, centerY, radius, angleFrom, angleTo, precision) {
        var degToRad = 0.0174532925;
        var angleDiff = angleTo - angleFrom;
        var steps = Math.round(angleDiff * precision);
        var angle = angleFrom;
        var px = centerX + radius * Math.cos(angle * degToRad);
        var py = centerY + radius * Math.sin(angle * degToRad);
        graphics.moveTo(px, py);
        for (var i = 1; i <= steps; i++) {
            angle = angleFrom + (angleDiff / steps) * i;
            graphics.lineTo(centerX + radius * Math.cos(angle * degToRad), centerY + radius * Math.sin(angle * degToRad));
        }
    };
    SmileyView.prototype.move = function () {
        this.x = Math.random() * 960;
        this.y = Math.random() * 400;
        this.x = Math.max(this.x, this.width / 2);
        this.x = Math.min(this.x, 960 - this.width / 2);
        this.y = Math.max(this.y, this.height / 2);
        this.y = Math.min(this.y, 400 - this.height / 2);
    };
    SmileyView.prototype.enableButtonMode = function () {
        this.useHandCursor = true;
        this.mouseEnabled = true;
        this.mouseChildren = false;
        this.buttonMode = true;
    };
    return SmileyView;
}(Sprite_1.default));
exports.SmileyView = SmileyView;


/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Dependency injection
 */
var inversify_1 = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
exports.ContainerModule = inversify_1.ContainerModule;
exports.decorate = inversify_1.decorate;
exports.inject = inversify_1.inject;
exports.injectable = inversify_1.injectable;
exports.multiInject = inversify_1.multiInject;
exports.named = inversify_1.named;
exports.optional = inversify_1.optional;
exports.postConstruct = inversify_1.postConstruct;
exports.tagged = inversify_1.tagged;
exports.targetName = inversify_1.targetName;
exports.unmanaged = inversify_1.unmanaged;
var IContext_1 = __webpack_require__(/*! ./robotlegs/bender/framework/api/IContext */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IContext.js");
exports.IContext = IContext_1.IContext;
var IInjector_1 = __webpack_require__(/*! ./robotlegs/bender/framework/api/IInjector */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IInjector.js");
exports.IInjector = IInjector_1.IInjector;
var ILogger_1 = __webpack_require__(/*! ./robotlegs/bender/framework/api/ILogger */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/ILogger.js");
exports.ILogger = ILogger_1.ILogger;
var LifecycleError_1 = __webpack_require__(/*! ./robotlegs/bender/framework/api/LifecycleError */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleError.js");
exports.LifecycleError = LifecycleError_1.LifecycleError;
var LifecycleEvent_1 = __webpack_require__(/*! ./robotlegs/bender/framework/api/LifecycleEvent */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleEvent.js");
exports.LifecycleEvent = LifecycleEvent_1.LifecycleEvent;
var LifecycleState_1 = __webpack_require__(/*! ./robotlegs/bender/framework/api/LifecycleState */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleState.js");
exports.LifecycleState = LifecycleState_1.LifecycleState;
var LogLevel_1 = __webpack_require__(/*! ./robotlegs/bender/framework/api/LogLevel */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LogLevel.js");
exports.LogLevel = LogLevel_1.LogLevel;
var PinEvent_1 = __webpack_require__(/*! ./robotlegs/bender/framework/api/PinEvent */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/PinEvent.js");
exports.PinEvent = PinEvent_1.PinEvent;
/**
 * Framework Implementation
 */
var ConfigManager_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/ConfigManager */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ConfigManager.js");
exports.ConfigManager = ConfigManager_1.ConfigManager;
var Context_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/Context */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Context.js");
exports.Context = Context_1.Context;
var ExtensionInstaller_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/ExtensionInstaller */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ExtensionInstaller.js");
exports.ExtensionInstaller = ExtensionInstaller_1.ExtensionInstaller;
var Lifecycle_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/Lifecycle */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Lifecycle.js");
exports.Lifecycle = Lifecycle_1.Lifecycle;
var LifecycleTransition_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/LifecycleTransition */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/LifecycleTransition.js");
exports.LifecycleTransition = LifecycleTransition_1.LifecycleTransition;
var Logger_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/Logger */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Logger.js");
exports.Logger = Logger_1.Logger;
var LogManager_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/LogManager */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/LogManager.js");
exports.LogManager = LogManager_1.LogManager;
var MessageDispatcher_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/MessageDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/MessageDispatcher.js");
exports.MessageDispatcher = MessageDispatcher_1.MessageDispatcher;
var MessageRunner_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/MessageRunner */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/MessageRunner.js");
exports.MessageRunner = MessageRunner_1.MessageRunner;
var ObjectProcessor_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/ObjectProcessor */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectProcessor.js");
exports.ObjectProcessor = ObjectProcessor_1.ObjectProcessor;
var Pin_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/Pin */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Pin.js");
exports.Pin = Pin_1.Pin;
var RobotlegsInjector_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/RobotlegsInjector */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/RobotlegsInjector.js");
exports.RobotlegsInjector = RobotlegsInjector_1.RobotlegsInjector;
var UID_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/UID */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/UID.js");
exports.UID = UID_1.UID;
/**
 * Framework Functions
 */
var applyHooks_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/applyHooks */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/applyHooks.js");
exports.applyHooks = applyHooks_1.applyHooks;
var getQualifiedClassName_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/getQualifiedClassName */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/getQualifiedClassName.js");
exports.getQualifiedClassName = getQualifiedClassName_1.getQualifiedClassName;
var guardsApprove_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/guardsApprove */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/guardsApprove.js");
exports.guardsApprove = guardsApprove_1.guardsApprove;
var instantiateUnmapped_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/instantiateUnmapped */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/instantiateUnmapped.js");
exports.instantiateUnmapped = instantiateUnmapped_1.instantiateUnmapped;
var safelyCallBack_1 = __webpack_require__(/*! ./robotlegs/bender/framework/impl/safelyCallBack */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/safelyCallBack.js");
exports.safelyCallBack = safelyCallBack_1.safelyCallBack;
var IEventDispatcher_1 = __webpack_require__(/*! ./robotlegs/bender/events/api/IEventDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/api/IEventDispatcher.js");
exports.IEventDispatcher = IEventDispatcher_1.IEventDispatcher;
var Event_1 = __webpack_require__(/*! ./robotlegs/bender/events/impl/Event */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/Event.js");
exports.Event = Event_1.Event;
var EventDispatcher_1 = __webpack_require__(/*! ./robotlegs/bender/events/impl/EventDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/EventDispatcher.js");
exports.EventDispatcher = EventDispatcher_1.EventDispatcher;
/**
 * Extensions
 */
// CommandCenter
var CommandPayload_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/api/CommandPayload */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/api/CommandPayload.js");
exports.CommandPayload = CommandPayload_1.CommandPayload;
var ICommand_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/api/ICommand */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/api/ICommand.js");
exports.ICommand = ICommand_1.ICommand;
var Command_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/impl/Command */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/Command.js");
exports.Command = Command_1.Command;
var CommandExecutor_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/impl/CommandExecutor */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandExecutor.js");
exports.CommandExecutor = CommandExecutor_1.CommandExecutor;
var CommandMapper_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/impl/CommandMapper */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapper.js");
exports.CommandMapper = CommandMapper_1.CommandMapper;
var CommandMapping_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/impl/CommandMapping */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapping.js");
exports.CommandMapping = CommandMapping_1.CommandMapping;
var CommandMappingList_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/impl/CommandMappingList */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMappingList.js");
exports.CommandMappingList = CommandMappingList_1.CommandMappingList;
var CommandTriggerMap_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/impl/CommandTriggerMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandTriggerMap.js");
exports.CommandTriggerMap = CommandTriggerMap_1.CommandTriggerMap;
var NullCommandTrigger_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/commandCenter/impl/NullCommandTrigger */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/NullCommandTrigger.js");
exports.NullCommandTrigger = NullCommandTrigger_1.NullCommandTrigger;
// DirectCommandMap
var IDirectCommandMap_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/directCommandMap/api/IDirectCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/api/IDirectCommandMap.js");
exports.IDirectCommandMap = IDirectCommandMap_1.IDirectCommandMap;
var DirectCommandMap_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMap.js");
exports.DirectCommandMap = DirectCommandMap_1.DirectCommandMap;
var DirectCommandMapper_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMapper */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMapper.js");
exports.DirectCommandMapper = DirectCommandMapper_1.DirectCommandMapper;
var DirectCommandMapExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/directCommandMap/DirectCommandMapExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/DirectCommandMapExtension.js");
exports.DirectCommandMapExtension = DirectCommandMapExtension_1.DirectCommandMapExtension;
// EnhancedLogging
var ConsoleLogTarget_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/enhancedLogging/impl/ConsoleLogTarget */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/impl/ConsoleLogTarget.js");
exports.ConsoleLogTarget = ConsoleLogTarget_1.ConsoleLogTarget;
var LogMessageParser_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/enhancedLogging/impl/LogMessageParser */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/impl/LogMessageParser.js");
exports.LogMessageParser = LogMessageParser_1.LogMessageParser;
var ConsoleLoggingExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/enhancedLogging/ConsoleLoggingExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/ConsoleLoggingExtension.js");
exports.ConsoleLoggingExtension = ConsoleLoggingExtension_1.ConsoleLoggingExtension;
var InjectableLoggerExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/enhancedLogging/InjectableLoggerExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/InjectableLoggerExtension.js");
exports.InjectableLoggerExtension = InjectableLoggerExtension_1.InjectableLoggerExtension;
// EventCommandMap
var IEventCommandMap_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/eventCommandMap/api/IEventCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/api/IEventCommandMap.js");
exports.IEventCommandMap = IEventCommandMap_1.IEventCommandMap;
var EventCommandMap_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/eventCommandMap/impl/EventCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/impl/EventCommandMap.js");
exports.EventCommandMap = EventCommandMap_1.EventCommandMap;
var EventCommandTrigger_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/eventCommandMap/impl/EventCommandTrigger */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/impl/EventCommandTrigger.js");
exports.EventCommandTrigger = EventCommandTrigger_1.EventCommandTrigger;
var EventCommandMapExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/eventCommandMap/EventCommandMapExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/EventCommandMapExtension.js");
exports.EventCommandMapExtension = EventCommandMapExtension_1.EventCommandMapExtension;
// EventDispatcher
var EventRelay_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/eventDispatcher/impl/EventRelay */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/impl/EventRelay.js");
exports.EventRelay = EventRelay_1.EventRelay;
var LifecycleEventRelay_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/eventDispatcher/impl/LifecycleEventRelay */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/impl/LifecycleEventRelay.js");
exports.LifecycleEventRelay = LifecycleEventRelay_1.LifecycleEventRelay;
var EventDispatcherExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/eventDispatcher/EventDispatcherExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/EventDispatcherExtension.js");
exports.EventDispatcherExtension = EventDispatcherExtension_1.EventDispatcherExtension;
// LocalEventMap
var IEventMap_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/localEventMap/api/IEventMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/api/IEventMap.js");
exports.IEventMap = IEventMap_1.IEventMap;
var DomEventMapConfig_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/localEventMap/impl/DomEventMapConfig */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/DomEventMapConfig.js");
exports.DomEventMapConfig = DomEventMapConfig_1.DomEventMapConfig;
var EventMap_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/localEventMap/impl/EventMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/EventMap.js");
exports.EventMap = EventMap_1.EventMap;
var EventMapConfig_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/localEventMap/impl/EventMapConfig */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/EventMapConfig.js");
exports.EventMapConfig = EventMapConfig_1.EventMapConfig;
var LocalEventMapExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/localEventMap/LocalEventMapExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/LocalEventMapExtension.js");
exports.LocalEventMapExtension = LocalEventMapExtension_1.LocalEventMapExtension;
var TypeFilter_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/matching/TypeFilter */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeFilter.js");
exports.TypeFilter = TypeFilter_1.TypeFilter;
var TypeMatcher_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/matching/TypeMatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeMatcher.js");
exports.TypeMatcher = TypeMatcher_1.TypeMatcher;
var TypeMatcherError_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/matching/TypeMatcherError */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeMatcherError.js");
exports.TypeMatcherError = TypeMatcherError_1.TypeMatcherError;
// Matching helpers
var instanceOfType_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/matching/instanceOfType */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/instanceOfType.js");
exports.instanceOfType = instanceOfType_1.instanceOfType;
var isInstanceOfType_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/matching/isInstanceOfType */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/isInstanceOfType.js");
exports.isInstanceOfType = isInstanceOfType_1.isInstanceOfType;
/**
 * Bundles
 */
var MVCSBundle_1 = __webpack_require__(/*! ./robotlegs/bender/bundles/mvcs/MVCSBundle */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/bundles/mvcs/MVCSBundle.js");
exports.MVCSBundle = MVCSBundle_1.MVCSBundle;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/bundles/mvcs/MVCSBundle.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/bundles/mvcs/MVCSBundle.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var DirectCommandMapExtension_1 = __webpack_require__(/*! ../../extensions/directCommandMap/DirectCommandMapExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/DirectCommandMapExtension.js");
var InjectableLoggerExtension_1 = __webpack_require__(/*! ../../extensions/enhancedLogging/InjectableLoggerExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/InjectableLoggerExtension.js");
var ConsoleLoggingExtension_1 = __webpack_require__(/*! ../../extensions/enhancedLogging/ConsoleLoggingExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/ConsoleLoggingExtension.js");
var EventCommandMapExtension_1 = __webpack_require__(/*! ../../extensions/eventCommandMap/EventCommandMapExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/EventCommandMapExtension.js");
var EventDispatcherExtension_1 = __webpack_require__(/*! ../../extensions/eventDispatcher/EventDispatcherExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/EventDispatcherExtension.js");
var LocalEventMapExtension_1 = __webpack_require__(/*! ../../extensions/localEventMap/LocalEventMapExtension */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/LocalEventMapExtension.js");
/**
 * For that Classic Robotlegs flavour
 *
 * <p>This bundle installs a number of extensions commonly used
 * in typical Robotlegs applications and modules.</p>
 */
var MVCSBundle = /** @class */ (function () {
    function MVCSBundle() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    MVCSBundle.prototype.extend = function (context) {
        context.install(ConsoleLoggingExtension_1.ConsoleLoggingExtension, InjectableLoggerExtension_1.InjectableLoggerExtension, EventDispatcherExtension_1.EventDispatcherExtension, DirectCommandMapExtension_1.DirectCommandMapExtension, EventCommandMapExtension_1.EventCommandMapExtension, LocalEventMapExtension_1.LocalEventMapExtension);
    };
    return MVCSBundle;
}());
exports.MVCSBundle = MVCSBundle;
//# sourceMappingURL=MVCSBundle.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/api/IEventDispatcher.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/api/IEventDispatcher.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.IEventDispatcher = Symbol("IEventDispatcher");
//# sourceMappingURL=IEventDispatcher.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/Event.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/Event.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The Event class is used as the base class for the creation of Event objects, which are passed as parameters to event
 * listeners when an event occurs.The properties of the Event class carry basic information about an event, such as
 * the event's type or whether the event's default behavior can be canceled. For many events, such as the events represented
 * by the Event class constants, this basic information is sufficient. Other events, however, may require more detailed
 * information. Events associated with a touch tap, for example, need to include additional information about the
 * location of the touch event. You can pass such additional information to event listeners by extending the Event class,
 * which is what the TouchEvent class does. Egret API defines several Event subclasses for common events that require
 * additional information. Events associated with each of the Event subclasses are described in the documentation for
 * each class.The methods of the Event class can be used in event listener functions to affect the behavior of the event
 * object. Some events have an associated default behavior. Your event listener can cancel this behavior by calling the
 * preventDefault() method. You can also make the current event listener the last one to process an event by calling
 * the stopPropagation() or stopImmediatePropagation() method.
 * @see egret.EventDispatcher
 * @version Egret 2.4
 * @platform Web,Native
 * @includeExample egret/events/Event.ts
 * @see http://edn.egret.com/cn/docs/page/798 取消触摸事件
 * @language en_US
 */
var Event = /** @class */ (function () {
    /**
     * Creates an Event object to pass as a parameter to event listeners.
     * @param type  The type of the event, accessible as Event.type.
     * @param bubbles  Determines whether the Event object participates in the bubbling stage of the event flow. The default value is false.
     * @param cancelable Determines whether the Event object can be canceled. The default values is false.
     * @param data the optional data associated with this event
     * @version Egret 2.4
     * @platform Web,Native
     * @language en_US
     */
    function Event(type, bubbles, cancelable, data) {
        /**
         * @private
         */
        this._isDefaultPrevented = false;
        /**
         * @private
         */
        this._isPropagationStopped = false;
        /**
         * @private
         */
        this._isPropagationImmediateStopped = false;
        this._type = type;
        this._bubbles = !!bubbles;
        this._cancelable = !!cancelable;
        this._data = data;
    }
    /**
     * Cancels an event's default behavior if that behavior can be canceled.Many events have associated behaviors that
     * are carried out by default. For example, if a user types a character into a text input, the default behavior
     * is that the character is displayed in the text input. Because the TextEvent.TEXT_INPUT event's default behavior
     * can be canceled, you can use the preventDefault() method to prevent the character from appearing.
     * You can use the Event.cancelable property to check whether you can prevent the default behavior associated with
     * a particular event. If the value of Event.cancelable is true, then preventDefault() can be used to cancel the event;
     * otherwise, preventDefault() has no effect.
     * @see #cancelable
     * @see #isDefaultPrevented
     * @version Egret 2.4
     * @platform Web,Native
     * @language en_US
     */
    Event.prototype.preventDefault = function () {
        if (this._cancelable) {
            this._isDefaultPrevented = true;
        }
    };
    /**
     * Prevents processing of any event listeners in nodes subsequent to the current node in the event flow. This method
     * does not affect any event listeners in the current node (currentTarget). In contrast, the stopImmediatePropagation()
     * method prevents processing of event listeners in both the current node and subsequent nodes. Additional calls to this
     * method have no effect. This method can be called in any phase of the event flow.<br/>
     * Note: This method does not cancel the behavior associated with this event; see preventDefault() for that functionality.
     * @see #stopImmediatePropagation()
     * @see #preventDefault()
     * @version Egret 2.4
     * @platform Web,Native
     * @language en_US
     */
    Event.prototype.stopPropagation = function () {
        if (this._bubbles) {
            this._isPropagationStopped = true;
        }
    };
    /**
     * Prevents processing of any event listeners in the current node and any subsequent nodes in the event flow.
     * This method takes effect immediately, and it affects event listeners in the current node. In contrast, the
     * stopPropagation() method doesn't take effect until all the event listeners in the current node finish processing.<br/>
     * Note: This method does not cancel the behavior associated with this event; see preventDefault() for that functionality.
     * @see #stopPropagation()
     * @see #preventDefault()
     * @version Egret 2.4
     * @platform Web,Native
     * @language en_US
     */
    Event.prototype.stopImmediatePropagation = function () {
        if (this._bubbles) {
            this._isPropagationImmediateStopped = true;
        }
    };
    Object.defineProperty(Event.prototype, "type", {
        /**
         * The type of event. The type is case-sensitive.
         * @version Egret 2.4
         * @platform Web,Native
         * @language en_US
         */
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "bubbles", {
        /**
         * Indicates whether an event is a bubbling event.
         * @version Egret 2.4
         * @platform Web,Native
         * @language en_US
         */
        get: function () {
            return this._bubbles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "cancelable", {
        /**
         * Indicates whether the behavior associated with the event can be prevented. If the behavior can be
         * canceled, this value is true; otherwise it is false.
         * @see #preventDefault()
         * @version Egret 2.4
         * @platform Web,Native
         * @language en_US
         */
        get: function () {
            return this._cancelable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "isDefaultPrevented", {
        /**
         * Checks whether the preventDefault() method has been called on the event. If the preventDefault() method has been
         * called, returns true; otherwise, returns false.
         * @returns If preventDefault() has been called, returns true; otherwise, returns false.
         * @see #preventDefault()
         * @version Egret 2.4
         * @platform Web,Native
         * @language en_US
         */
        get: function () {
            return this._isDefaultPrevented;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "isPropagationStopped", {
        get: function () {
            return this._isPropagationStopped;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "isPropagationImmediateStopped", {
        get: function () {
            return this._isPropagationImmediateStopped;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "currentTarget", {
        /**
         * The object that is actively processing the Event object with an event listener. For example, if a
         * user clicks an OK button, the current target could be the node containing that button or one of its ancestors
         * that has registered an event listener for that event.
         * @version Egret 2.4
         * @platform Web,Native
         * @language en_US
         */
        get: function () {
            return this._currentTarget;
        },
        set: function (value) {
            this._currentTarget = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "target", {
        /**
         * The event target. This property contains the target node. For example, if a user clicks an OK button,
         * the target node is the display list node containing that button.
         * @version Egret 2.4
         * @platform Web,Native
         * @language en_US
         */
        get: function () {
            return this._target;
        },
        set: function (value) {
            this._target = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "data", {
        /**
         * the optional data associated with this event
         * @version Egret 2.4
         * @platform Web,Native
         * @language en_US
         */
        get: function () {
            return this._data;
        },
        set: function (value) {
            this._data = value;
        },
        enumerable: true,
        configurable: true
    });
    return Event;
}());
exports.Event = Event;
//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/EventDispatcher.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/EventDispatcher.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var inversify_1 = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
var IEventDispatcher_1 = __webpack_require__(/*! ../api/IEventDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/api/IEventDispatcher.js");
var Event_1 = __webpack_require__(/*! ../impl/Event */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/Event.js");
var ONCE_EVENT_LIST = [];
/**
 * The EventDispatcher class is the base class for all classes that dispatchEvent events. The EventDispatcher class implements
 * the IEventDispatcher interface and is the base class for the DisplayObject class. The EventDispatcher class allows
 * any object on the display list to be an event target and as such, to use the methods of the IEventDispatcher interface.
 * Event targets are an important part of the Egret event model. The event target serves as the focal point for how events
 * flow through the display list hierarchy. When an event such as a touch tap, Egret dispatches an event object into the
 * event flow from the root of the display list. The event object then makes its way through the display list until it
 * reaches the event target, at which point it begins its return trip through the display list. This round-trip journey
 * to the event target is conceptually divided into three phases: <br/>
 * the capture phase comprises the journey from the root to the last node before the event target's node, the target
 * phase comprises only the event target node, and the bubbling phase comprises any subsequent nodes encountered on
 * the return trip to the root of the display list. In general, the easiest way for a user-defined class to gain event
 * dispatching capabilities is to extend EventDispatcher. If this is impossible (that is, if the class is already extending
 * another class), you can instead implement the IEventDispatcher interface, create an EventDispatcher member, and write simple
 * hooks to route calls into the aggregated EventDispatcher.
 * @see egret.IEventDispatcher
 * @version Egret 2.4
 * @platform Web,Native
 * @includeExample egret/events/EventDispatcher.ts
 * @language en_US
 */
var EventDispatcher = /** @class */ (function () {
    /**
     * create an instance of the EventDispatcher class.
     * @param target The target object for events dispatched to the EventDispatcher object. This parameter is used when
     * the EventDispatcher instance is aggregated by a class that implements IEventDispatcher; it is necessary so that the
     * containing object can be the target for events. Do not use this parameter in simple cases in which a class extends EventDispatcher.
     * @version Egret 2.4
     * @platform Web,Native
     * @language en_US
     */
    function EventDispatcher(target) {
        if (target === void 0) { target = null; }
        this._eventDispatcher = {
            0: target ? target : this,
            1: {},
            2: {},
            3: 0
        };
    }
    /**
     * @inheritDoc
     * @version Egret 2.4
     * @platform Web,Native
     */
    EventDispatcher.prototype.addEventListener = function (type, listener, thisObject, useCapture, priority) {
        this._addListener(type, listener, thisObject, useCapture, priority);
    };
    /**
     * @inheritDoc
     * @version Egret 2.4
     * @platform Web,Native
     */
    EventDispatcher.prototype.once = function (type, listener, thisObject, useCapture, priority) {
        this._addListener(type, listener, thisObject, useCapture, priority, true);
    };
    /**
     * @inheritDoc
     * @version Egret 2.4
     * @platform Web,Native
     */
    EventDispatcher.prototype.removeEventListener = function (type, listener, thisObject, useCapture) {
        var values = this._eventDispatcher;
        var eventMap = this._getEventMap(useCapture);
        var list = eventMap[type];
        if (!list) {
            return;
        }
        if (values[3 /* notifyLevel */] !== 0) {
            eventMap[type] = list = list.concat();
        }
        this._removeEventBin(list, listener, thisObject);
        if (list.length === 0) {
            eventMap[type] = null;
        }
    };
    /**
     * @inheritDoc
     * @version Egret 2.4
     * @platform Web,Native
     */
    EventDispatcher.prototype.hasEventListener = function (type) {
        var values = this._eventDispatcher;
        return !!(values[1 /* eventsMap */][type] || values[2 /* captureEventsMap */][type]);
    };
    /**
     * @inheritDoc
     * @version Egret 2.4
     * @platform Web,Native
     */
    EventDispatcher.prototype.willTrigger = function (type) {
        return this.hasEventListener(type);
    };
    /**
     * @inheritDoc
     * @version Egret 2.4
     * @platform Web,Native
     */
    EventDispatcher.prototype.dispatchEvent = function (event) {
        event.currentTarget = this._eventDispatcher[0 /* eventTarget */];
        event.target = event.currentTarget;
        return this._notifyListener(event, false);
    };
    /**
     * Distribute a specified event parameters.
     * @param type The type of the event. Event listeners can access this information through the inherited type property.
     * @param bubbles Determines whether the Event object bubbles. Event listeners can access this information through
     * the inherited bubbles property.
     * @param data {any} data
     * @param cancelable Determines whether the Event object can be canceled. The default values is false.
     * @version Egret 2.4
     * @platform Web,Native
     * @language en_US
     */
    EventDispatcher.prototype.dispatchEventWith = function (type, bubbles, data, cancelable) {
        if (bubbles || this.hasEventListener(type)) {
            var event_1 = new Event_1.Event(type, bubbles, cancelable, data);
            var result = this.dispatchEvent(event_1);
            return result;
        }
        return true;
    };
    /**
     * @private
     *
     * @param useCapture
     */
    EventDispatcher.prototype._getEventMap = function (useCapture) {
        var values = this._eventDispatcher;
        var eventMap = useCapture ? values[2 /* captureEventsMap */] : values[1 /* eventsMap */];
        return eventMap;
    };
    /**
     * @private
     */
    EventDispatcher.prototype._addListener = function (type, listener, thisObject, useCapture, priority, dispatchOnce) {
        var values = this._eventDispatcher;
        var eventMap = this._getEventMap(useCapture);
        var list = eventMap[type];
        if (!list) {
            list = eventMap[type] = [];
        }
        else if (values[3 /* notifyLevel */] !== 0) {
            eventMap[type] = list = list.concat();
        }
        this._insertEventBin(list, type, listener, thisObject, useCapture, priority, dispatchOnce);
    };
    /**
     * @private
     */
    EventDispatcher.prototype._insertEventBin = function (list, type, listener, thisObject, useCapture, priority, dispatchOnce) {
        priority = priority || 0;
        var insertIndex = -1;
        var length = list.length;
        for (var i = 0; i < length; i++) {
            var bin = list[i];
            if (bin.listener === listener && bin.thisObject === thisObject && bin.target === this) {
                return false;
            }
            if (insertIndex === -1 && bin.priority < priority) {
                insertIndex = i;
            }
        }
        var eventBin = {
            type: type,
            listener: listener,
            thisObject: thisObject,
            priority: priority,
            target: this,
            useCapture: useCapture,
            dispatchOnce: !!dispatchOnce
        };
        if (insertIndex !== -1) {
            list.splice(insertIndex, 0, eventBin);
        }
        else {
            list.push(eventBin);
        }
        return true;
    };
    /**
     * @private
     */
    EventDispatcher.prototype._removeEventBin = function (list, listener, thisObject) {
        var length = list.length;
        for (var i = 0; i < length; i++) {
            var bin = list[i];
            if (bin.listener === listener && bin.thisObject === thisObject && bin.target === this) {
                list.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    /**
     * @private
     */
    EventDispatcher.prototype._notifyListener = function (event, capturePhase) {
        var values = this._eventDispatcher;
        var eventMap = this._getEventMap(capturePhase);
        var list = eventMap[event.type];
        if (!list) {
            return true;
        }
        var length = list.length;
        if (length === 0) {
            return true;
        }
        var onceList = ONCE_EVENT_LIST;
        values[3 /* notifyLevel */]++;
        for (var i = 0; i < length; i++) {
            var eventBin = list[i];
            eventBin.listener.call(eventBin.thisObject, event);
            if (eventBin.dispatchOnce) {
                onceList.push(eventBin);
            }
            if (event.isPropagationImmediateStopped) {
                break;
            }
        }
        values[3 /* notifyLevel */]--;
        while (onceList.length) {
            var eventBin = onceList.pop();
            eventBin.target.removeEventListener(eventBin.type, eventBin.listener, eventBin.thisObject, eventBin.useCapture);
        }
        return !event.isDefaultPrevented;
    };
    EventDispatcher = tslib_1.__decorate([
        inversify_1.injectable(),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], EventDispatcher);
    return EventDispatcher;
}());
exports.EventDispatcher = EventDispatcher;
//# sourceMappingURL=EventDispatcher.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/api/CommandPayload.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/api/CommandPayload.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var CommandPayload = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a command payload
     * @param values Optional values
     * @param classes Optional classes
     */
    function CommandPayload(values, classes) {
        this._values = values;
        this._classes = classes;
    }
    Object.defineProperty(CommandPayload.prototype, "values", {
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        /**
         * Ordered list of values
         */
        get: function () {
            return this._values;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandPayload.prototype, "classes", {
        /**
         * Ordered list of value classes
         */
        get: function () {
            return this._classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandPayload.prototype, "length", {
        /**
         * The number of payload items
         */
        get: function () {
            return this._classes ? this._classes.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Adds an item to this payload
     * @param payloadValue The value
     * @param payloadClass The class of the value
     * @return Self
     */
    CommandPayload.prototype.addPayload = function (payloadValue, payloadClass) {
        if (this._values) {
            this._values.push(payloadValue);
        }
        else {
            this._values = [payloadValue];
        }
        if (this._classes) {
            this._classes.push(payloadClass);
        }
        else {
            this._classes = [payloadClass];
        }
        return this;
    };
    /**
     * Does this payload have any items?
     * @return boolean
     */
    CommandPayload.prototype.hasPayload = function () {
        var payload = false;
        if (this._values && this._classes) {
            payload = this._values.length > 0 && this._classes.length > 0 && this._values.length === this._classes.length;
        }
        return payload;
    };
    return CommandPayload;
}());
exports.CommandPayload = CommandPayload;
//# sourceMappingURL=CommandPayload.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/api/ICommand.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/api/ICommand.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Mandatory Command interface.
 *
 * <p>Note, you do not need to implement this interface,
 * any class with an execute method can be used.</p>
 */
exports.ICommand = Symbol("ICommand");
//# sourceMappingURL=ICommand.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/Command.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/Command.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Abstract command implementation
 *
 * <p>Please note: you do not have to extend this class.
 * Any class with an execute method can be used.</p>
 */
var Command = /** @class */ (function () {
    function Command() {
    }
    return Command;
}());
exports.Command = Command;
//# sourceMappingURL=Command.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandExecutor.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandExecutor.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var applyHooks_1 = __webpack_require__(/*! ../../../framework/impl/applyHooks */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/applyHooks.js");
var guardsApprove_1 = __webpack_require__(/*! ../../../framework/impl/guardsApprove */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/guardsApprove.js");
var instantiateUnmapped_1 = __webpack_require__(/*! ../../../framework/impl/instantiateUnmapped */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/instantiateUnmapped.js");
/**
 * @private
 */
var CommandExecutor = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a Command Executor
     * @param injector The Injector to use. A child injector will be created from it.
     * @param removeMapping Remove mapping handler (optional)
     * @param handleResult Result handler (optional)
     */
    function CommandExecutor(injector, removeMapping, handleResult) {
        this._injector = injector.createChild();
        this._removeMapping = removeMapping;
        this._handleResult = handleResult;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    CommandExecutor.prototype.executeCommands = function (mappings, payload) {
        var length = mappings.length;
        for (var i = 0; i < length; i++) {
            this.executeCommand(mappings[i], payload);
        }
    };
    /**
     * @inheritDoc
     */
    CommandExecutor.prototype.executeCommand = function (mapping, payload) {
        var hasPayload = payload && payload.hasPayload();
        var injectionEnabled = hasPayload && mapping.payloadInjectionEnabled;
        var command = null;
        if (injectionEnabled) {
            this.mapPayload(payload);
        }
        if (mapping.guards.length === 0 || guardsApprove_1.guardsApprove(mapping.guards, this._injector)) {
            var commandClass = mapping.commandClass;
            if (mapping.fireOnce && this._removeMapping) {
                this._removeMapping(mapping);
            }
            command = instantiateUnmapped_1.instantiateUnmapped(this._injector, commandClass);
            if (mapping.hooks.length > 0) {
                this._injector.bind(commandClass).toConstantValue(command);
                applyHooks_1.applyHooks(mapping.hooks, this._injector);
                this._injector.unbind(commandClass);
            }
        }
        if (injectionEnabled) {
            this.unmapPayload(payload);
        }
        if (command) {
            var executeMethod = command.execute.bind(command);
            var result = hasPayload && executeMethod.length > 0 ? executeMethod.apply(command, payload.values) : executeMethod();
            if (this._handleResult) {
                this._handleResult(result, command, mapping);
            }
        }
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    CommandExecutor.prototype.mapPayload = function (payload) {
        var i = payload.length;
        while (i--) {
            this._injector.bind(payload.classes[i]).toConstantValue(payload.values[i]);
        }
    };
    CommandExecutor.prototype.unmapPayload = function (payload) {
        var i = payload.length;
        while (i--) {
            this._injector.unbind(payload.classes[i]);
        }
    };
    return CommandExecutor;
}());
exports.CommandExecutor = CommandExecutor;
//# sourceMappingURL=CommandExecutor.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapper.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapper.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var CommandMapping_1 = __webpack_require__(/*! ./CommandMapping */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapping.js");
/**
 * @private
 */
var CommandMapper = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a Command Mapper
     * @param mappings The command mapping list to add mappings to
     */
    function CommandMapper(mappings) {
        this._mappings = mappings;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    CommandMapper.prototype.toCommand = function (commandClass) {
        this._mapping = new CommandMapping_1.CommandMapping(commandClass);
        this._mappings.addMapping(this._mapping);
        return this;
    };
    /**
     * @inheritDoc
     */
    CommandMapper.prototype.fromCommand = function (commandClass) {
        this._mappings.removeMappingFor(commandClass);
    };
    /**
     * @inheritDoc
     */
    CommandMapper.prototype.fromAll = function () {
        this._mappings.removeAllMappings();
    };
    /**
     * @inheritDoc
     */
    CommandMapper.prototype.once = function (value) {
        if (value === void 0) { value = true; }
        this._mapping.setFireOnce(value);
        return this;
    };
    /**
     * @inheritDoc
     */
    CommandMapper.prototype.withGuards = function () {
        var _a;
        var guards = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            guards[_i] = arguments[_i];
        }
        (_a = this._mapping).addGuards.apply(_a, guards);
        return this;
    };
    /**
     * @inheritDoc
     */
    CommandMapper.prototype.withHooks = function () {
        var _a;
        var hooks = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            hooks[_i] = arguments[_i];
        }
        (_a = this._mapping).addHooks.apply(_a, hooks);
        return this;
    };
    /**
     * @inheritDoc
     */
    CommandMapper.prototype.withPayloadInjection = function (value) {
        if (value === void 0) { value = true; }
        this._mapping.setPayloadInjectionEnabled(value);
        return this;
    };
    return CommandMapper;
}());
exports.CommandMapper = CommandMapper;
//# sourceMappingURL=CommandMapper.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapping.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapping.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var getQualifiedClassName_1 = __webpack_require__(/*! ../../../framework/impl/getQualifiedClassName */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/getQualifiedClassName.js");
/**
 * @private
 */
var CommandMapping = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a Command Mapping
     * @param commandClass The concrete Command class
     */
    function CommandMapping(commandClass) {
        this._guards = [];
        this._hooks = [];
        this._fireOnce = false;
        this._payloadInjectionEnabled = true;
        this._commandClass = commandClass;
    }
    Object.defineProperty(CommandMapping.prototype, "commandClass", {
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        /**
         * @inheritDoc
         */
        get: function () {
            return this._commandClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandMapping.prototype, "guards", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._guards;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandMapping.prototype, "hooks", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._hooks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandMapping.prototype, "fireOnce", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._fireOnce;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandMapping.prototype, "payloadInjectionEnabled", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._payloadInjectionEnabled;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    CommandMapping.prototype.addGuards = function () {
        var guards = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            guards[_i] = arguments[_i];
        }
        this._guards = this._guards.concat.apply(this._guards, guards);
        return this;
    };
    /**
     * @inheritDoc
     */
    CommandMapping.prototype.addHooks = function () {
        var hooks = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            hooks[_i] = arguments[_i];
        }
        this._hooks = this._hooks.concat.apply(this._hooks, hooks);
        return this;
    };
    /**
     * @inheritDoc
     */
    CommandMapping.prototype.setFireOnce = function (value) {
        this._fireOnce = value;
        return this;
    };
    /**
     * @inheritDoc
     */
    CommandMapping.prototype.setPayloadInjectionEnabled = function (value) {
        this._payloadInjectionEnabled = value;
        return this;
    };
    /**
     *
     */
    CommandMapping.prototype.toString = function () {
        return "Command " + getQualifiedClassName_1.getQualifiedClassName(this._commandClass);
    };
    return CommandMapping;
}());
exports.CommandMapping = CommandMapping;
//# sourceMappingURL=CommandMapping.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMappingList.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMappingList.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var CommandMappingList = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Create a command mapping list
     * @param trigger The trigger that owns this list
     * @param processors A reference to the mapping processors for this command map
     * @param logger Optional logger
     */
    function CommandMappingList(trigger, processors, logger) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._mappingsByCommand = new Map();
        this._mappings = [];
        this._trigger = trigger;
        this._processors = processors;
        this._logger = logger;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    CommandMappingList.prototype.getList = function () {
        if (!this._sorted) {
            this.sortMappings();
        }
        return this._mappings.concat();
    };
    /**
     * @inheritDoc
     */
    CommandMappingList.prototype.withSortFunction = function (sorter) {
        this._sorted = false;
        this._compareFunction = sorter;
        return this;
    };
    /**
     * @inheritDoc
     */
    CommandMappingList.prototype.addMapping = function (mapping) {
        this._sorted = false;
        this.applyProcessors(mapping);
        var oldMapping = this._mappingsByCommand.get(mapping.commandClass);
        if (oldMapping) {
            this.overwriteMapping(oldMapping, mapping);
        }
        else {
            this.storeMapping(mapping);
            if (this._mappings.length === 1) {
                this._trigger.activate();
            }
        }
    };
    /**
     * @inheritDoc
     */
    CommandMappingList.prototype.removeMapping = function (mapping) {
        if (this._mappingsByCommand.has(mapping.commandClass)) {
            this.deleteMapping(mapping);
            if (this._mappings.length === 0) {
                this._trigger.deactivate();
            }
        }
    };
    /**
     * @inheritDoc
     */
    CommandMappingList.prototype.removeMappingFor = function (commandClass) {
        var mapping = this._mappingsByCommand.get(commandClass);
        if (mapping) {
            this.removeMapping(mapping);
        }
    };
    /**
     * @inheritDoc
     */
    CommandMappingList.prototype.removeAllMappings = function () {
        if (this._mappings.length > 0) {
            var list = this._mappings.concat();
            var length_1 = list.length;
            while (length_1--) {
                this.deleteMapping(list[length_1]);
            }
            this._trigger.deactivate();
        }
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    CommandMappingList.prototype.storeMapping = function (mapping) {
        this._mappingsByCommand.set(mapping.commandClass, mapping);
        this._mappings.push(mapping);
        if (this._logger) {
            this._logger.debug("{0} mapped to {1}", [this._trigger, mapping]);
        }
    };
    CommandMappingList.prototype.deleteMapping = function (mapping) {
        this._mappingsByCommand.delete(mapping.commandClass);
        this._mappings.splice(this._mappings.indexOf(mapping), 1);
        if (this._logger) {
            this._logger.debug("{0} unmapped from {1}", [this._trigger, mapping]);
        }
    };
    CommandMappingList.prototype.overwriteMapping = function (oldMapping, newMapping) {
        if (this._logger) {
            this._logger.warn("{0} already mapped to {1}\n" +
                "If you have overridden this mapping intentionally you can use 'unmap()' " +
                "prior to your replacement mapping in order to avoid seeing this message.\n", [this._trigger, oldMapping]);
        }
        this.deleteMapping(oldMapping);
        this.storeMapping(newMapping);
    };
    CommandMappingList.prototype.sortMappings = function () {
        if (this._compareFunction != null) {
            this._mappings = this._mappings.sort(this._compareFunction);
        }
        this._sorted = true;
    };
    CommandMappingList.prototype.applyProcessors = function (mapping) {
        this._processors.forEach(function (processor) {
            processor(mapping);
        });
    };
    return CommandMappingList;
}());
exports.CommandMappingList = CommandMappingList;
//# sourceMappingURL=CommandMappingList.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandTriggerMap.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandTriggerMap.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var CommandTriggerMap = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a command trigger map
     * @param keyFactory Factory function to creates keys
     * @param triggerFactory Factory function to create triggers
     */
    function CommandTriggerMap(keyFactory, triggerFactory) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._triggers = new Map();
        this._keyFactory = keyFactory;
        this._triggerFactory = triggerFactory;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    CommandTriggerMap.prototype.getTrigger = function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var key = this.getKey(params);
        var trigger = this._triggers.get(key);
        if (!trigger) {
            trigger = this.createTrigger(params);
            this._triggers.set(key, trigger);
        }
        return trigger;
    };
    /**
     * @private
     */
    CommandTriggerMap.prototype.removeTrigger = function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        return this.destroyTrigger(this.getKey(params));
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    CommandTriggerMap.prototype.getKey = function (mapperArgs) {
        return this._keyFactory.apply(null, mapperArgs);
    };
    CommandTriggerMap.prototype.createTrigger = function (mapperArgs) {
        return this._triggerFactory.apply(null, mapperArgs);
    };
    CommandTriggerMap.prototype.destroyTrigger = function (key) {
        var trigger = this._triggers.get(key);
        if (trigger) {
            trigger.deactivate();
            this._triggers.delete(key);
        }
        return trigger;
    };
    return CommandTriggerMap;
}());
exports.CommandTriggerMap = CommandTriggerMap;
//# sourceMappingURL=CommandTriggerMap.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/NullCommandTrigger.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/NullCommandTrigger.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var NullCommandTrigger = /** @class */ (function () {
    function NullCommandTrigger() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    NullCommandTrigger.prototype.activate = function () { };
    /**
     * @private
     */
    NullCommandTrigger.prototype.deactivate = function () { };
    return NullCommandTrigger;
}());
exports.NullCommandTrigger = NullCommandTrigger;
//# sourceMappingURL=NullCommandTrigger.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/DirectCommandMapExtension.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/DirectCommandMapExtension.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var IDirectCommandMap_1 = __webpack_require__(/*! ./api/IDirectCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/api/IDirectCommandMap.js");
var DirectCommandMap_1 = __webpack_require__(/*! ./impl/DirectCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMap.js");
/**
 * Maps commands for direct (manual) execution
 */
var DirectCommandMapExtension = /** @class */ (function () {
    function DirectCommandMapExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    DirectCommandMapExtension.prototype.extend = function (context) {
        context.injector.bind(IDirectCommandMap_1.IDirectCommandMap).to(DirectCommandMap_1.DirectCommandMap);
    };
    return DirectCommandMapExtension;
}());
exports.DirectCommandMapExtension = DirectCommandMapExtension;
//# sourceMappingURL=DirectCommandMapExtension.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/api/IDirectCommandMap.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/api/IDirectCommandMap.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Maps commands for direct (manual) execution
 */
exports.IDirectCommandMap = Symbol("IDirectCommandMap");
//# sourceMappingURL=IDirectCommandMap.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMap.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMap.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var inversify_1 = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
var IContext_1 = __webpack_require__(/*! ../../../framework/api/IContext */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IContext.js");
var CommandExecutor_1 = __webpack_require__(/*! ../../commandCenter/impl/CommandExecutor */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandExecutor.js");
var CommandMappingList_1 = __webpack_require__(/*! ../../commandCenter/impl/CommandMappingList */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMappingList.js");
var NullCommandTrigger_1 = __webpack_require__(/*! ../../commandCenter/impl/NullCommandTrigger */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/NullCommandTrigger.js");
var IDirectCommandMap_1 = __webpack_require__(/*! ../api/IDirectCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/api/IDirectCommandMap.js");
var DirectCommandMapper_1 = __webpack_require__(/*! ./DirectCommandMapper */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMapper.js");
/**
 * Maps commands for direct (manual) execution
 */
var DirectCommandMap = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a Direct Command Map
     * @param context The context that owns this map
     */
    function DirectCommandMap(context) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._mappingProcessors = [];
        this._context = context;
        // Create a child injector
        var sandboxedInjector = context.injector.createChild();
        // allow access to this specific instance in the commands
        sandboxedInjector.bind(IDirectCommandMap_1.IDirectCommandMap).toConstantValue(this);
        this._mappings = new CommandMappingList_1.CommandMappingList(new NullCommandTrigger_1.NullCommandTrigger(), this._mappingProcessors, context.getLogger(this));
        this._executor = new CommandExecutor_1.CommandExecutor(sandboxedInjector, this._mappings.removeMapping.bind(this._mappings));
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    DirectCommandMap.prototype.map = function (commandClass) {
        return new DirectCommandMapper_1.DirectCommandMapper(this._executor, this._mappings, commandClass);
    };
    /**
     * @inheritDoc
     */
    DirectCommandMap.prototype.detain = function (command) {
        this._context.detain(command);
    };
    /**
     * @inheritDoc
     */
    DirectCommandMap.prototype.release = function (command) {
        this._context.release(command);
    };
    /**
     * @inheritDoc
     */
    DirectCommandMap.prototype.execute = function (payload) {
        this._executor.executeCommands(this._mappings.getList(), payload);
    };
    /**
     * @inheritDoc
     */
    DirectCommandMap.prototype.addMappingProcessor = function (handler) {
        if (this._mappingProcessors.indexOf(handler) === -1) {
            this._mappingProcessors.push(handler);
        }
        return this;
    };
    DirectCommandMap = tslib_1.__decorate([
        inversify_1.injectable(),
        tslib_1.__param(0, inversify_1.inject(IContext_1.IContext)),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], DirectCommandMap);
    return DirectCommandMap;
}());
exports.DirectCommandMap = DirectCommandMap;
//# sourceMappingURL=DirectCommandMap.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMapper.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/directCommandMap/impl/DirectCommandMapper.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var CommandMapping_1 = __webpack_require__(/*! ../../commandCenter/impl/CommandMapping */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapping.js");
/**
 * @private
 */
var DirectCommandMapper = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function DirectCommandMapper(executor, mappings, commandClass) {
        this._executor = executor;
        this._mappings = mappings;
        this._mapping = new CommandMapping_1.CommandMapping(commandClass);
        this._mapping.setFireOnce(true);
        this._mappings.addMapping(this._mapping);
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    DirectCommandMapper.prototype.withGuards = function () {
        var _a;
        var guards = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            guards[_i] = arguments[_i];
        }
        (_a = this._mapping).addGuards.apply(_a, guards);
        return this;
    };
    /**
     * @inheritDoc
     */
    DirectCommandMapper.prototype.withHooks = function () {
        var _a;
        var hooks = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            hooks[_i] = arguments[_i];
        }
        (_a = this._mapping).addHooks.apply(_a, hooks);
        return this;
    };
    /**
     * @inheritDoc
     */
    DirectCommandMapper.prototype.withPayloadInjection = function (value) {
        if (value === void 0) { value = true; }
        this._mapping.setPayloadInjectionEnabled(value);
        return this;
    };
    /**
     * @inheritDoc
     */
    DirectCommandMapper.prototype.execute = function (payload) {
        this._executor.executeCommands(this._mappings.getList(), payload);
    };
    /**
     * @inheritDoc
     */
    DirectCommandMapper.prototype.map = function (commandClass) {
        return new DirectCommandMapper(this._executor, this._mappings, commandClass);
    };
    return DirectCommandMapper;
}());
exports.DirectCommandMapper = DirectCommandMapper;
//# sourceMappingURL=DirectCommandMapper.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/ConsoleLoggingExtension.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/ConsoleLoggingExtension.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var ConsoleLogTarget_1 = __webpack_require__(/*! ./impl/ConsoleLogTarget */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/impl/ConsoleLogTarget.js");
/**
 * Adds a TraceLogTarget to the context
 */
var ConsoleLoggingExtension = /** @class */ (function () {
    function ConsoleLoggingExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ConsoleLoggingExtension.prototype.extend = function (context) {
        context.addLogTarget(new ConsoleLogTarget_1.ConsoleLogTarget(context));
    };
    return ConsoleLoggingExtension;
}());
exports.ConsoleLoggingExtension = ConsoleLoggingExtension;
//# sourceMappingURL=ConsoleLoggingExtension.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/InjectableLoggerExtension.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/InjectableLoggerExtension.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var ILogger_1 = __webpack_require__(/*! ../../framework/api/ILogger */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/ILogger.js");
/**
 * Allows you to @inject unique loggers into your objects.
 *
 * There are two ways to inject the logger on the constructor of your class:
 *
 * * Using the literal string "ILogger":
 *
 * <code>
 *     constructor( @inject("ILogger") logger: ILogger ) { ... }
 * </code>
 *
 * * Using the ILogger Symbol:
 *
 * <code>
 *     constructor( @inject(ILogger) logger: ILogger ) { ... }
 * </code>
 */
var InjectableLoggerExtension = /** @class */ (function () {
    function InjectableLoggerExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    InjectableLoggerExtension.prototype.extend = function (context) {
        // Map the literal string "ILogger"
        context.injector
            .bind("ILogger")
            .toDynamicValue(function () {
            return context.getLogger(null);
        })
            .onActivation(function (ctx, logger) {
            logger.source = ctx.plan.rootRequest.serviceIdentifier;
            return logger;
        });
        // Map the Symbol ILogger
        context.injector
            .bind(ILogger_1.ILogger)
            .toDynamicValue(function () {
            return context.getLogger(null);
        })
            .onActivation(function (ctx, logger) {
            logger.source = ctx.plan.rootRequest.serviceIdentifier;
            return logger;
        });
    };
    return InjectableLoggerExtension;
}());
exports.InjectableLoggerExtension = InjectableLoggerExtension;
//# sourceMappingURL=InjectableLoggerExtension.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/impl/ConsoleLogTarget.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/impl/ConsoleLogTarget.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel_1 = __webpack_require__(/*! ../../../framework/api/LogLevel */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LogLevel.js");
var LogMessageParser_1 = __webpack_require__(/*! ./LogMessageParser */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/impl/LogMessageParser.js");
/**
 * A simple trace logger
 * @private
 */
var ConsoleLogTarget = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a Trace Log Target
     * @param context Context
     */
    function ConsoleLogTarget(context) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._messageParser = new LogMessageParser_1.LogMessageParser();
        this._context = context;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ConsoleLogTarget.prototype.log = function (source, level, timestamp, message, params) {
        if (this._context.logLevel < level) {
            return;
        }
        switch (level) {
            case LogLevel_1.LogLevel.DEBUG:
                console.log(timestamp, this._context, source, this._messageParser.parseMessage(message, params));
                break;
            case LogLevel_1.LogLevel.INFO:
                console.info(timestamp, this._context, source, this._messageParser.parseMessage(message, params));
                break;
            case LogLevel_1.LogLevel.WARN:
                console.warn(timestamp, this._context, source, this._messageParser.parseMessage(message, params));
                break;
            case LogLevel_1.LogLevel.ERROR:
                console.error(timestamp, this._context, source, this._messageParser.parseMessage(message, params));
                break;
            case LogLevel_1.LogLevel.FATAL:
                console.error(timestamp, this._context, source, this._messageParser.parseMessage(message, params));
                break;
        }
    };
    return ConsoleLogTarget;
}());
exports.ConsoleLogTarget = ConsoleLogTarget;
//# sourceMappingURL=ConsoleLogTarget.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/impl/LogMessageParser.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/enhancedLogging/impl/LogMessageParser.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var LogMessageParser = /** @class */ (function () {
    function LogMessageParser() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Parse a parametrized message
     *
     * @param message The message string
     * @param params The parameter values
     * @return The parsed message
     */
    LogMessageParser.prototype.parseMessage = function (message, params) {
        if (params && params.length) {
            params.forEach(function (value, index) {
                message = message.replace("{" + index + "}", value);
            });
        }
        return message;
    };
    return LogMessageParser;
}());
exports.LogMessageParser = LogMessageParser;
//# sourceMappingURL=LogMessageParser.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/EventCommandMapExtension.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/EventCommandMapExtension.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var IEventCommandMap_1 = __webpack_require__(/*! ./api/IEventCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/api/IEventCommandMap.js");
var EventCommandMap_1 = __webpack_require__(/*! ./impl/EventCommandMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/impl/EventCommandMap.js");
/**
 * The Event Command Map allows you to bind Events to Commands
 */
var EventCommandMapExtension = /** @class */ (function () {
    function EventCommandMapExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    EventCommandMapExtension.prototype.extend = function (context) {
        context.injector
            .bind(IEventCommandMap_1.IEventCommandMap)
            .to(EventCommandMap_1.EventCommandMap)
            .inSingletonScope();
    };
    return EventCommandMapExtension;
}());
exports.EventCommandMapExtension = EventCommandMapExtension;
//# sourceMappingURL=EventCommandMapExtension.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/api/IEventCommandMap.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/api/IEventCommandMap.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The Event Command Map allows you to bind Events to Commands
 */
exports.IEventCommandMap = Symbol("IEventCommandMap");
//# sourceMappingURL=IEventCommandMap.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/impl/EventCommandMap.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/impl/EventCommandMap.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var inversify_1 = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
var IContext_1 = __webpack_require__(/*! ../../../framework/api/IContext */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IContext.js");
var IEventDispatcher_1 = __webpack_require__(/*! ../../../events/api/IEventDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/api/IEventDispatcher.js");
var CommandTriggerMap_1 = __webpack_require__(/*! ../../commandCenter/impl/CommandTriggerMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandTriggerMap.js");
var EventCommandTrigger_1 = __webpack_require__(/*! ./EventCommandTrigger */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/impl/EventCommandTrigger.js");
/**
 * @private
 */
var EventCommandMap = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function EventCommandMap(context, dispatcher) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._mappingProcessors = [];
        this._injector = context.injector;
        this._logger = context.getLogger(this);
        this._dispatcher = dispatcher;
        this._triggerMap = new CommandTriggerMap_1.CommandTriggerMap(this.getKey, this.createTrigger.bind(this));
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    EventCommandMap.prototype.map = function (type, eventClass) {
        return this.getTrigger(type, eventClass).createMapper();
    };
    /**
     * @inheritDoc
     */
    EventCommandMap.prototype.unmap = function (type, eventClass) {
        return this.getTrigger(type, eventClass).createMapper();
    };
    /**
     * @inheritDoc
     */
    EventCommandMap.prototype.addMappingProcessor = function (handler) {
        if (this._mappingProcessors.indexOf(handler) === -1) {
            this._mappingProcessors.push(handler);
        }
        return this;
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    EventCommandMap.prototype.getKey = function (type, eventClass) {
        return type + eventClass;
    };
    EventCommandMap.prototype.getTrigger = function (type, eventClass) {
        return this._triggerMap.getTrigger(type, eventClass);
    };
    EventCommandMap.prototype.createTrigger = function (type, eventClass) {
        return new EventCommandTrigger_1.EventCommandTrigger(this._injector, this._dispatcher, type, eventClass, this._mappingProcessors, this._logger);
    };
    EventCommandMap = tslib_1.__decorate([
        inversify_1.injectable(),
        tslib_1.__param(0, inversify_1.inject(IContext_1.IContext)), tslib_1.__param(1, inversify_1.inject(IEventDispatcher_1.IEventDispatcher)),
        tslib_1.__metadata("design:paramtypes", [Object, Object])
    ], EventCommandMap);
    return EventCommandMap;
}());
exports.EventCommandMap = EventCommandMap;
//# sourceMappingURL=EventCommandMap.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/impl/EventCommandTrigger.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventCommandMap/impl/EventCommandTrigger.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var getQualifiedClassName_1 = __webpack_require__(/*! ../../../framework/impl/getQualifiedClassName */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/getQualifiedClassName.js");
var isInstanceOfType_1 = __webpack_require__(/*! ../../matching/isInstanceOfType */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/isInstanceOfType.js");
var CommandPayload_1 = __webpack_require__(/*! ../../commandCenter/api/CommandPayload */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/api/CommandPayload.js");
var CommandExecutor_1 = __webpack_require__(/*! ../../commandCenter/impl/CommandExecutor */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandExecutor.js");
var CommandMapper_1 = __webpack_require__(/*! ../../commandCenter/impl/CommandMapper */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMapper.js");
var CommandMappingList_1 = __webpack_require__(/*! ../../commandCenter/impl/CommandMappingList */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/commandCenter/impl/CommandMappingList.js");
/**
 * @private
 */
var EventCommandTrigger = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function EventCommandTrigger(injector, dispatcher, type, eventClass, processors, logger) {
        this._dispatcher = dispatcher;
        this._type = type;
        this._eventClass = eventClass;
        this._mappings = new CommandMappingList_1.CommandMappingList(this, processors ? processors : [], logger);
        this._executor = new CommandExecutor_1.CommandExecutor(injector, this._mappings.removeMapping.bind(this._mappings));
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    EventCommandTrigger.prototype.createMapper = function () {
        return new CommandMapper_1.CommandMapper(this._mappings);
    };
    /**
     * @inheritDoc
     */
    EventCommandTrigger.prototype.activate = function () {
        this._dispatcher.addEventListener(this._type, this.eventHandler, this);
    };
    /**
     * @inheritDoc
     */
    EventCommandTrigger.prototype.deactivate = function () {
        this._dispatcher.removeEventListener(this._type, this.eventHandler, this);
    };
    EventCommandTrigger.prototype.toString = function () {
        var eventDescription = "";
        eventDescription = !this._eventClass ? "Event" : getQualifiedClassName_1.getQualifiedClassName(this._eventClass);
        return eventDescription + " with selector '" + this._type + "'";
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    EventCommandTrigger.prototype.eventHandler = function (event) {
        var eventConstructor = event.constructor;
        var payloadEventClass;
        // not pretty, but optimized to avoid duplicate checks and shortest paths
        if (!this._eventClass) {
            payloadEventClass = eventConstructor;
        }
        else if (isInstanceOfType_1.isInstanceOfType(event, this._eventClass)) {
            payloadEventClass = this._eventClass;
        }
        else {
            return;
        }
        this._executor.executeCommands(this._mappings.getList(), new CommandPayload_1.CommandPayload([event], [payloadEventClass]));
    };
    return EventCommandTrigger;
}());
exports.EventCommandTrigger = EventCommandTrigger;
//# sourceMappingURL=EventCommandTrigger.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/EventDispatcherExtension.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/EventDispatcherExtension.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var IEventDispatcher_1 = __webpack_require__(/*! ../../events/api/IEventDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/api/IEventDispatcher.js");
var EventDispatcher_1 = __webpack_require__(/*! ../../events/impl/EventDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/EventDispatcher.js");
var LifecycleEventRelay_1 = __webpack_require__(/*! ./impl/LifecycleEventRelay */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/impl/LifecycleEventRelay.js");
/**
 * This extension maps an IEventDispatcher into a context's injector.
 */
var EventDispatcherExtension = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates an Event Dispatcher Extension
     * @param eventDispatcher Optional IEventDispatcher instance to share
     */
    function EventDispatcherExtension(eventDispatcher) {
        if (eventDispatcher === void 0) { eventDispatcher = null; }
        this._eventDispatcher = eventDispatcher || new EventDispatcher_1.EventDispatcher();
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    EventDispatcherExtension.prototype.extend = function (context) {
        this._context = context;
        this._context.injector.bind(IEventDispatcher_1.IEventDispatcher).toConstantValue(this._eventDispatcher);
        this._context.beforeInitializing(this.configureLifecycleEventRelay.bind(this));
        this._context.afterDestroying(this.destroyLifecycleEventRelay.bind(this));
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    EventDispatcherExtension.prototype.configureLifecycleEventRelay = function () {
        this._lifecycleRelay = new LifecycleEventRelay_1.LifecycleEventRelay(this._context, this._eventDispatcher);
    };
    EventDispatcherExtension.prototype.destroyLifecycleEventRelay = function () {
        this._lifecycleRelay.destroy();
    };
    return EventDispatcherExtension;
}());
exports.EventDispatcherExtension = EventDispatcherExtension;
//# sourceMappingURL=EventDispatcherExtension.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/impl/EventRelay.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/impl/EventRelay.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Relays events from a source to a destination
 */
var EventRelay = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Relays events from the source to the destination
     * @param source Event Dispatcher
     * @param destination Event Dispatcher
     * @param types The list of event types to relay
     */
    function EventRelay(source, destination, types) {
        this._source = source;
        this._destination = destination;
        this._types = types || [];
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Start relaying events
     * @return Self
     */
    EventRelay.prototype.start = function () {
        if (!this._active) {
            this._active = true;
            this.addListeners();
        }
        return this;
    };
    /**
     * Stop relaying events
     * @return Self
     */
    EventRelay.prototype.stop = function () {
        if (this._active) {
            this._active = false;
            this.removeListeners();
        }
        return this;
    };
    /**
     * Add a new event type to relay
     * @param eventType
     */
    EventRelay.prototype.addType = function (eventType) {
        this._types.push(eventType);
        if (this._active) {
            this.addListener(eventType);
        }
    };
    /**
     * Remove a relay event type
     * @param eventType
     */
    EventRelay.prototype.removeType = function (eventType) {
        var index = this._types.indexOf(eventType);
        if (index > -1) {
            this._types.splice(index, 1);
            this.removeListener(eventType);
        }
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    EventRelay.prototype.addListener = function (type) {
        this._source.addEventListener(type, this._destination.dispatchEvent, this._destination);
    };
    EventRelay.prototype.removeListener = function (type) {
        this._source.removeEventListener(type, this._destination.dispatchEvent, this._destination);
    };
    EventRelay.prototype.addListeners = function () {
        var _this = this;
        this._types.forEach(function (type) {
            _this.addListener(type);
        });
    };
    EventRelay.prototype.removeListeners = function () {
        var _this = this;
        this._types.forEach(function (type) {
            _this.removeListener(type);
        });
    };
    return EventRelay;
}());
exports.EventRelay = EventRelay;
//# sourceMappingURL=EventRelay.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/impl/LifecycleEventRelay.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/impl/LifecycleEventRelay.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var LifecycleEvent_1 = __webpack_require__(/*! ../../../framework/api/LifecycleEvent */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleEvent.js");
var EventRelay_1 = __webpack_require__(/*! ./EventRelay */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/eventDispatcher/impl/EventRelay.js");
/**
 * @private
 */
var LifecycleEventRelay = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function LifecycleEventRelay(source, destination) {
        this._relay = new EventRelay_1.EventRelay(source, destination, LifecycleEventRelay.TYPES).start();
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    LifecycleEventRelay.prototype.destroy = function () {
        this._relay.stop();
        this._relay = null;
    };
    /*============================================================================*/
    /* Private Static Properties                                                  */
    /*============================================================================*/
    LifecycleEventRelay.TYPES = [
        LifecycleEvent_1.LifecycleEvent.STATE_CHANGE,
        LifecycleEvent_1.LifecycleEvent.PRE_INITIALIZE,
        LifecycleEvent_1.LifecycleEvent.INITIALIZE,
        LifecycleEvent_1.LifecycleEvent.POST_INITIALIZE,
        LifecycleEvent_1.LifecycleEvent.PRE_SUSPEND,
        LifecycleEvent_1.LifecycleEvent.SUSPEND,
        LifecycleEvent_1.LifecycleEvent.POST_SUSPEND,
        LifecycleEvent_1.LifecycleEvent.PRE_RESUME,
        LifecycleEvent_1.LifecycleEvent.RESUME,
        LifecycleEvent_1.LifecycleEvent.POST_RESUME,
        LifecycleEvent_1.LifecycleEvent.PRE_DESTROY,
        LifecycleEvent_1.LifecycleEvent.DESTROY,
        LifecycleEvent_1.LifecycleEvent.POST_DESTROY
    ];
    return LifecycleEventRelay;
}());
exports.LifecycleEventRelay = LifecycleEventRelay;
//# sourceMappingURL=LifecycleEventRelay.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/LocalEventMapExtension.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/LocalEventMapExtension.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var IEventMap_1 = __webpack_require__(/*! ./api/IEventMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/api/IEventMap.js");
var EventMap_1 = __webpack_require__(/*! ./impl/EventMap */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/EventMap.js");
/**
 * An Event Map keeps track of listeners and provides the ability
 * to unregister all listeners with a single method call.
 */
var LocalEventMapExtension = /** @class */ (function () {
    function LocalEventMapExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    LocalEventMapExtension.prototype.extend = function (context) {
        context.injector.bind(IEventMap_1.IEventMap).to(EventMap_1.EventMap);
    };
    return LocalEventMapExtension;
}());
exports.LocalEventMapExtension = LocalEventMapExtension;
//# sourceMappingURL=LocalEventMapExtension.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/api/IEventMap.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/api/IEventMap.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The Event Map keeps track of listeners and provides the ability
 * to unregister all listeners with a single method call.
 */
exports.IEventMap = Symbol("IEventMap");
//# sourceMappingURL=IEventMap.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/DomEventMapConfig.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/DomEventMapConfig.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var DomEventMapConfig = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function DomEventMapConfig(dispatcher, eventString, listener, options) {
        this._dispatcher = dispatcher;
        this._eventString = eventString;
        this._listener = listener;
        this._options = options;
    }
    Object.defineProperty(DomEventMapConfig.prototype, "dispatcher", {
        /**
         * @private
         */
        get: function () {
            return this._dispatcher;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomEventMapConfig.prototype, "eventString", {
        /**
         * @private
         */
        get: function () {
            return this._eventString;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomEventMapConfig.prototype, "listener", {
        /**
         * @private
         */
        get: function () {
            return this._listener;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomEventMapConfig.prototype, "options", {
        /**
         * @private
         */
        get: function () {
            return this._options;
        },
        enumerable: true,
        configurable: true
    });
    DomEventMapConfig.prototype.equalTo = function (dispatcher, eventString, listener, options) {
        return (this._dispatcher === dispatcher && this._eventString === eventString && this._listener === listener && this._options === options);
    };
    return DomEventMapConfig;
}());
exports.DomEventMapConfig = DomEventMapConfig;
//# sourceMappingURL=DomEventMapConfig.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/EventMap.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/EventMap.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var inversify_1 = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
var Event_1 = __webpack_require__(/*! ../../../events/impl/Event */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/Event.js");
var isInstanceOfType_1 = __webpack_require__(/*! ../../../extensions/matching/isInstanceOfType */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/isInstanceOfType.js");
var DomEventMapConfig_1 = __webpack_require__(/*! ./DomEventMapConfig */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/DomEventMapConfig.js");
var EventMapConfig_1 = __webpack_require__(/*! ./EventMapConfig */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/EventMapConfig.js");
/**
 * @private
 */
var EventMap = /** @class */ (function () {
    function EventMap() {
        /*============================================================================*/
        /* Protected Properties                                                       */
        /*============================================================================*/
        this._listeners = [];
        this._suspendedListeners = [];
        this._domListeners = [];
        this._suspendedDomListeners = [];
        this._suspended = false;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    EventMap.prototype.mapListener = function (dispatcher, eventString, listener, thisObject, eventClass, useCapture, // Not used in browser environment
    priority) {
        var _this = this;
        if (useCapture === void 0) { useCapture = false; }
        if (priority === void 0) { priority = 0; }
        eventClass = eventClass === undefined ? Event_1.Event : eventClass;
        var currentListeners = this._suspended ? this._suspendedListeners : this._listeners;
        var config;
        var i = currentListeners.length;
        while (i--) {
            config = currentListeners[i];
            if (config.equalTo(dispatcher, eventString, listener, thisObject, eventClass, useCapture)) {
                return;
            }
        }
        var callback = eventClass === Event_1.Event
            ? listener
            : function (event) {
                _this.routeEventToListener(event, listener, eventClass);
            };
        config = new EventMapConfig_1.EventMapConfig(dispatcher, eventString, listener, thisObject, eventClass, callback, useCapture, priority);
        currentListeners.push(config);
        if (!this._suspended) {
            dispatcher.addEventListener(eventString, callback, thisObject, useCapture, priority);
        }
    };
    /**
     * @inheritDoc
     */
    EventMap.prototype.unmapListener = function (dispatcher, eventString, listener, thisObject, eventClass, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        eventClass = eventClass !== undefined ? eventClass : Event_1.Event;
        var currentListeners = this._suspended ? this._suspendedListeners : this._listeners;
        var i = currentListeners.length;
        while (i--) {
            var config = currentListeners[i];
            if (config.equalTo(dispatcher, eventString, listener, thisObject, eventClass, useCapture)) {
                if (!this._suspended) {
                    dispatcher.removeEventListener(eventString, config.callback, thisObject, useCapture);
                }
                currentListeners.splice(i, 1);
                return;
            }
        }
    };
    /**
     * @inheritDoc
     */
    EventMap.prototype.unmapListeners = function () {
        var currentListeners = this._suspended ? this._suspendedListeners : this._listeners;
        var eventConfig;
        var dispatcher;
        while (currentListeners.length) {
            eventConfig = currentListeners.pop();
            if (!this._suspended) {
                dispatcher = eventConfig.dispatcher;
                dispatcher.removeEventListener(eventConfig.eventString, eventConfig.callback, eventConfig.thisObject, eventConfig.useCapture);
            }
        }
    };
    /**
     * @inheritDoc
     */
    EventMap.prototype.mapDomListener = function (dispatcher, eventString, listener, options) {
        var currentDomListeners = this._suspended ? this._suspendedDomListeners : this._domListeners;
        var domConfig;
        var i = currentDomListeners.length;
        while (i--) {
            domConfig = currentDomListeners[i];
            if (domConfig.equalTo(dispatcher, eventString, listener, options)) {
                return;
            }
        }
        domConfig = new DomEventMapConfig_1.DomEventMapConfig(dispatcher, eventString, listener, options);
        currentDomListeners.push(domConfig);
        if (!this._suspended) {
            dispatcher.addEventListener(eventString, listener, options);
        }
    };
    /**
     * @inheritDoc
     */
    EventMap.prototype.unmapDomListener = function (dispatcher, eventString, listener, options) {
        var currentDomListeners = this._suspended ? this._suspendedDomListeners : this._domListeners;
        var i = currentDomListeners.length;
        while (i--) {
            var config = currentDomListeners[i];
            if (config.equalTo(dispatcher, eventString, listener, options)) {
                if (!this._suspended) {
                    dispatcher.removeEventListener(eventString, listener, options);
                }
                currentDomListeners.splice(i, 1);
                return;
            }
        }
    };
    /**
     * @inheritDoc
     */
    EventMap.prototype.unmapDomListeners = function () {
        var currentDomListeners = this._suspended ? this._suspendedDomListeners : this._domListeners;
        var domEventConfig;
        var dispatcher;
        while (currentDomListeners.length) {
            domEventConfig = currentDomListeners.pop();
            if (!this._suspended) {
                dispatcher = domEventConfig.dispatcher;
                dispatcher.removeEventListener(domEventConfig.eventString, domEventConfig.listener, domEventConfig.options);
            }
        }
    };
    /**
     * @inheritDoc
     */
    EventMap.prototype.unmapAllListeners = function () {
        this.unmapListeners();
        this.unmapDomListeners();
    };
    /**
     * @inheritDoc
     */
    EventMap.prototype.suspend = function () {
        var _this = this;
        if (this._suspended) {
            return;
        }
        this._suspended = true;
        // Handle EventDispatcher's
        var dispatcher;
        this._listeners.forEach(function (eventConfig) {
            dispatcher = eventConfig.dispatcher;
            dispatcher.removeEventListener(eventConfig.eventString, eventConfig.callback, eventConfig.thisObject, eventConfig.useCapture);
            _this._suspendedListeners.push(eventConfig);
        });
        this._listeners = [];
        // Handle EventTarget's (DOM)
        var domDispatcher;
        this._domListeners.forEach(function (domEventConfig) {
            domDispatcher = domEventConfig.dispatcher;
            domDispatcher.removeEventListener(domEventConfig.eventString, domEventConfig.listener, domEventConfig.options);
            _this._suspendedDomListeners.push(domEventConfig);
        });
        this._domListeners = [];
    };
    /**
     * @inheritDoc
     */
    EventMap.prototype.resume = function () {
        var _this = this;
        if (!this._suspended) {
            return;
        }
        this._suspended = false;
        // Handle EventDispatcher's
        var dispatcher;
        this._suspendedListeners.forEach(function (eventConfig) {
            dispatcher = eventConfig.dispatcher;
            dispatcher.addEventListener(eventConfig.eventString, eventConfig.callback, eventConfig.thisObject, eventConfig.useCapture, eventConfig.priority);
            _this._listeners.push(eventConfig);
        });
        this._suspendedListeners = [];
        // Handle EventTarget's (DOM)
        var domDispatcher;
        this._suspendedDomListeners.forEach(function (domEventConfig) {
            domDispatcher = domEventConfig.dispatcher;
            domDispatcher.addEventListener(domEventConfig.eventString, domEventConfig.listener, domEventConfig.options);
            _this._domListeners.push(domEventConfig);
        });
        this._suspendedDomListeners = [];
    };
    /*============================================================================*/
    /* Protected Functions                                                        */
    /*============================================================================*/
    /**
     * Event Handler
     *
     * @param event The <code>Event</code>
     * @param listener
     * @param originalEventClass
     */
    EventMap.prototype.routeEventToListener = function (event, listener, originalEventClass) {
        if (isInstanceOfType_1.isInstanceOfType(event, originalEventClass)) {
            listener(event);
        }
    };
    EventMap = tslib_1.__decorate([
        inversify_1.injectable()
    ], EventMap);
    return EventMap;
}());
exports.EventMap = EventMap;
//# sourceMappingURL=EventMap.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/EventMapConfig.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/localEventMap/impl/EventMapConfig.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var EventMapConfig = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function EventMapConfig(dispatcher, eventString, listener, thisObject, eventClass, callback, useCapture, priority) {
        this._dispatcher = dispatcher;
        this._eventString = eventString;
        this._listener = listener;
        this._thisObject = thisObject;
        this._eventClass = eventClass;
        this._callback = callback;
        this._useCapture = useCapture;
        this._priority = priority;
    }
    Object.defineProperty(EventMapConfig.prototype, "dispatcher", {
        /**
         * @private
         */
        get: function () {
            return this._dispatcher;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventMapConfig.prototype, "eventString", {
        /**
         * @private
         */
        get: function () {
            return this._eventString;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventMapConfig.prototype, "listener", {
        /**
         * @private
         */
        get: function () {
            return this._listener;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventMapConfig.prototype, "thisObject", {
        /**
         * @private
         */
        get: function () {
            return this._thisObject;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventMapConfig.prototype, "eventClass", {
        /**
         * @private
         */
        get: function () {
            return this._eventClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventMapConfig.prototype, "callback", {
        /**
         * @private
         */
        get: function () {
            return this._callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventMapConfig.prototype, "useCapture", {
        /**
         * @private
         */
        get: function () {
            return this._useCapture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventMapConfig.prototype, "priority", {
        /**
         * @private
         */
        get: function () {
            return this._priority;
        },
        enumerable: true,
        configurable: true
    });
    EventMapConfig.prototype.equalTo = function (dispatcher, eventString, listener, thisObject, eventClass, useCapture) {
        return (this._eventString === eventString &&
            this._eventClass === eventClass &&
            this._thisObject === thisObject &&
            this._dispatcher === dispatcher &&
            this._listener === listener &&
            this._useCapture === useCapture);
    };
    return EventMapConfig;
}());
exports.EventMapConfig = EventMapConfig;
//# sourceMappingURL=EventMapConfig.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeFilter.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeFilter.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var getQualifiedClassName_1 = __webpack_require__(/*! ../../framework/impl/getQualifiedClassName */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/getQualifiedClassName.js");
var isInstanceOfType_1 = __webpack_require__(/*! ./isInstanceOfType */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/isInstanceOfType.js");
/**
 * @private
 */
var TypeFilter = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function TypeFilter(allOf, anyOf, noneOf) {
        if (!allOf || !anyOf || !noneOf) {
            throw Error("TypeFilter parameters can not be null");
        }
        this._allOfTypes = allOf;
        this._anyOfTypes = anyOf;
        this._noneOfTypes = noneOf;
    }
    Object.defineProperty(TypeFilter.prototype, "allOfTypes", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._allOfTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeFilter.prototype, "anyOfTypes", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._anyOfTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeFilter.prototype, "noneOfTypes", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._noneOfTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeFilter.prototype, "descriptor", {
        /**
         * @inheritDoc
         */
        get: function () {
            return (this._descriptor = this._descriptor || this.createDescriptor());
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    TypeFilter.prototype.matches = function (item) {
        var i = this._allOfTypes.length;
        while (i--) {
            if (!isInstanceOfType_1.isInstanceOfType(item, this._allOfTypes[i])) {
                return false;
            }
        }
        i = this._noneOfTypes.length;
        while (i--) {
            if (isInstanceOfType_1.isInstanceOfType(item, this._noneOfTypes[i])) {
                return false;
            }
        }
        if (this._anyOfTypes.length === 0 && (this._allOfTypes.length > 0 || this._noneOfTypes.length > 0)) {
            return true;
        }
        i = this._anyOfTypes.length;
        while (i--) {
            if (isInstanceOfType_1.isInstanceOfType(item, this._anyOfTypes[i])) {
                return true;
            }
        }
        return false;
    };
    /*============================================================================*/
    /* Protected Functions                                                        */
    /*============================================================================*/
    TypeFilter.prototype.alphabetiseCaseInsensitiveFCQNs = function (classes) {
        var fqcn;
        var allFCQNs = [];
        var iLength = classes.length;
        for (var i = 0; i < iLength; i++) {
            fqcn = getQualifiedClassName_1.getQualifiedClassName(classes[i]);
            allFCQNs[allFCQNs.length] = fqcn;
        }
        return allFCQNs.sort(this.stringSort);
    };
    TypeFilter.prototype.createDescriptor = function () {
        var allOf_FCQNs = this.alphabetiseCaseInsensitiveFCQNs(this.allOfTypes);
        var anyOf_FCQNs = this.alphabetiseCaseInsensitiveFCQNs(this.anyOfTypes);
        var noneOf_FQCNs = this.alphabetiseCaseInsensitiveFCQNs(this.noneOfTypes);
        var description = [];
        if (allOf_FCQNs.length) {
            description.push("all of: " + allOf_FCQNs.toString());
        }
        if (anyOf_FCQNs.length) {
            description.push("any of: " + anyOf_FCQNs.toString());
        }
        if (noneOf_FQCNs.length) {
            description.push("none of: " + noneOf_FQCNs.toString());
        }
        return description.join("; ");
    };
    TypeFilter.prototype.stringSort = function (item1, item2) {
        var result = 0;
        // ignore upper and lowercase
        item1 = item1.toUpperCase();
        item2 = item2.toUpperCase();
        if (item1 < item2) {
            result = -1;
        }
        else if (item1 > item2) {
            result = 1;
        }
        return result;
    };
    return TypeFilter;
}());
exports.TypeFilter = TypeFilter;
//# sourceMappingURL=TypeFilter.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeMatcher.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeMatcher.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var TypeFilter_1 = __webpack_require__(/*! ./TypeFilter */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeFilter.js");
var TypeMatcherError_1 = __webpack_require__(/*! ./TypeMatcherError */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeMatcherError.js");
/**
 * A Type Matcher matches objects that satisfy type matching rules
 */
var TypeMatcher = /** @class */ (function () {
    function TypeMatcher() {
        /*============================================================================*/
        /* Protected Properties                                                       */
        /*============================================================================*/
        this._allOfTypes = [];
        this._anyOfTypes = [];
        this._noneOfTypes = [];
        this._typeFilter = null;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * All types that an item must extend or implement
     */
    TypeMatcher.prototype.allOf = function (type) {
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
        }
        if (type instanceof Array) {
            this.pushAddedTypesTo(type.concat(types), this._allOfTypes);
        }
        else {
            this.pushAddedTypesTo([type].concat(types), this._allOfTypes);
        }
        return this;
    };
    /**
     * Any types that an item must extend or implement
     */
    TypeMatcher.prototype.anyOf = function (type) {
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
        }
        if (type instanceof Array) {
            this.pushAddedTypesTo(type.concat(types), this._anyOfTypes);
        }
        else {
            this.pushAddedTypesTo([type].concat(types), this._anyOfTypes);
        }
        return this;
    };
    /**
     * Types that an item must not extend or implement
     */
    TypeMatcher.prototype.noneOf = function (type) {
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
        }
        if (type instanceof Array) {
            this.pushAddedTypesTo(type.concat(types), this._noneOfTypes);
        }
        else {
            this.pushAddedTypesTo([type].concat(types), this._noneOfTypes);
        }
        return this;
    };
    /**
     * @inheritDoc
     */
    TypeMatcher.prototype.createTypeFilter = function () {
        // calling this seals the matcher
        return (this._typeFilter = this._typeFilter || this.buildTypeFilter());
    };
    /**
     * Locks this type matcher
     * @return
     */
    TypeMatcher.prototype.lock = function () {
        this.createTypeFilter();
        return this;
    };
    /**
     * @inheritDoc
     */
    TypeMatcher.prototype.clone = function () {
        return new TypeMatcher()
            .allOf(this._allOfTypes)
            .anyOf(this._anyOfTypes)
            .noneOf(this._noneOfTypes);
    };
    /*============================================================================*/
    /* Protected Functions                                                        */
    /*============================================================================*/
    TypeMatcher.prototype.buildTypeFilter = function () {
        if (this._allOfTypes.length === 0 && this._anyOfTypes.length === 0 && this._noneOfTypes.length === 0) {
            throw new TypeMatcherError_1.TypeMatcherError(TypeMatcherError_1.TypeMatcherError.EMPTY_MATCHER);
        }
        return new TypeFilter_1.TypeFilter(this._allOfTypes, this._anyOfTypes, this._noneOfTypes);
    };
    TypeMatcher.prototype.pushAddedTypesTo = function (types, targetSet) {
        if (this._typeFilter) {
            this.throwSealedMatcherError();
        }
        this.pushValuesToTargetSet(types, targetSet);
    };
    TypeMatcher.prototype.throwSealedMatcherError = function () {
        throw new TypeMatcherError_1.TypeMatcherError(TypeMatcherError_1.TypeMatcherError.SEALED_MATCHER);
    };
    TypeMatcher.prototype.pushValuesToTargetSet = function (values, targetSet) {
        values.forEach(function (type) {
            targetSet.push(type);
        });
    };
    return TypeMatcher;
}());
exports.TypeMatcher = TypeMatcher;
//# sourceMappingURL=TypeMatcher.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeMatcherError.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/TypeMatcherError.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * Type Matcher Error
 */
var TypeMatcherError = /** @class */ (function (_super) {
    tslib_1.__extends(TypeMatcherError, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a Type Matcher Error
     * @param message The error message
     */
    function TypeMatcherError(message) {
        return _super.call(this, message) || this;
    }
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    TypeMatcherError.EMPTY_MATCHER = "An empty matcher will create a filter which matches nothing. " + "You should specify at least one condition for the filter.";
    TypeMatcherError.SEALED_MATCHER = "This matcher has been sealed and can no longer be configured.";
    return TypeMatcherError;
}(Error));
exports.TypeMatcherError = TypeMatcherError;
//# sourceMappingURL=TypeMatcherError.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/instanceOfType.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/instanceOfType.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var isInstanceOfType_1 = __webpack_require__(/*! ./isInstanceOfType */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/isInstanceOfType.js");
/*============================================================================*/
/* Public Functions                                                           */
/*============================================================================*/
/**
 * @private
 */
var InstanceOfTypeMatcher = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function InstanceOfTypeMatcher(type) {
        this._type = type;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Verify if the given item is a instance of this type.
     *
     * @param { any } item The item to test
     * @return { boolean } <code>true</code> if the item is a instance of the type,
     * <code>false</code> otherwise.
     */
    InstanceOfTypeMatcher.prototype.matches = function (item) {
        return isInstanceOfType_1.isInstanceOfType(item, this._type);
    };
    return InstanceOfTypeMatcher;
}());
/**
 * Creates a matcher that matches objects of the given type
 * @param type The type to match
 * @return A matcher
 */
function instanceOfType(type) {
    return new InstanceOfTypeMatcher(type);
}
exports.instanceOfType = instanceOfType;
//# sourceMappingURL=instanceOfType.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/isInstanceOfType.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/extensions/matching/isInstanceOfType.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/*============================================================================*/
/* Public Functions                                                           */
/*============================================================================*/
/**
 * Verify if a given item is a instance of a given type.
 *
 * Matches primitive types using constructor.
 * Matches all other types using instanceof operator.
 *
 * According to TypeScript specification:
 *
 * 4.19.4 The instanceof operator
 *
 * The instanceof operator requires the left operand to be of type Any,
 * an object type, or a type parameter type, and the right operand
 * to be of type Any or a subtype of the 'Function' interface type.
 *
 * The result is always of the boolean primitive type.
 *
 * @param { any } item The item to test
 * @param { IType<T> } type The type to match to
 * @return { boolean } <code>true</code> if the item is a instance of the type,
 * <code>false</code> otherwise.
 *
 * @see {@link https://github.com/Microsoft/TypeScript/blob/v2.6.1/doc/spec.md#4.19.4}
 */
function isInstanceOfType(item, type) {
    return item instanceof type || item.constructor === type;
}
exports.isInstanceOfType = isInstanceOfType;
//# sourceMappingURL=isInstanceOfType.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IContext.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IContext.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/*[Event(name="destroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="detain", type="robotlegs.bender.framework.api.PinEvent")]*/
/*[Event(name="initialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postDestroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postInitialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postResume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postSuspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preDestroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preInitialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preResume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preSuspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="release", type="robotlegs.bender.framework.api.PinEvent")]*/
/*[Event(name="resume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="stateChange", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="suspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/**
 * The Robotlegs context contract
 */
exports.IContext = Symbol("IContext");
//# sourceMappingURL=IContext.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IInjector.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IInjector.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The <code>Injector</code> manages the mappings and acts as the central hub from which all
 * injections are started.
 */
exports.IInjector = Symbol("IInjector");
//# sourceMappingURL=IInjector.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/ILogger.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/ILogger.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The Robotlegs logger contract
 */
exports.ILogger = Symbol("ILogger");
//# sourceMappingURL=ILogger.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleError.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleError.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * Lifecycle Error
 */
var LifecycleError = /** @class */ (function (_super) {
    tslib_1.__extends(LifecycleError, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a Lifecycle Error
     * @param message The error message
     */
    function LifecycleError(message) {
        var _this = _super.call(this) || this;
        _this.name = "LifecycleError";
        _this.message = message;
        return _this;
    }
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    LifecycleError.SYNC_HANDLER_ARG_MISMATCH = "When and After handlers must accept 0 or 1 arguments";
    LifecycleError.LATE_HANDLER_ERROR_MESSAGE = "Handler added late and will never fire";
    return LifecycleError;
}(Error));
exports.LifecycleError = LifecycleError;
//# sourceMappingURL=LifecycleError.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleEvent.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleEvent.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Robotlegs object lifecycle event
 */
var LifecycleEvent = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a Lifecycle Event
     * @param type The event type
     * @param error Optional error
     */
    function LifecycleEvent(type, error) {
        this._type = type;
        this._error = error;
    }
    Object.defineProperty(LifecycleEvent.prototype, "error", {
        /**
         * Associated lifecycle error
         */
        get: function () {
            return this._error;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LifecycleEvent.prototype, "type", {
        /**
         * The type of event
         */
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LifecycleEvent.prototype, "target", {
        /**
         * The target of event
         */
        get: function () {
            return this._target;
        },
        set: function (value) {
            this._target = value;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    LifecycleEvent.prototype.clone = function () {
        return new LifecycleEvent(this.type, this.error);
    };
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    LifecycleEvent.ERROR = "_error";
    LifecycleEvent.STATE_CHANGE = "stateChange";
    LifecycleEvent.PRE_INITIALIZE = "preInitialize";
    LifecycleEvent.INITIALIZE = "initialize";
    LifecycleEvent.POST_INITIALIZE = "postInitialize";
    LifecycleEvent.PRE_SUSPEND = "preSuspend";
    LifecycleEvent.SUSPEND = "suspend";
    LifecycleEvent.POST_SUSPEND = "postSuspend";
    LifecycleEvent.PRE_RESUME = "preResume";
    LifecycleEvent.RESUME = "resume";
    LifecycleEvent.POST_RESUME = "postResume";
    LifecycleEvent.PRE_DESTROY = "preDestroy";
    LifecycleEvent.DESTROY = "destroy";
    LifecycleEvent.POST_DESTROY = "postDestroy";
    return LifecycleEvent;
}());
exports.LifecycleEvent = LifecycleEvent;
//# sourceMappingURL=LifecycleEvent.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleState.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleState.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Robotlegs object lifecycle state
 */
var LifecycleState = /** @class */ (function () {
    function LifecycleState() {
    }
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    LifecycleState.UNINITIALIZED = "uninitialized";
    LifecycleState.INITIALIZING = "initializing";
    LifecycleState.ACTIVE = "active";
    LifecycleState.SUSPENDING = "suspending";
    LifecycleState.SUSPENDED = "suspended";
    LifecycleState.RESUMING = "resuming";
    LifecycleState.DESTROYING = "destroying";
    LifecycleState.DESTROYED = "destroyed";
    return LifecycleState;
}());
exports.LifecycleState = LifecycleState;
//# sourceMappingURL=LifecycleState.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LogLevel.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LogLevel.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Robotlegs log level
 */
var LogLevel = /** @class */ (function () {
    function LogLevel() {
    }
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    LogLevel.FATAL = 2;
    LogLevel.ERROR = 4;
    LogLevel.WARN = 8;
    LogLevel.INFO = 16;
    LogLevel.DEBUG = 32;
    LogLevel.NAME = [
        0,
        0,
        "FATAL",
        0,
        "ERROR",
        0,
        0,
        0,
        "WARN",
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        "INFO",
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        "DEBUG"
    ]; // 32
    return LogLevel;
}());
exports.LogLevel = LogLevel;
//# sourceMappingURL=LogLevel.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/PinEvent.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/PinEvent.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var Event_1 = __webpack_require__(/*! ../../events/impl/Event */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/Event.js");
/**
 * Detain/release pin Event
 */
var PinEvent = /** @class */ (function (_super) {
    tslib_1.__extends(PinEvent, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Create a Pin Event
     * @param type The event type
     * @param instance The associated instance
     */
    function PinEvent(type, instance) {
        var _this = _super.call(this, type) || this;
        _this._instance = instance;
        return _this;
    }
    Object.defineProperty(PinEvent.prototype, "instance", {
        /**
         * The instance being detained or released
         */
        get: function () {
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    PinEvent.prototype.clone = function () {
        return new PinEvent(this.type, this._instance);
    };
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    PinEvent.DETAIN = "detain";
    PinEvent.RELEASE = "release";
    return PinEvent;
}(Event_1.Event));
exports.PinEvent = PinEvent;
//# sourceMappingURL=PinEvent.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ClassMatcher.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ClassMatcher.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var ClassMatcher = /** @class */ (function () {
    function ClassMatcher() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    ClassMatcher.prototype.matches = function (item) {
        return typeof item === "function";
    };
    return ClassMatcher;
}());
exports.ClassMatcher = ClassMatcher;
//# sourceMappingURL=ClassMatcher.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ConfigManager.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ConfigManager.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var LifecycleEvent_1 = __webpack_require__(/*! ../api/LifecycleEvent */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleEvent.js");
var ClassMatcher_1 = __webpack_require__(/*! ./ClassMatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ClassMatcher.js");
var ObjectMatcher_1 = __webpack_require__(/*! ./ObjectMatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectMatcher.js");
var ObjectProcessor_1 = __webpack_require__(/*! ./ObjectProcessor */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectProcessor.js");
var instantiateUnmapped_1 = __webpack_require__(/*! ./instantiateUnmapped */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/instantiateUnmapped.js");
/**
 * The config manager handles configuration files and
 * allows the installation of custom configuration handlers.
 *
 * <p>It is pre-configured to handle plain objects and classes</p>
 *
 * @private
 */
var ConfigManager = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function ConfigManager(context) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._objectProcessor = new ObjectProcessor_1.ObjectProcessor();
        this._configs = new Map();
        this._queue = [];
        this._initialized = false;
        this._context = context;
        this._injector = context.injector;
        this._logger = context.getLogger(this);
        this.addConfigHandler(new ClassMatcher_1.ClassMatcher(), this.handleClass.bind(this));
        this.addConfigHandler(new ObjectMatcher_1.ObjectMatcher(), this.handleObject.bind(this));
        // The ConfigManager should process the config queue
        // at the end of the INITIALIZE phase,
        // but *before* POST_INITIALIZE, so use low event priority
        context.addEventListener(LifecycleEvent_1.LifecycleEvent.INITIALIZE, this.initialize, this, false, -100);
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Process a given configuration object by running it through registered handlers.
     * <p>If the manager is not initialized the configuration will be queued.</p>
     * @param config The configuration object or class
     */
    ConfigManager.prototype.addConfig = function (config) {
        if (!this._configs.get(config)) {
            this._configs.set(config, true);
            this._objectProcessor.processObject(config);
        }
    };
    /**
     * Adds a custom configuration handlers
     * @param matcher Pattern to match configuration objects
     * @param handler Handler to process matching configurations
     */
    ConfigManager.prototype.addConfigHandler = function (matcher, handler) {
        this._objectProcessor.addObjectHandler(matcher, handler);
    };
    /**
     * Destroy
     */
    ConfigManager.prototype.destroy = function () {
        this._context.removeEventListener(LifecycleEvent_1.LifecycleEvent.INITIALIZE, this.initialize);
        this._objectProcessor.removeAllHandlers();
        this._queue.length = 0;
        this._configs.clear();
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    ConfigManager.prototype.initialize = function (event) {
        if (!this._initialized) {
            this._initialized = true;
            this.processQueue();
        }
    };
    ConfigManager.prototype.handleClass = function (type) {
        if (this._initialized) {
            this._logger.debug("Already initialized. Instantiating config class {0}", [type]);
            this.processClass(type);
        }
        else {
            this._logger.debug("Not yet initialized. Queuing config class {0}", [type]);
            this._queue.push(type);
        }
    };
    ConfigManager.prototype.handleObject = function (object) {
        if (this._initialized) {
            this._logger.debug("Already initialized. Injecting into config object {0}", [object]);
            this.processObject(object);
        }
        else {
            this._logger.debug("Not yet initialized. Queuing config object {0}", [object]);
            this._queue.push(object);
        }
    };
    ConfigManager.prototype.processQueue = function () {
        for (var i in this._queue) {
            if (this._queue.hasOwnProperty(i)) {
                var config = this._queue[i];
                if (typeof config === "function") {
                    // instanceof Class
                    this._logger.debug("Now initializing. Instantiating config class {0}", [config]);
                    this.processClass(config);
                }
                else {
                    this._logger.debug("Now initializing. Injecting into config object {0}", [config]);
                    this.processObject(config);
                }
            }
        }
        this._queue.length = 0;
    };
    ConfigManager.prototype.processClass = function (type) {
        var config = instantiateUnmapped_1.instantiateUnmapped(this._injector, type);
        if (config) {
            config.configure();
        }
    };
    ConfigManager.prototype.processObject = function (object) {
        var config = object;
        if (config && config.configure) {
            config.configure();
        }
    };
    return ConfigManager;
}());
exports.ConfigManager = ConfigManager;
//# sourceMappingURL=ConfigManager.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Context.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Context.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var inversify_1 = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
var IContext_1 = __webpack_require__(/*! ../api/IContext */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IContext.js");
var IInjector_1 = __webpack_require__(/*! ../api/IInjector */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/IInjector.js");
var LifecycleEvent_1 = __webpack_require__(/*! ../api/LifecycleEvent */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleEvent.js");
var ConfigManager_1 = __webpack_require__(/*! ./ConfigManager */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ConfigManager.js");
var ExtensionInstaller_1 = __webpack_require__(/*! ./ExtensionInstaller */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ExtensionInstaller.js");
var Lifecycle_1 = __webpack_require__(/*! ./Lifecycle */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Lifecycle.js");
var LogManager_1 = __webpack_require__(/*! ./LogManager */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/LogManager.js");
var Pin_1 = __webpack_require__(/*! ./Pin */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Pin.js");
var RobotlegsInjector_1 = __webpack_require__(/*! ./RobotlegsInjector */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/RobotlegsInjector.js");
var UID_1 = __webpack_require__(/*! ./UID */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/UID.js");
var EventDispatcher_1 = __webpack_require__(/*! ../../events/impl/EventDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/events/impl/EventDispatcher.js");
/*[Event(name="destroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="detain", type="robotlegs.bender.framework.api.PinEvent")]*/
/*[Event(name="initialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postDestroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postInitialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postResume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postSuspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preDestroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preInitialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preResume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preSuspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="release", type="robotlegs.bender.framework.api.PinEvent")]*/
/*[Event(name="resume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="stateChange", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="suspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/**
 * The core Robotlegs Context implementation
 */
var Context = /** @class */ (function (_super) {
    tslib_1.__extends(Context, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a new Context
     */
    function Context() {
        var _this = _super.call(this) || this;
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        _this._uid = UID_1.UID.create(Context_1);
        _this._children = [];
        _this.setup();
        return _this;
    }
    Context_1 = Context;
    Object.defineProperty(Context.prototype, "injector", {
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        /**
         * @inheritDoc
         */
        get: function () {
            return this._injector;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "logLevel", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._logManager.logLevel;
        },
        /**
         * @inheritDoc
         */
        set: function (value) {
            this._logManager.logLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "state", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._lifecycle.state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "uninitialized", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._lifecycle.uninitialized;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "initialized", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._lifecycle.initialized;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "active", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._lifecycle.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "suspended", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._lifecycle.suspended;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "destroyed", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._lifecycle.destroyed;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    Context.prototype.initialize = function (callback) {
        this._lifecycle.initialize(callback);
    };
    /**
     * @inheritDoc
     */
    Context.prototype.suspend = function (callback) {
        this._lifecycle.suspend(callback);
    };
    /**
     * @inheritDoc
     */
    Context.prototype.resume = function (callback) {
        this._lifecycle.resume(callback);
    };
    /**
     * @inheritDoc
     */
    Context.prototype.destroy = function (callback) {
        this._lifecycle.destroy(callback);
    };
    /**
     * @inheritDoc
     */
    Context.prototype.beforeInitializing = function (handler) {
        this._lifecycle.beforeInitializing(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.whenInitializing = function (handler) {
        this._lifecycle.whenInitializing(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.afterInitializing = function (handler) {
        this._lifecycle.afterInitializing(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.beforeSuspending = function (handler) {
        this._lifecycle.beforeSuspending(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.whenSuspending = function (handler) {
        this._lifecycle.whenSuspending(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.afterSuspending = function (handler) {
        this._lifecycle.afterSuspending(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.beforeResuming = function (handler) {
        this._lifecycle.beforeResuming(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.whenResuming = function (handler) {
        this._lifecycle.whenResuming(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.afterResuming = function (handler) {
        this._lifecycle.afterResuming(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.beforeDestroying = function (handler) {
        this._lifecycle.beforeDestroying(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.whenDestroying = function (handler) {
        this._lifecycle.whenDestroying(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.afterDestroying = function (handler) {
        this._lifecycle.afterDestroying(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.install = function () {
        var _this = this;
        var extensions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            extensions[_i] = arguments[_i];
        }
        extensions.forEach(function (extension) {
            _this._extensionInstaller.install(extension);
        });
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.configure = function () {
        var _this = this;
        var configs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            configs[_i] = arguments[_i];
        }
        configs.forEach(function (config) {
            _this._configManager.addConfig(config);
        });
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.addChild = function (child) {
        if (this._children.indexOf(child) === -1) {
            this._logger.debug("Adding child context {0}", [child]);
            if (!child.uninitialized) {
                this._logger.warn("Child context {0} must be uninitialized", [child]);
            }
            if (child.injector.parent) {
                this._logger.warn("Child context {0} must not have a parent Injector", [child]);
            }
            this._children.push(child);
            child.injector.parent = this.injector;
            child.addEventListener(LifecycleEvent_1.LifecycleEvent.POST_DESTROY, this.onChildDestroy, this);
        }
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.removeChild = function (child) {
        var childIndex = this._children.indexOf(child);
        if (childIndex > -1) {
            this._logger.debug("Removing child context {0}", [child]);
            this._children.splice(childIndex, 1);
            child.injector.parent = null;
            child.removeEventListener(LifecycleEvent_1.LifecycleEvent.POST_DESTROY, this.onChildDestroy, this);
        }
        else {
            this._logger.warn("Child context {0} must be a child of {1}", [child, this]);
        }
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.addConfigHandler = function (matcher, handler) {
        this._configManager.addConfigHandler(matcher, handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.getLogger = function (source) {
        return this._logManager.getLogger(source);
    };
    /**
     * @inheritDoc
     */
    Context.prototype.addLogTarget = function (target) {
        this._logManager.addLogTarget(target);
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.detain = function () {
        var _this = this;
        var instances = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            instances[_i] = arguments[_i];
        }
        instances.forEach(function (instance) {
            _this._pin.detain(instance);
        });
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.release = function () {
        var _this = this;
        var instances = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            instances[_i] = arguments[_i];
        }
        instances.forEach(function (instance) {
            _this._pin.release(instance);
        });
        return this;
    };
    /**
     * @inheritDoc
     */
    Context.prototype.toString = function () {
        return this._uid;
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    /**
     * Configures mandatory context dependencies
     */
    Context.prototype.setup = function () {
        this._logManager = new LogManager_1.LogManager();
        this._injector = new RobotlegsInjector_1.RobotlegsInjector();
        this._injector.bind(IInjector_1.IInjector).toConstantValue(this._injector);
        this._injector.bind(IContext_1.IContext).toConstantValue(this);
        this._logger = this._logManager.getLogger(this);
        this._pin = new Pin_1.Pin(this);
        this._lifecycle = new Lifecycle_1.Lifecycle(this);
        this._configManager = new ConfigManager_1.ConfigManager(this);
        this._extensionInstaller = new ExtensionInstaller_1.ExtensionInstaller(this);
        this.beforeInitializing(this.beforeInitializingCallback.bind(this));
        this.afterInitializing(this.afterInitializingCallback.bind(this));
        this.beforeDestroying(this.beforeDestroyingCallback.bind(this));
        this.afterDestroying(this.afterDestroyingCallback.bind(this));
    };
    Context.prototype.beforeInitializingCallback = function () {
        this._logger.debug("Initializing...");
    };
    Context.prototype.afterInitializingCallback = function () {
        this._logger.debug("Initialize complete");
    };
    Context.prototype.beforeDestroyingCallback = function () {
        this._logger.debug("Destroying...");
    };
    Context.prototype.afterDestroyingCallback = function () {
        this._extensionInstaller.destroy();
        this._configManager.destroy();
        this._pin.releaseAll();
        this._injector.unbindAll();
        this.removeChildren();
        this._logger.debug("Destroy complete");
        this._logManager.removeAllTargets();
    };
    Context.prototype.onChildDestroy = function (event) {
        this.removeChild(event.target);
    };
    Context.prototype.removeChildren = function () {
        while (this._children.length > 0) {
            this.removeChild(this._children[this._children.length - 1]);
        }
    };
    var Context_1;
    Context = Context_1 = tslib_1.__decorate([
        inversify_1.injectable(),
        tslib_1.__metadata("design:paramtypes", [])
    ], Context);
    return Context;
}(EventDispatcher_1.EventDispatcher));
exports.Context = Context;
//# sourceMappingURL=Context.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ExtensionInstaller.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ExtensionInstaller.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Installs custom extensions into a given context
 *
 * @private
 */
var ExtensionInstaller = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function ExtensionInstaller(context) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._classes = new Map();
        this._context = context;
        this._logger = this._context.getLogger(this);
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Installs the supplied extension
     * @param extension An object or class implementing IExtension
     */
    ExtensionInstaller.prototype.install = function (extension) {
        if (typeof extension === "function" && extension.prototype.extend !== undefined) {
            if (!this._classes.get(extension)) {
                this.install(new extension());
            }
        }
        else {
            var extensionClass = extension.constructor;
            if (!this._classes.get(extensionClass)) {
                this._logger.debug("Installing extension {0}", [extension]);
                this._classes.set(extensionClass, true);
                extension.extend(this._context);
            }
        }
    };
    /**
     * Destroy
     */
    ExtensionInstaller.prototype.destroy = function () {
        this._classes.clear();
    };
    return ExtensionInstaller;
}());
exports.ExtensionInstaller = ExtensionInstaller;
//# sourceMappingURL=ExtensionInstaller.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Lifecycle.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Lifecycle.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var LifecycleError_1 = __webpack_require__(/*! ../api/LifecycleError */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleError.js");
var LifecycleEvent_1 = __webpack_require__(/*! ../api/LifecycleEvent */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleEvent.js");
var LifecycleState_1 = __webpack_require__(/*! ../api/LifecycleState */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleState.js");
var LifecycleTransition_1 = __webpack_require__(/*! ./LifecycleTransition */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/LifecycleTransition.js");
/*[Event(name="destroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="error", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="initialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postDestroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postInitialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postResume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="postSuspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preDestroy", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preInitialize", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preResume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="preSuspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="resume", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="stateChange", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/*[Event(name="suspend", type="robotlegs.bender.framework.api.LifecycleEvent")]*/
/**
 * Default object lifecycle
 *
 * @private
 */
var Lifecycle = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a lifecycle for a given target object
     * @param target The target object
     */
    function Lifecycle(target) {
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        this._state = LifecycleState_1.LifecycleState.UNINITIALIZED;
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._reversedEventTypes = new Map();
        this._reversePriority = 0;
        this._target = target;
        this._dispatcher = target; // || new EventDispatcher(this);
        this.configureTransitions();
    }
    Object.defineProperty(Lifecycle.prototype, "state", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Lifecycle.prototype, "target", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Lifecycle.prototype, "uninitialized", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._state === LifecycleState_1.LifecycleState.UNINITIALIZED;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Lifecycle.prototype, "initialized", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._state !== LifecycleState_1.LifecycleState.UNINITIALIZED && this._state !== LifecycleState_1.LifecycleState.INITIALIZING;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Lifecycle.prototype, "active", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._state === LifecycleState_1.LifecycleState.ACTIVE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Lifecycle.prototype, "suspended", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._state === LifecycleState_1.LifecycleState.SUSPENDED;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Lifecycle.prototype, "destroyed", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._state === LifecycleState_1.LifecycleState.DESTROYED;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.initialize = function (callback) {
        this._initialize.enter(callback);
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.suspend = function (callback) {
        this._suspend.enter(callback);
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.resume = function (callback) {
        this._resume.enter(callback);
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.destroy = function (callback) {
        this._destroy.enter(callback);
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.beforeInitializing = function (handler) {
        if (!this.uninitialized) {
            this.reportError(LifecycleError_1.LifecycleError.LATE_HANDLER_ERROR_MESSAGE);
        }
        this._initialize.addBeforeHandler(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.whenInitializing = function (handler) {
        if (this.initialized) {
            this.reportError(LifecycleError_1.LifecycleError.LATE_HANDLER_ERROR_MESSAGE);
        }
        this.addEventListener(LifecycleEvent_1.LifecycleEvent.INITIALIZE, this.createSyncLifecycleListener(handler, true));
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.afterInitializing = function (handler) {
        if (this.initialized) {
            this.reportError(LifecycleError_1.LifecycleError.LATE_HANDLER_ERROR_MESSAGE);
        }
        this.addEventListener(LifecycleEvent_1.LifecycleEvent.POST_INITIALIZE, this.createSyncLifecycleListener(handler, true));
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.beforeSuspending = function (handler) {
        this._suspend.addBeforeHandler(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.whenSuspending = function (handler) {
        this.addEventListener(LifecycleEvent_1.LifecycleEvent.SUSPEND, this.createSyncLifecycleListener(handler));
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.afterSuspending = function (handler) {
        this.addEventListener(LifecycleEvent_1.LifecycleEvent.POST_SUSPEND, this.createSyncLifecycleListener(handler));
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.beforeResuming = function (handler) {
        this._resume.addBeforeHandler(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.whenResuming = function (handler) {
        this.addEventListener(LifecycleEvent_1.LifecycleEvent.RESUME, this.createSyncLifecycleListener(handler));
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.afterResuming = function (handler) {
        this.addEventListener(LifecycleEvent_1.LifecycleEvent.POST_RESUME, this.createSyncLifecycleListener(handler));
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.beforeDestroying = function (handler) {
        this._destroy.addBeforeHandler(handler);
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.whenDestroying = function (handler) {
        this.addEventListener(LifecycleEvent_1.LifecycleEvent.DESTROY, this.createSyncLifecycleListener(handler, true));
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.afterDestroying = function (handler) {
        this.addEventListener(LifecycleEvent_1.LifecycleEvent.POST_DESTROY, this.createSyncLifecycleListener(handler, true));
        return this;
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
        if (useCapture === void 0) { useCapture = false; }
        if (priority === void 0) { priority = 0; }
        if (useWeakReference === void 0) { useWeakReference = false; }
        priority = this.flipPriority(type, priority);
        // this._dispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference);
        this._dispatcher.addEventListener(type, listener, undefined, useCapture, priority);
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.removeEventListener = function (type, listener, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        this._dispatcher.removeEventListener(type, listener);
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.dispatchEvent = function (event) {
        return this._dispatcher.dispatchEvent(event);
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.hasEventListener = function (type) {
        return this._dispatcher.hasEventListener(type);
    };
    /**
     * @inheritDoc
     */
    Lifecycle.prototype.willTrigger = function (type) {
        return this._dispatcher.willTrigger(type);
    };
    /*============================================================================*/
    /* Internal Functions                                                         */
    /*============================================================================*/
    Lifecycle.prototype.setCurrentState = function (state) {
        if (this._state !== state) {
            this._state = state;
            this.dispatchEvent(new LifecycleEvent_1.LifecycleEvent(LifecycleEvent_1.LifecycleEvent.STATE_CHANGE));
        }
    };
    Lifecycle.prototype.addReversedEventTypes = function () {
        var _this = this;
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        types.forEach(function (type) {
            _this._reversedEventTypes.set(type, true);
        });
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    Lifecycle.prototype.configureTransitions = function () {
        this._initialize = new LifecycleTransition_1.LifecycleTransition(LifecycleEvent_1.LifecycleEvent.PRE_INITIALIZE, this)
            .fromStates(LifecycleState_1.LifecycleState.UNINITIALIZED)
            .toStates(LifecycleState_1.LifecycleState.INITIALIZING, LifecycleState_1.LifecycleState.ACTIVE)
            .withEvents(LifecycleEvent_1.LifecycleEvent.PRE_INITIALIZE, LifecycleEvent_1.LifecycleEvent.INITIALIZE, LifecycleEvent_1.LifecycleEvent.POST_INITIALIZE);
        this._suspend = new LifecycleTransition_1.LifecycleTransition(LifecycleEvent_1.LifecycleEvent.PRE_SUSPEND, this)
            .fromStates(LifecycleState_1.LifecycleState.ACTIVE)
            .toStates(LifecycleState_1.LifecycleState.SUSPENDING, LifecycleState_1.LifecycleState.SUSPENDED)
            .withEvents(LifecycleEvent_1.LifecycleEvent.PRE_SUSPEND, LifecycleEvent_1.LifecycleEvent.SUSPEND, LifecycleEvent_1.LifecycleEvent.POST_SUSPEND)
            .inReverse();
        this._resume = new LifecycleTransition_1.LifecycleTransition(LifecycleEvent_1.LifecycleEvent.PRE_RESUME, this)
            .fromStates(LifecycleState_1.LifecycleState.SUSPENDED)
            .toStates(LifecycleState_1.LifecycleState.RESUMING, LifecycleState_1.LifecycleState.ACTIVE)
            .withEvents(LifecycleEvent_1.LifecycleEvent.PRE_RESUME, LifecycleEvent_1.LifecycleEvent.RESUME, LifecycleEvent_1.LifecycleEvent.POST_RESUME);
        this._destroy = new LifecycleTransition_1.LifecycleTransition(LifecycleEvent_1.LifecycleEvent.PRE_DESTROY, this)
            .fromStates(LifecycleState_1.LifecycleState.SUSPENDED, LifecycleState_1.LifecycleState.ACTIVE)
            .toStates(LifecycleState_1.LifecycleState.DESTROYING, LifecycleState_1.LifecycleState.DESTROYED)
            .withEvents(LifecycleEvent_1.LifecycleEvent.PRE_DESTROY, LifecycleEvent_1.LifecycleEvent.DESTROY, LifecycleEvent_1.LifecycleEvent.POST_DESTROY)
            .inReverse();
    };
    Lifecycle.prototype.flipPriority = function (type, priority) {
        return priority === 0 && this._reversedEventTypes.get(type) ? this._reversePriority++ : priority;
    };
    Lifecycle.prototype.createSyncLifecycleListener = function (handler, once) {
        if (once === void 0) { once = false; }
        // When and After handlers can not be asynchronous
        if (handler.length > 1) {
            throw new LifecycleError_1.LifecycleError(LifecycleError_1.LifecycleError.SYNC_HANDLER_ARG_MISMATCH);
        }
        // A handler that accepts 1 argument is provided with the event type
        if (handler.length === 1) {
            return function (event) {
                if (once) {
                    // (<IEventDispatcher>event.target).removeEventListener(event.type, arguments.callee);
                    event.target.removeEventListener(event.type, handler);
                }
                handler(event.type);
            };
        }
        // Or, just call the handler
        return function (event) {
            if (once) {
                // (<IEventDispatcher>event.target).removeEventListener(event.type, arguments.callee);
                event.target.removeEventListener(event.type, handler);
            }
            handler();
        };
    };
    Lifecycle.prototype.reportError = function (message) {
        var error = new LifecycleError_1.LifecycleError(message);
        if (this.hasEventListener(LifecycleEvent_1.LifecycleEvent.ERROR)) {
            var event_1 = new LifecycleEvent_1.LifecycleEvent(LifecycleEvent_1.LifecycleEvent.ERROR, error);
            this.dispatchEvent(event_1);
        }
        else {
            throw error;
        }
    };
    return Lifecycle;
}());
exports.Lifecycle = Lifecycle;
//# sourceMappingURL=Lifecycle.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/LifecycleTransition.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/LifecycleTransition.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var LifecycleEvent_1 = __webpack_require__(/*! ../api/LifecycleEvent */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LifecycleEvent.js");
var MessageDispatcher_1 = __webpack_require__(/*! ./MessageDispatcher */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/MessageDispatcher.js");
var safelyCallBack_1 = __webpack_require__(/*! ./safelyCallBack */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/safelyCallBack.js");
/**
 * Handles a lifecycle transition
 *
 * @private
 */
var LifecycleTransition = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a lifecycle transition
     * @param name The name of the transition
     * @param lifecycle The associated lifecycle instance
     */
    function LifecycleTransition(name, lifecycle) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._fromStates = [];
        this._dispatcher = new MessageDispatcher_1.MessageDispatcher();
        this._callbacks = [];
        this._reverse = false;
        this._name = name;
        this._lifecycle = lifecycle;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * States that this transition is allowed to enter from
     * @param states Allowed states
     * @return Self
     */
    LifecycleTransition.prototype.fromStates = function () {
        var _this = this;
        var states = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            states[_i] = arguments[_i];
        }
        states.forEach(function (state) {
            _this._fromStates.push(state);
        });
        return this;
    };
    /**
     * The states that this transition applies
     * @param transitionState The state that the target is put into during the transition
     * @param finalState The state that the target is put into after the transition
     * @return
     */
    LifecycleTransition.prototype.toStates = function (transitionState, finalState) {
        this._transitionState = transitionState;
        this._finalState = finalState;
        return this;
    };
    /**
     * The events that the lifecycle will dispatch
     * @param preTransitionEvent
     * @param transitionEvent
     * @param postTransitionEvent
     * @return Self
     */
    LifecycleTransition.prototype.withEvents = function (preTransitionEvent, transitionEvent, postTransitionEvent) {
        this._preTransitionEvent = preTransitionEvent;
        this._transitionEvent = transitionEvent;
        this._postTransitionEvent = postTransitionEvent;
        if (this._reverse) {
            this._lifecycle.addReversedEventTypes(preTransitionEvent, transitionEvent, postTransitionEvent);
        }
        return this;
    };
    /**
     * Reverse the dispatch order of this transition
     * @return Self
     */
    LifecycleTransition.prototype.inReverse = function () {
        this._reverse = true;
        this._lifecycle.addReversedEventTypes(this._preTransitionEvent, this._transitionEvent, this._postTransitionEvent);
        return this;
    };
    /**
     * A handler to run before the transition runs
     * @param handler Possibly asynchronous before handler
     * @return Self
     */
    LifecycleTransition.prototype.addBeforeHandler = function (handler) {
        this._dispatcher.addMessageHandler(this._name, handler);
        return this;
    };
    /**
     * Attempts to enter the transition
     * @param callback Completion callback
     */
    LifecycleTransition.prototype.enter = function (callback) {
        var _this = this;
        // immediately call back if we have already transitioned, and exit
        if (this._lifecycle.state === this._finalState) {
            if (callback) {
                safelyCallBack_1.safelyCallBack(callback, null, this._name);
            }
            return;
        }
        // queue this callback if we are mid transition, and exit
        if (this._lifecycle.state === this._transitionState) {
            if (callback) {
                this._callbacks.push(callback);
            }
            return;
        }
        // report invalid transition, and exit
        if (this.invalidTransition()) {
            this.reportError("Invalid transition", [callback]);
            return;
        }
        // store the initial lifecycle state in case we need to roll back
        var initialState = this._lifecycle.state;
        // queue the first callback
        if (callback) {
            this._callbacks.push(callback);
        }
        // put lifecycle into transition state
        this.setState(this._transitionState);
        // run before handlers
        this._dispatcher.dispatchMessage(this._name, function (error) {
            // revert state, report error, and exit
            if (error) {
                _this.setState(initialState);
                _this.reportError(error, _this._callbacks);
                return;
            }
            // dispatch pre transition and transition events
            _this.dispatch(_this._preTransitionEvent);
            _this.dispatch(_this._transitionEvent);
            // put lifecycle into final state
            _this.setState(_this._finalState);
            // process callback queue (dup and trash for safety)
            var callbacks = _this._callbacks.concat();
            _this._callbacks.length = 0;
            callbacks.forEach(function (callbackChild) {
                safelyCallBack_1.safelyCallBack(callbackChild, null, _this._name);
            });
            // dispatch post transition event
            _this.dispatch(_this._postTransitionEvent);
        }, this._reverse);
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    LifecycleTransition.prototype.invalidTransition = function () {
        return this._fromStates.length > 0 && this._fromStates.indexOf(this._lifecycle.state) === -1;
    };
    LifecycleTransition.prototype.setState = function (state) {
        if (state) {
            this._lifecycle.setCurrentState(state);
        }
    };
    LifecycleTransition.prototype.dispatch = function (type) {
        if (type && this._lifecycle.hasEventListener(type)) {
            this._lifecycle.dispatchEvent(new LifecycleEvent_1.LifecycleEvent(type));
        }
    };
    LifecycleTransition.prototype.reportError = function (message, callbacks) {
        var _this = this;
        // turn message into Error
        var error = message instanceof Error ? message : new Error(message);
        // dispatch error event if a listener exists, or throw
        if (this._lifecycle.hasEventListener(LifecycleEvent_1.LifecycleEvent.ERROR)) {
            var event_1 = new LifecycleEvent_1.LifecycleEvent(LifecycleEvent_1.LifecycleEvent.ERROR, error);
            this._lifecycle.dispatchEvent(event_1);
            // process callback queue
            if (callbacks) {
                callbacks.forEach(function (callback) {
                    if (callback) {
                        safelyCallBack_1.safelyCallBack(callback, error, _this._name);
                    }
                });
                callbacks.length = 0;
            }
        }
        else {
            // explode!
            throw error;
        }
    };
    return LifecycleTransition;
}());
exports.LifecycleTransition = LifecycleTransition;
//# sourceMappingURL=LifecycleTransition.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/LogManager.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/LogManager.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel_1 = __webpack_require__(/*! ../api/LogLevel */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LogLevel.js");
var Logger_1 = __webpack_require__(/*! ../impl/Logger */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Logger.js");
/**
 * The log manager creates loggers and is itself a log target
 *
 * @private
 */
var LogManager = /** @class */ (function () {
    function LogManager() {
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        this._logLevel = LogLevel_1.LogLevel.INFO;
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._targets = [];
    }
    Object.defineProperty(LogManager.prototype, "logLevel", {
        /**
         * The current log level
         */
        get: function () {
            return this._logLevel;
        },
        /**
         * Sets the current log level
         */
        set: function (value) {
            this._logLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Retrieves a logger for a given source
     * @param source Logging source
     * @return Logger
     */
    LogManager.prototype.getLogger = function (source) {
        return new Logger_1.Logger(source, this);
    };
    /**
     * Adds a custom log target
     * @param target Log target
     * @return this
     */
    LogManager.prototype.addLogTarget = function (target) {
        this._targets.push(target);
    };
    /**
     * @inheritDoc
     */
    LogManager.prototype.log = function (source, level, timestamp, message, params) {
        if (level > this._logLevel) {
            return;
        }
        this._targets.forEach(function (target) {
            target.log(source, level, timestamp, message, params);
        });
    };
    LogManager.prototype.removeAllTargets = function () {
        this._targets = [];
    };
    return LogManager;
}());
exports.LogManager = LogManager;
//# sourceMappingURL=LogManager.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Logger.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Logger.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel_1 = __webpack_require__(/*! ../api/LogLevel */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/LogLevel.js");
/**
 * Default Robotlegs logger
 *
 * @private
 */
var Logger = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a new logger
     * @param source The log source object
     * @param target The log target
     */
    function Logger(source, target) {
        this._source = source;
        this._target = target;
    }
    Object.defineProperty(Logger.prototype, "source", {
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        /**
         * @inheritDoc
         */
        set: function (source) {
            this._source = source;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    Logger.prototype.debug = function (message, params) {
        this._target.log(this._source, LogLevel_1.LogLevel.DEBUG, this.getTimer(), message, params);
    };
    /**
     * @inheritDoc
     */
    Logger.prototype.info = function (message, params) {
        this._target.log(this._source, LogLevel_1.LogLevel.INFO, this.getTimer(), message, params);
    };
    /**
     * @inheritDoc
     */
    Logger.prototype.warn = function (message, params) {
        this._target.log(this._source, LogLevel_1.LogLevel.WARN, this.getTimer(), message, params);
    };
    /**
     * @inheritDoc
     */
    Logger.prototype.error = function (message, params) {
        this._target.log(this._source, LogLevel_1.LogLevel.ERROR, this.getTimer(), message, params);
    };
    /**
     * @inheritDoc
     */
    Logger.prototype.fatal = function (message, params) {
        this._target.log(this._source, LogLevel_1.LogLevel.FATAL, this.getTimer(), message, params);
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    Logger.prototype.getTimer = function () {
        return Date.now();
    };
    return Logger;
}());
exports.Logger = Logger;
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/MessageDispatcher.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/MessageDispatcher.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var MessageRunner_1 = __webpack_require__(/*! ./MessageRunner */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/MessageRunner.js");
var safelyCallBack_1 = __webpack_require__(/*! ./safelyCallBack */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/safelyCallBack.js");
/**
 * Message Dispatcher implementation.
 */
var MessageDispatcher = /** @class */ (function () {
    function MessageDispatcher() {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._handlers = new Map();
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Registers a message handler with a MessageDispatcher.
     * @param message The interesting message
     * @param handler The handler function
     */
    MessageDispatcher.prototype.addMessageHandler = function (message, handler) {
        var messageHandlers = this._handlers.get(message);
        if (messageHandlers) {
            if (messageHandlers.indexOf(handler) === -1) {
                messageHandlers.push(handler);
            }
        }
        else {
            this._handlers.set(message, [handler]);
        }
    };
    /**
     * Checks whether the MessageDispatcher has any handlers registered for a specific message.
     * @param message The interesting message
     * @return A value of true if a handler of the specified message is registered; false otherwise.
     */
    MessageDispatcher.prototype.hasMessageHandler = function (message) {
        return this._handlers.has(message);
    };
    /**
     * Removes a message handler from a MessageDispatcher
     * @param message The interesting message
     * @param handler The handler function
     */
    MessageDispatcher.prototype.removeMessageHandler = function (message, handler) {
        var messageHandlers = this._handlers.get(message);
        var index = messageHandlers ? messageHandlers.indexOf(handler) : -1;
        if (index !== -1) {
            messageHandlers.splice(index, 1);
            if (messageHandlers.length === 0) {
                this._handlers.delete(message);
            }
        }
    };
    /**
     * Dispatches a message into the message flow.
     * @param message The interesting message
     * @param callback The completion callback function
     * @param reverse Should handlers be called in reverse order
     */
    MessageDispatcher.prototype.dispatchMessage = function (message, callback, reverse) {
        if (callback === void 0) { callback = null; }
        if (reverse === void 0) { reverse = false; }
        var handlers = this._handlers.get(message);
        if (handlers) {
            handlers = handlers.concat();
            if (!reverse) {
                handlers.reverse();
            }
            new MessageRunner_1.MessageRunner(message, handlers, callback).run();
        }
        else {
            if (callback) {
                safelyCallBack_1.safelyCallBack(callback);
            }
        }
    };
    return MessageDispatcher;
}());
exports.MessageDispatcher = MessageDispatcher;
//# sourceMappingURL=MessageDispatcher.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/MessageRunner.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/MessageRunner.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var safelyCallBack_1 = __webpack_require__(/*! ./safelyCallBack */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/safelyCallBack.js");
var MessageRunner = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function MessageRunner(message, handlers, callback) {
        this._message = message;
        this._handlers = handlers;
        this._callback = callback;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    MessageRunner.prototype.run = function () {
        this.next();
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    MessageRunner.prototype.next = function () {
        var _this = this;
        // Try to keep things synchronous with a simple loop,
        // forcefully breaking out for async handlers and recursing.
        // We do this to avoid increasing the stack depth unnecessarily.
        var handler;
        var _loop_1 = function () {
            handler = this_1._handlers.pop();
            if (handler.length === 0) {
                // sync handler: ()
                handler();
            }
            else if (handler.length === 1) {
                // sync handler: (message)
                handler(this_1._message);
            }
            else if (handler.length === 2) {
                // sync or async handler: (message, callback)
                var handled_1 = false;
                handler(this_1._message, function (error, msg) {
                    if (error === void 0) { error = null; }
                    if (msg === void 0) { msg = null; }
                    // handler must not invoke the callback more than once
                    if (handled_1) {
                        return;
                    }
                    handled_1 = true;
                    if (error || _this._handlers.length === 0) {
                        if (_this._callback) {
                            safelyCallBack_1.safelyCallBack(_this._callback, error, _this._message);
                        }
                    }
                    else {
                        _this.next();
                    }
                });
                return { value: void 0 };
            }
            else {
                // ERROR: this should NEVER happen
                throw new Error("Bad handler signature");
            }
        };
        var this_1 = this;
        while (this._handlers.length > 0) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        // If we got here then this loop finished synchronously.
        // Nobody broke out, so we are done.
        // This relies on the various return statements above. Be careful.
        if (this._callback) {
            safelyCallBack_1.safelyCallBack(this._callback, null, this._message);
        }
    };
    return MessageRunner;
}());
exports.MessageRunner = MessageRunner;
//# sourceMappingURL=MessageRunner.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectHandler.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectHandler.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var ObjectHandler = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function ObjectHandler(matcher, handler) {
        this._matcher = matcher;
        this._handler = handler;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    ObjectHandler.prototype.handle = function (object) {
        if (this._matcher.matches(object)) {
            this._handler(object);
        }
    };
    return ObjectHandler;
}());
exports.ObjectHandler = ObjectHandler;
//# sourceMappingURL=ObjectHandler.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectMatcher.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectMatcher.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var ObjectMatcher = /** @class */ (function () {
    function ObjectMatcher() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    ObjectMatcher.prototype.matches = function (item) {
        return typeof item === "object";
    };
    return ObjectMatcher;
}());
exports.ObjectMatcher = ObjectMatcher;
//# sourceMappingURL=ObjectMatcher.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectProcessor.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectProcessor.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var ObjectHandler_1 = __webpack_require__(/*! ./ObjectHandler */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/ObjectHandler.js");
/**
 * Robotlegs object processor
 *
 * @private
 */
var ObjectProcessor = /** @class */ (function () {
    function ObjectProcessor() {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._handlers = [];
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Add a handler to process objects that match a given matcher.
     * @param matcher The matcher
     * @param handler The handler function
     */
    ObjectProcessor.prototype.addObjectHandler = function (matcher, handler) {
        this._handlers.push(new ObjectHandler_1.ObjectHandler(matcher, handler));
    };
    /**
     * Process an object by running it through all registered handlers
     * @param object The object instance to process.
     */
    ObjectProcessor.prototype.processObject = function (object) {
        this._handlers.forEach(function (handler) {
            handler.handle(object);
        });
    };
    /**
     * Removes all handlers
     */
    ObjectProcessor.prototype.removeAllHandlers = function () {
        this._handlers = [];
    };
    return ObjectProcessor;
}());
exports.ObjectProcessor = ObjectProcessor;
//# sourceMappingURL=ObjectProcessor.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Pin.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/Pin.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var PinEvent_1 = __webpack_require__(/*! ../api/PinEvent */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/api/PinEvent.js");
/**
 * Pins objects in memory
 *
 * @private
 */
var Pin = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function Pin(dispatcher) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._instances = new Map();
        this._dispatcher = dispatcher;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * Pin an object in memory
     * @param instance Instance to pin
     */
    Pin.prototype.detain = function (instance) {
        if (!this._instances.get(instance)) {
            this._instances.set(instance, true);
            this._dispatcher.dispatchEvent(new PinEvent_1.PinEvent(PinEvent_1.PinEvent.DETAIN, instance));
        }
    };
    /**
     * Unpins an object
     * @param instance Instance to unpin
     */
    Pin.prototype.release = function (instance) {
        if (this._instances.get(instance)) {
            this._instances.delete(instance);
            this._dispatcher.dispatchEvent(new PinEvent_1.PinEvent(PinEvent_1.PinEvent.RELEASE, instance));
        }
    };
    /**
     * Removes all pins
     */
    Pin.prototype.releaseAll = function () {
        var _this = this;
        this._instances.forEach(function (value, key) { return _this.release(key); });
    };
    return Pin;
}());
exports.Pin = Pin;
//# sourceMappingURL=Pin.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/RobotlegsInjector.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/RobotlegsInjector.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var inversify_1 = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/**
 * Robotlegs IInjector Adapter
 */
var RobotlegsInjector = /** @class */ (function (_super) {
    tslib_1.__extends(RobotlegsInjector, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a new Injector
     */
    function RobotlegsInjector() {
        return _super.call(this) || this;
    }
    RobotlegsInjector = tslib_1.__decorate([
        inversify_1.injectable(),
        tslib_1.__metadata("design:paramtypes", [])
    ], RobotlegsInjector);
    return RobotlegsInjector;
}(inversify_1.Container));
exports.RobotlegsInjector = RobotlegsInjector;
//# sourceMappingURL=RobotlegsInjector.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/UID.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/UID.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/**
 * Utility for generating unique object IDs
 */
var UID = /** @class */ (function () {
    function UID() {
    }
    /**
     * Generates a UID for a given source object or class
     * @param source The source object or class
     * @return Generated UID
     */
    UID.create = function (source) {
        return inversify_1.id().toString();
    };
    return UID;
}());
exports.UID = UID;
//# sourceMappingURL=UID.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/applyHooks.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/applyHooks.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var instantiateUnmapped_1 = __webpack_require__(/*! ./instantiateUnmapped */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/instantiateUnmapped.js");
/*============================================================================*/
/* Public Functions                                                           */
/*============================================================================*/
/**
 * <p>A hook can be a function, object or class.</p>
 *
 * <p>When an object is passed it is expected to expose a "hook" method.</p>
 *
 * <p>When a class is passed, an instance of that class will be instantiated and called.
 * If an injector is provided the instance will be created using that injector,
 * otherwise the instance will be created manually.</p>
 *
 * @param hooks An array of hooks
 * @param injector An optional Injector
 */
function applyHooks(hooks, injector) {
    for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {
        var hook = hooks_1[_i];
        if (typeof hook === "function" && hook.prototype.hook === undefined) {
            hook();
            continue;
        }
        if (typeof hook === "function" && hook.prototype.hook !== undefined) {
            hook = injector ? instantiateUnmapped_1.instantiateUnmapped(injector, hook) : new hook();
        }
        hook.hook();
    }
}
exports.applyHooks = applyHooks;
//# sourceMappingURL=applyHooks.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/getQualifiedClassName.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/getQualifiedClassName.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/*============================================================================*/
/* Public Functions                                                           */
/*============================================================================*/
/**
 * Returns the fully qualified class name of an object. Support EcmaScript from v3 upto v6.
 *
 * @param {any} value The object for which a fully qualified class name is desired.
 * @return {string} A string containing the fully qualified class name.
 */
function getQualifiedClassName(value) {
    // es pattern
    var v3 = /function\ ([^\(]+)/;
    var v6 = /class\ ([^\ ]+)/;
    var classDescriptor = value.toString();
    var result = classDescriptor.match(v3) || classDescriptor.match(v6);
    return result[1];
}
exports.getQualifiedClassName = getQualifiedClassName;
//# sourceMappingURL=getQualifiedClassName.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/guardsApprove.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/guardsApprove.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var instantiateUnmapped_1 = __webpack_require__(/*! ./instantiateUnmapped */ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/instantiateUnmapped.js");
/*============================================================================*/
/* Public Functions                                                           */
/*============================================================================*/
/**
 * <p>A guard can be a function, object or class.</p>
 *
 * <p>When a function is provided it is expected to return a boolean when called.</p>
 *
 * <p>When an object is provided it is expected to expose an "approve" method
 * that returns a boolean.</p>
 *
 * <p>When a class is provided, an instance of that class will be instantiated and tested.
 * If an injector is provided the instance will be created using that injector,
 * otherwise the instance will be created manually.</p>
 *
 * @param guards An array of guards
 * @param injector An optional Injector
 *
 * @return A boolean value of false if any guard returns false
 */
function guardsApprove(guards, injector) {
    for (var _i = 0, guards_1 = guards; _i < guards_1.length; _i++) {
        var guard = guards_1[_i];
        if (typeof guard === "function" && guard.prototype.approve === undefined) {
            if (guard()) {
                continue;
            }
            return false;
        }
        if (typeof guard === "function" && guard.prototype.approve !== undefined) {
            guard = injector ? instantiateUnmapped_1.instantiateUnmapped(injector, guard) : new guard();
        }
        if (!guard.approve()) {
            return false;
        }
    }
    return true;
}
exports.guardsApprove = guardsApprove;
//# sourceMappingURL=guardsApprove.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/instantiateUnmapped.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/instantiateUnmapped.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/*============================================================================*/
/* Public Functions                                                           */
/*============================================================================*/
/**
 * Instantiate a object inside the context of the injector without keeping it for future requests.
 * All injections of the object will be provided by the injector, but the injector will not keep
 * a reference of the object for future requests.
 *
 * @param injector An injector
 * @param type A object that must be instantiated
 */
function instantiateUnmapped(injector, type) {
    injector.bind(type).to(type);
    var instance = injector.get(type);
    injector.unbind(type);
    return instance;
}
exports.instantiateUnmapped = instantiateUnmapped;
//# sourceMappingURL=instantiateUnmapped.js.map

/***/ }),

/***/ "./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/safelyCallBack.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@robotlegsjs/core/lib/robotlegs/bender/framework/impl/safelyCallBack.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/*============================================================================*/
/* Public Functions                                                           */
/*============================================================================*/
/**
 * <p>Helper function to call any of the 3 forms of eventual callback: </p>
 *
 * <code>(), (error) and (error, message)</code>
 *
 * <p>NOTE: This helper will not handle null callbacks. You should check
 * if the callback is null from the calling location: </p>
 *
 * <code>callback &amp;&amp; safelyCallBack(callback, error, message);</code>
 *
 * <p>This prevents the overhead of calling safelyCallBack()
 * when there is no callback to call. Likewise it reduces the overhead
 * of a null check in safelyCallBack().</p>
 *
 * <p>QUESTION: Is this too harsh? Should we protect from null?</p>
 *
 * @param callback The actual callback
 * @param error An optional error
 * @param message An optional message
 */
function safelyCallBack(callback, error, message) {
    if (callback.length === 0) {
        callback();
    }
    else if (callback.length === 1) {
        callback(error);
    }
    else if (callback.length === 2) {
        callback(error, message);
    }
    else {
        throw new TypeError("Callback function accepts more than two parameters.");
    }
}
exports.safelyCallBack = safelyCallBack;
//# sourceMappingURL=safelyCallBack.js.map

/***/ }),

/***/ "./node_modules/howler/dist/howler.js":
/*!********************************************!*\
  !*** ./node_modules/howler/dist/howler.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 *  howler.js v2.1.3
 *  howlerjs.com
 *
 *  (c) 2013-2019, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this if Web Audio is supported and it hasn't already been unlocked.
      if (self._audioUnlocked || !self.ctx) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        for (var i=0; i<self.html5PoolSize; i++) {
          try {
            var audioNode = new Audio();

            // Mark this Audio object as unlocked to ensure it can get returned
            // to the unlocked pool when released.
            audioNode._unlocked = true;

            // Add the audio node to the pool.
            self._releaseHtml5Audio(audioNode);
          } catch (e) {
            self.noAudio = true;
          }
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';
        self.ctx.suspend().then(function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        });
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhrWithCredentials = o.xhrWithCredentials || false;

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload) {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended. 
        // If there is, play that sound. If not, continue as usual.  
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
              self._loadQueue();
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // If this is streaming audio, make sure the src is set and load again.
        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
          node.src = self._src;
          node.load();
        }

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;

          var listener = function() {
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();

              // If this is a live stream, stop download once the audio is stopped.
              if (sound._node.duration === Infinity) {
                self._clearSound(sound._node);
              }
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = parseFloat(from);
      to = parseFloat(to);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Make sure the volume is in the right bounds.
        vol = Math.max(0, vol);
        vol = Math.min(1, vol);

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return self;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            self._emit('seek', id);

            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          self._clearSound(sounds[i]._node);

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    },

    /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */
    _clearSound: function(node) {
      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
      if (!checkIE) {
        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      }
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else if (!Howler.noAudio) {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = 'auto';
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.withCredentials = self._xhrWithCredentials;
      xhr.responseType = 'arraybuffer';
      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  // Add support for CommonJS libraries such as browserify.
  if (true) {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Define globally in case AMD is not available or unused.
  if (typeof window !== 'undefined') {
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).
    global.HowlerGlobal = HowlerGlobal;
    global.Howler = Howler;
    global.Howl = Howl;
    global.Sound = Sound;
  }
})();


/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.1.3
 *  howlerjs.com
 *
 *  (c) 2013-2019, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup default properties.
  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
  HowlerGlobal.prototype.stereo = function(pan) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Loop through all Howls and update their stereo panning.
    for (var i=self._howls.length-1; i>=0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };

  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
  HowlerGlobal.prototype.pos = function(x, y, z) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._pos[1] : y;
    z = (typeof z !== 'number') ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];

      if (typeof self.ctx.listener.positionX !== 'undefined') {
        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
      }
    } else {
      return self._pos;
    }

    return self;
  };

  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    var or = self._orientation;
    y = (typeof y !== 'number') ? or[1] : y;
    z = (typeof z !== 'number') ? or[2] : z;
    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];

      if (typeof self.ctx.listener.forwardX !== 'undefined') {
        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
      }
    } else {
      return or;
    }

    return self;
  };

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
  Howl.prototype.init = (function(_super) {
    return function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      };

      // Setup event listeners.
      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

      // Complete initilization with howler.js core's init function.
      return _super.call(this, o);
    };
  })(Howl.prototype.init);

  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
  Howl.prototype.stereo = function(pan, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function() {
          self.stereo(pan, id);
        }
      });

      return self;
    }

    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

    // Setup the group's stereo panning if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    }

    // Change the streo panning of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower';

            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              if (typeof sound._panner.positionX !== 'undefined') {
                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
  Howl.prototype.pos = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change position when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? 0 : y;
    z = (typeof z !== 'number') ? -0.5 : z;

    // Setup the group's spatial position if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    }

    // Change the spatial position of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.positionX !== 'undefined') {
              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(x, y, z);
            }
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
  Howl.prototype.orientation = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._orientation[1] : y;
    z = (typeof z !== 'number') ? self._orientation[2] : z;

    // Setup the group's spatial orientation if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    }

    // Change the spatial orientation of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.orientationX !== 'undefined') {
              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x, y, z);
            }
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */
  Howl.prototype.pannerAttr = function() {
    var self = this;
    var args = arguments;
    var o, id, sound;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // Determine the values based on arguments.
    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0];

        // Set the grou's panner attribute values.
        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    }

    // Update the values of the specified sounds.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        };

        // Update the panner values or create a new panner if none exists.
        var panner = sound._panner;
        if (panner) {
          panner.coneInnerAngle = pa.coneInnerAngle;
          panner.coneOuterAngle = pa.coneOuterAngle;
          panner.coneOuterGain = pa.coneOuterGain;
          panner.distanceModel = pa.distanceModel;
          panner.maxDistance = pa.maxDistance;
          panner.refDistance = pa.refDistance;
          panner.rolloffFactor = pa.rolloffFactor;
          panner.panningModel = pa.panningModel;
        } else {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          }

          // Create a new panner node.
          setupPanner(sound, 'spatial');
        }
      }
    }

    return self;
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
  Sound.prototype.init = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Setup user-defined default properties.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // Complete initilization with howler.js core Sound's init function.
      _super.call(this);

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  })(Sound.prototype.init);

  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
  Sound.prototype.reset = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Reset all spatial plugin properties on this sound.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      } else if (self._panner) {
        // Disconnect the panner.
        self._panner.disconnect(0);
        self._panner = undefined;
        parent._refreshBuffer(self);
      }

      // Complete resetting of the sound.
      return _super.call(this);
    };
  })(Sound.prototype.reset);

  /** Helper Methods **/
  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
  var setupPanner = function(sound, type) {
    type = type || 'spatial';

    // Create the new panner node.
    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      if (typeof sound._panner.positionX !== 'undefined') {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }

      if (typeof sound._panner.orientationX !== 'undefined') {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
    }

    sound._panner.connect(sound._node);

    // Update the connections.
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
})();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/inversify/lib/annotation/decorator_utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/decorator_utils.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
function tagParameter(annotationTarget, propertyName, parameterIndex, metadata) {
    var metadataKey = METADATA_KEY.TAGGED;
    _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex);
}
exports.tagParameter = tagParameter;
function tagProperty(annotationTarget, propertyName, metadata) {
    var metadataKey = METADATA_KEY.TAGGED_PROP;
    _tagParameterOrProperty(metadataKey, annotationTarget.constructor, propertyName, metadata);
}
exports.tagProperty = tagProperty;
function _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex) {
    var paramsOrPropertiesMetadata = {};
    var isParameterDecorator = (typeof parameterIndex === "number");
    var key = (parameterIndex !== undefined && isParameterDecorator) ? parameterIndex.toString() : propertyName;
    if (isParameterDecorator && propertyName !== undefined) {
        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
    }
    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
    }
    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    if (!Array.isArray(paramOrPropertyMetadata)) {
        paramOrPropertyMetadata = [];
    }
    else {
        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
            var m = paramOrPropertyMetadata_1[_i];
            if (m.key === metadata.key) {
                throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + m.key.toString());
            }
        }
    }
    paramOrPropertyMetadata.push(metadata);
    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function _decorate(decorators, target) {
    Reflect.decorate(decorators, target);
}
function _param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); };
}
function decorate(decorator, target, parameterIndex) {
    if (typeof parameterIndex === "number") {
        _decorate([_param(parameterIndex, decorator)], target);
    }
    else if (typeof parameterIndex === "string") {
        Reflect.decorate([decorator], target, parameterIndex);
    }
    else {
        _decorate([decorator], target);
    }
}
exports.decorate = decorate;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/inject.js":
/*!*********************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/inject.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var error_msgs_1 = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var decorator_utils_1 = __webpack_require__(/*! ./decorator_utils */ "./node_modules/inversify/lib/annotation/decorator_utils.js");
var LazyServiceIdentifer = (function () {
    function LazyServiceIdentifer(cb) {
        this._cb = cb;
    }
    LazyServiceIdentifer.prototype.unwrap = function () {
        return this._cb();
    };
    return LazyServiceIdentifer;
}());
exports.LazyServiceIdentifer = LazyServiceIdentifer;
function inject(serviceIdentifier) {
    return function (target, targetKey, index) {
        if (serviceIdentifier === undefined) {
            throw new Error(error_msgs_1.UNDEFINED_INJECT_ANNOTATION(target.name));
        }
        var metadata = new metadata_1.Metadata(METADATA_KEY.INJECT_TAG, serviceIdentifier);
        if (typeof index === "number") {
            decorator_utils_1.tagParameter(target, targetKey, index, metadata);
        }
        else {
            decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
    };
}
exports.inject = inject;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/injectable.js":
/*!*************************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/injectable.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERRORS_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
function injectable() {
    return function (target) {
        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {
            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);
        }
        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];
        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);
        return target;
    };
}
exports.injectable = injectable;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/multi_inject.js":
/*!***************************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/multi_inject.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var decorator_utils_1 = __webpack_require__(/*! ./decorator_utils */ "./node_modules/inversify/lib/annotation/decorator_utils.js");
function multiInject(serviceIdentifier) {
    return function (target, targetKey, index) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);
        if (typeof index === "number") {
            decorator_utils_1.tagParameter(target, targetKey, index, metadata);
        }
        else {
            decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
    };
}
exports.multiInject = multiInject;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/named.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/named.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var decorator_utils_1 = __webpack_require__(/*! ./decorator_utils */ "./node_modules/inversify/lib/annotation/decorator_utils.js");
function named(name) {
    return function (target, targetKey, index) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, name);
        if (typeof index === "number") {
            decorator_utils_1.tagParameter(target, targetKey, index, metadata);
        }
        else {
            decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
    };
}
exports.named = named;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/optional.js":
/*!***********************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/optional.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var decorator_utils_1 = __webpack_require__(/*! ./decorator_utils */ "./node_modules/inversify/lib/annotation/decorator_utils.js");
function optional() {
    return function (target, targetKey, index) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true);
        if (typeof index === "number") {
            decorator_utils_1.tagParameter(target, targetKey, index, metadata);
        }
        else {
            decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
    };
}
exports.optional = optional;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/post_construct.js":
/*!*****************************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/post_construct.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERRORS_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
function postConstruct() {
    return function (target, propertyKey, descriptor) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.POST_CONSTRUCT, propertyKey);
        if (Reflect.hasOwnMetadata(METADATA_KEY.POST_CONSTRUCT, target.constructor)) {
            throw new Error(ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);
        }
        Reflect.defineMetadata(METADATA_KEY.POST_CONSTRUCT, metadata, target.constructor);
    };
}
exports.postConstruct = postConstruct;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/tagged.js":
/*!*********************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/tagged.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var decorator_utils_1 = __webpack_require__(/*! ./decorator_utils */ "./node_modules/inversify/lib/annotation/decorator_utils.js");
function tagged(metadataKey, metadataValue) {
    return function (target, targetKey, index) {
        var metadata = new metadata_1.Metadata(metadataKey, metadataValue);
        if (typeof index === "number") {
            decorator_utils_1.tagParameter(target, targetKey, index, metadata);
        }
        else {
            decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
    };
}
exports.tagged = tagged;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/target_name.js":
/*!**************************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/target_name.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var decorator_utils_1 = __webpack_require__(/*! ./decorator_utils */ "./node_modules/inversify/lib/annotation/decorator_utils.js");
function targetName(name) {
    return function (target, targetKey, index) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.NAME_TAG, name);
        decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    };
}
exports.targetName = targetName;


/***/ }),

/***/ "./node_modules/inversify/lib/annotation/unmanaged.js":
/*!************************************************************!*\
  !*** ./node_modules/inversify/lib/annotation/unmanaged.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var decorator_utils_1 = __webpack_require__(/*! ./decorator_utils */ "./node_modules/inversify/lib/annotation/decorator_utils.js");
function unmanaged() {
    return function (target, targetKey, index) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.UNMANAGED_TAG, true);
        decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    };
}
exports.unmanaged = unmanaged;


/***/ }),

/***/ "./node_modules/inversify/lib/bindings/binding.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/lib/bindings/binding.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var literal_types_1 = __webpack_require__(/*! ../constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
var id_1 = __webpack_require__(/*! ../utils/id */ "./node_modules/inversify/lib/utils/id.js");
var Binding = (function () {
    function Binding(serviceIdentifier, scope) {
        this.id = id_1.id();
        this.activated = false;
        this.serviceIdentifier = serviceIdentifier;
        this.scope = scope;
        this.type = literal_types_1.BindingTypeEnum.Invalid;
        this.constraint = function (request) { return true; };
        this.implementationType = null;
        this.cache = null;
        this.factory = null;
        this.provider = null;
        this.onActivation = null;
        this.dynamicValue = null;
    }
    Binding.prototype.clone = function () {
        var clone = new Binding(this.serviceIdentifier, this.scope);
        clone.activated = false;
        clone.implementationType = this.implementationType;
        clone.dynamicValue = this.dynamicValue;
        clone.scope = this.scope;
        clone.type = this.type;
        clone.factory = this.factory;
        clone.provider = this.provider;
        clone.constraint = this.constraint;
        clone.onActivation = this.onActivation;
        clone.cache = this.cache;
        return clone;
    };
    return Binding;
}());
exports.Binding = Binding;


/***/ }),

/***/ "./node_modules/inversify/lib/bindings/binding_count.js":
/*!**************************************************************!*\
  !*** ./node_modules/inversify/lib/bindings/binding_count.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BindingCount = {
    MultipleBindingsAvailable: 2,
    NoBindingsAvailable: 0,
    OnlyOneBindingAvailable: 1
};
exports.BindingCount = BindingCount;


/***/ }),

/***/ "./node_modules/inversify/lib/constants/error_msgs.js":
/*!************************************************************!*\
  !*** ./node_modules/inversify/lib/constants/error_msgs.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
exports.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
exports.NULL_ARGUMENT = "NULL argument";
exports.KEY_NOT_FOUND = "Key Not Found";
exports.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
exports.CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
exports.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
exports.MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
exports.MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
exports.UNDEFINED_INJECT_ANNOTATION = function (name) {
    return "@inject called with undefined this could mean that the class " + name + " has " +
        "a circular dependency problem. You can use a LazyServiceIdentifer to  " +
        "overcome this limitation.";
};
exports.CIRCULAR_DEPENDENCY = "Circular dependency found:";
exports.NOT_IMPLEMENTED = "Sorry, this feature is not fully implemented yet.";
exports.INVALID_BINDING_TYPE = "Invalid binding type:";
exports.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
exports.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
exports.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
exports.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is " +
    "used as service identifier";
exports.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators " +
    "must be applied to the parameters of a class constructor or a class property.";
exports.ARGUMENTS_LENGTH_MISMATCH = function () {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    return "The number of constructor arguments in the derived class " +
        (values[0] + " must be >= than the number of constructor arguments of its base class.");
};
exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options " +
    "must be an object.";
exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must " +
    "be a string ('singleton' or 'transient').";
exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must " +
    "be a boolean";
exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must " +
    "be a boolean";
exports.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
exports.POST_CONSTRUCT_ERROR = function () {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    return "@postConstruct error in class " + values[0] + ": " + values[1];
};
exports.CIRCULAR_DEPENDENCY_IN_FACTORY = function () {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    return "It looks like there is a circular dependency " +
        ("in one of the '" + values[0] + "' bindings. Please investigate bindings with") +
        ("service identifier '" + values[1] + "'.");
};
exports.STACK_OVERFLOW = "Maximum call stack size exceeded";


/***/ }),

/***/ "./node_modules/inversify/lib/constants/literal_types.js":
/*!***************************************************************!*\
  !*** ./node_modules/inversify/lib/constants/literal_types.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BindingScopeEnum = {
    Request: "Request",
    Singleton: "Singleton",
    Transient: "Transient"
};
exports.BindingScopeEnum = BindingScopeEnum;
var BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider"
};
exports.BindingTypeEnum = BindingTypeEnum;
var TargetTypeEnum = {
    ClassProperty: "ClassProperty",
    ConstructorArgument: "ConstructorArgument",
    Variable: "Variable"
};
exports.TargetTypeEnum = TargetTypeEnum;


/***/ }),

/***/ "./node_modules/inversify/lib/constants/metadata_keys.js":
/*!***************************************************************!*\
  !*** ./node_modules/inversify/lib/constants/metadata_keys.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NAMED_TAG = "named";
exports.NAME_TAG = "name";
exports.UNMANAGED_TAG = "unmanaged";
exports.OPTIONAL_TAG = "optional";
exports.INJECT_TAG = "inject";
exports.MULTI_INJECT_TAG = "multi_inject";
exports.TAGGED = "inversify:tagged";
exports.TAGGED_PROP = "inversify:tagged_props";
exports.PARAM_TYPES = "inversify:paramtypes";
exports.DESIGN_PARAM_TYPES = "design:paramtypes";
exports.POST_CONSTRUCT = "post_construct";


/***/ }),

/***/ "./node_modules/inversify/lib/container/container.js":
/*!***********************************************************!*\
  !*** ./node_modules/inversify/lib/container/container.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var binding_1 = __webpack_require__(/*! ../bindings/binding */ "./node_modules/inversify/lib/bindings/binding.js");
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var literal_types_1 = __webpack_require__(/*! ../constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_reader_1 = __webpack_require__(/*! ../planning/metadata_reader */ "./node_modules/inversify/lib/planning/metadata_reader.js");
var planner_1 = __webpack_require__(/*! ../planning/planner */ "./node_modules/inversify/lib/planning/planner.js");
var resolver_1 = __webpack_require__(/*! ../resolution/resolver */ "./node_modules/inversify/lib/resolution/resolver.js");
var binding_to_syntax_1 = __webpack_require__(/*! ../syntax/binding_to_syntax */ "./node_modules/inversify/lib/syntax/binding_to_syntax.js");
var id_1 = __webpack_require__(/*! ../utils/id */ "./node_modules/inversify/lib/utils/id.js");
var serialization_1 = __webpack_require__(/*! ../utils/serialization */ "./node_modules/inversify/lib/utils/serialization.js");
var container_snapshot_1 = __webpack_require__(/*! ./container_snapshot */ "./node_modules/inversify/lib/container/container_snapshot.js");
var lookup_1 = __webpack_require__(/*! ./lookup */ "./node_modules/inversify/lib/container/lookup.js");
var Container = (function () {
    function Container(containerOptions) {
        var options = containerOptions || {};
        if (typeof options !== "object") {
            throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
        }
        if (options.defaultScope === undefined) {
            options.defaultScope = literal_types_1.BindingScopeEnum.Transient;
        }
        else if (options.defaultScope !== literal_types_1.BindingScopeEnum.Singleton &&
            options.defaultScope !== literal_types_1.BindingScopeEnum.Transient &&
            options.defaultScope !== literal_types_1.BindingScopeEnum.Request) {
            throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
        }
        if (options.autoBindInjectable === undefined) {
            options.autoBindInjectable = false;
        }
        else if (typeof options.autoBindInjectable !== "boolean") {
            throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
        }
        if (options.skipBaseClassChecks === undefined) {
            options.skipBaseClassChecks = false;
        }
        else if (typeof options.skipBaseClassChecks !== "boolean") {
            throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
        }
        this.options = {
            autoBindInjectable: options.autoBindInjectable,
            defaultScope: options.defaultScope,
            skipBaseClassChecks: options.skipBaseClassChecks
        };
        this.id = id_1.id();
        this._bindingDictionary = new lookup_1.Lookup();
        this._snapshots = [];
        this._middleware = null;
        this.parent = null;
        this._metadataReader = new metadata_reader_1.MetadataReader();
    }
    Container.merge = function (container1, container2) {
        var container = new Container();
        var bindingDictionary = planner_1.getBindingDictionary(container);
        var bindingDictionary1 = planner_1.getBindingDictionary(container1);
        var bindingDictionary2 = planner_1.getBindingDictionary(container2);
        function copyDictionary(origin, destination) {
            origin.traverse(function (key, value) {
                value.forEach(function (binding) {
                    destination.add(binding.serviceIdentifier, binding.clone());
                });
            });
        }
        copyDictionary(bindingDictionary1, bindingDictionary);
        copyDictionary(bindingDictionary2, bindingDictionary);
        return container;
    };
    Container.prototype.load = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var getHelpers = this._getContainerModuleHelpersFactory();
        for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
            var currentModule = modules_1[_a];
            var containerModuleHelpers = getHelpers(currentModule.id);
            currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
        }
    };
    Container.prototype.loadAsync = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        getHelpers = this._getContainerModuleHelpersFactory();
                        _a = 0, modules_2 = modules;
                        _b.label = 1;
                    case 1:
                        if (!(_a < modules_2.length)) return [3, 4];
                        currentModule = modules_2[_a];
                        containerModuleHelpers = getHelpers(currentModule.id);
                        return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _a++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    Container.prototype.unload = function () {
        var _this = this;
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var conditionFactory = function (expected) { return function (item) {
            return item.moduleId === expected;
        }; };
        modules.forEach(function (module) {
            var condition = conditionFactory(module.id);
            _this._bindingDictionary.removeByCondition(condition);
        });
    };
    Container.prototype.bind = function (serviceIdentifier) {
        var scope = this.options.defaultScope || literal_types_1.BindingScopeEnum.Transient;
        var binding = new binding_1.Binding(serviceIdentifier, scope);
        this._bindingDictionary.add(serviceIdentifier, binding);
        return new binding_to_syntax_1.BindingToSyntax(binding);
    };
    Container.prototype.rebind = function (serviceIdentifier) {
        this.unbind(serviceIdentifier);
        return this.bind(serviceIdentifier);
    };
    Container.prototype.unbind = function (serviceIdentifier) {
        try {
            this._bindingDictionary.remove(serviceIdentifier);
        }
        catch (e) {
            throw new Error(ERROR_MSGS.CANNOT_UNBIND + " " + serialization_1.getServiceIdentifierAsString(serviceIdentifier));
        }
    };
    Container.prototype.unbindAll = function () {
        this._bindingDictionary = new lookup_1.Lookup();
    };
    Container.prototype.isBound = function (serviceIdentifier) {
        var bound = this._bindingDictionary.hasKey(serviceIdentifier);
        if (!bound && this.parent) {
            bound = this.parent.isBound(serviceIdentifier);
        }
        return bound;
    };
    Container.prototype.isBoundNamed = function (serviceIdentifier, named) {
        return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
    };
    Container.prototype.isBoundTagged = function (serviceIdentifier, key, value) {
        var bound = false;
        if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            var bindings = this._bindingDictionary.get(serviceIdentifier);
            var request_1 = planner_1.createMockRequest(this, serviceIdentifier, key, value);
            bound = bindings.some(function (b) { return b.constraint(request_1); });
        }
        if (!bound && this.parent) {
            bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
        }
        return bound;
    };
    Container.prototype.snapshot = function () {
        this._snapshots.push(container_snapshot_1.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware));
    };
    Container.prototype.restore = function () {
        var snapshot = this._snapshots.pop();
        if (snapshot === undefined) {
            throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);
        }
        this._bindingDictionary = snapshot.bindings;
        this._middleware = snapshot.middleware;
    };
    Container.prototype.createChild = function (containerOptions) {
        var child = new Container(containerOptions || this.options);
        child.parent = this;
        return child;
    };
    Container.prototype.applyMiddleware = function () {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        var initial = (this._middleware) ? this._middleware : this._planAndResolve();
        this._middleware = middlewares.reduce(function (prev, curr) { return curr(prev); }, initial);
    };
    Container.prototype.applyCustomMetadataReader = function (metadataReader) {
        this._metadataReader = metadataReader;
    };
    Container.prototype.get = function (serviceIdentifier) {
        return this._get(false, false, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier);
    };
    Container.prototype.getTagged = function (serviceIdentifier, key, value) {
        return this._get(false, false, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier, key, value);
    };
    Container.prototype.getNamed = function (serviceIdentifier, named) {
        return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
    };
    Container.prototype.getAll = function (serviceIdentifier) {
        return this._get(true, true, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier);
    };
    Container.prototype.getAllTagged = function (serviceIdentifier, key, value) {
        return this._get(false, true, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier, key, value);
    };
    Container.prototype.getAllNamed = function (serviceIdentifier, named) {
        return this.getAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
    };
    Container.prototype.resolve = function (constructorFunction) {
        var tempContainer = this.createChild();
        tempContainer.bind(constructorFunction).toSelf();
        return tempContainer.get(constructorFunction);
    };
    Container.prototype._getContainerModuleHelpersFactory = function () {
        var _this = this;
        var setModuleId = function (bindingToSyntax, moduleId) {
            bindingToSyntax._binding.moduleId = moduleId;
        };
        var getBindFunction = function (moduleId) {
            return function (serviceIdentifier) {
                var _bind = _this.bind.bind(_this);
                var bindingToSyntax = _bind(serviceIdentifier);
                setModuleId(bindingToSyntax, moduleId);
                return bindingToSyntax;
            };
        };
        var getUnbindFunction = function (moduleId) {
            return function (serviceIdentifier) {
                var _unbind = _this.unbind.bind(_this);
                _unbind(serviceIdentifier);
            };
        };
        var getIsboundFunction = function (moduleId) {
            return function (serviceIdentifier) {
                var _isBound = _this.isBound.bind(_this);
                return _isBound(serviceIdentifier);
            };
        };
        var getRebindFunction = function (moduleId) {
            return function (serviceIdentifier) {
                var _rebind = _this.rebind.bind(_this);
                var bindingToSyntax = _rebind(serviceIdentifier);
                setModuleId(bindingToSyntax, moduleId);
                return bindingToSyntax;
            };
        };
        return function (mId) { return ({
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(mId),
            rebindFunction: getRebindFunction(mId),
            unbindFunction: getUnbindFunction(mId)
        }); };
    };
    Container.prototype._get = function (avoidConstraints, isMultiInject, targetType, serviceIdentifier, key, value) {
        var result = null;
        var defaultArgs = {
            avoidConstraints: avoidConstraints,
            contextInterceptor: function (context) { return context; },
            isMultiInject: isMultiInject,
            key: key,
            serviceIdentifier: serviceIdentifier,
            targetType: targetType,
            value: value
        };
        if (this._middleware) {
            result = this._middleware(defaultArgs);
            if (result === undefined || result === null) {
                throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);
            }
        }
        else {
            result = this._planAndResolve()(defaultArgs);
        }
        return result;
    };
    Container.prototype._planAndResolve = function () {
        var _this = this;
        return function (args) {
            var context = planner_1.plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
            context = args.contextInterceptor(context);
            var result = resolver_1.resolve(context);
            return result;
        };
    };
    return Container;
}());
exports.Container = Container;


/***/ }),

/***/ "./node_modules/inversify/lib/container/container_module.js":
/*!******************************************************************!*\
  !*** ./node_modules/inversify/lib/container/container_module.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var id_1 = __webpack_require__(/*! ../utils/id */ "./node_modules/inversify/lib/utils/id.js");
var ContainerModule = (function () {
    function ContainerModule(registry) {
        this.id = id_1.id();
        this.registry = registry;
    }
    return ContainerModule;
}());
exports.ContainerModule = ContainerModule;
var AsyncContainerModule = (function () {
    function AsyncContainerModule(registry) {
        this.id = id_1.id();
        this.registry = registry;
    }
    return AsyncContainerModule;
}());
exports.AsyncContainerModule = AsyncContainerModule;


/***/ }),

/***/ "./node_modules/inversify/lib/container/container_snapshot.js":
/*!********************************************************************!*\
  !*** ./node_modules/inversify/lib/container/container_snapshot.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ContainerSnapshot = (function () {
    function ContainerSnapshot() {
    }
    ContainerSnapshot.of = function (bindings, middleware) {
        var snapshot = new ContainerSnapshot();
        snapshot.bindings = bindings;
        snapshot.middleware = middleware;
        return snapshot;
    };
    return ContainerSnapshot;
}());
exports.ContainerSnapshot = ContainerSnapshot;


/***/ }),

/***/ "./node_modules/inversify/lib/container/lookup.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/lib/container/lookup.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var Lookup = (function () {
    function Lookup() {
        this._map = new Map();
    }
    Lookup.prototype.getMap = function () {
        return this._map;
    };
    Lookup.prototype.add = function (serviceIdentifier, value) {
        if (serviceIdentifier === null || serviceIdentifier === undefined) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        if (value === null || value === undefined) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== undefined) {
            entry.push(value);
            this._map.set(serviceIdentifier, entry);
        }
        else {
            this._map.set(serviceIdentifier, [value]);
        }
    };
    Lookup.prototype.get = function (serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === undefined) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== undefined) {
            return entry;
        }
        else {
            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
        }
    };
    Lookup.prototype.remove = function (serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === undefined) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        if (!this._map.delete(serviceIdentifier)) {
            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
        }
    };
    Lookup.prototype.removeByCondition = function (condition) {
        var _this = this;
        this._map.forEach(function (entries, key) {
            var updatedEntries = entries.filter(function (entry) { return !condition(entry); });
            if (updatedEntries.length > 0) {
                _this._map.set(key, updatedEntries);
            }
            else {
                _this._map.delete(key);
            }
        });
    };
    Lookup.prototype.hasKey = function (serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === undefined) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        return this._map.has(serviceIdentifier);
    };
    Lookup.prototype.clone = function () {
        var copy = new Lookup();
        this._map.forEach(function (value, key) {
            value.forEach(function (b) { return copy.add(key, b.clone()); });
        });
        return copy;
    };
    Lookup.prototype.traverse = function (func) {
        this._map.forEach(function (value, key) {
            func(key, value);
        });
    };
    return Lookup;
}());
exports.Lookup = Lookup;


/***/ }),

/***/ "./node_modules/inversify/lib/inversify.js":
/*!*************************************************!*\
  !*** ./node_modules/inversify/lib/inversify.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var keys = __webpack_require__(/*! ./constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
exports.METADATA_KEY = keys;
var container_1 = __webpack_require__(/*! ./container/container */ "./node_modules/inversify/lib/container/container.js");
exports.Container = container_1.Container;
var literal_types_1 = __webpack_require__(/*! ./constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
exports.BindingScopeEnum = literal_types_1.BindingScopeEnum;
exports.BindingTypeEnum = literal_types_1.BindingTypeEnum;
exports.TargetTypeEnum = literal_types_1.TargetTypeEnum;
var container_module_1 = __webpack_require__(/*! ./container/container_module */ "./node_modules/inversify/lib/container/container_module.js");
exports.AsyncContainerModule = container_module_1.AsyncContainerModule;
exports.ContainerModule = container_module_1.ContainerModule;
var injectable_1 = __webpack_require__(/*! ./annotation/injectable */ "./node_modules/inversify/lib/annotation/injectable.js");
exports.injectable = injectable_1.injectable;
var tagged_1 = __webpack_require__(/*! ./annotation/tagged */ "./node_modules/inversify/lib/annotation/tagged.js");
exports.tagged = tagged_1.tagged;
var named_1 = __webpack_require__(/*! ./annotation/named */ "./node_modules/inversify/lib/annotation/named.js");
exports.named = named_1.named;
var inject_1 = __webpack_require__(/*! ./annotation/inject */ "./node_modules/inversify/lib/annotation/inject.js");
exports.inject = inject_1.inject;
exports.LazyServiceIdentifer = inject_1.LazyServiceIdentifer;
var optional_1 = __webpack_require__(/*! ./annotation/optional */ "./node_modules/inversify/lib/annotation/optional.js");
exports.optional = optional_1.optional;
var unmanaged_1 = __webpack_require__(/*! ./annotation/unmanaged */ "./node_modules/inversify/lib/annotation/unmanaged.js");
exports.unmanaged = unmanaged_1.unmanaged;
var multi_inject_1 = __webpack_require__(/*! ./annotation/multi_inject */ "./node_modules/inversify/lib/annotation/multi_inject.js");
exports.multiInject = multi_inject_1.multiInject;
var target_name_1 = __webpack_require__(/*! ./annotation/target_name */ "./node_modules/inversify/lib/annotation/target_name.js");
exports.targetName = target_name_1.targetName;
var post_construct_1 = __webpack_require__(/*! ./annotation/post_construct */ "./node_modules/inversify/lib/annotation/post_construct.js");
exports.postConstruct = post_construct_1.postConstruct;
var metadata_reader_1 = __webpack_require__(/*! ./planning/metadata_reader */ "./node_modules/inversify/lib/planning/metadata_reader.js");
exports.MetadataReader = metadata_reader_1.MetadataReader;
var id_1 = __webpack_require__(/*! ./utils/id */ "./node_modules/inversify/lib/utils/id.js");
exports.id = id_1.id;
var decorator_utils_1 = __webpack_require__(/*! ./annotation/decorator_utils */ "./node_modules/inversify/lib/annotation/decorator_utils.js");
exports.decorate = decorator_utils_1.decorate;
var constraint_helpers_1 = __webpack_require__(/*! ./syntax/constraint_helpers */ "./node_modules/inversify/lib/syntax/constraint_helpers.js");
exports.traverseAncerstors = constraint_helpers_1.traverseAncerstors;
exports.taggedConstraint = constraint_helpers_1.taggedConstraint;
exports.namedConstraint = constraint_helpers_1.namedConstraint;
exports.typeConstraint = constraint_helpers_1.typeConstraint;
var serialization_1 = __webpack_require__(/*! ./utils/serialization */ "./node_modules/inversify/lib/utils/serialization.js");
exports.getServiceIdentifierAsString = serialization_1.getServiceIdentifierAsString;
var binding_utils_1 = __webpack_require__(/*! ./utils/binding_utils */ "./node_modules/inversify/lib/utils/binding_utils.js");
exports.multiBindToService = binding_utils_1.multiBindToService;


/***/ }),

/***/ "./node_modules/inversify/lib/planning/context.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/lib/planning/context.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var id_1 = __webpack_require__(/*! ../utils/id */ "./node_modules/inversify/lib/utils/id.js");
var Context = (function () {
    function Context(container) {
        this.id = id_1.id();
        this.container = container;
    }
    Context.prototype.addPlan = function (plan) {
        this.plan = plan;
    };
    Context.prototype.setCurrentRequest = function (currentRequest) {
        this.currentRequest = currentRequest;
    };
    return Context;
}());
exports.Context = Context;


/***/ }),

/***/ "./node_modules/inversify/lib/planning/metadata.js":
/*!*********************************************************!*\
  !*** ./node_modules/inversify/lib/planning/metadata.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var Metadata = (function () {
    function Metadata(key, value) {
        this.key = key;
        this.value = value;
    }
    Metadata.prototype.toString = function () {
        if (this.key === METADATA_KEY.NAMED_TAG) {
            return "named: " + this.value.toString() + " ";
        }
        else {
            return "tagged: { key:" + this.key.toString() + ", value: " + this.value + " }";
        }
    };
    return Metadata;
}());
exports.Metadata = Metadata;


/***/ }),

/***/ "./node_modules/inversify/lib/planning/metadata_reader.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/lib/planning/metadata_reader.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var MetadataReader = (function () {
    function MetadataReader() {
    }
    MetadataReader.prototype.getConstructorMetadata = function (constructorFunc) {
        var compilerGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, constructorFunc);
        var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, constructorFunc);
        return {
            compilerGeneratedMetadata: compilerGeneratedMetadata,
            userGeneratedMetadata: userGeneratedMetadata || {}
        };
    };
    MetadataReader.prototype.getPropertiesMetadata = function (constructorFunc) {
        var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED_PROP, constructorFunc) || [];
        return userGeneratedMetadata;
    };
    return MetadataReader;
}());
exports.MetadataReader = MetadataReader;


/***/ }),

/***/ "./node_modules/inversify/lib/planning/plan.js":
/*!*****************************************************!*\
  !*** ./node_modules/inversify/lib/planning/plan.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Plan = (function () {
    function Plan(parentContext, rootRequest) {
        this.parentContext = parentContext;
        this.rootRequest = rootRequest;
    }
    return Plan;
}());
exports.Plan = Plan;


/***/ }),

/***/ "./node_modules/inversify/lib/planning/planner.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/lib/planning/planner.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var binding_count_1 = __webpack_require__(/*! ../bindings/binding_count */ "./node_modules/inversify/lib/bindings/binding_count.js");
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var literal_types_1 = __webpack_require__(/*! ../constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var exceptions_1 = __webpack_require__(/*! ../utils/exceptions */ "./node_modules/inversify/lib/utils/exceptions.js");
var serialization_1 = __webpack_require__(/*! ../utils/serialization */ "./node_modules/inversify/lib/utils/serialization.js");
var context_1 = __webpack_require__(/*! ./context */ "./node_modules/inversify/lib/planning/context.js");
var metadata_1 = __webpack_require__(/*! ./metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var plan_1 = __webpack_require__(/*! ./plan */ "./node_modules/inversify/lib/planning/plan.js");
var reflection_utils_1 = __webpack_require__(/*! ./reflection_utils */ "./node_modules/inversify/lib/planning/reflection_utils.js");
var request_1 = __webpack_require__(/*! ./request */ "./node_modules/inversify/lib/planning/request.js");
var target_1 = __webpack_require__(/*! ./target */ "./node_modules/inversify/lib/planning/target.js");
function getBindingDictionary(cntnr) {
    return cntnr._bindingDictionary;
}
exports.getBindingDictionary = getBindingDictionary;
function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
    var metadataKey = isMultiInject ? METADATA_KEY.MULTI_INJECT_TAG : METADATA_KEY.INJECT_TAG;
    var injectMetadata = new metadata_1.Metadata(metadataKey, serviceIdentifier);
    var target = new target_1.Target(targetType, name, serviceIdentifier, injectMetadata);
    if (key !== undefined) {
        var tagMetadata = new metadata_1.Metadata(key, value);
        target.metadata.push(tagMetadata);
    }
    return target;
}
function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
    var bindings = getBindings(context.container, target.serviceIdentifier);
    var activeBindings = [];
    if (bindings.length === binding_count_1.BindingCount.NoBindingsAvailable &&
        context.container.options.autoBindInjectable &&
        typeof target.serviceIdentifier === "function" &&
        metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
        context.container.bind(target.serviceIdentifier).toSelf();
        bindings = getBindings(context.container, target.serviceIdentifier);
    }
    if (!avoidConstraints) {
        activeBindings = bindings.filter(function (binding) {
            var request = new request_1.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
            return binding.constraint(request);
        });
    }
    else {
        activeBindings = bindings;
    }
    _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
    return activeBindings;
}
function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
    switch (bindings.length) {
        case binding_count_1.BindingCount.NoBindingsAvailable:
            if (target.isOptional()) {
                return bindings;
            }
            else {
                var serviceIdentifierString = serialization_1.getServiceIdentifierAsString(serviceIdentifier);
                var msg = ERROR_MSGS.NOT_REGISTERED;
                msg += serialization_1.listMetadataForTarget(serviceIdentifierString, target);
                msg += serialization_1.listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
                throw new Error(msg);
            }
        case binding_count_1.BindingCount.OnlyOneBindingAvailable:
            if (!target.isArray()) {
                return bindings;
            }
        case binding_count_1.BindingCount.MultipleBindingsAvailable:
        default:
            if (!target.isArray()) {
                var serviceIdentifierString = serialization_1.getServiceIdentifierAsString(serviceIdentifier);
                var msg = ERROR_MSGS.AMBIGUOUS_MATCH + " " + serviceIdentifierString;
                msg += serialization_1.listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
                throw new Error(msg);
            }
            else {
                return bindings;
            }
    }
}
function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
    var activeBindings;
    var childRequest;
    if (parentRequest === null) {
        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
        childRequest = new request_1.Request(serviceIdentifier, context, null, activeBindings, target);
        var thePlan = new plan_1.Plan(context, childRequest);
        context.addPlan(thePlan);
    }
    else {
        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
        childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
    }
    activeBindings.forEach(function (binding) {
        var subChildRequest = null;
        if (target.isArray()) {
            subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
        }
        else {
            if (binding.cache) {
                return;
            }
            subChildRequest = childRequest;
        }
        if (binding.type === literal_types_1.BindingTypeEnum.Instance && binding.implementationType !== null) {
            var dependencies = reflection_utils_1.getDependencies(metadataReader, binding.implementationType);
            if (!context.container.options.skipBaseClassChecks) {
                var baseClassDependencyCount = reflection_utils_1.getBaseClassDependencyCount(metadataReader, binding.implementationType);
                if (dependencies.length < baseClassDependencyCount) {
                    var error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH(reflection_utils_1.getFunctionName(binding.implementationType));
                    throw new Error(error);
                }
            }
            dependencies.forEach(function (dependency) {
                _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
            });
        }
    });
}
function getBindings(container, serviceIdentifier) {
    var bindings = [];
    var bindingDictionary = getBindingDictionary(container);
    if (bindingDictionary.hasKey(serviceIdentifier)) {
        bindings = bindingDictionary.get(serviceIdentifier);
    }
    else if (container.parent !== null) {
        bindings = getBindings(container.parent, serviceIdentifier);
    }
    return bindings;
}
function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
    if (avoidConstraints === void 0) { avoidConstraints = false; }
    var context = new context_1.Context(container);
    var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
    try {
        _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
        return context;
    }
    catch (error) {
        if (exceptions_1.isStackOverflowExeption(error)) {
            if (context.plan) {
                serialization_1.circularDependencyToException(context.plan.rootRequest);
            }
        }
        throw error;
    }
}
exports.plan = plan;
function createMockRequest(container, serviceIdentifier, key, value) {
    var target = new target_1.Target(literal_types_1.TargetTypeEnum.Variable, "", serviceIdentifier, new metadata_1.Metadata(key, value));
    var context = new context_1.Context(container);
    var request = new request_1.Request(serviceIdentifier, context, null, [], target);
    return request;
}
exports.createMockRequest = createMockRequest;


/***/ }),

/***/ "./node_modules/inversify/lib/planning/queryable_string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/inversify/lib/planning/queryable_string.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var QueryableString = (function () {
    function QueryableString(str) {
        this.str = str;
    }
    QueryableString.prototype.startsWith = function (searchString) {
        return this.str.indexOf(searchString) === 0;
    };
    QueryableString.prototype.endsWith = function (searchString) {
        var reverseString = "";
        var reverseSearchString = searchString.split("").reverse().join("");
        reverseString = this.str.split("").reverse().join("");
        return this.startsWith.call({ str: reverseString }, reverseSearchString);
    };
    QueryableString.prototype.contains = function (searchString) {
        return (this.str.indexOf(searchString) !== -1);
    };
    QueryableString.prototype.equals = function (compareString) {
        return this.str === compareString;
    };
    QueryableString.prototype.value = function () {
        return this.str;
    };
    return QueryableString;
}());
exports.QueryableString = QueryableString;


/***/ }),

/***/ "./node_modules/inversify/lib/planning/reflection_utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/inversify/lib/planning/reflection_utils.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var inject_1 = __webpack_require__(/*! ../annotation/inject */ "./node_modules/inversify/lib/annotation/inject.js");
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var literal_types_1 = __webpack_require__(/*! ../constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var serialization_1 = __webpack_require__(/*! ../utils/serialization */ "./node_modules/inversify/lib/utils/serialization.js");
exports.getFunctionName = serialization_1.getFunctionName;
var target_1 = __webpack_require__(/*! ./target */ "./node_modules/inversify/lib/planning/target.js");
function getDependencies(metadataReader, func) {
    var constructorName = serialization_1.getFunctionName(func);
    var targets = getTargets(metadataReader, constructorName, func, false);
    return targets;
}
exports.getDependencies = getDependencies;
function getTargets(metadataReader, constructorName, func, isBaseClass) {
    var metadata = metadataReader.getConstructorMetadata(func);
    var serviceIdentifiers = metadata.compilerGeneratedMetadata;
    if (serviceIdentifiers === undefined) {
        var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
        throw new Error(msg);
    }
    var constructorArgsMetadata = metadata.userGeneratedMetadata;
    var keys = Object.keys(constructorArgsMetadata);
    var hasUserDeclaredUnknownInjections = (func.length === 0 && keys.length > 0);
    var iterations = (hasUserDeclaredUnknownInjections) ? keys.length : func.length;
    var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
    var propertyTargets = getClassPropsAsTargets(metadataReader, func);
    var targets = constructorTargets.concat(propertyTargets);
    return targets;
}
function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
    var targetMetadata = constructorArgsMetadata[index.toString()] || [];
    var metadata = formatTargetMetadata(targetMetadata);
    var isManaged = metadata.unmanaged !== true;
    var serviceIdentifier = serviceIdentifiers[index];
    var injectIdentifier = (metadata.inject || metadata.multiInject);
    serviceIdentifier = (injectIdentifier) ? (injectIdentifier) : serviceIdentifier;
    if (serviceIdentifier instanceof inject_1.LazyServiceIdentifer) {
        serviceIdentifier = serviceIdentifier.unwrap();
    }
    if (isManaged) {
        var isObject = serviceIdentifier === Object;
        var isFunction = serviceIdentifier === Function;
        var isUndefined = serviceIdentifier === undefined;
        var isUnknownType = (isObject || isFunction || isUndefined);
        if (!isBaseClass && isUnknownType) {
            var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
            throw new Error(msg);
        }
        var target = new target_1.Target(literal_types_1.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
        target.metadata = targetMetadata;
        return target;
    }
    return null;
}
function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
    var targets = [];
    for (var i = 0; i < iterations; i++) {
        var index = i;
        var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
        if (target !== null) {
            targets.push(target);
        }
    }
    return targets;
}
function getClassPropsAsTargets(metadataReader, constructorFunc) {
    var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
    var targets = [];
    var keys = Object.keys(classPropsMetadata);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        var targetMetadata = classPropsMetadata[key];
        var metadata = formatTargetMetadata(classPropsMetadata[key]);
        var targetName = metadata.targetName || key;
        var serviceIdentifier = (metadata.inject || metadata.multiInject);
        var target = new target_1.Target(literal_types_1.TargetTypeEnum.ClassProperty, targetName, serviceIdentifier);
        target.metadata = targetMetadata;
        targets.push(target);
    }
    var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
    if (baseConstructor !== Object) {
        var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor);
        targets = targets.concat(baseTargets);
    }
    return targets;
}
function getBaseClassDependencyCount(metadataReader, func) {
    var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
    if (baseConstructor !== Object) {
        var baseConstructorName = serialization_1.getFunctionName(baseConstructor);
        var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
        var metadata = targets.map(function (t) {
            return t.metadata.filter(function (m) {
                return m.key === METADATA_KEY.UNMANAGED_TAG;
            });
        });
        var unmanagedCount = [].concat.apply([], metadata).length;
        var dependencyCount = targets.length - unmanagedCount;
        if (dependencyCount > 0) {
            return dependencyCount;
        }
        else {
            return getBaseClassDependencyCount(metadataReader, baseConstructor);
        }
    }
    else {
        return 0;
    }
}
exports.getBaseClassDependencyCount = getBaseClassDependencyCount;
function formatTargetMetadata(targetMetadata) {
    var targetMetadataMap = {};
    targetMetadata.forEach(function (m) {
        targetMetadataMap[m.key.toString()] = m.value;
    });
    return {
        inject: targetMetadataMap[METADATA_KEY.INJECT_TAG],
        multiInject: targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG],
        targetName: targetMetadataMap[METADATA_KEY.NAME_TAG],
        unmanaged: targetMetadataMap[METADATA_KEY.UNMANAGED_TAG]
    };
}


/***/ }),

/***/ "./node_modules/inversify/lib/planning/request.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/lib/planning/request.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var id_1 = __webpack_require__(/*! ../utils/id */ "./node_modules/inversify/lib/utils/id.js");
var Request = (function () {
    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {
        this.id = id_1.id();
        this.serviceIdentifier = serviceIdentifier;
        this.parentContext = parentContext;
        this.parentRequest = parentRequest;
        this.target = target;
        this.childRequests = [];
        this.bindings = (Array.isArray(bindings) ? bindings : [bindings]);
        this.requestScope = parentRequest === null
            ? new Map()
            : null;
    }
    Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {
        var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);
        this.childRequests.push(child);
        return child;
    };
    return Request;
}());
exports.Request = Request;


/***/ }),

/***/ "./node_modules/inversify/lib/planning/target.js":
/*!*******************************************************!*\
  !*** ./node_modules/inversify/lib/planning/target.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var id_1 = __webpack_require__(/*! ../utils/id */ "./node_modules/inversify/lib/utils/id.js");
var metadata_1 = __webpack_require__(/*! ./metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var queryable_string_1 = __webpack_require__(/*! ./queryable_string */ "./node_modules/inversify/lib/planning/queryable_string.js");
var Target = (function () {
    function Target(type, name, serviceIdentifier, namedOrTagged) {
        this.id = id_1.id();
        this.type = type;
        this.serviceIdentifier = serviceIdentifier;
        this.name = new queryable_string_1.QueryableString(name || "");
        this.metadata = new Array();
        var metadataItem = null;
        if (typeof namedOrTagged === "string") {
            metadataItem = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);
        }
        else if (namedOrTagged instanceof metadata_1.Metadata) {
            metadataItem = namedOrTagged;
        }
        if (metadataItem !== null) {
            this.metadata.push(metadataItem);
        }
    }
    Target.prototype.hasTag = function (key) {
        for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
            var m = _a[_i];
            if (m.key === key) {
                return true;
            }
        }
        return false;
    };
    Target.prototype.isArray = function () {
        return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);
    };
    Target.prototype.matchesArray = function (name) {
        return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);
    };
    Target.prototype.isNamed = function () {
        return this.hasTag(METADATA_KEY.NAMED_TAG);
    };
    Target.prototype.isTagged = function () {
        return this.metadata.some(function (m) {
            return (m.key !== METADATA_KEY.INJECT_TAG) &&
                (m.key !== METADATA_KEY.MULTI_INJECT_TAG) &&
                (m.key !== METADATA_KEY.NAME_TAG) &&
                (m.key !== METADATA_KEY.UNMANAGED_TAG) &&
                (m.key !== METADATA_KEY.NAMED_TAG);
        });
    };
    Target.prototype.isOptional = function () {
        return this.matchesTag(METADATA_KEY.OPTIONAL_TAG)(true);
    };
    Target.prototype.getNamedTag = function () {
        if (this.isNamed()) {
            return this.metadata.filter(function (m) { return m.key === METADATA_KEY.NAMED_TAG; })[0];
        }
        return null;
    };
    Target.prototype.getCustomTags = function () {
        if (this.isTagged()) {
            return this.metadata.filter(function (m) {
                return (m.key !== METADATA_KEY.INJECT_TAG) &&
                    (m.key !== METADATA_KEY.MULTI_INJECT_TAG) &&
                    (m.key !== METADATA_KEY.NAME_TAG) &&
                    (m.key !== METADATA_KEY.UNMANAGED_TAG) &&
                    (m.key !== METADATA_KEY.NAMED_TAG);
            });
        }
        return null;
    };
    Target.prototype.matchesNamedTag = function (name) {
        return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);
    };
    Target.prototype.matchesTag = function (key) {
        var _this = this;
        return function (value) {
            for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
                var m = _a[_i];
                if (m.key === key && m.value === value) {
                    return true;
                }
            }
            return false;
        };
    };
    return Target;
}());
exports.Target = Target;


/***/ }),

/***/ "./node_modules/inversify/lib/resolution/instantiation.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/lib/resolution/instantiation.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var error_msgs_1 = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var literal_types_1 = __webpack_require__(/*! ../constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
function _injectProperties(instance, childRequests, resolveRequest) {
    var propertyInjectionsRequests = childRequests.filter(function (childRequest) {
        return (childRequest.target !== null &&
            childRequest.target.type === literal_types_1.TargetTypeEnum.ClassProperty);
    });
    var propertyInjections = propertyInjectionsRequests.map(resolveRequest);
    propertyInjectionsRequests.forEach(function (r, index) {
        var propertyName = "";
        propertyName = r.target.name.value();
        var injection = propertyInjections[index];
        instance[propertyName] = injection;
    });
    return instance;
}
function _createInstance(Func, injections) {
    return new (Func.bind.apply(Func, [void 0].concat(injections)))();
}
function _postConstruct(constr, result) {
    if (Reflect.hasMetadata(METADATA_KEY.POST_CONSTRUCT, constr)) {
        var data = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, constr);
        try {
            result[data.value]();
        }
        catch (e) {
            throw new Error(error_msgs_1.POST_CONSTRUCT_ERROR(constr.name, e.message));
        }
    }
}
function resolveInstance(constr, childRequests, resolveRequest) {
    var result = null;
    if (childRequests.length > 0) {
        var constructorInjectionsRequests = childRequests.filter(function (childRequest) {
            return (childRequest.target !== null && childRequest.target.type === literal_types_1.TargetTypeEnum.ConstructorArgument);
        });
        var constructorInjections = constructorInjectionsRequests.map(resolveRequest);
        result = _createInstance(constr, constructorInjections);
        result = _injectProperties(result, childRequests, resolveRequest);
    }
    else {
        result = new constr();
    }
    _postConstruct(constr, result);
    return result;
}
exports.resolveInstance = resolveInstance;


/***/ }),

/***/ "./node_modules/inversify/lib/resolution/resolver.js":
/*!***********************************************************!*\
  !*** ./node_modules/inversify/lib/resolution/resolver.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var literal_types_1 = __webpack_require__(/*! ../constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
var exceptions_1 = __webpack_require__(/*! ../utils/exceptions */ "./node_modules/inversify/lib/utils/exceptions.js");
var serialization_1 = __webpack_require__(/*! ../utils/serialization */ "./node_modules/inversify/lib/utils/serialization.js");
var instantiation_1 = __webpack_require__(/*! ./instantiation */ "./node_modules/inversify/lib/resolution/instantiation.js");
var invokeFactory = function (factoryType, serviceIdentifier, fn) {
    try {
        return fn();
    }
    catch (error) {
        if (exceptions_1.isStackOverflowExeption(error)) {
            throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryType, serviceIdentifier.toString()));
        }
        else {
            throw error;
        }
    }
};
var _resolveRequest = function (requestScope) {
    return function (request) {
        request.parentContext.setCurrentRequest(request);
        var bindings = request.bindings;
        var childRequests = request.childRequests;
        var targetIsAnArray = request.target && request.target.isArray();
        var targetParentIsNotAnArray = !request.parentRequest ||
            !request.parentRequest.target ||
            !request.target ||
            !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
        if (targetIsAnArray && targetParentIsNotAnArray) {
            return childRequests.map(function (childRequest) {
                var _f = _resolveRequest(requestScope);
                return _f(childRequest);
            });
        }
        else {
            var result = null;
            if (request.target.isOptional() && bindings.length === 0) {
                return undefined;
            }
            var binding_1 = bindings[0];
            var isSingleton = binding_1.scope === literal_types_1.BindingScopeEnum.Singleton;
            var isRequestSingleton = binding_1.scope === literal_types_1.BindingScopeEnum.Request;
            if (isSingleton && binding_1.activated) {
                return binding_1.cache;
            }
            if (isRequestSingleton &&
                requestScope !== null &&
                requestScope.has(binding_1.id)) {
                return requestScope.get(binding_1.id);
            }
            if (binding_1.type === literal_types_1.BindingTypeEnum.ConstantValue) {
                result = binding_1.cache;
            }
            else if (binding_1.type === literal_types_1.BindingTypeEnum.Function) {
                result = binding_1.cache;
            }
            else if (binding_1.type === literal_types_1.BindingTypeEnum.Constructor) {
                result = binding_1.implementationType;
            }
            else if (binding_1.type === literal_types_1.BindingTypeEnum.DynamicValue && binding_1.dynamicValue !== null) {
                result = invokeFactory("toDynamicValue", binding_1.serviceIdentifier, function () { return binding_1.dynamicValue(request.parentContext); });
            }
            else if (binding_1.type === literal_types_1.BindingTypeEnum.Factory && binding_1.factory !== null) {
                result = invokeFactory("toFactory", binding_1.serviceIdentifier, function () { return binding_1.factory(request.parentContext); });
            }
            else if (binding_1.type === literal_types_1.BindingTypeEnum.Provider && binding_1.provider !== null) {
                result = invokeFactory("toProvider", binding_1.serviceIdentifier, function () { return binding_1.provider(request.parentContext); });
            }
            else if (binding_1.type === literal_types_1.BindingTypeEnum.Instance && binding_1.implementationType !== null) {
                result = instantiation_1.resolveInstance(binding_1.implementationType, childRequests, _resolveRequest(requestScope));
            }
            else {
                var serviceIdentifier = serialization_1.getServiceIdentifierAsString(request.serviceIdentifier);
                throw new Error(ERROR_MSGS.INVALID_BINDING_TYPE + " " + serviceIdentifier);
            }
            if (typeof binding_1.onActivation === "function") {
                result = binding_1.onActivation(request.parentContext, result);
            }
            if (isSingleton) {
                binding_1.cache = result;
                binding_1.activated = true;
            }
            if (isRequestSingleton &&
                requestScope !== null &&
                !requestScope.has(binding_1.id)) {
                requestScope.set(binding_1.id, result);
            }
            return result;
        }
    };
};
function resolve(context) {
    var _f = _resolveRequest(context.plan.rootRequest.requestScope);
    return _f(context.plan.rootRequest);
}
exports.resolve = resolve;


/***/ }),

/***/ "./node_modules/inversify/lib/syntax/binding_in_syntax.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/lib/syntax/binding_in_syntax.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var literal_types_1 = __webpack_require__(/*! ../constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
var binding_when_on_syntax_1 = __webpack_require__(/*! ./binding_when_on_syntax */ "./node_modules/inversify/lib/syntax/binding_when_on_syntax.js");
var BindingInSyntax = (function () {
    function BindingInSyntax(binding) {
        this._binding = binding;
    }
    BindingInSyntax.prototype.inRequestScope = function () {
        this._binding.scope = literal_types_1.BindingScopeEnum.Request;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };
    BindingInSyntax.prototype.inSingletonScope = function () {
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };
    BindingInSyntax.prototype.inTransientScope = function () {
        this._binding.scope = literal_types_1.BindingScopeEnum.Transient;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };
    return BindingInSyntax;
}());
exports.BindingInSyntax = BindingInSyntax;


/***/ }),

/***/ "./node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js":
/*!************************************************************************!*\
  !*** ./node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var binding_in_syntax_1 = __webpack_require__(/*! ./binding_in_syntax */ "./node_modules/inversify/lib/syntax/binding_in_syntax.js");
var binding_on_syntax_1 = __webpack_require__(/*! ./binding_on_syntax */ "./node_modules/inversify/lib/syntax/binding_on_syntax.js");
var binding_when_syntax_1 = __webpack_require__(/*! ./binding_when_syntax */ "./node_modules/inversify/lib/syntax/binding_when_syntax.js");
var BindingInWhenOnSyntax = (function () {
    function BindingInWhenOnSyntax(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
        this._bindingInSyntax = new binding_in_syntax_1.BindingInSyntax(binding);
    }
    BindingInWhenOnSyntax.prototype.inRequestScope = function () {
        return this._bindingInSyntax.inRequestScope();
    };
    BindingInWhenOnSyntax.prototype.inSingletonScope = function () {
        return this._bindingInSyntax.inSingletonScope();
    };
    BindingInWhenOnSyntax.prototype.inTransientScope = function () {
        return this._bindingInSyntax.inTransientScope();
    };
    BindingInWhenOnSyntax.prototype.when = function (constraint) {
        return this._bindingWhenSyntax.when(constraint);
    };
    BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function () {
        return this._bindingWhenSyntax.whenTargetIsDefault();
    };
    BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
    };
    BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };
    BindingInWhenOnSyntax.prototype.onActivation = function (handler) {
        return this._bindingOnSyntax.onActivation(handler);
    };
    return BindingInWhenOnSyntax;
}());
exports.BindingInWhenOnSyntax = BindingInWhenOnSyntax;


/***/ }),

/***/ "./node_modules/inversify/lib/syntax/binding_on_syntax.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/lib/syntax/binding_on_syntax.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var binding_when_syntax_1 = __webpack_require__(/*! ./binding_when_syntax */ "./node_modules/inversify/lib/syntax/binding_when_syntax.js");
var BindingOnSyntax = (function () {
    function BindingOnSyntax(binding) {
        this._binding = binding;
    }
    BindingOnSyntax.prototype.onActivation = function (handler) {
        this._binding.onActivation = handler;
        return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
    };
    return BindingOnSyntax;
}());
exports.BindingOnSyntax = BindingOnSyntax;


/***/ }),

/***/ "./node_modules/inversify/lib/syntax/binding_to_syntax.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/lib/syntax/binding_to_syntax.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
var literal_types_1 = __webpack_require__(/*! ../constants/literal_types */ "./node_modules/inversify/lib/constants/literal_types.js");
var binding_in_when_on_syntax_1 = __webpack_require__(/*! ./binding_in_when_on_syntax */ "./node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js");
var binding_when_on_syntax_1 = __webpack_require__(/*! ./binding_when_on_syntax */ "./node_modules/inversify/lib/syntax/binding_when_on_syntax.js");
var BindingToSyntax = (function () {
    function BindingToSyntax(binding) {
        this._binding = binding;
    }
    BindingToSyntax.prototype.to = function (constructor) {
        this._binding.type = literal_types_1.BindingTypeEnum.Instance;
        this._binding.implementationType = constructor;
        return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toSelf = function () {
        if (typeof this._binding.serviceIdentifier !== "function") {
            throw new Error("" + ERROR_MSGS.INVALID_TO_SELF_VALUE);
        }
        var self = this._binding.serviceIdentifier;
        return this.to(self);
    };
    BindingToSyntax.prototype.toConstantValue = function (value) {
        this._binding.type = literal_types_1.BindingTypeEnum.ConstantValue;
        this._binding.cache = value;
        this._binding.dynamicValue = null;
        this._binding.implementationType = null;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toDynamicValue = function (func) {
        this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
        this._binding.cache = null;
        this._binding.dynamicValue = func;
        this._binding.implementationType = null;
        return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toConstructor = function (constructor) {
        this._binding.type = literal_types_1.BindingTypeEnum.Constructor;
        this._binding.implementationType = constructor;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toFactory = function (factory) {
        this._binding.type = literal_types_1.BindingTypeEnum.Factory;
        this._binding.factory = factory;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toFunction = function (func) {
        if (typeof func !== "function") {
            throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);
        }
        var bindingWhenOnSyntax = this.toConstantValue(func);
        this._binding.type = literal_types_1.BindingTypeEnum.Function;
        return bindingWhenOnSyntax;
    };
    BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {
        this._binding.type = literal_types_1.BindingTypeEnum.Factory;
        this._binding.factory = function (context) {
            var autofactory = function () { return context.container.get(serviceIdentifier); };
            return autofactory;
        };
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toProvider = function (provider) {
        this._binding.type = literal_types_1.BindingTypeEnum.Provider;
        this._binding.provider = provider;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toService = function (service) {
        this.toDynamicValue(function (context) { return context.container.get(service); });
    };
    return BindingToSyntax;
}());
exports.BindingToSyntax = BindingToSyntax;


/***/ }),

/***/ "./node_modules/inversify/lib/syntax/binding_when_on_syntax.js":
/*!*********************************************************************!*\
  !*** ./node_modules/inversify/lib/syntax/binding_when_on_syntax.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var binding_on_syntax_1 = __webpack_require__(/*! ./binding_on_syntax */ "./node_modules/inversify/lib/syntax/binding_on_syntax.js");
var binding_when_syntax_1 = __webpack_require__(/*! ./binding_when_syntax */ "./node_modules/inversify/lib/syntax/binding_when_syntax.js");
var BindingWhenOnSyntax = (function () {
    function BindingWhenOnSyntax(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
    }
    BindingWhenOnSyntax.prototype.when = function (constraint) {
        return this._bindingWhenSyntax.when(constraint);
    };
    BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenTargetIsDefault = function () {
        return this._bindingWhenSyntax.whenTargetIsDefault();
    };
    BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
    };
    BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };
    BindingWhenOnSyntax.prototype.onActivation = function (handler) {
        return this._bindingOnSyntax.onActivation(handler);
    };
    return BindingWhenOnSyntax;
}());
exports.BindingWhenOnSyntax = BindingWhenOnSyntax;


/***/ }),

/***/ "./node_modules/inversify/lib/syntax/binding_when_syntax.js":
/*!******************************************************************!*\
  !*** ./node_modules/inversify/lib/syntax/binding_when_syntax.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var binding_on_syntax_1 = __webpack_require__(/*! ./binding_on_syntax */ "./node_modules/inversify/lib/syntax/binding_on_syntax.js");
var constraint_helpers_1 = __webpack_require__(/*! ./constraint_helpers */ "./node_modules/inversify/lib/syntax/constraint_helpers.js");
var BindingWhenSyntax = (function () {
    function BindingWhenSyntax(binding) {
        this._binding = binding;
    }
    BindingWhenSyntax.prototype.when = function (constraint) {
        this._binding.constraint = constraint;
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetNamed = function (name) {
        this._binding.constraint = constraint_helpers_1.namedConstraint(name);
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetIsDefault = function () {
        this._binding.constraint = function (request) {
            var targetIsDefault = (request.target !== null) &&
                (!request.target.isNamed()) &&
                (!request.target.isTagged());
            return targetIsDefault;
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {
        this._binding.constraint = constraint_helpers_1.taggedConstraint(tag)(value);
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {
        this._binding.constraint = function (request) {
            return constraint_helpers_1.typeConstraint(parent)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenParentNamed = function (name) {
        this._binding.constraint = function (request) {
            return constraint_helpers_1.namedConstraint(name)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {
        this._binding.constraint = function (request) {
            return constraint_helpers_1.taggedConstraint(tag)(value)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
        this._binding.constraint = function (request) {
            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {
        this._binding.constraint = function (request) {
            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {
        this._binding.constraint = function (request) {
            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {
        this._binding.constraint = function (request) {
            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
        this._binding.constraint = function (request) {
            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
        this._binding.constraint = function (request) {
            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
        this._binding.constraint = function (request) {
            return constraint_helpers_1.traverseAncerstors(request, constraint);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {
        this._binding.constraint = function (request) {
            return !constraint_helpers_1.traverseAncerstors(request, constraint);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };
    return BindingWhenSyntax;
}());
exports.BindingWhenSyntax = BindingWhenSyntax;


/***/ }),

/***/ "./node_modules/inversify/lib/syntax/constraint_helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/inversify/lib/syntax/constraint_helpers.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var METADATA_KEY = __webpack_require__(/*! ../constants/metadata_keys */ "./node_modules/inversify/lib/constants/metadata_keys.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "./node_modules/inversify/lib/planning/metadata.js");
var traverseAncerstors = function (request, constraint) {
    var parent = request.parentRequest;
    if (parent !== null) {
        return constraint(parent) ? true : traverseAncerstors(parent, constraint);
    }
    else {
        return false;
    }
};
exports.traverseAncerstors = traverseAncerstors;
var taggedConstraint = function (key) { return function (value) {
    var constraint = function (request) {
        return request !== null && request.target !== null && request.target.matchesTag(key)(value);
    };
    constraint.metaData = new metadata_1.Metadata(key, value);
    return constraint;
}; };
exports.taggedConstraint = taggedConstraint;
var namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);
exports.namedConstraint = namedConstraint;
var typeConstraint = function (type) { return function (request) {
    var binding = null;
    if (request !== null) {
        binding = request.bindings[0];
        if (typeof type === "string") {
            var serviceIdentifier = binding.serviceIdentifier;
            return serviceIdentifier === type;
        }
        else {
            var constructor = request.bindings[0].implementationType;
            return type === constructor;
        }
    }
    return false;
}; };
exports.typeConstraint = typeConstraint;


/***/ }),

/***/ "./node_modules/inversify/lib/utils/binding_utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/inversify/lib/utils/binding_utils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.multiBindToService = function (container) {
    return function (service) {
        return function () {
            var types = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                types[_i] = arguments[_i];
            }
            return types.forEach(function (t) { return container.bind(t).toService(service); });
        };
    };
};


/***/ }),

/***/ "./node_modules/inversify/lib/utils/exceptions.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/lib/utils/exceptions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
function isStackOverflowExeption(error) {
    return (error instanceof RangeError ||
        error.message === ERROR_MSGS.STACK_OVERFLOW);
}
exports.isStackOverflowExeption = isStackOverflowExeption;


/***/ }),

/***/ "./node_modules/inversify/lib/utils/id.js":
/*!************************************************!*\
  !*** ./node_modules/inversify/lib/utils/id.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var idCounter = 0;
function id() {
    return idCounter++;
}
exports.id = id;


/***/ }),

/***/ "./node_modules/inversify/lib/utils/serialization.js":
/*!***********************************************************!*\
  !*** ./node_modules/inversify/lib/utils/serialization.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERROR_MSGS = __webpack_require__(/*! ../constants/error_msgs */ "./node_modules/inversify/lib/constants/error_msgs.js");
function getServiceIdentifierAsString(serviceIdentifier) {
    if (typeof serviceIdentifier === "function") {
        var _serviceIdentifier = serviceIdentifier;
        return _serviceIdentifier.name;
    }
    else if (typeof serviceIdentifier === "symbol") {
        return serviceIdentifier.toString();
    }
    else {
        var _serviceIdentifier = serviceIdentifier;
        return _serviceIdentifier;
    }
}
exports.getServiceIdentifierAsString = getServiceIdentifierAsString;
function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
    var registeredBindingsList = "";
    var registeredBindings = getBindings(container, serviceIdentifier);
    if (registeredBindings.length !== 0) {
        registeredBindingsList = "\nRegistered bindings:";
        registeredBindings.forEach(function (binding) {
            var name = "Object";
            if (binding.implementationType !== null) {
                name = getFunctionName(binding.implementationType);
            }
            registeredBindingsList = registeredBindingsList + "\n " + name;
            if (binding.constraint.metaData) {
                registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
            }
        });
    }
    return registeredBindingsList;
}
exports.listRegisteredBindingsForServiceIdentifier = listRegisteredBindingsForServiceIdentifier;
function alreadyDependencyChain(request, serviceIdentifier) {
    if (request.parentRequest === null) {
        return false;
    }
    else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
        return true;
    }
    else {
        return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
    }
}
function dependencyChainToString(request) {
    function _createStringArr(req, result) {
        if (result === void 0) { result = []; }
        var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
        result.push(serviceIdentifier);
        if (req.parentRequest !== null) {
            return _createStringArr(req.parentRequest, result);
        }
        return result;
    }
    var stringArr = _createStringArr(request);
    return stringArr.reverse().join(" --> ");
}
function circularDependencyToException(request) {
    request.childRequests.forEach(function (childRequest) {
        if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
            var services = dependencyChainToString(childRequest);
            throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY + " " + services);
        }
        else {
            circularDependencyToException(childRequest);
        }
    });
}
exports.circularDependencyToException = circularDependencyToException;
function listMetadataForTarget(serviceIdentifierString, target) {
    if (target.isTagged() || target.isNamed()) {
        var m_1 = "";
        var namedTag = target.getNamedTag();
        var otherTags = target.getCustomTags();
        if (namedTag !== null) {
            m_1 += namedTag.toString() + "\n";
        }
        if (otherTags !== null) {
            otherTags.forEach(function (tag) {
                m_1 += tag.toString() + "\n";
            });
        }
        return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
    }
    else {
        return " " + serviceIdentifierString;
    }
}
exports.listMetadataForTarget = listMetadataForTarget;
function getFunctionName(v) {
    if (v.name) {
        return v.name;
    }
    else {
        var name_1 = v.toString();
        var match = name_1.match(/^function\s*([^\s(]+)/);
        return match ? match[1] : "Anonymous function: " + name_1;
    }
}
exports.getFunctionName = getFunctionName;


/***/ }),

/***/ "./node_modules/openfl/lib/_gen/EReg.js":
/*!**********************************************!*\
  !*** ./node_modules/openfl/lib/_gen/EReg.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: EReg

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function HxOverrides() {return __webpack_require__(/*! ./HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function StringBuf() {return __webpack_require__(/*! ./StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}

// Constructor

var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
}

// Meta

EReg.__name__ = "EReg";
EReg.__isInterface__ = false;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	},
	matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new (js__$Boot_HaxeError().default)("EReg::matched");
		}
	},
	matchedRight: function() {
		if(this.r.m == null) {
			throw new (js__$Boot_HaxeError().default)("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return (HxOverrides().default).substr(this.r.s,sz,this.r.s.length - sz);
	},
	matchedPos: function() {
		if(this.r.m == null) {
			throw new (js__$Boot_HaxeError().default)("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	},
	matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : (HxOverrides().default).substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b1 = this.match(len < 0 ? (HxOverrides().default).substr(s,pos,null) : (HxOverrides().default).substr(s,pos,len));
			if(b1) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b1;
		}
	},
	split: function(s) {
		var d = "#__delim__#";
		return this.replace(s,d).split(d);
	},
	replace: function(s,by) {
		return s.replace(this.r,by);
	},
	map: function(s,f) {
		var offset = 0;
		var buf = new (StringBuf().default)();
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf.add((HxOverrides().default).substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf.add((HxOverrides().default).substr(s,offset,p.pos - offset));
			buf.add(f(this));
			if(p.len == 0) {
				buf.add((HxOverrides().default).substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf.add((HxOverrides().default).substr(s,offset,null));
		}
		return buf.toString();
	}
};
EReg.prototype.__class__ = EReg.prototype.constructor = $hxClasses["EReg"] = EReg;

// Init



// Statics




// Export

exports.default = EReg;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/HxOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/HxOverrides.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: HxOverrides

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function js_Lib() {return __webpack_require__(/*! ./js/Lib */ "./node_modules/openfl/lib/_gen/js/Lib.js");}

// Constructor

var HxOverrides = function(){}

// Meta

HxOverrides.__name__ = "HxOverrides";
HxOverrides.__isInterface__ = false;
HxOverrides.prototype = {
	
};
HxOverrides.prototype.__class__ = HxOverrides.prototype.constructor = $hxClasses["HxOverrides"] = HxOverrides;

// Init



// Statics

HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new (js__$Boot_HaxeError().default)("Invalid date format : " + s);
	}
}
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return (js_Lib().default).get_undefined();
	}
	return x;
}
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
}
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
}
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
}


// Export

exports.default = HxOverrides;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/Lambda.js":
/*!************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/Lambda.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: Lambda

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $getIterator = __webpack_require__(/*! ./getIterator_stub */ "./node_modules/openfl/lib/_gen/getIterator_stub.js").default;

// Constructor

var Lambda = function(){}

// Meta

Lambda.__name__ = "Lambda";
Lambda.__isInterface__ = false;
Lambda.prototype = {
	
};
Lambda.prototype.__class__ = Lambda.prototype.constructor = $hxClasses["Lambda"] = Lambda;

// Init



// Statics

Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
}
Lambda.map = function(it,f) {
	var _g = [];
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		_g.push(f(x1));
	}
	return _g;
}
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
}


// Export

exports.default = Lambda;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/Reflect.js":
/*!*************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/Reflect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: Reflect

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_CallStack() {return __webpack_require__(/*! ./haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function js_Boot() {return __webpack_require__(/*! ./js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}

// Constructor

var Reflect = function(){}

// Meta

Reflect.__name__ = "Reflect";
Reflect.__isInterface__ = false;
Reflect.prototype = {
	
};
Reflect.prototype.__class__ = Reflect.prototype.constructor = $hxClasses["Reflect"] = Reflect;

// Init



// Statics

Reflect.hasField = function(o,field) {
	return Object.prototype.hasOwnProperty.call(o,field);
}
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		(haxe_CallStack().default).lastException = e;
		var e1 = ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e;
		return null;
	}
}
Reflect.setField = function(o,field,value) {
	o[field] = value;
}
Reflect.getProperty = function(o,field) {
	var tmp;
	if(o == null) {
		return null;
	} else {
		var tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["get_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			return o[tmp]();
		} else {
			return o[field];
		}
	}
}
Reflect.callMethod = function(o,func,args) {
	return func.apply(o,args);
}
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
}
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !((js_Boot().default).isClass(f) || (js_Boot().default).isEnum(f));
	} else {
		return false;
	}
}
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
}
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
}
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
}
Reflect.deleteField = function(o,field) {
	if(!Reflect.hasField(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
}
Reflect.makeVarArgs = function(f) {
	return function() {
		var a = Array.prototype.slice.call(arguments);
		return f(a);
	};
}


// Export

exports.default = Reflect;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/Std.js":
/*!*********************************************!*\
  !*** ./node_modules/openfl/lib/_gen/Std.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: Std

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js_Boot() {return __webpack_require__(/*! ./js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}
function StringTools() {return __webpack_require__(/*! ./StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}

// Constructor

var Std = function(){}

// Meta

Std.__name__ = "Std";
Std.__isInterface__ = false;
Std.prototype = {
	
};
Std.prototype.__class__ = Std.prototype.constructor = $hxClasses["Std"] = Std;

// Init

{
	String.prototype.__class__ = $hxClasses["String"] = String
	String.__name__ = "String";
	$hxClasses["Array"] = Array
	Array.__name__ = "Array";
	Date.prototype.__class__ = $hxClasses["Date"] = Date;
	Date.__name__ = "Date";
	var Int = $hxClasses["Int"] = { };
	var Dynamic = $hxClasses["Dynamic"] = { };
	var Float = $hxClasses["Float"] = Number;
	var Bool = $hxClasses["Bool"] = Boolean;
	var Class = $hxClasses["Class"] = { };
	var Enum = $hxClasses["Enum"] = { };
};

// Statics

Std.is = function(v,t) {
	return (js_Boot().default).__instanceof(v,t);
}
Std.string = function(s) {
	return (js_Boot().default).__string_rec(s,"");
}
Std.int = function(x) {
	return x | 0;
}
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = (StringTools().default).fastCodeAt(x,i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var v = parseInt(x, (x[(i + 1)]=="x" || x[(i + 1)]=="X") ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
}
Std.parseFloat = function(x) {
	return parseFloat(x);
}


// Export

exports.default = Std;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/StringBuf.js":
/*!***************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/StringBuf.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: StringBuf

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function HxOverrides() {return __webpack_require__(/*! ./HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var StringBuf = function() {
	this.b = "";
}

// Meta

StringBuf.__name__ = "StringBuf";
StringBuf.__isInterface__ = false;
StringBuf.prototype = {
	add: function(x) {
		this.b += (Std().default).string(x);
	},
	addChar: function(c) {
		this.b += String.fromCodePoint(c);
	},
	addSub: function(s,pos,len) {
		this.b += len == null ? (HxOverrides().default).substr(s,pos,null) : (HxOverrides().default).substr(s,pos,len);
	},
	toString: function() {
		return this.b;
	}
};
StringBuf.prototype.__class__ = StringBuf.prototype.constructor = $hxClasses["StringBuf"] = StringBuf;

// Init



// Statics




// Export

exports.default = StringBuf;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/StringTools.js":
/*!*****************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/StringTools.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: StringTools

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function StringBuf() {return __webpack_require__(/*! ./StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}
function haxe_iterators_StringIteratorUnicode() {return __webpack_require__(/*! ./haxe/iterators/StringIteratorUnicode */ "./node_modules/openfl/lib/_gen/haxe/iterators/StringIteratorUnicode.js");}
function HxOverrides() {return __webpack_require__(/*! ./HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var StringTools = function(){}

// Meta

StringTools.__name__ = "StringTools";
StringTools.__isInterface__ = false;
StringTools.prototype = {
	
};
StringTools.prototype.__class__ = StringTools.prototype.constructor = $hxClasses["StringTools"] = StringTools;

// Init



// Statics

StringTools.urlEncode = function(s) {
	return encodeURIComponent(s);
}
StringTools.urlDecode = function(s) {
	return decodeURIComponent(s.split("+").join(" "));
}
StringTools.htmlEscape = function(s,quotes) {
	var buf = new (StringBuf().default)();
	var code = new (haxe_iterators_StringIteratorUnicode().default)(s);
	while(code.hasNext()) {
		var code1 = code.next();
		switch(code1) {
		case 34:
			if(quotes) {
				buf.add("&quot;");
			} else {
				buf.addChar(code1);
			}
			break;
		case 38:
			buf.add("&amp;");
			break;
		case 39:
			if(quotes) {
				buf.add("&#039;");
			} else {
				buf.addChar(code1);
			}
			break;
		case 60:
			buf.add("&lt;");
			break;
		case 62:
			buf.add("&gt;");
			break;
		default:
			buf.addChar(code1);
		}
	}
	return buf.toString();
}
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
}
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
}
StringTools.isSpace = function(s,pos) {
	var c = (HxOverrides().default).cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
}
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return (HxOverrides().default).substr(s,r,l - r);
	} else {
		return s;
	}
}
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return (HxOverrides().default).substr(s,0,l - r);
	} else {
		return s;
	}
}
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
}
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
}
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
}
StringTools.fastCodeAt = function(s,index) {
	return s.charCodeAt(index);
}
StringTools.isEof = function(c) {
	return c != c;
}
StringTools.utf16CodePointAt = function(s,index) {
	var c = StringTools.fastCodeAt(s,index);
	if(c >= 55296 && c <= 56319) {
		c = c - 55232 << 10 | StringTools.fastCodeAt(s,index + 1) & 1023;
	}
	return c;
}


// Export

exports.default = StringTools;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/Type.js":
/*!**********************************************!*\
  !*** ./node_modules/openfl/lib/_gen/Type.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: Type

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js_Boot() {return __webpack_require__(/*! ./js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}
function Reflect() {return __webpack_require__(/*! ./Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function HxOverrides() {return __webpack_require__(/*! ./HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function ValueType() {return __webpack_require__(/*! ./ValueType */ "./node_modules/openfl/lib/_gen/ValueType.js");}

// Constructor

var Type = function(){}

// Meta

Type.__name__ = "Type";
Type.__isInterface__ = false;
Type.prototype = {
	
};
Type.prototype.__class__ = Type.prototype.constructor = $hxClasses["Type"] = Type;

// Init



// Statics

Type.getClass = function(o) {
	return (js_Boot().default).getClass(o);
}
Type.getSuperClass = function(c) {
	return c.__super__;
}
Type.getClassName = function(c) {
	return c.__name__;
}
Type.getEnumName = function(e) {
	return e.__ename__;
}
Type.resolveClass = function(name) {
	return $hxClasses[name];
}
Type.resolveEnum = function(name) {
	return $hxEnums[name];
}
Type.createInstance = function(cl,args) {
	return new (Function.prototype.bind.apply(cl,[null].concat(args)));
}
Type.createEmptyInstance = function(cl) {
	return Object.create(cl.prototype);
}
Type.createEnum = function(e,constr,params) {
	var f = (Reflect().default).field(e,constr);
	if(f == null) {
		throw new (js__$Boot_HaxeError().default)("No such constructor " + constr);
	}
	if((Reflect().default).isFunction(f)) {
		if(params == null) {
			throw new (js__$Boot_HaxeError().default)("Constructor " + constr + " need parameters");
		}
		return (Reflect().default).callMethod(e,f,params);
	}
	if(params != null && params.length != 0) {
		throw new (js__$Boot_HaxeError().default)("Constructor " + constr + " does not need parameters");
	}
	return f;
}
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	(HxOverrides().default).remove(a,"__class__");
	(HxOverrides().default).remove(a,"__properties__");
	return a;
}
Type.getEnumConstructs = function(e) {
	return e.__constructs__.slice();
}
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return (ValueType().default).TBool;
	case "function":
		if((js_Boot().default).isClass(v) || (js_Boot().default).isEnum(v)) {
			return (ValueType().default).TObject;
		}
		return (ValueType().default).TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return (ValueType().default).TInt;
		}
		return (ValueType().default).TFloat;
	case "object":
		if(v == null) {
			return (ValueType().default).TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return (ValueType().default).TEnum($hxEnums[e]);
		}
		var c = (js_Boot().default).getClass(v);
		if(c != null) {
			return (ValueType().default).TClass(c);
		}
		return (ValueType().default).TObject;
	case "string":
		return (ValueType().default).TClass(String);
	case "undefined":
		return (ValueType().default).TNull;
	default:
		return (ValueType().default).TUnknown;
	}
}
Type.enumConstructor = function(e) {
	return $hxEnums[e.__enum__].__constructs__[e._hx_index];
}
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var ctorName = enm.__constructs__[e._hx_index];
	var params = enm[ctorName].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
}
Type.enumIndex = function(e) {
	return e._hx_index;
}


// Export

exports.default = Type;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/ValueType.js":
/*!***************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/ValueType.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: ValueType

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var ValueType = $hxEnums["ValueType"] = { __ename__ : "ValueType", __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"]
  ,TUnknown: {_hx_index:8,__enum__:"ValueType",toString:$estr}
  ,TObject: {_hx_index:4,__enum__:"ValueType",toString:$estr}
  ,TNull: {_hx_index:0,__enum__:"ValueType",toString:$estr}
  ,TInt: {_hx_index:1,__enum__:"ValueType",toString:$estr}
  ,TFunction: {_hx_index:5,__enum__:"ValueType",toString:$estr}
  ,TFloat: {_hx_index:2,__enum__:"ValueType",toString:$estr}
  ,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["e"],$_)
  ,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["c"],$_)
  ,TBool: {_hx_index:3,__enum__:"ValueType",toString:$estr}
};

exports.default = ValueType;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/Xml.js":
/*!*********************************************!*\
  !*** ./node_modules/openfl/lib/_gen/Xml.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: Xml

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function _$Xml_XmlType_$Impl_$() {return __webpack_require__(/*! ./_Xml/XmlType_Impl_ */ "./node_modules/openfl/lib/_gen/_Xml/XmlType_Impl_.js");}
function HxOverrides() {return __webpack_require__(/*! ./HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function haxe_xml_Printer() {return __webpack_require__(/*! ./haxe/xml/Printer */ "./node_modules/openfl/lib/_gen/haxe/xml/Printer.js");}
function haxe_xml_Parser() {return __webpack_require__(/*! ./haxe/xml/Parser */ "./node_modules/openfl/lib/_gen/haxe/xml/Parser.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}

// Constructor

var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new (haxe_ds_StringMap().default)();
}

// Meta

Xml.__name__ = "Xml";
Xml.__isInterface__ = false;
Xml.prototype = {
	get_nodeName: function() {
		if(this.nodeType != Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, expected Element but found " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
		return this.nodeName;
	},
	set_nodeName: function(v) {
		if(this.nodeType != Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, expected Element but found " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
		return this.nodeName = v;
	},
	get_nodeValue: function() {
		if(this.nodeType == Xml.Document || this.nodeType == Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, unexpected " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
		return this.nodeValue;
	},
	set_nodeValue: function(v) {
		if(this.nodeType == Xml.Document || this.nodeType == Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, unexpected " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
		return this.nodeValue = v;
	},
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, expected Element but found " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
		return this.attributeMap.get(att);
	},
	set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, expected Element but found " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
		this.attributeMap.set(att,value);
	},
	exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, expected Element but found " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
		return this.attributeMap.exists(att);
	},
	attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, expected Element but found " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
		return this.attributeMap.keys();
	},
	iterator: function() {
		this.ensureElementType();
		return (HxOverrides().default).iter(this.children);
	},
	addChild: function(x) {
		this.ensureElementType();
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	},
	removeChild: function(x) {
		this.ensureElementType();
		if((HxOverrides().default).remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	},
	toString: function() {
		return (haxe_xml_Printer().default).print(this);
	},
	ensureElementType: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new (js__$Boot_HaxeError().default)("Bad node type, expected Element or Document but found " + (_$Xml_XmlType_$Impl_$().default).toString(this.nodeType));
		}
	}
};
Xml.prototype.__class__ = Xml.prototype.constructor = $hxClasses["Xml"] = Xml;

// Init



// Statics

Xml.parse = function(str) {
	return (haxe_xml_Parser().default).parse(str);
}
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	xml.set_nodeName(name);
	return xml;
}
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	xml.set_nodeValue(data);
	return xml;
}
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	xml.set_nodeValue(data);
	return xml;
}
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	xml.set_nodeValue(data);
	return xml;
}
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	xml.set_nodeValue(data);
	return xml;
}
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	xml.set_nodeValue(data);
	return xml;
}
Xml.createDocument = function() {
	return new Xml(Xml.Document);
}
Xml.Element = 0
Xml.PCData = 1
Xml.CData = 2
Xml.Comment = 3
Xml.DocType = 4
Xml.ProcessingInstruction = 5
Xml.Document = 6

// Export

exports.default = Xml;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/_String/String_Impl_.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/_String/String_Impl_.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: _String.String_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var String_Impl_ = function(){}

// Meta

String_Impl_.__name__ = "_String.String_Impl_";
String_Impl_.__isInterface__ = false;
String_Impl_.prototype = {
	
};
String_Impl_.prototype.__class__ = String_Impl_.prototype.constructor = $hxClasses["_String.String_Impl_"] = String_Impl_;

// Init



// Statics

String_Impl_.fromCharCode = function(code) {
	return String.fromCodePoint(code);
}


// Export

exports.default = String_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: _UInt.UInt_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var UInt_Impl_ = function(){}

// Meta

UInt_Impl_.__name__ = "_UInt.UInt_Impl_";
UInt_Impl_.__isInterface__ = false;
UInt_Impl_.prototype = {
	
};
UInt_Impl_.prototype.__class__ = UInt_Impl_.prototype.constructor = $hxClasses["_UInt.UInt_Impl_"] = UInt_Impl_;

// Init



// Statics

UInt_Impl_.gt = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a > b;
	}
}
UInt_Impl_.toFloat = function(this1) {
	var int = this1;
	if(int < 0) {
		return 4294967296.0 + int;
	} else {
		return int + 0.0;
	}
}


// Export

exports.default = UInt_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/_Xml/XmlType_Impl_.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/_Xml/XmlType_Impl_.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: _Xml.XmlType_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var XmlType_Impl_ = function(){}

// Meta

XmlType_Impl_.__name__ = "_Xml.XmlType_Impl_";
XmlType_Impl_.__isInterface__ = false;
XmlType_Impl_.prototype = {
	
};
XmlType_Impl_.prototype.__class__ = XmlType_Impl_.prototype.constructor = $hxClasses["_Xml.XmlType_Impl_"] = XmlType_Impl_;

// Init



// Statics

XmlType_Impl_.toString = function(this1) {
	switch(this1) {
	case 0:
		return "Element";
	case 1:
		return "PCData";
	case 2:
		return "CData";
	case 3:
		return "Comment";
	case 4:
		return "DocType";
	case 5:
		return "ProcessingInstruction";
	case 6:
		return "Document";
	}
}


// Export

exports.default = XmlType_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/bind_stub.js":
/*!***************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/bind_stub.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Haxe uses its own caching bind method.  It's faster, but less standard than Function.bind.
// This version is slightly modified for compressability, modularization and readability.
// https://github.com/HaxeFoundation/haxe/issues/1349
// http://stackoverflow.com/a/17638540/1732990

Object.defineProperty(exports, "__esModule", {value: true});

var $fid = 0;

exports.default = function $bind(obj, method) {
    var func, mId;

    if( method == null ) { return null; }
    mId = method._i = method._i || $fid++;

    if( obj._c == null ) {
        obj._c = {};
    } else {
        func = obj._c[mId];
    }
    if( func == null ) {
        func = function(){
            return func._m.apply(func._s, arguments);
        };
        func._s = obj;
        func._m = method;
        obj._c[mId] = func;
    }
    return func;
};

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/estr_stub.js":
/*!***************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/estr_stub.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {value: true});

var js_Boot = __webpack_require__(/*! ./js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");

exports.default = function $estr() {
	return js_Boot.__string_rec(this, '');
}


/***/ }),

/***/ "./node_modules/openfl/lib/_gen/extend_stub.js":
/*!*****************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/extend_stub.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {value: true});

exports.default = function $extend(from, fields) {
    function Inherit() {};
    Inherit.prototype = from;
    var proto = new Inherit();
    for (var name in fields) proto[name] = fields[name];
    if(fields.toString !== Object.prototype.toString) proto.toString = fields.toString;
    return proto;
};


/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf/Reader.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf/Reader.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: format.amf.Reader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function format_amf_Value() {return __webpack_require__(/*! ./../../format/amf/Value */ "./node_modules/openfl/lib/_gen/format/amf/Value.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}

// Constructor

var Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
}

// Meta

Reader.__name__ = "format.amf.Reader";
Reader.__isInterface__ = false;
Reader.prototype = {
	readObject: function() {
		var h = new (haxe_ds_StringMap().default)();
		while(true) {
			var c1 = this.i.readByte();
			var c2 = this.i.readByte();
			var name = this.i.readString(c1 << 8 | c2);
			var k = this.i.readByte();
			if(k == 9) {
				break;
			}
			h.set(name,this.readWithCode(k));
		}
		return h;
	},
	readArray: function(n) {
		var a = [];
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			a.push(this.read());
		}
		return a;
	},
	readInt: function() {
		return this.i.readInt32();
	},
	readWithCode: function(id) {
		var i = this.i;
		switch(id) {
		case 0:
			return (format_amf_Value().default).ANumber(i.readDouble());
		case 1:
			var tmp;
			switch(i.readByte()) {
			case 0:
				tmp = false;
				break;
			case 1:
				tmp = true;
				break;
			default:
				throw new (js__$Boot_HaxeError().default)("Invalid AMF");
			}
			return (format_amf_Value().default).ABool(tmp);
		case 2:
			return (format_amf_Value().default).AString(i.readString(i.readUInt16()));
		case 5:
			return (format_amf_Value().default).ANull;
		case 6:
			return (format_amf_Value().default).AUndefined;
		case 7:
			throw new (js__$Boot_HaxeError().default)("Not supported : Reference");
		case 3:case 8:
			var ismixed = id == 8;
			var size = ismixed ? this.readInt() : null;
			return (format_amf_Value().default).AObject(this.readObject(),size);
		case 10:
			return (format_amf_Value().default).AArray(this.readArray(this.readInt()));
		case 11:
			var time_ms = i.readDouble();
			var tz_min = i.readUInt16();
			return (format_amf_Value().default).ADate(new Date(time_ms + tz_min * 60 * 1000.0));
		case 12:
			return (format_amf_Value().default).AString(i.readString(this.readInt()));
		default:
			throw new (js__$Boot_HaxeError().default)("Unknown AMF " + id);
		}
	},
	read: function() {
		return this.readWithCode(this.i.readByte());
	}
};
Reader.prototype.__class__ = Reader.prototype.constructor = $hxClasses["format.amf.Reader"] = Reader;

// Init



// Statics




// Export

exports.default = Reader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf/Tools.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf/Tools.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: format.amf.Tools

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function format_amf_Value() {return __webpack_require__(/*! ./../../format/amf/Value */ "./node_modules/openfl/lib/_gen/format/amf/Value.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Tools = function(){}

// Meta

Tools.__name__ = "format.amf.Tools";
Tools.__isInterface__ = false;
Tools.prototype = {
	
};
Tools.prototype.__class__ = Tools.prototype.constructor = $hxClasses["format.amf.Tools"] = Tools;

// Init



// Statics

Tools.encode = function(o) {
	var _g = (Type().default).typeof(o);
	switch(_g._hx_index) {
	case 0:
		return (format_amf_Value().default).ANull;
	case 1:
		return (format_amf_Value().default).ANumber(o);
	case 2:
		return (format_amf_Value().default).ANumber(o);
	case 3:
		return (format_amf_Value().default).ABool(o);
	case 4:
		var h = new (haxe_ds_StringMap().default)();
		var _g1 = 0;
		var _g11 = (Reflect().default).fields(o);
		while(_g1 < _g11.length) {
			var f = _g11[_g1];
			++_g1;
			h.set(f,Tools.encode((Reflect().default).field(o,f)));
		}
		return (format_amf_Value().default).AObject(h);
	case 6:
		var c = _g.c;
		switch(c) {
		case Array:
			var o1 = o;
			var a = [];
			var _g2 = 0;
			while(_g2 < o1.length) {
				var v = o1[_g2];
				++_g2;
				a.push(Tools.encode(v));
			}
			return (format_amf_Value().default).AArray(a);
		case String:
			return (format_amf_Value().default).AString(o);
		case (haxe_ds_StringMap().default):
			var o2 = o;
			var h1 = new (haxe_ds_StringMap().default)();
			var f1 = o2.keys();
			while(f1.hasNext()) {
				var f2 = f1.next();
				h1.set(f2,Tools.encode(o2.get(f2)));
			}
			return (format_amf_Value().default).AObject(h1);
		default:
			throw new (js__$Boot_HaxeError().default)("Can't encode instance of " + (Type().default).getClassName(c));
		}
		break;
	default:
		throw new (js__$Boot_HaxeError().default)("Can't encode " + (Std().default).string(o));
	}
}
Tools.number = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 0) {
		var n = a.f;
		return n;
	} else {
		return null;
	}
}
Tools.string = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 2) {
		var s = a.s;
		return s;
	} else {
		return null;
	}
}
Tools.object = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 3) {
		var _g1 = a.size;
		var o = a.fields;
		return o;
	} else {
		return null;
	}
}
Tools.abool = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 1) {
		var b = a.b;
		return b;
	} else {
		return null;
	}
}
Tools.array = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 7) {
		var a1 = a.values;
		return a1;
	} else {
		return null;
	}
}


// Export

exports.default = Tools;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf/Value.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf/Value.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: format.amf.Value

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var Value = $hxEnums["format.amf.Value"] = { __ename__ : "format.amf.Value", __constructs__ : ["ANumber","ABool","AString","AObject","ADate","AUndefined","ANull","AArray"]
  ,AUndefined: {_hx_index:5,__enum__:"format.amf.Value",toString:$estr}
  ,AString: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"format.amf.Value",toString:$estr}; },$_.__params__ = ["s"],$_)
  ,AObject: ($_=function(fields,size) { return {_hx_index:3,fields:fields,size:size,__enum__:"format.amf.Value",toString:$estr}; },$_.__params__ = ["fields","size"],$_)
  ,ANumber: ($_=function(f) { return {_hx_index:0,f:f,__enum__:"format.amf.Value",toString:$estr}; },$_.__params__ = ["f"],$_)
  ,ANull: {_hx_index:6,__enum__:"format.amf.Value",toString:$estr}
  ,ADate: ($_=function(d) { return {_hx_index:4,d:d,__enum__:"format.amf.Value",toString:$estr}; },$_.__params__ = ["d"],$_)
  ,ABool: ($_=function(b) { return {_hx_index:1,b:b,__enum__:"format.amf.Value",toString:$estr}; },$_.__params__ = ["b"],$_)
  ,AArray: ($_=function(values) { return {_hx_index:7,values:values,__enum__:"format.amf.Value",toString:$estr}; },$_.__params__ = ["values"],$_)
};

exports.default = Value;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf/Writer.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf/Writer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: format.amf.Writer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var Writer = function(o) {
	this.o = o;
	o.set_bigEndian(true);
}

// Meta

Writer.__name__ = "format.amf.Writer";
Writer.__isInterface__ = false;
Writer.prototype = {
	write: function(v) {
		var o = this.o;
		switch(v._hx_index) {
		case 0:
			var n = v.f;
			o.writeByte(0);
			o.writeDouble(n);
			break;
		case 1:
			var b = v.b;
			o.writeByte(1);
			o.writeByte(b ? 1 : 0);
			break;
		case 2:
			var s = v.s;
			if(s.length <= 65535) {
				o.writeByte(2);
				o.writeUInt16(s.length);
			} else {
				o.writeByte(12);
				o.writeInt32(s.length);
			}
			o.writeString(s);
			break;
		case 3:
			var size = v.size;
			var h = v.fields;
			if(size == null) {
				o.writeByte(3);
			} else {
				o.writeByte(8);
				o.writeInt32(size);
			}
			var f = h.keys();
			while(f.hasNext()) {
				var f1 = f.next();
				o.writeUInt16(f1.length);
				o.writeString(f1);
				this.write(h.get(f1));
			}
			o.writeByte(0);
			o.writeByte(0);
			o.writeByte(9);
			break;
		case 4:
			var d = v.d;
			o.writeByte(11);
			o.writeDouble(d.getTime());
			o.writeUInt16(0);
			break;
		case 5:
			o.writeByte(6);
			break;
		case 6:
			o.writeByte(5);
			break;
		case 7:
			var a = v.values;
			o.writeByte(10);
			o.writeInt32(a.length);
			var _g = 0;
			while(_g < a.length) {
				var f2 = a[_g];
				++_g;
				this.write(f2);
			}
			break;
		}
	}
};
Writer.prototype.__class__ = Writer.prototype.constructor = $hxClasses["format.amf.Writer"] = Writer;

// Init



// Statics




// Export

exports.default = Writer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf3/Amf3Array.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf3/Amf3Array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: format.amf3.Amf3Array

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var Amf3Array = function(initA,initExtra) {
	this.a = initA;
	this.extra = initExtra;
}

// Meta

Amf3Array.__name__ = "format.amf3.Amf3Array";
Amf3Array.__isInterface__ = false;
Amf3Array.prototype = {
	
};
Amf3Array.prototype.__class__ = Amf3Array.prototype.constructor = $hxClasses["format.amf3.Amf3Array"] = Amf3Array;

// Init



// Statics


Amf3Array.__meta__ = { fields : { extra : { optional : null}}}

// Export

exports.default = Amf3Array;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf3/Reader.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf3/Reader.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: format.amf3.Reader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function format_amf3_Tools() {return __webpack_require__(/*! ./../../format/amf3/Tools */ "./node_modules/openfl/lib/_gen/format/amf3/Tools.js");}
function haxe_Log() {return __webpack_require__(/*! ./../../haxe/Log */ "./node_modules/openfl/lib/_gen/haxe/Log.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function format_amf3_Value() {return __webpack_require__(/*! ./../../format/amf3/Value */ "./node_modules/openfl/lib/_gen/format/amf3/Value.js");}
function haxe_ds_EnumValueMap() {return __webpack_require__(/*! ./../../haxe/ds/EnumValueMap */ "./node_modules/openfl/lib/_gen/haxe/ds/EnumValueMap.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function Xml() {return __webpack_require__(/*! ./../../Xml */ "./node_modules/openfl/lib/_gen/Xml.js");}

// Constructor

var Reader = function(i) {
	this.complexObjectsTable = [];
	this.objectTraitsTable = [];
	this.stringTable = [];
	this.i = i;
	i.set_bigEndian(true);
}

// Meta

Reader.__name__ = "format.amf3.Reader";
Reader.__isInterface__ = false;
Reader.prototype = {
	readObject: function() {
		var dyn = false;
		var isExternalizable = false;
		var className = null;
		var sealedMemberNames = [];
		var n = this.readInt();
		if((n & 1) == 0) {
			return this.complexObjectsTable[n >> 1];
		} else if((n & 3) == 1) {
			n >>= 3;
			var refTraits = this.objectTraitsTable[n];
			dyn = refTraits.isDynamic;
			isExternalizable = refTraits.isExternalizable;
			sealedMemberNames = refTraits.sealedMemberNames;
		} else if((n & 7) == 3) {
			dyn = (n >> 3 & 1) == 1;
			n >>= 4;
			className = this.readString();
			var _g = 0;
			var _g1 = n;
			while(_g < _g1) {
				var j = _g++;
				sealedMemberNames.push((format_amf3_Tools().default).decode(this.readString()));
			}
			this.objectTraitsTable.push({ isExternalizable : isExternalizable, isDynamic : dyn, className : className, sealedMemberNames : sealedMemberNames});
		} else if((n & 7) == 7) {
			isExternalizable = true;
			className = this.readString();
			(haxe_Log().default).trace((format_amf3_Tools().default).decode(className),{ fileName : "../node_modules/format/format/amf3/Reader.hx", lineNumber : 108, className : "format.amf3.Reader", methodName : "readObject"});
		} else {
			throw new (js__$Boot_HaxeError().default)("Invalid object traits");
		}
		var h = new (haxe_ds_StringMap().default)();
		var ret = (format_amf3_Value().default).AObject(h);
		this.complexObjectsTable.push(ret);
		if(!isExternalizable) {
			var _g2 = 0;
			var _g11 = sealedMemberNames.length;
			while(_g2 < _g11) {
				var j1 = _g2++;
				var value = this.read();
				h.set(sealedMemberNames[j1],value);
			}
			if(dyn) {
				var s;
				while(true) {
					s = (format_amf3_Tools().default).decode(this.readString());
					if(s == "") {
						break;
					}
					h.set(s,this.read());
				}
			}
		} else {
			throw new (js__$Boot_HaxeError().default)("Externalizable not supported");
		}
		return ret;
	},
	readMap: function() {
		var n = this.readInt();
		if((n & 1) == 0) {
			return this.complexObjectsTable[n >> 1];
		}
		n >>= 1;
		var h = new (haxe_ds_EnumValueMap().default)();
		var ret = (format_amf3_Value().default).AMap(h);
		this.complexObjectsTable.push(ret);
		this.i.readByte();
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			h.set(this.read(),this.read());
		}
		return ret;
	},
	readArray: function() {
		var n = this.readInt();
		if((n & 1) == 0) {
			return this.complexObjectsTable[n >> 1];
		}
		n >>= 1;
		var a = [];
		var m = new (haxe_ds_StringMap().default)();
		var ret = (format_amf3_Value().default).AArray(a,m);
		this.complexObjectsTable.push(ret);
		var assocName = (format_amf3_Tools().default).decode(this.readString());
		while(assocName.length != 0) {
			var v = this.read();
			m.set(assocName,v);
			assocName = (format_amf3_Tools().default).decode(this.readString());
		}
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			a.push(this.read());
		}
		return ret;
	},
	readIntVector: function() {
		var header = this.readInt();
		if((header & 1) == 0) {
			return this.complexObjectsTable[header >> 1];
		}
		var len = header >> 1;
		var fixed = this.i.readByte() != 0;
		var a;
		if(fixed) {
			var this1 = new Array(len);
			a = this1;
		} else {
			a = [];
		}
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var r = _g++;
			a[r] = (format_amf3_Value().default).AInt(this.i.readInt32());
		}
		var ret = fixed ? (format_amf3_Value().default).AVector(a) : (format_amf3_Value().default).AArray(a);
		this.complexObjectsTable.push(ret);
		return ret;
	},
	readDoubleVector: function() {
		var header = this.readInt();
		if((header & 1) == 0) {
			return this.complexObjectsTable[header >> 1];
		}
		var len = header >> 1;
		var fixed = this.i.readByte() != 0;
		var a;
		if(fixed) {
			var this1 = new Array(len);
			a = this1;
		} else {
			a = [];
		}
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var r = _g++;
			a[r] = (format_amf3_Value().default).ANumber(this.i.readDouble());
		}
		var ret = fixed ? (format_amf3_Value().default).AVector(a) : (format_amf3_Value().default).AArray(a);
		this.complexObjectsTable.push(ret);
		return ret;
	},
	readObjectVector: function() {
		var header = this.readInt();
		if((header & 1) == 0) {
			return this.complexObjectsTable[header >> 1];
		}
		var len = header >> 1;
		var fixed = this.i.readByte() != 0;
		var objectTypeName = (format_amf3_Tools().default).decode(this.readString());
		(haxe_Log().default).trace("readObjectVector name:" + objectTypeName,{ fileName : "../node_modules/format/format/amf3/Reader.hx", lineNumber : 259, className : "format.amf3.Reader", methodName : "readObjectVector"});
		var VC = (Type().default).resolveClass(objectTypeName);
		(haxe_Log().default).trace("VC:" + (Std().default).string(VC),{ fileName : "../node_modules/format/format/amf3/Reader.hx", lineNumber : 261, className : "format.amf3.Reader", methodName : "readObjectVector"});
		var a;
		var ret;
		if(fixed) {
			var this1 = new Array(len);
			a = this1;
			ret = (format_amf3_Value().default).AVector(a);
		} else {
			a = [];
			ret = (format_amf3_Value().default).AArray(a);
		}
		this.complexObjectsTable.push(ret);
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var r = _g++;
			a[r] = this.read();
		}
		return ret;
	},
	readBytes: function() {
		var n = this.readInt();
		if((n & 1) == 0) {
			return this.complexObjectsTable[n >> 1];
		}
		n >>= 1;
		var b = (haxe_io_Bytes().default).alloc(n);
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var j = _g++;
			b.set(j,this.i.readByte());
		}
		var ret = (format_amf3_Value().default).ABytes(b);
		this.complexObjectsTable.push(ret);
		return ret;
	},
	readInt: function(signExtend,preShift) {
		if(preShift == null) {
			preShift = 0;
		}
		if(signExtend == null) {
			signExtend = false;
		}
		var c = this.i.readByte() & 255;
		if(c < 128) {
			return c >> preShift;
		}
		var ret = (c & 127) << 7;
		c = this.i.readByte() & 255;
		if(c < 128) {
			return (ret | c) >> preShift;
		}
		ret |= c & 127;
		ret <<= 7;
		c = this.i.readByte() & 255;
		if(c < 128) {
			return (ret | c) >> preShift;
		}
		ret |= c & 127;
		ret <<= 8;
		c = this.i.readByte() & 255;
		ret |= c;
		if(signExtend && (ret & 268435456) != 0) {
			ret |= -536870912;
		}
		return ret >> preShift;
	},
	readString: function() {
		var header = this.readInt();
		if((header & 1) == 0) {
			var strRefIdx = header >> 1;
			return this.stringTable[strRefIdx];
		}
		var len = header >> 1;
		return this.readStringNoHeader(len);
	},
	readStringNoHeader: function(len) {
		if(len == 0) {
			return (format_amf3_Value().default).AString("");
		}
		var u = "";
		var c = 0;
		var d = 0;
		var j = 0;
		var it = 0;
		while(j < len) {
			c = this.i.readByte();
			if(c < 128) {
				it = 0;
				d = c;
			} else if(c < 224) {
				it = 1;
				d = c & 31;
			} else if(c < 240) {
				it = 2;
				d = c & 15;
			} else if(c < 241) {
				it = 3;
				d = c & 7;
			}
			c = it;
			while(c-- > 0) {
				d <<= 6;
				d |= this.i.readByte() & 63;
			}
			j += it + 1;
			if(d != 1) {
				u = u + String.fromCodePoint(d);
			}
		}
		var ret = (format_amf3_Value().default).AString(u.toString());
		this.stringTable.push(ret);
		return ret;
	},
	readDate: function() {
		var n = this.readInt();
		if((n & 1) == 0) {
			return this.complexObjectsTable[n >> 1];
		}
		var date = new Date(this.i.readDouble());
		var ret = (format_amf3_Value().default).ADate(date);
		this.complexObjectsTable.push(ret);
		return ret;
	},
	readXml: function() {
		var n = this.readInt();
		if((n & 1) == 0) {
			return this.complexObjectsTable[n >> 1];
		}
		n >>= 1;
		var xml = (Xml().default).parse((format_amf3_Tools().default).decode(this.readStringNoHeader(n)));
		var ret = (format_amf3_Value().default).AXml(xml);
		this.complexObjectsTable.push(ret);
		return ret;
	},
	readWithCode: function(id) {
		var i = this.i;
		switch(id) {
		case 0:
			return (format_amf3_Value().default).AUndefined;
		case 1:
			return (format_amf3_Value().default).ANull;
		case 2:
			return (format_amf3_Value().default).ABool(false);
		case 3:
			return (format_amf3_Value().default).ABool(true);
		case 4:
			return (format_amf3_Value().default).AInt(this.readInt(true));
		case 5:
			return (format_amf3_Value().default).ANumber(i.readDouble());
		case 6:
			return this.readString();
		case 7:
			throw new (js__$Boot_HaxeError().default)("XMLDocument unsupported");
		case 8:
			return this.readDate();
		case 9:
			return this.readArray();
		case 10:
			return this.readObject();
		case 11:
			return this.readXml();
		case 12:
			return this.readBytes();
		case 13:case 14:
			return this.readIntVector();
		case 15:
			return this.readDoubleVector();
		case 16:
			return this.readObjectVector();
		case 17:
			return this.readMap();
		default:
			throw new (js__$Boot_HaxeError().default)("Unknown AMF " + id);
		}
	},
	read: function() {
		return this.readWithCode(this.i.readByte());
	}
};
Reader.prototype.__class__ = Reader.prototype.constructor = $hxClasses["format.amf3.Reader"] = Reader;

// Init



// Statics




// Export

exports.default = Reader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf3/Tools.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf3/Tools.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: format.amf3.Tools

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function format_amf3_Value() {return __webpack_require__(/*! ./../../format/amf3/Value */ "./node_modules/openfl/lib/_gen/format/amf3/Value.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function Xml() {return __webpack_require__(/*! ./../../Xml */ "./node_modules/openfl/lib/_gen/Xml.js");}
function format_amf3_Amf3Array() {return __webpack_require__(/*! ./../../format/amf3/Amf3Array */ "./node_modules/openfl/lib/_gen/format/amf3/Amf3Array.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function haxe_ds_ObjectMap() {return __webpack_require__(/*! ./../../haxe/ds/ObjectMap */ "./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js");}
function haxe_ds_EnumValueMap() {return __webpack_require__(/*! ./../../haxe/ds/EnumValueMap */ "./node_modules/openfl/lib/_gen/haxe/ds/EnumValueMap.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Tools = function(){}

// Meta

Tools.__name__ = "format.amf3.Tools";
Tools.__isInterface__ = false;
Tools.prototype = {
	
};
Tools.prototype.__class__ = Tools.prototype.constructor = $hxClasses["format.amf3.Tools"] = Tools;

// Init



// Statics

Tools.encode = function(o) {
	var _g = (Type().default).typeof(o);
	switch(_g._hx_index) {
	case 0:
		return (format_amf3_Value().default).ANull;
	case 1:
		return (format_amf3_Value().default).AInt(o);
	case 2:
		return (format_amf3_Value().default).ANumber(o);
	case 3:
		return (format_amf3_Value().default).ABool(o);
	case 4:
		var h = new (haxe_ds_StringMap().default)();
		var _g1 = 0;
		var _g11 = (Reflect().default).fields(o);
		while(_g1 < _g11.length) {
			var f = _g11[_g1];
			++_g1;
			h.set(f,Tools.encode((Reflect().default).field(o,f)));
		}
		return (format_amf3_Value().default).AObject(h);
	case 6:
		var c = _g.c;
		switch(c) {
		case Array:
			var o1 = o;
			var a = [];
			var _g2 = 0;
			while(_g2 < o1.length) {
				var v = o1[_g2];
				++_g2;
				a.push(Tools.encode(v));
			}
			return (format_amf3_Value().default).AArray(a);
		case Date:
			return (format_amf3_Value().default).ADate(o);
		case String:
			return (format_amf3_Value().default).AString(o);
		case (Xml().default):
			return (format_amf3_Value().default).AXml(o);
		case (format_amf3_Amf3Array().default):
			var o2 = o;
			var a1 = [];
			var m = new (haxe_ds_StringMap().default)();
			var _g3 = 0;
			var _g12 = o2.a;
			while(_g3 < _g12.length) {
				var v1 = _g12[_g3];
				++_g3;
				a1.push(Tools.encode(v1));
			}
			var k = o2.extra.iterator();
			while(k.hasNext()) {
				var k1 = k.next();
				var v2 = Tools.encode(o2.extra.get(k1));
				m.set(k1,v2);
			}
			return (format_amf3_Value().default).AArray(a1,m);
		case (haxe_ds_IntMap().default):case (haxe_ds_ObjectMap().default):case (haxe_ds_StringMap().default):
			var o3 = o;
			var h1 = new (haxe_ds_EnumValueMap().default)();
			var f1 = o3.keys();
			while(f1.hasNext()) {
				var f2 = f1.next();
				h1.set(Tools.encode(f2),Tools.encode(o3.get(f2)));
			}
			return (format_amf3_Value().default).AMap(h1);
		case (haxe_io_Bytes().default):
			return (format_amf3_Value().default).ABytes(o);
		default:
			var h2 = new (haxe_ds_StringMap().default)();
			var i = 0;
			var _g4 = 0;
			var _g13 = (Type().default).getInstanceFields((Type().default).getClass(o));
			while(_g4 < _g13.length) {
				var f3 = _g13[_g4];
				++_g4;
				h2.set(f3,Tools.encode((Reflect().default).getProperty(o,f3)));
				++i;
			}
			return (format_amf3_Value().default).AObject(h2,i);
		}
		break;
	default:
		throw new (js__$Boot_HaxeError().default)("Can't encode " + (Std().default).string(o));
	}
}
Tools.decode = function(a) {
	switch(a._hx_index) {
	case 0:
		return Tools.undefined(a);
	case 1:
		return Tools.anull(a);
	case 2:
		var _g = a.b;
		return Tools.bool(a);
	case 3:
		var _g10 = a.i;
		return Tools.int(a);
	case 4:
		var _g7 = a.f;
		return Tools.number(a);
	case 5:
		var _g3 = a.s;
		return Tools.string(a);
	case 6:
		var _g8 = a.d;
		return Tools.date(a);
	case 7:
		var _g5 = a.size;
		var _g4 = a.fields;
		return Tools.object(a);
	case 8:
		var _g12 = a.extra;
		var _g11 = a.values;
		return Tools.array(a);
	case 9:
		var _g1 = a.values;
		return Tools.vector(a);
	case 10:
		var _g2 = a.x;
		return Tools.xml(a);
	case 11:
		var _g6 = a.b;
		return Tools.bytes(a);
	case 12:
		var _g9 = a.m;
		return Tools.map(a);
	}
}
Tools.undefined = function(a) {
	return null;
}
Tools.anull = function(a) {
	return null;
}
Tools.bool = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 2) {
		var b = a.b;
		return b;
	} else {
		return null;
	}
}
Tools.int = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 3) {
		var n = a.i;
		return n;
	} else {
		return null;
	}
}
Tools.number = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 4) {
		var n = a.f;
		return n;
	} else {
		return null;
	}
}
Tools.string = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 5) {
		var s = a.s;
		return s;
	} else {
		return null;
	}
}
Tools.date = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 6) {
		var d = a.d;
		return d;
	} else {
		return null;
	}
}
Tools.array = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 8) {
		var m = a.extra;
		var a1 = a.values;
		var b = [];
		var _g = 0;
		while(_g < a1.length) {
			var f = a1[_g];
			++_g;
			b.push(Tools.decode(f));
		}
		var c = new (haxe_ds_StringMap().default)();
		var mk = m.keys();
		while(mk.hasNext()) {
			var mk1 = mk.next();
			var v = Tools.decode(m.get(mk1));
			c.set(mk1,v);
		}
		return new (format_amf3_Amf3Array().default)(b,c);
	} else {
		return null;
	}
}
Tools.vector = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 9) {
		var a1 = a.values;
		var this1 = new Array(a1.length);
		var v = this1;
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			v[i] = Tools.decode(a1[i]);
		}
		return v;
	} else {
		return null;
	}
}
Tools.object = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 7) {
		var _g1 = a.size;
		var o = a.fields;
		var m = new (haxe_ds_StringMap().default)();
		var f = o.keys();
		while(f.hasNext()) {
			var f1 = f.next();
			m.set(f1,Tools.decode(o.get(f1)));
		}
		return m;
	} else {
		return null;
	}
}
Tools.xml = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 10) {
		var x = a.x;
		return x;
	} else {
		return null;
	}
}
Tools.bytes = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 11) {
		var b = a.b;
		return b;
	} else {
		return null;
	}
}
Tools.map = function(a) {
	if(a == null) {
		return null;
	}
	if(a._hx_index == 12) {
		var m = a.m;
		var p = new (haxe_ds_EnumValueMap().default)();
		var f = m.keys();
		while(f.hasNext()) {
			var f1 = f.next();
			p.set(Tools.decode(f1),Tools.decode(m.get(f1)));
		}
		return p;
	} else {
		return null;
	}
}


// Export

exports.default = Tools;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf3/Value.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf3/Value.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: format.amf3.Value

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var Value = $hxEnums["format.amf3.Value"] = { __ename__ : "format.amf3.Value", __constructs__ : ["AUndefined","ANull","ABool","AInt","ANumber","AString","ADate","AObject","AArray","AVector","AXml","ABytes","AMap"]
  ,AXml: ($_=function(x) { return {_hx_index:10,x:x,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["x"],$_)
  ,AVector: ($_=function(values) { return {_hx_index:9,values:values,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["values"],$_)
  ,AUndefined: {_hx_index:0,__enum__:"format.amf3.Value",toString:$estr}
  ,AString: ($_=function(s) { return {_hx_index:5,s:s,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["s"],$_)
  ,AObject: ($_=function(fields,size) { return {_hx_index:7,fields:fields,size:size,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["fields","size"],$_)
  ,ANumber: ($_=function(f) { return {_hx_index:4,f:f,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["f"],$_)
  ,ANull: {_hx_index:1,__enum__:"format.amf3.Value",toString:$estr}
  ,AMap: ($_=function(m) { return {_hx_index:12,m:m,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["m"],$_)
  ,AInt: ($_=function(i) { return {_hx_index:3,i:i,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["i"],$_)
  ,ADate: ($_=function(d) { return {_hx_index:6,d:d,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["d"],$_)
  ,ABytes: ($_=function(b) { return {_hx_index:11,b:b,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["b"],$_)
  ,ABool: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["b"],$_)
  ,AArray: ($_=function(values,extra) { return {_hx_index:8,values:values,extra:extra,__enum__:"format.amf3.Value",toString:$estr}; },$_.__params__ = ["values","extra"],$_)
};

exports.default = Value;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/format/amf3/Writer.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/format/amf3/Writer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: format.amf3.Writer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function Lambda() {return __webpack_require__(/*! ./../../Lambda */ "./node_modules/openfl/lib/_gen/Lambda.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}

// Constructor

var Writer = function(o) {
	this.o = o;
	o.set_bigEndian(true);
}

// Meta

Writer.__name__ = "format.amf3.Writer";
Writer.__isInterface__ = false;
Writer.prototype = {
	writeInt: function(i) {
		if(i > 268435455 || i < -268435456) {
			this.o.writeByte(5);
			this.o.writeDouble(i);
		} else {
			this.o.writeByte(4);
			this.writeUInt(i);
		}
	},
	writeUInt: function(u,shiftLeft) {
		if(shiftLeft == null) {
			shiftLeft = false;
		}
		if(shiftLeft) {
			u = u << 1 | 1;
		}
		if((u >>> 31 & 1) == 1) {
			u = u & 536870911;
		}
		var bits = 22;
		var started = false;
		var chunk = u >>> bits - 1;
		if((_$UInt_UInt_$Impl_$().default).gt(chunk,0)) {
			chunk = chunk >>> 1;
			this.o.writeByte(chunk | 128);
			u = u - (chunk << bits);
			++bits;
			started = true;
		}
		bits -= 8;
		chunk = u >>> bits;
		if(started || (_$UInt_UInt_$Impl_$().default).gt(chunk,0)) {
			this.o.writeByte(chunk | 128);
			u = u - (chunk << bits);
			started = true;
		}
		bits -= 7;
		chunk = u >>> bits;
		if(started || (_$UInt_UInt_$Impl_$().default).gt(chunk,0)) {
			this.o.writeByte(chunk | 128);
			u = u - (chunk << bits);
			started = true;
		}
		this.o.writeByte(u);
	},
	writeString: function(s) {
		this.writeUInt(s.length,true);
		var j = 0;
		var it = 0;
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			j = (HxOverrides().default).cca(s,i);
			if(j < 127) {
				this.o.writeByte(j);
				it = 0;
			} else if(j < 2047) {
				this.o.writeByte(j >> 6 | 192);
				j &= 63;
				it = 1;
			} else if(j < 65535) {
				this.o.writeByte(j >> 12 | 224);
				j &= 4095;
				it = 2;
			} else if(j < 1114111) {
				this.o.writeByte(j >> 18 | 240);
				j &= 196607;
				it = 3;
			}
			while(it-- > 0) this.o.writeByte(j >> 6 * it);
		}
	},
	writeObject: function(h,size) {
		if(size == null) {
			this.o.writeByte(11);
		} else {
			this.writeUInt(size << 4 | 3);
		}
		this.o.writeByte(1);
		if(size == null) {
			var f = h.keys();
			while(f.hasNext()) {
				var f1 = f.next();
				this.writeString(f1);
				this.write(h.get(f1));
			}
			this.o.writeByte(1);
		} else {
			var k = [];
			var f2 = h.keys();
			while(f2.hasNext()) {
				var f3 = f2.next();
				k.push(f3);
				this.writeString(f3);
			}
			var _g = 0;
			var _g1 = k.length;
			while(_g < _g1) {
				var i = _g++;
				this.write(h.get(k[i]));
			}
		}
	},
	write: function(v) {
		var o = this.o;
		switch(v._hx_index) {
		case 0:
			o.writeByte(0);
			break;
		case 1:
			o.writeByte(1);
			break;
		case 2:
			var b = v.b;
			o.writeByte(b ? 3 : 2);
			break;
		case 3:
			var i = v.i;
			this.writeInt(i);
			break;
		case 4:
			var n = v.f;
			o.writeByte(5);
			o.writeDouble(n);
			break;
		case 5:
			var s = v.s;
			o.writeByte(6);
			this.writeString(s);
			break;
		case 6:
			var d = v.d;
			o.writeByte(8);
			o.writeByte(1);
			o.writeDouble(d.getTime());
			break;
		case 7:
			var n1 = v.size;
			var h = v.fields;
			o.writeByte(10);
			this.writeObject(h,n1);
			break;
		case 8:
			var extra = v.extra;
			var a = v.values;
			o.writeByte(9);
			this.writeUInt(a.length,true);
			if(extra != null) {
				var mk = extra.keys();
				while(mk.hasNext()) {
					var mk1 = mk.next();
					o.writeString(mk1);
					this.write(extra.get(mk1));
				}
			}
			o.writeByte(1);
			var _g = 0;
			while(_g < a.length) {
				var f = a[_g];
				++_g;
				this.write(f);
			}
			break;
		case 10:
			var x = v.x;
			o.writeByte(11);
			this.writeString(x.toString());
			break;
		case 11:
			var b1 = v.b;
			o.writeByte(12);
			this.writeUInt(b1.get_length(),true);
			o.write(b1);
			break;
		case 12:
			var m = v.m;
			o.writeByte(17);
			this.writeUInt((Lambda().default).count(m),true);
			o.writeByte(0);
			var f1 = m.keys();
			while(f1.hasNext()) {
				var f2 = f1.next();
				this.write(f2);
				this.write(m.get(f2));
			}
			break;
		default:
			throw new (js__$Boot_HaxeError().default)("Unsupported type");
		}
	}
};
Writer.prototype.__class__ = Writer.prototype.constructor = $hxClasses["format.amf3.Writer"] = Writer;

// Init



// Statics




// Export

exports.default = Writer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/getIterator_stub.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/getIterator_stub.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });

var HxOverrides = __webpack_require__(/*! ./HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js").default;

exports.default = function $getIterator(o) {
	if (o instanceof Array) 
		return HxOverrides.iter(o);
	else
		return o.iterator();
}

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/CallStack.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/CallStack.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.CallStack

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function HxOverrides() {return __webpack_require__(/*! ./../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function haxe_StackItem() {return __webpack_require__(/*! ./../haxe/StackItem */ "./node_modules/openfl/lib/_gen/haxe/StackItem.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function StringBuf() {return __webpack_require__(/*! ./../StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}
function EReg() {return __webpack_require__(/*! ./../EReg */ "./node_modules/openfl/lib/_gen/EReg.js");}
function Std() {return __webpack_require__(/*! ./../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function StringTools() {return __webpack_require__(/*! ./../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}

// Constructor

var CallStack = function(){}

// Meta

CallStack.__name__ = "haxe.CallStack";
CallStack.__isInterface__ = false;
CallStack.prototype = {
	
};
CallStack.prototype.__class__ = CallStack.prototype.constructor = $hxClasses["haxe.CallStack"] = CallStack;

// Init



// Statics

CallStack.getStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = function(error,callsites) {
		var stack = [];
		var _g = 0;
		while(_g < callsites.length) {
			var site = callsites[_g];
			++_g;
			if(CallStack.wrapCallSite != null) {
				site = CallStack.wrapCallSite(site);
			}
			var method = null;
			var fullName = site.getFunctionName();
			if(fullName != null) {
				var idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					var className = (HxOverrides().default).substr(fullName,0,idx);
					var methodName = (HxOverrides().default).substr(fullName,idx + 1,null);
					method = (haxe_StackItem().default).Method(className,methodName);
				}
			}
			var fileName = site.getFileName();
			var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
			if(CallStack.wrapCallSite != null && fileAddr > 0) {
				fileName = (HxOverrides().default).substr(fileName,fileAddr + 6,null);
			}
			stack.push((haxe_StackItem().default).FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
		}
		return stack;
	};
	var a = CallStack.makeStack(e.stack);
	Error.prepareStackTrace = oldValue;
	return a;
}
CallStack.callStack = function() {
	try {
		throw new Error();
	} catch( e ) {
		CallStack.lastException = e;
		var e1 = ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e;
		var a = CallStack.getStack(e);
		a.shift();
		return a;
	}
}
CallStack.exceptionStack = function() {
	return CallStack.getStack(CallStack.lastException);
}
CallStack.toString = function(stack) {
	var b = new (StringBuf().default)();
	var _g = 0;
	while(_g < stack.length) {
		var s = stack[_g];
		++_g;
		b.add("\nCalled from ");
		CallStack.itemToString(b,s);
	}
	return b.toString();
}
CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.add("a C function");
		break;
	case 1:
		var m = s.m;
		b.add("module ");
		b.add(m);
		break;
	case 2:
		var col = s.column;
		var line = s.line;
		var file = s.file;
		var s1 = s.s;
		if(s1 != null) {
			CallStack.itemToString(b,s1);
			b.add(" (");
		}
		b.add(file);
		b.add(" line ");
		b.add(line);
		if(col != null) {
			b.add(" column ");
			b.add(col);
		}
		if(s1 != null) {
			b.add(")");
		}
		break;
	case 3:
		var meth = s.method;
		var cname = s.classname;
		b.add(cname == null ? "<unknown>" : cname);
		b.add(".");
		b.add(meth);
		break;
	case 4:
		var n = s.v;
		b.add("local function #");
		b.add(n);
		break;
	}
}
CallStack.makeStack = function(s) {
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var rie10 = new (EReg().default)("^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$","");
		var _g = 0;
		while(_g < stack.length) {
			var line = stack[_g];
			++_g;
			if(rie10.match(line)) {
				var path = rie10.matched(1).split(".");
				var meth = path.pop();
				var file = rie10.matched(2);
				var line1 = (Std().default).parseInt(rie10.matched(3));
				var column = (Std().default).parseInt(rie10.matched(4));
				m.push((haxe_StackItem().default).FilePos(meth == "Anonymous function" ? (haxe_StackItem().default).LocalFunction() : meth == "Global code" ? null : (haxe_StackItem().default).Method(path.join("."),meth),file,line1,column));
			} else {
				m.push((haxe_StackItem().default).Module((StringTools().default).trim(line)));
			}
		}
		return m;
	} else {
		return s;
	}
}


// Export

exports.default = CallStack;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/IMap.js":
/*!***************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/IMap.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.IMap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IMap = function() {}

// Meta

IMap.__name__ = "haxe.IMap";
IMap.__isInterface__ = true;
IMap.prototype = {
	
};
IMap.prototype.__class__ = IMap.prototype.constructor = $hxClasses["haxe.IMap"] = IMap;

// Init



// Statics




// Export

exports.default = IMap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/Log.js":
/*!**************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/Log.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.Log

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Log = function(){}

// Meta

Log.__name__ = "haxe.Log";
Log.__isInterface__ = false;
Log.prototype = {
	
};
Log.prototype.__class__ = Log.prototype.constructor = $hxClasses["haxe.Log"] = Log;

// Init



// Statics

Log.formatOutput = function(v,infos) {
	var str = (Std().default).string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v1 = _g1[_g];
			++_g;
			str += ", " + (Std().default).string(v1);
		}
	}
	return pstr + ": " + str;
}
Log.trace = function(v,infos) {
	var str = Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
}


// Export

exports.default = Log;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/Serializer.js":
/*!*********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/Serializer.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.Serializer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function StringTools() {return __webpack_require__(/*! ./../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function Reflect() {return __webpack_require__(/*! ./../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function Type() {return __webpack_require__(/*! ./../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function Std() {return __webpack_require__(/*! ./../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function haxe_ds_List() {return __webpack_require__(/*! ./../haxe/ds/List */ "./node_modules/openfl/lib/_gen/haxe/ds/List.js");}
function haxe_ds_ObjectMap() {return __webpack_require__(/*! ./../haxe/ds/ObjectMap */ "./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function HxOverrides() {return __webpack_require__(/*! ./../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function StringBuf() {return __webpack_require__(/*! ./../StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}

// Constructor

var Serializer = function() {
	this.buf = new (StringBuf().default)();
	this.cache = [];
	this.useCache = Serializer.USE_CACHE;
	this.useEnumIndex = Serializer.USE_ENUM_INDEX;
	this.shash = new (haxe_ds_StringMap().default)();
	this.scount = 0;
}

// Meta

Serializer.__name__ = "haxe.Serializer";
Serializer.__isInterface__ = false;
Serializer.prototype = {
	toString: function() {
		return this.buf.toString();
	},
	serializeString: function(s) {
		var x = this.shash.get(s);
		if(x != null) {
			this.buf.add("R");
			this.buf.add(x);
			return;
		}
		this.shash.set(s,this.scount++);
		this.buf.add("y");
		s = (StringTools().default).urlEncode(s);
		this.buf.add(s.length);
		this.buf.add(":");
		this.buf.add(s);
	},
	serializeRef: function(v) {
		var vt = typeof(v);
		var _g = 0;
		var _g1 = this.cache.length;
		while(_g < _g1) {
			var i = _g++;
			var ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.add("r");
				this.buf.add(i);
				return true;
			}
		}
		this.cache.push(v);
		return false;
	},
	serializeFields: function(v) {
		var _g = 0;
		var _g1 = (Reflect().default).fields(v);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize((Reflect().default).field(v,f));
		}
		this.buf.add("g");
	},
	serialize: function(v) {
		var _g = (Type().default).typeof(v);
		switch(_g._hx_index) {
		case 0:
			this.buf.add("n");
			break;
		case 1:
			var v1 = v;
			if(v1 == 0) {
				this.buf.add("z");
				return;
			}
			this.buf.add("i");
			this.buf.add(v1);
			break;
		case 2:
			var v2 = v;
			if(isNaN(v2)) {
				this.buf.add("k");
			} else if(!isFinite(v2)) {
				this.buf.add(v2 < 0 ? "m" : "p");
			} else {
				this.buf.add("d");
				this.buf.add(v2);
			}
			break;
		case 3:
			this.buf.add(v ? "t" : "f");
			break;
		case 4:
			if((Std().default).is(v,$hxClasses["Class"])) {
				var className = (Type().default).getClassName(v);
				this.buf.add("A");
				this.serializeString(className);
			} else if((Std().default).is(v,$hxClasses["Enum"])) {
				this.buf.add("B");
				this.serializeString((Type().default).getEnumName(v));
			} else {
				if(this.useCache && this.serializeRef(v)) {
					return;
				}
				this.buf.add("o");
				this.serializeFields(v);
			}
			break;
		case 5:
			throw new (js__$Boot_HaxeError().default)("Cannot serialize function");
		case 6:
			var c = _g.c;
			if(c == String) {
				this.serializeString(v);
				return;
			}
			if(this.useCache && this.serializeRef(v)) {
				return;
			}
			switch(c) {
			case Array:
				var ucount = 0;
				this.buf.add("a");
				var l = v["length"];
				var _g1 = 0;
				var _g11 = l;
				while(_g1 < _g11) {
					var i = _g1++;
					if(v[i] == null) {
						++ucount;
					} else {
						if(ucount > 0) {
							if(ucount == 1) {
								this.buf.add("n");
							} else {
								this.buf.add("u");
								this.buf.add(ucount);
							}
							ucount = 0;
						}
						this.serialize(v[i]);
					}
				}
				if(ucount > 0) {
					if(ucount == 1) {
						this.buf.add("n");
					} else {
						this.buf.add("u");
						this.buf.add(ucount);
					}
				}
				this.buf.add("h");
				break;
			case Date:
				var d = v;
				this.buf.add("v");
				this.buf.add(d.getTime());
				break;
			case (haxe_ds_IntMap().default):
				this.buf.add("q");
				var v3 = v;
				var k = v3.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					this.buf.add(":");
					this.buf.add(k1);
					this.serialize(v3.get(k1));
				}
				this.buf.add("h");
				break;
			case (haxe_ds_List().default):
				this.buf.add("l");
				var v4 = v;
				var i1 = v4.iterator();
				while(i1.hasNext()) {
					var i2 = i1.next();
					this.serialize(i2);
				}
				this.buf.add("h");
				break;
			case (haxe_ds_ObjectMap().default):
				this.buf.add("M");
				var v5 = v;
				var k2 = v5.keys();
				while(k2.hasNext()) {
					var k3 = k2.next();
					var id = (Reflect().default).field(k3,"__id__");
					(Reflect().default).deleteField(k3,"__id__");
					this.serialize(k3);
					(Reflect().default).setField(k3,"__id__",id);
					this.serialize(v5.get(k3));
				}
				this.buf.add("h");
				break;
			case (haxe_ds_StringMap().default):
				this.buf.add("b");
				var v6 = v;
				var k4 = v6.keys();
				while(k4.hasNext()) {
					var k5 = k4.next();
					this.serializeString(k5);
					this.serialize(v6.get(k5));
				}
				this.buf.add("h");
				break;
			case (haxe_io_Bytes().default):
				var v7 = v;
				this.buf.add("s");
				this.buf.add(Math.ceil(v7.get_length() * 8 / 6));
				this.buf.add(":");
				var i3 = 0;
				var max = v7.get_length() - 2;
				var b64 = Serializer.BASE64_CODES;
				if(b64 == null) {
					var this1 = new Array(Serializer.BASE64.length);
					b64 = this1;
					var _g2 = 0;
					var _g12 = Serializer.BASE64.length;
					while(_g2 < _g12) {
						var i4 = _g2++;
						b64[i4] = (HxOverrides().default).cca(Serializer.BASE64,i4);
					}
					Serializer.BASE64_CODES = b64;
				}
				while(i3 < max) {
					var b1 = v7.get(i3++);
					var b2 = v7.get(i3++);
					var b3 = v7.get(i3++);
					this.buf.addChar(b64[b1 >> 2]);
					this.buf.addChar(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.addChar(b64[(b2 << 2 | b3 >> 6) & 63]);
					this.buf.addChar(b64[b3 & 63]);
				}
				if(i3 == max) {
					var b11 = v7.get(i3++);
					var b21 = v7.get(i3++);
					this.buf.addChar(b64[b11 >> 2]);
					this.buf.addChar(b64[(b11 << 4 | b21 >> 4) & 63]);
					this.buf.addChar(b64[b21 << 2 & 63]);
				} else if(i3 == max + 1) {
					var b12 = v7.get(i3++);
					this.buf.addChar(b64[b12 >> 2]);
					this.buf.addChar(b64[b12 << 4 & 63]);
				}
				break;
			default:
				if(this.useCache) {
					this.cache.pop();
				}
				if(v.hxSerialize != null) {
					this.buf.add("C");
					this.serializeString((Type().default).getClassName(c));
					if(this.useCache) {
						this.cache.push(v);
					}
					v.hxSerialize(this);
					this.buf.add("g");
				} else {
					this.buf.add("c");
					this.serializeString((Type().default).getClassName(c));
					if(this.useCache) {
						this.cache.push(v);
					}
					this.serializeFields(v);
				}
			}
			break;
		case 7:
			var e = _g.e;
			if(this.useCache) {
				if(this.serializeRef(v)) {
					return;
				}
				this.cache.pop();
			}
			this.buf.add(this.useEnumIndex ? "j" : "w");
			this.serializeString((Type().default).getEnumName(e));
			if(this.useEnumIndex) {
				this.buf.add(":");
				this.buf.add(v._hx_index);
			} else {
				this.serializeString((Type().default).enumConstructor(v));
			}
			this.buf.add(":");
			var params = (Type().default).enumParameters(v);
			this.buf.add(params.length);
			var _g3 = 0;
			while(_g3 < params.length) {
				var p = params[_g3];
				++_g3;
				this.serialize(p);
			}
			if(this.useCache) {
				this.cache.push(v);
			}
			break;
		default:
			throw new (js__$Boot_HaxeError().default)("Cannot serialize " + (Std().default).string(v));
		}
	}
};
Serializer.prototype.__class__ = Serializer.prototype.constructor = $hxClasses["haxe.Serializer"] = Serializer;

// Init



// Statics

Serializer.run = function(v) {
	var s = new Serializer();
	s.serialize(v);
	return s.toString();
}
Serializer.USE_CACHE = false
Serializer.USE_ENUM_INDEX = false
Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
Serializer.BASE64_CODES = null

// Export

exports.default = Serializer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/StackItem.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/StackItem.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: haxe.StackItem

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var StackItem = $hxEnums["haxe.StackItem"] = { __ename__ : "haxe.StackItem", __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"]
  ,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["m"],$_)
  ,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["classname","method"],$_)
  ,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["v"],$_)
  ,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["s","file","line","column"],$_)
  ,CFunction: {_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
};

exports.default = StackItem;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/Timer.js":
/*!****************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/Timer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.Timer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_Log() {return __webpack_require__(/*! ./../haxe/Log */ "./node_modules/openfl/lib/_gen/haxe/Log.js");}

// Constructor

var Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
}

// Meta

Timer.__name__ = "haxe.Timer";
Timer.__isInterface__ = false;
Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	},
	run: function() {
	}
};
Timer.prototype.__class__ = Timer.prototype.constructor = $hxClasses["haxe.Timer"] = Timer;

// Init



// Statics

Timer.delay = function(f,time_ms) {
	var t = new Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
}
Timer.measure = function(f,pos) {
	var t0 = Timer.stamp();
	var r = f();
	(haxe_Log().default).trace(Timer.stamp() - t0 + "s",pos);
	return r;
}
Timer.stamp = function() {
	return new Date().getTime() / 1000;
}


// Export

exports.default = Timer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/Unserializer.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/Unserializer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.Unserializer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe__$Unserializer_NullResolver() {return __webpack_require__(/*! ./../haxe/_Unserializer/NullResolver */ "./node_modules/openfl/lib/_gen/haxe/_Unserializer/NullResolver.js");}
function StringTools() {return __webpack_require__(/*! ./../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function Std() {return __webpack_require__(/*! ./../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function HxOverrides() {return __webpack_require__(/*! ./../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function Reflect() {return __webpack_require__(/*! ./../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function Type() {return __webpack_require__(/*! ./../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function haxe_ds_ObjectMap() {return __webpack_require__(/*! ./../haxe/ds/ObjectMap */ "./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function haxe_ds_List() {return __webpack_require__(/*! ./../haxe/ds/List */ "./node_modules/openfl/lib/_gen/haxe/ds/List.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function haxe__$Unserializer_DefaultResolver() {return __webpack_require__(/*! ./../haxe/_Unserializer/DefaultResolver */ "./node_modules/openfl/lib/_gen/haxe/_Unserializer/DefaultResolver.js");}

// Constructor

var Unserializer = function(buf) {
	this.buf = buf;
	this.length = buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = new (haxe__$Unserializer_DefaultResolver().default)();
		Unserializer.DEFAULT_RESOLVER = r;
	}
	this.resolver = r;
}

// Meta

Unserializer.__name__ = "haxe.Unserializer";
Unserializer.__isInterface__ = false;
Unserializer.prototype = {
	setResolver: function(r) {
		if(r == null) {
			this.resolver = (haxe__$Unserializer_NullResolver().default).get_instance();
		} else {
			this.resolver = r;
		}
	},
	get: function(p) {
		return (StringTools().default).fastCodeAt(this.buf,p);
	},
	readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.get(this.pos);
			if((StringTools().default).isEof(c)) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	},
	readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.get(this.pos);
			if((StringTools().default).isEof(c)) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return (Std().default).parseFloat((HxOverrides().default).substr(this.buf,p1,this.pos - p1));
	},
	unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw new (js__$Boot_HaxeError().default)("Invalid object");
			}
			if(this.get(this.pos) == 103) {
				break;
			}
			var k = this.unserialize();
			if(typeof(k) != "string") {
				throw new (js__$Boot_HaxeError().default)("Invalid object key");
			}
			var v = this.unserialize();
			(Reflect().default).setField(o,k,v);
		}
		this.pos++;
	},
	unserializeEnum: function(edecl,tag) {
		if(this.get(this.pos++) != 58) {
			throw new (js__$Boot_HaxeError().default)("Invalid enum format");
		}
		var nargs = this.readDigits();
		if(nargs == 0) {
			return (Type().default).createEnum(edecl,tag);
		}
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return (Type().default).createEnum(edecl,tag,args);
	},
	unserialize: function() {
		switch(this.get(this.pos++)) {
		case 65:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw new (js__$Boot_HaxeError().default)("Class not found " + name);
			}
			return cl;
		case 66:
			var name1 = this.unserialize();
			var e = this.resolver.resolveEnum(name1);
			if(e == null) {
				throw new (js__$Boot_HaxeError().default)("Enum not found " + name1);
			}
			return e;
		case 67:
			var name2 = this.unserialize();
			var cl1 = this.resolver.resolveClass(name2);
			if(cl1 == null) {
				throw new (js__$Boot_HaxeError().default)("Class not found " + name2);
			}
			var o = (Type().default).createEmptyInstance(cl1);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.get(this.pos++) != 103) {
				throw new (js__$Boot_HaxeError().default)("Invalid custom data");
			}
			return o;
		case 77:
			var h = new (haxe_ds_ObjectMap().default)();
			this.cache.push(h);
			var buf = this.buf;
			while(this.get(this.pos) != 104) {
				var s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			var n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw new (js__$Boot_HaxeError().default)("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			var buf1 = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.get(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n1 = this.readDigits();
					a[a.length + n1 - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			var h1 = new (haxe_ds_StringMap().default)();
			this.cache.push(h1);
			var buf2 = this.buf;
			while(this.get(this.pos) != 104) {
				var s1 = this.unserialize();
				h1.set(s1,this.unserialize());
			}
			this.pos++;
			return h1;
		case 99:
			var name3 = this.unserialize();
			var cl2 = this.resolver.resolveClass(name3);
			if(cl2 == null) {
				throw new (js__$Boot_HaxeError().default)("Class not found " + name3);
			}
			var o1 = (Type().default).createEmptyInstance(cl2);
			this.cache.push(o1);
			this.unserializeObject(o1);
			return o1;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			var name4 = this.unserialize();
			var edecl = this.resolver.resolveEnum(name4);
			if(edecl == null) {
				throw new (js__$Boot_HaxeError().default)("Enum not found " + name4);
			}
			this.pos++;
			var index = this.readDigits();
			var tag = (Type().default).getEnumConstructs(edecl)[index];
			if(tag == null) {
				throw new (js__$Boot_HaxeError().default)("Unknown enum index " + name4 + "@" + index);
			}
			var e1 = this.unserializeEnum(edecl,tag);
			this.cache.push(e1);
			return e1;
		case 107:
			return NaN;
		case 108:
			var l = new (haxe_ds_List().default)();
			this.cache.push(l);
			var buf3 = this.buf;
			while(this.get(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			var o2 = { };
			this.cache.push(o2);
			this.unserializeObject(o2);
			return o2;
		case 112:
			return Infinity;
		case 113:
			var h2 = new (haxe_ds_IntMap().default)();
			this.cache.push(h2);
			var buf4 = this.buf;
			var c1 = this.get(this.pos++);
			while(c1 == 58) {
				var i = this.readDigits();
				h2.set(i,this.unserialize());
				c1 = this.get(this.pos++);
			}
			if(c1 != 104) {
				throw new (js__$Boot_HaxeError().default)("Invalid IntMap format");
			}
			return h2;
		case 114:
			var n2 = this.readDigits();
			if(n2 < 0 || n2 >= this.cache.length) {
				throw new (js__$Boot_HaxeError().default)("Invalid reference");
			}
			return this.cache[n2];
		case 115:
			var len = this.readDigits();
			var buf5 = this.buf;
			if(this.get(this.pos++) != 58 || this.length - this.pos < len) {
				throw new (js__$Boot_HaxeError().default)("Invalid bytes length");
			}
			var codes = Unserializer.CODES;
			if(codes == null) {
				codes = Unserializer.initCodes();
				Unserializer.CODES = codes;
			}
			var i1 = this.pos;
			var rest = len & 3;
			var size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			var max = i1 + (len - rest);
			var bytes = (haxe_io_Bytes().default).alloc(size);
			var bpos = 0;
			while(i1 < max) {
				var c11 = codes[(StringTools().default).fastCodeAt(buf5,i1++)];
				var c2 = codes[(StringTools().default).fastCodeAt(buf5,i1++)];
				bytes.set(bpos++,c11 << 2 | c2 >> 4);
				var c3 = codes[(StringTools().default).fastCodeAt(buf5,i1++)];
				bytes.set(bpos++,c2 << 4 | c3 >> 2);
				var c4 = codes[(StringTools().default).fastCodeAt(buf5,i1++)];
				bytes.set(bpos++,c3 << 6 | c4);
			}
			if(rest >= 2) {
				var c12 = codes[(StringTools().default).fastCodeAt(buf5,i1++)];
				var c21 = codes[(StringTools().default).fastCodeAt(buf5,i1++)];
				bytes.set(bpos++,c12 << 2 | c21 >> 4);
				if(rest == 3) {
					var c31 = codes[(StringTools().default).fastCodeAt(buf5,i1++)];
					bytes.set(bpos++,c21 << 4 | c31 >> 2);
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			var d;
			if(this.get(this.pos) >= 48 && this.get(this.pos) <= 57 && this.get(this.pos + 1) >= 48 && this.get(this.pos + 1) <= 57 && this.get(this.pos + 2) >= 48 && this.get(this.pos + 2) <= 57 && this.get(this.pos + 3) >= 48 && this.get(this.pos + 3) <= 57 && this.get(this.pos + 4) == 45) {
				d = (HxOverrides().default).strDate((HxOverrides().default).substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				d = new Date(this.readFloat());
			}
			this.cache.push(d);
			return d;
		case 119:
			var name5 = this.unserialize();
			var edecl1 = this.resolver.resolveEnum(name5);
			if(edecl1 == null) {
				throw new (js__$Boot_HaxeError().default)("Enum not found " + name5);
			}
			var e2 = this.unserializeEnum(edecl1,this.unserialize());
			this.cache.push(e2);
			return e2;
		case 120:
			throw (js__$Boot_HaxeError().default).wrap(this.unserialize());
		case 121:
			var len1 = this.readDigits();
			if(this.get(this.pos++) != 58 || this.length - this.pos < len1) {
				throw new (js__$Boot_HaxeError().default)("Invalid string length");
			}
			var s2 = (HxOverrides().default).substr(this.buf,this.pos,len1);
			this.pos += len1;
			s2 = (StringTools().default).urlDecode(s2);
			this.scache.push(s2);
			return s2;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw new (js__$Boot_HaxeError().default)("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
};
Unserializer.prototype.__class__ = Unserializer.prototype.constructor = $hxClasses["haxe.Unserializer"] = Unserializer;

// Init



// Statics

Unserializer.initCodes = function() {
	var codes = [];
	var _g = 0;
	var _g1 = Unserializer.BASE64.length;
	while(_g < _g1) {
		var i = _g++;
		codes[(StringTools().default).fastCodeAt(Unserializer.BASE64,i)] = i;
	}
	return codes;
}
Unserializer.run = function(v) {
	return new Unserializer(v).unserialize();
}
Unserializer.DEFAULT_RESOLVER = new (haxe__$Unserializer_DefaultResolver().default)()
Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
Unserializer.CODES = null

// Export

exports.default = Unserializer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/_Int64/___Int64.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/_Int64/___Int64.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe._Int64.___Int64

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var ___Int64 = function(high,low) {
	this.high = high;
	this.low = low;
}

// Meta

___Int64.__name__ = "haxe._Int64.___Int64";
___Int64.__isInterface__ = false;
___Int64.prototype = {
	
};
___Int64.prototype.__class__ = ___Int64.prototype.constructor = $hxClasses["haxe._Int64.___Int64"] = ___Int64;

// Init



// Statics




// Export

exports.default = ___Int64;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/_Unserializer/DefaultResolver.js":
/*!****************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/_Unserializer/DefaultResolver.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe._Unserializer.DefaultResolver

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}

// Constructor

var DefaultResolver = function() {
}

// Meta

DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver";
DefaultResolver.__isInterface__ = false;
DefaultResolver.prototype = {
	resolveClass: function(name) {
		return (Type().default).resolveClass(name);
	},
	resolveEnum: function(name) {
		return (Type().default).resolveEnum(name);
	}
};
DefaultResolver.prototype.__class__ = DefaultResolver.prototype.constructor = $hxClasses["haxe._Unserializer.DefaultResolver"] = DefaultResolver;

// Init



// Statics




// Export

exports.default = DefaultResolver;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/_Unserializer/NullResolver.js":
/*!*************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/_Unserializer/NullResolver.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe._Unserializer.NullResolver

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var NullResolver = function() {
}

// Meta

NullResolver.__name__ = "haxe._Unserializer.NullResolver";
NullResolver.__isInterface__ = false;
NullResolver.prototype = {
	resolveClass: function(name) {
		return null;
	},
	resolveEnum: function(name) {
		return null;
	}
};
NullResolver.prototype.__class__ = NullResolver.prototype.constructor = $hxClasses["haxe._Unserializer.NullResolver"] = NullResolver;

// Init



// Statics

NullResolver.get_instance = function() {
	if(NullResolver.instance == null) {
		NullResolver.instance = new NullResolver();
	}
	return NullResolver.instance;
}


// Export

exports.default = NullResolver;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/crypto/Adler32.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/crypto/Adler32.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.crypto.Adler32

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var Adler32 = function() {
	this.a1 = 1;
	this.a2 = 0;
}

// Meta

Adler32.__name__ = "haxe.crypto.Adler32";
Adler32.__isInterface__ = false;
Adler32.prototype = {
	update: function(b,pos,len) {
		var a1 = this.a1;
		var a2 = this.a2;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var p = _g++;
			var c = b.get(p);
			a1 = (a1 + c) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	},
	equals: function(a) {
		if(a.a1 == this.a1) {
			return a.a2 == this.a2;
		} else {
			return false;
		}
	}
};
Adler32.prototype.__class__ = Adler32.prototype.constructor = $hxClasses["haxe.crypto.Adler32"] = Adler32;

// Init



// Statics

Adler32.read = function(i) {
	var a = new Adler32();
	var a2a = i.readByte();
	var a2b = i.readByte();
	var a1a = i.readByte();
	var a1b = i.readByte();
	a.a1 = a1a << 8 | a1b;
	a.a2 = a2a << 8 | a2b;
	return a;
}


// Export

exports.default = Adler32;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/crypto/Base64.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/crypto/Base64.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.crypto.Base64

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function haxe_crypto_BaseCode() {return __webpack_require__(/*! ./../../haxe/crypto/BaseCode */ "./node_modules/openfl/lib/_gen/haxe/crypto/BaseCode.js");}

// Constructor

var Base64 = function(){}

// Meta

Base64.__name__ = "haxe.crypto.Base64";
Base64.__isInterface__ = false;
Base64.prototype = {
	
};
Base64.prototype.__class__ = Base64.prototype.constructor = $hxClasses["haxe.crypto.Base64"] = Base64;

// Init



// Statics

Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while((HxOverrides().default).cca(str,str.length - 1) == 61) str = (HxOverrides().default).substr(str,0,-1);
	}
	return new (haxe_crypto_BaseCode().default)(Base64.BYTES).decodeBytes((haxe_io_Bytes().default).ofString(str));
}
Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
Base64.BYTES = (haxe_io_Bytes().default).ofString(Base64.CHARS)

// Export

exports.default = Base64;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/crypto/BaseCode.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/crypto/BaseCode.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.crypto.BaseCode

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}

// Constructor

var BaseCode = function(base) {
	var len = base.get_length();
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw new (js__$Boot_HaxeError().default)("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
}

// Meta

BaseCode.__name__ = "haxe.crypto.BaseCode";
BaseCode.__isInterface__ = false;
BaseCode.prototype = {
	initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g1 = 0;
		var _g2 = this.base.get_length();
		while(_g1 < _g2) {
			var i1 = _g1++;
			tbl[this.base.get(i1)] = i1;
		}
		this.tbl = tbl;
	},
	decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.get_length() * nbits >> 3;
		var out = (haxe_io_Bytes().default).alloc(size);
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.get(pin++)];
				if(i == -1) {
					throw new (js__$Boot_HaxeError().default)("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.set(pout++,buf >> curbits & 255);
		}
		return out;
	}
};
BaseCode.prototype.__class__ = BaseCode.prototype.constructor = $hxClasses["haxe.crypto.BaseCode"] = BaseCode;

// Init



// Statics




// Export

exports.default = BaseCode;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/ArraySort.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/ArraySort.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds.ArraySort

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var ArraySort = function(){}

// Meta

ArraySort.__name__ = "haxe.ds.ArraySort";
ArraySort.__isInterface__ = false;
ArraySort.prototype = {
	
};
ArraySort.prototype.__class__ = ArraySort.prototype.constructor = $hxClasses["haxe.ds.ArraySort"] = ArraySort;

// Init



// Statics

ArraySort.sort = function(a,cmp) {
	ArraySort.rec(a,cmp,0,a.length);
}
ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(ArraySort.compare(a,cmp,j,j - 1) < 0) {
					ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	ArraySort.rec(a,cmp,from,middle);
	ArraySort.rec(a,cmp,middle,to);
	ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
}
ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(ArraySort.compare(a,cmp,pivot,from) < 0) {
			ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
}
ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
}
ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
}
ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(ArraySort.compare(a,cmp,val,mid) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
}
ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(ArraySort.compare(a,cmp,mid,val) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
}
ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
}
ArraySort.compare = function(a,cmp,i,j) {
	return cmp(a[i],a[j]);
}


// Export

exports.default = ArraySort;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/BalancedTree.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/BalancedTree.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds.BalancedTree

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_IMap() {return __webpack_require__(/*! ./../../haxe/IMap */ "./node_modules/openfl/lib/_gen/haxe/IMap.js");}
function haxe_CallStack() {return __webpack_require__(/*! ./../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function haxe_ds_TreeNode() {return __webpack_require__(/*! ./../../haxe/ds/TreeNode */ "./node_modules/openfl/lib/_gen/haxe/ds/TreeNode.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var BalancedTree = function() {
}

// Meta

BalancedTree.__name__ = "haxe.ds.BalancedTree";
BalancedTree.__isInterface__ = false;
BalancedTree.__interfaces__ = [(haxe_IMap().default)];
BalancedTree.prototype = {
	set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	},
	get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	},
	remove: function(key) {
		try {
			this.root = this.removeLoop(key,this.root);
			return true;
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			var e1 = ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e;
			if(typeof(e1) == "string") {
				var e2 = e1;
				return false;
			} else {
				throw e;
			}
		}
	},
	exists: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return true;
			} else if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return false;
	},
	iterator: function() {
		var ret = [];
		this.iteratorLoop(this.root,ret);
		return (HxOverrides().default).iter(ret);
	},
	keys: function() {
		var ret = [];
		this.keysLoop(this.root,ret);
		return (HxOverrides().default).iter(ret);
	},
	setLoop: function(k,v,node) {
		if(node == null) {
			return new (haxe_ds_TreeNode().default)(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new (haxe_ds_TreeNode().default)(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	},
	removeLoop: function(k,node) {
		if(node == null) {
			throw new (js__$Boot_HaxeError().default)("Not_found");
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return this.merge(node.left,node.right);
		} else if(c < 0) {
			return this.balance(this.removeLoop(k,node.left),node.key,node.value,node.right);
		} else {
			return this.balance(node.left,node.key,node.value,this.removeLoop(k,node.right));
		}
	},
	iteratorLoop: function(node,acc) {
		if(node != null) {
			this.iteratorLoop(node.left,acc);
			acc.push(node.value);
			this.iteratorLoop(node.right,acc);
		}
	},
	keysLoop: function(node,acc) {
		if(node != null) {
			this.keysLoop(node.left,acc);
			acc.push(node.key);
			this.keysLoop(node.right,acc);
		}
	},
	merge: function(t1,t2) {
		if(t1 == null) {
			return t2;
		}
		if(t2 == null) {
			return t1;
		}
		var t = this.minBinding(t2);
		return this.balance(t1,t.key,t.value,this.removeMinBinding(t2));
	},
	minBinding: function(t) {
		if(t == null) {
			throw new (js__$Boot_HaxeError().default)("Not_found");
		} else if(t.left == null) {
			return t;
		} else {
			return this.minBinding(t.left);
		}
	},
	removeMinBinding: function(t) {
		if(t.left == null) {
			return t.right;
		} else {
			return this.balance(this.removeMinBinding(t.left),t.key,t.value,t.right);
		}
	},
	balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new (haxe_ds_TreeNode().default)(l.left,l.key,l.value,new (haxe_ds_TreeNode().default)(l.right,k,v,r));
			} else {
				return new (haxe_ds_TreeNode().default)(new (haxe_ds_TreeNode().default)(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new (haxe_ds_TreeNode().default)(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this2 = r.right;
			var _this3 = r.left;
			if((_this2 == null ? 0 : _this2._height) > (_this3 == null ? 0 : _this3._height)) {
				return new (haxe_ds_TreeNode().default)(new (haxe_ds_TreeNode().default)(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new (haxe_ds_TreeNode().default)(new (haxe_ds_TreeNode().default)(l,k,v,r.left.left),r.left.key,r.left.value,new (haxe_ds_TreeNode().default)(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new (haxe_ds_TreeNode().default)(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	},
	compare: function(k1,k2) {
		return (Reflect().default).compare(k1,k2);
	}
};
BalancedTree.prototype.__class__ = BalancedTree.prototype.constructor = $hxClasses["haxe.ds.BalancedTree"] = BalancedTree;

// Init



// Statics




// Export

exports.default = BalancedTree;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/EnumValueMap.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/EnumValueMap.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds.EnumValueMap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function haxe_IMap() {return __webpack_require__(/*! ./../../haxe/IMap */ "./node_modules/openfl/lib/_gen/haxe/IMap.js");}
function haxe_ds_BalancedTree() {return __webpack_require__(/*! ./../../haxe/ds/BalancedTree */ "./node_modules/openfl/lib/_gen/haxe/ds/BalancedTree.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var EnumValueMap = function() {
	(haxe_ds_BalancedTree().default).call(this);
}

// Meta

EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
EnumValueMap.__isInterface__ = false;
EnumValueMap.__interfaces__ = [(haxe_IMap().default)];
EnumValueMap.__super__ = (haxe_ds_BalancedTree().default);
EnumValueMap.prototype = $extend((haxe_ds_BalancedTree().default).prototype, {
	compare: function(k1,k2) {
		var d = (Type().default).enumIndex(k1) - (Type().default).enumIndex(k2);
		if(d != 0) {
			return d;
		}
		var p1 = (Type().default).enumParameters(k1);
		var p2 = (Type().default).enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	},
	compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	},
	compareArg: function(v1,v2) {
		if((Reflect().default).isEnumValue(v1) && (Reflect().default).isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return (Reflect().default).compare(v1,v2);
		}
	}
});
EnumValueMap.prototype.__class__ = EnumValueMap.prototype.constructor = $hxClasses["haxe.ds.EnumValueMap"] = EnumValueMap;

// Init



// Statics




// Export

exports.default = EnumValueMap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds.IntMap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_IMap() {return __webpack_require__(/*! ./../../haxe/IMap */ "./node_modules/openfl/lib/_gen/haxe/IMap.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var IntMap = function() {
	this.h = { };
}

// Meta

IntMap.__name__ = "haxe.ds.IntMap";
IntMap.__isInterface__ = false;
IntMap.__interfaces__ = [(haxe_IMap().default)];
IntMap.prototype = {
	set: function(key,value) {
		this.h[key] = value;
	},
	get: function(key) {
		return this.h[key];
	},
	exists: function(key) {
		return this.h.hasOwnProperty(key);
	},
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	},
	keys: function() {
		var a = [];
		for( var key in this.h ) (this.h.hasOwnProperty(key) ? a.push(key | 0) : null);
		return (HxOverrides().default).iter(a);
	},
	iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
};
IntMap.prototype.__class__ = IntMap.prototype.constructor = $hxClasses["haxe.ds.IntMap"] = IntMap;

// Init



// Statics




// Export

exports.default = IntMap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/List.js":
/*!******************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/List.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds.List

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds__$List_ListNode() {return __webpack_require__(/*! ./../../haxe/ds/_List/ListNode */ "./node_modules/openfl/lib/_gen/haxe/ds/_List/ListNode.js");}
function haxe_ds__$List_ListIterator() {return __webpack_require__(/*! ./../../haxe/ds/_List/ListIterator */ "./node_modules/openfl/lib/_gen/haxe/ds/_List/ListIterator.js");}

// Constructor

var List = function() {
	this.length = 0;
}

// Meta

List.__name__ = "haxe.ds.List";
List.__isInterface__ = false;
List.prototype = {
	add: function(item) {
		var x = new (haxe_ds__$List_ListNode().default)(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	},
	push: function(item) {
		var x = new (haxe_ds__$List_ListNode().default)(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	},
	pop: function() {
		if(this.h == null) {
			return null;
		}
		var x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	},
	clear: function() {
		this.h = null;
		this.q = null;
		this.length = 0;
	},
	remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	},
	iterator: function() {
		return new (haxe_ds__$List_ListIterator().default)(this.h);
	}
};
List.prototype.__class__ = List.prototype.constructor = $hxClasses["haxe.ds.List"] = List;

// Init



// Statics




// Export

exports.default = List;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds.ObjectMap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_IMap() {return __webpack_require__(/*! ./../../haxe/IMap */ "./node_modules/openfl/lib/_gen/haxe/IMap.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function js_Lib() {return __webpack_require__(/*! ./../../js/Lib */ "./node_modules/openfl/lib/_gen/js/Lib.js");}

// Constructor

var ObjectMap = function() {
	this.h = { __keys__ : { }};
}

// Meta

ObjectMap.__name__ = "haxe.ds.ObjectMap";
ObjectMap.__isInterface__ = false;
ObjectMap.__interfaces__ = [(haxe_IMap().default)];
ObjectMap.prototype = {
	set: function(key,value) {
		var id = ObjectMap.getId(key);
		if(id == null) {
			id = ObjectMap.assignId(key);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	},
	get: function(key) {
		return this.h[ObjectMap.getId(key)];
	},
	exists: function(key) {
		return this.h.__keys__[ObjectMap.getId(key)] != null;
	},
	remove: function(key) {
		var id = ObjectMap.getId(key);
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	},
	keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return (HxOverrides().default).iter(a);
	}
};
ObjectMap.prototype.__class__ = ObjectMap.prototype.constructor = $hxClasses["haxe.ds.ObjectMap"] = ObjectMap;

// Init

ObjectMap.count = 0;

// Statics

ObjectMap.assignId = function(obj) {
	return (obj.__id__ = (js_Lib().default).getNextHaxeUID());
}
ObjectMap.getId = function(obj) {
	return obj.__id__;
}


// Export

exports.default = ObjectMap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds.StringMap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_IMap() {return __webpack_require__(/*! ./../../haxe/IMap */ "./node_modules/openfl/lib/_gen/haxe/IMap.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function haxe_ds__$StringMap_StringMapIterator() {return __webpack_require__(/*! ./../../haxe/ds/_StringMap/StringMapIterator */ "./node_modules/openfl/lib/_gen/haxe/ds/_StringMap/StringMapIterator.js");}

// Constructor

var StringMap = function() {
	this.h = { };
}

// Meta

StringMap.__name__ = "haxe.ds.StringMap";
StringMap.__isInterface__ = false;
StringMap.__interfaces__ = [(haxe_IMap().default)];
StringMap.prototype = {
	isReserved: function(key) {
		return __map_reserved[key] != null;
	},
	set: function(key,value) {
		if(this.isReserved(key)) {
			this.setReserved(key,value);
		} else {
			this.h[key] = value;
		}
	},
	get: function(key) {
		if(this.isReserved(key)) {
			return this.getReserved(key);
		}
		return this.h[key];
	},
	exists: function(key) {
		if(this.isReserved(key)) {
			return this.existsReserved(key);
		}
		return this.h.hasOwnProperty(key);
	},
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	},
	getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	},
	existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	},
	remove: function(key) {
		if(this.isReserved(key)) {
			key = "$" + key;
			if(this.rh == null || !this.rh.hasOwnProperty(key)) {
				return false;
			}
			delete(this.rh[key]);
			return true;
		} else {
			if(!this.h.hasOwnProperty(key)) {
				return false;
			}
			delete(this.h[key]);
			return true;
		}
	},
	keys: function() {
		return (HxOverrides().default).iter(this.arrayKeys());
	},
	arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	},
	iterator: function() {
		return new (haxe_ds__$StringMap_StringMapIterator().default)(this,this.arrayKeys());
	}
};
StringMap.prototype.__class__ = StringMap.prototype.constructor = $hxClasses["haxe.ds.StringMap"] = StringMap;

// Init

var __map_reserved = {};;

// Statics




// Export

exports.default = StringMap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/TreeNode.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/TreeNode.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds.TreeNode

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this2 = this.left;
			tmp = _this2 == null ? 0 : _this2._height;
		} else {
			var _this3 = this.right;
			tmp = _this3 == null ? 0 : _this3._height;
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
}

// Meta

TreeNode.__name__ = "haxe.ds.TreeNode";
TreeNode.__isInterface__ = false;
TreeNode.prototype = {
	
};
TreeNode.prototype.__class__ = TreeNode.prototype.constructor = $hxClasses["haxe.ds.TreeNode"] = TreeNode;

// Init



// Statics




// Export

exports.default = TreeNode;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/_List/ListIterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/_List/ListIterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds._List.ListIterator

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var ListIterator = function(head) {
	this.head = head;
}

// Meta

ListIterator.__name__ = "haxe.ds._List.ListIterator";
ListIterator.__isInterface__ = false;
ListIterator.prototype = {
	hasNext: function() {
		return this.head != null;
	},
	next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
};
ListIterator.prototype.__class__ = ListIterator.prototype.constructor = $hxClasses["haxe.ds._List.ListIterator"] = ListIterator;

// Init



// Statics




// Export

exports.default = ListIterator;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/_List/ListNode.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/_List/ListNode.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds._List.ListNode

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var ListNode = function(item,next) {
	this.item = item;
	this.next = next;
}

// Meta

ListNode.__name__ = "haxe.ds._List.ListNode";
ListNode.__isInterface__ = false;
ListNode.prototype = {
	
};
ListNode.prototype.__class__ = ListNode.prototype.constructor = $hxClasses["haxe.ds._List.ListNode"] = ListNode;

// Init



// Statics




// Export

exports.default = ListNode;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/ds/_StringMap/StringMapIterator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/ds/_StringMap/StringMapIterator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.ds._StringMap.StringMapIterator

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var StringMapIterator = function(map,keys) {
	this.map = map;
	this.keys = keys;
	this.index = 0;
	this.count = keys.length;
}

// Meta

StringMapIterator.__name__ = "haxe.ds._StringMap.StringMapIterator";
StringMapIterator.__isInterface__ = false;
StringMapIterator.prototype = {
	hasNext: function() {
		return this.index < this.count;
	},
	next: function() {
		return this.map.get(this.keys[this.index++]);
	}
};
StringMapIterator.prototype.__class__ = StringMapIterator.prototype.constructor = $hxClasses["haxe.ds._StringMap.StringMapIterator"] = StringMapIterator;

// Init



// Statics




// Export

exports.default = StringMapIterator;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js":
/*!*******************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/Bytes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.Bytes

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_io_Error() {return __webpack_require__(/*! ./../../haxe/io/Error */ "./node_modules/openfl/lib/_gen/haxe/io/Error.js");}
function haxe__$Int64__$_$_$Int64() {return __webpack_require__(/*! ./../../haxe/_Int64/___Int64 */ "./node_modules/openfl/lib/_gen/haxe/_Int64/___Int64.js");}
function _$String_String_$Impl_$() {return __webpack_require__(/*! ./../../_String/String_Impl_ */ "./node_modules/openfl/lib/_gen/_String/String_Impl_.js");}
function StringBuf() {return __webpack_require__(/*! ./../../StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}

// Constructor

var Bytes = function(data) {
	this.set_length(data.byteLength);
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
}

// Meta

Bytes.__name__ = "haxe.io.Bytes";
Bytes.__isInterface__ = false;
Bytes.prototype = {
	get: function(pos) {
		return this.b[pos];
	},
	set: function(pos,v) {
		this.b[pos] = v & 255;
	},
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.get_length() || srcpos + len > src.get_length()) {
			throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	},
	fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.set(pos++,value);
		}
	},
	sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.get_length()) {
			throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).OutsideBounds);
		}
		return new Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	},
	compare: function(other) {
		var b1 = this.b;
		var b2 = other.b;
		var len = this.get_length() < other.get_length() ? this.get_length() : other.get_length();
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			if(b1[i] != b2[i]) {
				return b1[i] - b2[i];
			}
		}
		return this.get_length() - other.get_length();
	},
	initData: function() {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
	},
	getDouble: function(pos) {
		this.initData();
		return this.data.getFloat64(pos,true);
	},
	getFloat: function(pos) {
		this.initData();
		return this.data.getFloat32(pos,true);
	},
	setDouble: function(pos,v) {
		this.initData();
		this.data.setFloat64(pos,v,true);
	},
	setFloat: function(pos,v) {
		this.initData();
		this.data.setFloat32(pos,v,true);
	},
	getUInt16: function(pos) {
		this.initData();
		return this.data.getUint16(pos,true);
	},
	setUInt16: function(pos,v) {
		this.initData();
		this.data.setUint16(pos,v,true);
	},
	getInt32: function(pos) {
		this.initData();
		return this.data.getInt32(pos,true);
	},
	setInt32: function(pos,v) {
		this.initData();
		this.data.setInt32(pos,v,true);
	},
	getInt64: function(pos) {
		var this1 = new (haxe__$Int64__$_$_$Int64().default)(this.getInt32(pos + 4),this.getInt32(pos));
		return this1;
	},
	setInt64: function(pos,v) {
		this.setInt32(pos,v.low);
		this.setInt32(pos + 4,v.high);
	},
	getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.get_length()) {
			throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).OutsideBounds);
		}
		var s = "";
		var b = this.b;
		var fcc = (_$String_String_$Impl_$().default).fromCharCode;
		var i = pos;
		var max = pos + len;
		while(i < max) {
			var c = b[i++];
			if(c < 128) {
				if(c == 0) {
					break;
				}
				s += fcc(c);
			} else if(c < 224) {
				s += fcc((c & 63) << 6 | b[i++] & 127);
			} else if(c < 240) {
				var c2 = b[i++];
				s += fcc((c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127);
			} else {
				var c21 = b[i++];
				var c3 = b[i++];
				var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
				s += fcc((u >> 10) + 55232);
				s += fcc(u & 1023 | 56320);
			}
		}
		return s;
	},
	readString: function(pos,len) {
		return this.getString(pos,len);
	},
	toString: function() {
		return this.getString(0,this.get_length());
	},
	toHex: function() {
		var s = new (StringBuf().default)();
		var chars = [];
		var str = "0123456789abcdef";
		var _g = 0;
		var _g1 = str.length;
		while(_g < _g1) {
			var i = _g++;
			chars.push((HxOverrides().default).cca(str,i));
		}
		var _g2 = 0;
		var _g3 = this.get_length();
		while(_g2 < _g3) {
			var i1 = _g2++;
			var c = this.get(i1);
			s.addChar(chars[c >> 4]);
			s.addChar(chars[c & 15]);
		}
		return s.toString();
	},
	getData: function() {
		return this.b.bufferValue;
	},
	get_length: function() {
		return this.l;
	},
	set_length: function(v) {
		return this.l = v;
	}
};
Bytes.prototype.__class__ = Bytes.prototype.constructor = $hxClasses["haxe.io.Bytes"] = Bytes;

// Init



// Statics

Bytes.alloc = function(length) {
	return new Bytes(new ArrayBuffer(length));
}
Bytes.ofString = function(s,encoding) {
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = (StringTools().default).fastCodeAt(s,i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | (StringTools().default).fastCodeAt(s,i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new Bytes(new Uint8Array(a).buffer);
}
Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new Bytes(b);
}
Bytes.ofHex = function(s) {
	if((s.length & 1) != 0) {
		throw new (js__$Boot_HaxeError().default)("Not a hex string (odd number of digits)");
	}
	var a = [];
	var i = 0;
	var len = s.length >> 1;
	while(i < len) {
		var high = (StringTools().default).fastCodeAt(s,i * 2);
		var low = (StringTools().default).fastCodeAt(s,i * 2 + 1);
		high = (high & 15) + ((high & 64) >> 6) * 9;
		low = (low & 15) + ((low & 64) >> 6) * 9;
		a.push((high << 4 | low) & 255);
		++i;
	}
	return new Bytes(new Uint8Array(a).buffer);
}
Bytes.fastGet = function(b,pos) {
	return b.bytes[pos];
}


// Export

exports.default = Bytes;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/BytesBuffer.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/BytesBuffer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.BytesBuffer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_io_Error() {return __webpack_require__(/*! ./../../haxe/io/Error */ "./node_modules/openfl/lib/_gen/haxe/io/Error.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}

// Constructor

var BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
}

// Meta

BytesBuffer.__name__ = "haxe.io.BytesBuffer";
BytesBuffer.__isInterface__ = false;
BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	},
	add: function(src) {
		if(this.pos + src.get_length() > this.size) {
			this.grow(src.get_length());
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset,src.get_length());
		this.u8.set(sub,this.pos);
		this.pos += src.get_length();
	},
	addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.get_length()) {
			throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	},
	grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	},
	getBytes: function() {
		if(this.size == 0) {
			return (haxe_io_Bytes().default).alloc(0);
		}
		var b = new (haxe_io_Bytes().default)(this.buffer);
		b.set_length(this.pos);
		return b;
	}
};
BytesBuffer.prototype.__class__ = BytesBuffer.prototype.constructor = $hxClasses["haxe.io.BytesBuffer"] = BytesBuffer;

// Init



// Statics




// Export

exports.default = BytesBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/BytesInput.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/BytesInput.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.BytesInput

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function haxe_io_Input() {return __webpack_require__(/*! ./../../haxe/io/Input */ "./node_modules/openfl/lib/_gen/haxe/io/Input.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_io_Eof() {return __webpack_require__(/*! ./../../haxe/io/Eof */ "./node_modules/openfl/lib/_gen/haxe/io/Eof.js");}
function haxe_io_Error() {return __webpack_require__(/*! ./../../haxe/io/Error */ "./node_modules/openfl/lib/_gen/haxe/io/Error.js");}

// Constructor

var BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.get_length() - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.get_length()) {
		throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
}

// Meta

BytesInput.__name__ = "haxe.io.BytesInput";
BytesInput.__isInterface__ = false;
BytesInput.__super__ = (haxe_io_Input().default);
BytesInput.prototype = $extend((haxe_io_Input().default).prototype, {
	get_position: function() {
		return this.pos;
	},
	readByte: function() {
		if(this.len == 0) {
			throw new (js__$Boot_HaxeError().default)(new (haxe_io_Eof().default)());
		}
		this.len--;
		return this.b[this.pos++];
	},
	readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.get_length()) {
			throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw new (js__$Boot_HaxeError().default)(new (haxe_io_Eof().default)());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
});
BytesInput.prototype.__class__ = BytesInput.prototype.constructor = $hxClasses["haxe.io.BytesInput"] = BytesInput;

// Init



// Statics




// Export

exports.default = BytesInput;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/BytesOutput.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/BytesOutput.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.BytesOutput

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function haxe_io_Output() {return __webpack_require__(/*! ./../../haxe/io/Output */ "./node_modules/openfl/lib/_gen/haxe/io/Output.js");}
function haxe_io_BytesBuffer() {return __webpack_require__(/*! ./../../haxe/io/BytesBuffer */ "./node_modules/openfl/lib/_gen/haxe/io/BytesBuffer.js");}

// Constructor

var BytesOutput = function() {
	this.b = new (haxe_io_BytesBuffer().default)();
}

// Meta

BytesOutput.__name__ = "haxe.io.BytesOutput";
BytesOutput.__isInterface__ = false;
BytesOutput.__super__ = (haxe_io_Output().default);
BytesOutput.prototype = $extend((haxe_io_Output().default).prototype, {
	writeByte: function(c) {
		this.b.addByte(c);
	},
	writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	},
	getBytes: function() {
		return this.b.getBytes();
	}
});
BytesOutput.prototype.__class__ = BytesOutput.prototype.constructor = $hxClasses["haxe.io.BytesOutput"] = BytesOutput;

// Init



// Statics




// Export

exports.default = BytesOutput;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/Eof.js":
/*!*****************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/Eof.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.Eof

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var Eof = function() {
}

// Meta

Eof.__name__ = "haxe.io.Eof";
Eof.__isInterface__ = false;
Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
Eof.prototype.__class__ = Eof.prototype.constructor = $hxClasses["haxe.io.Eof"] = Eof;

// Init



// Statics




// Export

exports.default = Eof;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/Error.js":
/*!*******************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/Error.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: haxe.io.Error

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var Error = $hxEnums["haxe.io.Error"] = { __ename__ : "haxe.io.Error", __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
  ,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
  ,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
  ,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
  ,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
};

exports.default = Error;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/FPHelper.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/FPHelper.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.FPHelper

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe__$Int64__$_$_$Int64() {return __webpack_require__(/*! ./../../haxe/_Int64/___Int64 */ "./node_modules/openfl/lib/_gen/haxe/_Int64/___Int64.js");}

// Constructor

var FPHelper = function(){}

// Meta

FPHelper.__name__ = "haxe.io.FPHelper";
FPHelper.__isInterface__ = false;
FPHelper.prototype = {
	
};
FPHelper.prototype.__class__ = FPHelper.prototype.constructor = $hxClasses["haxe.io.FPHelper"] = FPHelper;

// Init



// Statics

FPHelper.i32ToFloat = function(i) {
	FPHelper.helper.setInt32(0,i,true);
	return FPHelper.helper.getFloat32(0,true);
}
FPHelper.floatToI32 = function(f) {
	FPHelper.helper.setFloat32(0,f,true);
	return FPHelper.helper.getInt32(0,true);
}
FPHelper.i64ToDouble = function(low,high) {
	FPHelper.helper.setInt32(0,low,true);
	FPHelper.helper.setInt32(4,high,true);
	return FPHelper.helper.getFloat64(0,true);
}
FPHelper.doubleToI64 = function(v) {
	var i64 = FPHelper.i64tmp;
	FPHelper.helper.setFloat64(0,v,true);
	i64.low = FPHelper.helper.getInt32(0,true);
	i64.high = FPHelper.helper.getInt32(4,true);
	return i64;
}
FPHelper.i64tmp = (function($this) {
	var $r;
	var this1 = new (haxe__$Int64__$_$_$Int64().default)(0,0);
	$r = this1;
	return $r;
}(this))
FPHelper.helper = new DataView(new ArrayBuffer(8))

// Export

exports.default = FPHelper;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/Input.js":
/*!*******************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/Input.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.Input

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_io_Error() {return __webpack_require__(/*! ./../../haxe/io/Error */ "./node_modules/openfl/lib/_gen/haxe/io/Error.js");}
function haxe_CallStack() {return __webpack_require__(/*! ./../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function haxe_io_Eof() {return __webpack_require__(/*! ./../../haxe/io/Eof */ "./node_modules/openfl/lib/_gen/haxe/io/Eof.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function haxe_io_FPHelper() {return __webpack_require__(/*! ./../../haxe/io/FPHelper */ "./node_modules/openfl/lib/_gen/haxe/io/FPHelper.js");}

// Constructor

var Input = function(){}

// Meta

Input.__name__ = "haxe.io.Input";
Input.__isInterface__ = false;
Input.prototype = {
	readByte: function() {
		throw new (js__$Boot_HaxeError().default)("Not implemented");
	},
	readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.get_length()) {
			throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			(haxe_CallStack().default).lastException = eof;
			var eof1 = ((eof) instanceof (js__$Boot_HaxeError().default)) ? eof.val : eof;
			if(((eof1) instanceof (haxe_io_Eof().default))) {
				var eof2 = eof1;
			} else {
				throw eof;
			}
		}
		return len - k;
	},
	set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	},
	readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).Blocked);
			}
			pos += k;
			len -= k;
		}
	},
	read: function(nbytes) {
		var s = (haxe_io_Bytes().default).alloc(nbytes);
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	},
	readDouble: function() {
		var i1 = this.readInt32();
		var i2 = this.readInt32();
		if(this.bigEndian) {
			return (haxe_io_FPHelper().default).i64ToDouble(i2,i1);
		} else {
			return (haxe_io_FPHelper().default).i64ToDouble(i1,i2);
		}
	},
	readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	},
	readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	},
	readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	},
	readString: function(len,encoding) {
		var b = (haxe_io_Bytes().default).alloc(len);
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
};
Input.prototype.__class__ = Input.prototype.constructor = $hxClasses["haxe.io.Input"] = Input;

// Init



// Statics




// Export

exports.default = Input;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/Output.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/Output.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.Output

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_io_Error() {return __webpack_require__(/*! ./../../haxe/io/Error */ "./node_modules/openfl/lib/_gen/haxe/io/Error.js");}
function haxe_io_FPHelper() {return __webpack_require__(/*! ./../../haxe/io/FPHelper */ "./node_modules/openfl/lib/_gen/haxe/io/FPHelper.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}

// Constructor

var Output = function(){}

// Meta

Output.__name__ = "haxe.io.Output";
Output.__isInterface__ = false;
Output.prototype = {
	writeByte: function(c) {
		throw new (js__$Boot_HaxeError().default)("Not implemented");
	},
	writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.get_length()) {
			throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	},
	set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	},
	write: function(s) {
		var l = s.get_length();
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).Blocked);
			}
			p += k;
			l -= k;
		}
	},
	writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	},
	writeDouble: function(x) {
		var i64 = (haxe_io_FPHelper().default).doubleToI64(x);
		if(this.bigEndian) {
			this.writeInt32(i64.high);
			this.writeInt32(i64.low);
		} else {
			this.writeInt32(i64.low);
			this.writeInt32(i64.high);
		}
	},
	writeUInt16: function(x) {
		if(x < 0 || x >= 65536) {
			throw new (js__$Boot_HaxeError().default)((haxe_io_Error().default).Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	},
	writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	},
	writeString: function(s,encoding) {
		var b = (haxe_io_Bytes().default).ofString(s,encoding);
		this.writeFullBytes(b,0,b.get_length());
	}
};
Output.prototype.__class__ = Output.prototype.constructor = $hxClasses["haxe.io.Output"] = Output;

// Init



// Statics




// Export

exports.default = Output;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/io/Path.js":
/*!******************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/io/Path.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.io.Path

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = (HxOverrides().default).substr(path,0,c2);
		path = (HxOverrides().default).substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = (HxOverrides().default).substr(path,0,c1);
		path = (HxOverrides().default).substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = (HxOverrides().default).substr(path,cp + 1,null);
		this.file = (HxOverrides().default).substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
}

// Meta

Path.__name__ = "haxe.io.Path";
Path.__isInterface__ = false;
Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
};
Path.prototype.__class__ = Path.prototype.constructor = $hxClasses["haxe.io.Path"] = Path;

// Init



// Statics

Path.withoutDirectory = function(path) {
	var s = new Path(path);
	s.dir = null;
	return s.toString();
}
Path.directory = function(path) {
	var s = new Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
}
Path.extension = function(path) {
	var s = new Path(path);
	if(s.ext == null) {
		return "";
	}
	return s.ext;
}


// Export

exports.default = Path;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/iterators/StringIteratorUnicode.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/iterators/StringIteratorUnicode.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.iterators.StringIteratorUnicode

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}

// Constructor

var StringIteratorUnicode = function(s) {
	this.offset = 0;
	this.s = s;
}

// Meta

StringIteratorUnicode.__name__ = "haxe.iterators.StringIteratorUnicode";
StringIteratorUnicode.__isInterface__ = false;
StringIteratorUnicode.prototype = {
	hasNext: function() {
		return this.offset < this.s.length;
	},
	next: function() {
		var c = (StringTools().default).utf16CodePointAt(this.s,this.offset++);
		if(c >= 65536) {
			this.offset++;
		}
		return c;
	}
};
StringIteratorUnicode.prototype.__class__ = StringIteratorUnicode.prototype.constructor = $hxClasses["haxe.iterators.StringIteratorUnicode"] = StringIteratorUnicode;

// Init



// Statics




// Export

exports.default = StringIteratorUnicode;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/xml/Parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/xml/Parser.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.xml.Parser

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function Xml() {return __webpack_require__(/*! ./../../Xml */ "./node_modules/openfl/lib/_gen/Xml.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function StringBuf() {return __webpack_require__(/*! ./../../StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_xml_XmlParserException() {return __webpack_require__(/*! ./../../haxe/xml/XmlParserException */ "./node_modules/openfl/lib/_gen/haxe/xml/XmlParserException.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Parser = function(){}

// Meta

Parser.__name__ = "haxe.xml.Parser";
Parser.__isInterface__ = false;
Parser.prototype = {
	
};
Parser.prototype.__class__ = Parser.prototype.constructor = $hxClasses["haxe.xml.Parser"] = Parser;

// Init



// Statics

Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = (Xml().default).createDocument();
	Parser.doParse(str,strict,0,doc);
	return doc;
}
Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var c = (StringTools().default).fastCodeAt(str,p);
	var buf = new (StringBuf().default)();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(!(StringTools().default).isEof(c)) {
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if((StringTools().default).fastCodeAt(str,p + 1) == 91) {
					p += 2;
					if((HxOverrides().default).substr(str,p,6).toUpperCase() != "CDATA[") {
						throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if((StringTools().default).fastCodeAt(str,p + 1) == 68 || (StringTools().default).fastCodeAt(str,p + 1) == 100) {
					if((HxOverrides().default).substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if((StringTools().default).fastCodeAt(str,p + 1) != 45 || (StringTools().default).fastCodeAt(str,p + 2) != 45) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!Parser.isValidChar(c)) {
				if(p == start) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected node name",str,p));
				}
				xml = (Xml().default).createElement((HxOverrides().default).substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!Parser.isValidChar(c)) {
				if(start == p) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected attribute name",str,p));
				}
				var tmp = (HxOverrides().default).substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(aname)) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Duplicate attribute [" + aname + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new (StringBuf().default)();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				buf.addSub(str,start,p - start);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					buf.addSub(str,start,p - start);
					var val = buf.toString();
					buf = new (StringBuf().default)();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					buf.addSub(str,start,p - start);
					var val1 = buf.toString();
					buf = new (StringBuf().default)();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!Parser.isValidChar(c)) {
				if(start == p) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected node name",str,p));
				}
				var v = (HxOverrides().default).substr(str,start,p - start);
				if(parent == null || parent.nodeType != 0) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Unexpected </" + v + ">, tag is not open",str,p));
				}
				if(v != parent.get_nodeName()) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected </" + parent.get_nodeName() + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild((Xml().default).createPCData(""));
				}
				return p;
			} else {
				throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				buf.addSub(str,start,p - start);
				var child = (Xml().default).createPCData(buf.toString());
				buf = new (StringBuf().default)();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				buf.addSub(str,start,p - start);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && (StringTools().default).fastCodeAt(str,p + 1) == 62) {
				++p;
				var str1 = (HxOverrides().default).substr(str,start + 1,p - start - 2);
				parent.addChild((Xml().default).createProcessingInstruction(str1));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && (StringTools().default).fastCodeAt(str,p + 1) == 45 && (StringTools().default).fastCodeAt(str,p + 2) == 62) {
				parent.addChild((Xml().default).createComment((HxOverrides().default).substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild((Xml().default).createDocType((HxOverrides().default).substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && (StringTools().default).fastCodeAt(str,p + 1) == 93 && (StringTools().default).fastCodeAt(str,p + 2) == 62) {
				var child1 = (Xml().default).createCData((HxOverrides().default).substr(str,start,p - start));
				parent.addChild(child1);
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = (HxOverrides().default).substr(str,start,p - start);
				if((StringTools().default).fastCodeAt(s,0) == 35) {
					var c1 = (StringTools().default).fastCodeAt(s,1) == 120 ? (Std().default).parseInt("0" + (HxOverrides().default).substr(s,1,s.length - 1)) : (Std().default).parseInt((HxOverrides().default).substr(s,1,s.length - 1));
					buf.addChar(c1);
				} else if(!Parser.escapes.exists(s)) {
					if(strict) {
						throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Undefined entity: " + s,str,p));
					}
					buf.add("&" + s + ";");
				} else {
					buf.add(Parser.escapes.get(s));
				}
				start = p + 1;
				state = escapeNext;
			} else if(!Parser.isValidChar(c) && c != 35) {
				if(strict) {
					throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Invalid character in entity: " + String.fromCodePoint(c),str,p));
				}
				buf.addChar(38);
				buf.addSub(str,start,p - start);
				--p;
				start = p + 1;
				state = escapeNext;
			}
			break;
		}
		c = (StringTools().default).fastCodeAt(str,++p);
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(parent.nodeType == 0) {
			throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Unclosed node <" + parent.get_nodeName() + ">",str,p));
		}
		if(p != start || nsubs == 0) {
			buf.addSub(str,start,p - start);
			parent.addChild((Xml().default).createPCData(buf.toString()));
			++nsubs;
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.addChar(38);
		buf.addSub(str,start,p - start);
		parent.addChild((Xml().default).createPCData(buf.toString()));
		++nsubs;
		return p;
	}
	throw new (js__$Boot_HaxeError().default)(new (haxe_xml_XmlParserException().default)("Unexpected end",str,p));
}
Parser.isValidChar = function(c) {
	if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95)) {
		return c == 45;
	} else {
		return true;
	}
}
Parser.escapes = (function($this) {
	var $r;
	var h = new (haxe_ds_StringMap().default)();
	h.set("lt","<");
	h.set("gt",">");
	h.set("amp","&");
	h.set("quot","\"");
	h.set("apos","'");
	$r = h;
	return $r;
}(this))

// Export

exports.default = Parser;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/xml/Printer.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/xml/Printer.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.xml.Printer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function EReg() {return __webpack_require__(/*! ./../../EReg */ "./node_modules/openfl/lib/_gen/EReg.js");}
function StringBuf() {return __webpack_require__(/*! ./../../StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}

// Constructor

var Printer = function(pretty) {
	this.output = new (StringBuf().default)();
	this.pretty = pretty;
}

// Meta

Printer.__name__ = "haxe.xml.Printer";
Printer.__isInterface__ = false;
Printer.prototype = {
	writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.write(tabs + "<");
			this.write(value.get_nodeName());
			var attribute = value.attributes();
			while(attribute.hasNext()) {
				var attribute1 = attribute.next();
				this.write(" " + attribute1 + "=\"");
				this.write((StringTools().default).htmlEscape(value.get(attribute1),true));
				this.write("\"");
			}
			if(this.hasChildren(value)) {
				this.write(">");
				this.newline();
				var child = value.iterator();
				while(child.hasNext()) {
					var child1 = child.next();
					this.writeNode(child1,this.pretty ? tabs + "\t" : tabs);
				}
				this.write(tabs + "</");
				this.write(value.get_nodeName());
				this.write(">");
				this.newline();
			} else {
				this.write("/>");
				this.newline();
			}
			break;
		case 1:
			var nodeValue = value.get_nodeValue();
			if(nodeValue.length != 0) {
				this.write(tabs + (StringTools().default).htmlEscape(nodeValue));
				this.newline();
			}
			break;
		case 2:
			this.write(tabs + "<![CDATA[");
			this.write(value.get_nodeValue());
			this.write("]]>");
			this.newline();
			break;
		case 3:
			var commentContent = value.get_nodeValue();
			commentContent = new (EReg().default)("[\n\r\t]+","g").replace(commentContent,"");
			commentContent = "<!--" + commentContent + "-->";
			this.write(tabs);
			this.write((StringTools().default).trim(commentContent));
			this.newline();
			break;
		case 4:
			this.write("<!DOCTYPE " + value.get_nodeValue() + ">");
			this.newline();
			break;
		case 5:
			this.write("<?" + value.get_nodeValue() + "?>");
			this.newline();
			break;
		case 6:
			var child2 = value.iterator();
			while(child2.hasNext()) {
				var child3 = child2.next();
				this.writeNode(child3,tabs);
			}
			break;
		}
	},
	write: function(input) {
		this.output.add(input);
	},
	newline: function() {
		if(this.pretty) {
			this.output.add("\n");
		}
	},
	hasChildren: function(value) {
		var child = value.iterator();
		while(child.hasNext()) {
			var child1 = child.next();
			switch(child1.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if((StringTools().default).ltrim(child1.get_nodeValue()).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
};
Printer.prototype.__class__ = Printer.prototype.constructor = $hxClasses["haxe.xml.Printer"] = Printer;

// Init



// Statics

Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.toString();
}


// Export

exports.default = Printer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/xml/XmlParserException.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/xml/XmlParserException.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.xml.XmlParserException

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}

// Constructor

var XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g = 0;
	var _g1 = position;
	while(_g < _g1) {
		var i = _g++;
		var c = (StringTools().default).fastCodeAt(xml,i);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
}

// Meta

XmlParserException.__name__ = "haxe.xml.XmlParserException";
XmlParserException.__isInterface__ = false;
XmlParserException.prototype = {
	toString: function() {
		return (Type().default).getClassName((Type().default).getClass(this)) + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
};
XmlParserException.prototype.__class__ = XmlParserException.prototype.constructor = $hxClasses["haxe.xml.XmlParserException"] = XmlParserException;

// Init



// Statics




// Export

exports.default = XmlParserException;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/zip/ExtraField.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/zip/ExtraField.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: haxe.zip.ExtraField

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var ExtraField = $hxEnums["haxe.zip.ExtraField"] = { __ename__ : "haxe.zip.ExtraField", __constructs__ : ["FUnknown","FInfoZipUnicodePath","FUtf8"]
  ,FUtf8: {_hx_index:2,__enum__:"haxe.zip.ExtraField",toString:$estr}
  ,FUnknown: ($_=function(tag,bytes) { return {_hx_index:0,tag:tag,bytes:bytes,__enum__:"haxe.zip.ExtraField",toString:$estr}; },$_.__params__ = ["tag","bytes"],$_)
  ,FInfoZipUnicodePath: ($_=function(name,crc) { return {_hx_index:1,name:name,crc:crc,__enum__:"haxe.zip.ExtraField",toString:$estr}; },$_.__params__ = ["name","crc"],$_)
};

exports.default = ExtraField;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/zip/HuffTools.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/zip/HuffTools.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.zip.HuffTools

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_zip_Huffman() {return __webpack_require__(/*! ./../../haxe/zip/Huffman */ "./node_modules/openfl/lib/_gen/haxe/zip/Huffman.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}

// Constructor

var HuffTools = function() {
}

// Meta

HuffTools.__name__ = "haxe.zip.HuffTools";
HuffTools.__isInterface__ = false;
HuffTools.prototype = {
	treeDepth: function(t) {
		switch(t._hx_index) {
		case 0:
			var _g = t.i;
			return 0;
		case 1:
			var b = t.right;
			var a = t.left;
			var da = this.treeDepth(a);
			var db = this.treeDepth(b);
			return 1 + (da < db ? da : db);
		case 2:
			var _g2 = t.table;
			var _g1 = t.n;
			throw new (js__$Boot_HaxeError().default)("assert");
		}
	},
	treeCompress: function(t) {
		var d = this.treeDepth(t);
		if(d == 0) {
			return t;
		}
		if(d == 1) {
			if(t._hx_index == 1) {
				var b = t.right;
				var a = t.left;
				return (haxe_zip_Huffman().default).NeedBit(this.treeCompress(a),this.treeCompress(b));
			} else {
				throw new (js__$Boot_HaxeError().default)("assert");
			}
		}
		var size = 1 << d;
		var table = [];
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var i = _g++;
			table.push((haxe_zip_Huffman().default).Found(-1));
		}
		this.treeWalk(table,0,0,d,t);
		return (haxe_zip_Huffman().default).NeedBits(d,table);
	},
	treeWalk: function(table,p,cd,d,t) {
		if(t._hx_index == 1) {
			var b = t.right;
			var a = t.left;
			if(d > 0) {
				this.treeWalk(table,p,cd + 1,d - 1,a);
				this.treeWalk(table,p | 1 << cd,cd + 1,d - 1,b);
			} else {
				table[p] = this.treeCompress(t);
			}
		} else {
			table[p] = this.treeCompress(t);
		}
	},
	treeMake: function(bits,maxbits,v,len) {
		if(len > maxbits) {
			throw new (js__$Boot_HaxeError().default)("Invalid huffman");
		}
		var idx = v << 5 | len;
		if(bits.exists(idx)) {
			return (haxe_zip_Huffman().default).Found(bits.get(idx));
		}
		v <<= 1;
		++len;
		return (haxe_zip_Huffman().default).NeedBit(this.treeMake(bits,maxbits,v,len),this.treeMake(bits,maxbits,v | 1,len));
	},
	make: function(lengths,pos,nlengths,maxbits) {
		if(nlengths == 1) {
			return (haxe_zip_Huffman().default).NeedBit((haxe_zip_Huffman().default).Found(0),(haxe_zip_Huffman().default).Found(0));
		}
		var counts = [];
		var tmp = [];
		if(maxbits > 32) {
			throw new (js__$Boot_HaxeError().default)("Invalid huffman");
		}
		var _g = 0;
		var _g1 = maxbits;
		while(_g < _g1) {
			var i = _g++;
			counts.push(0);
			tmp.push(0);
		}
		var _g2 = 0;
		var _g3 = nlengths;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var p = lengths[i1 + pos];
			if(p >= maxbits) {
				throw new (js__$Boot_HaxeError().default)("Invalid huffman");
			}
			counts[p]++;
		}
		var code = 0;
		var _g4 = 1;
		var _g5 = maxbits - 1;
		while(_g4 < _g5) {
			var i2 = _g4++;
			code = code + counts[i2] << 1;
			tmp[i2] = code;
		}
		var bits = new (haxe_ds_IntMap().default)();
		var _g6 = 0;
		var _g7 = nlengths;
		while(_g6 < _g7) {
			var i3 = _g6++;
			var l = lengths[i3 + pos];
			if(l != 0) {
				var n = tmp[l - 1];
				tmp[l - 1] = n + 1;
				bits.set(n << 5 | l,i3);
			}
		}
		return this.treeCompress((haxe_zip_Huffman().default).NeedBit(this.treeMake(bits,maxbits,0,1),this.treeMake(bits,maxbits,1,1)));
	}
};
HuffTools.prototype.__class__ = HuffTools.prototype.constructor = $hxClasses["haxe.zip.HuffTools"] = HuffTools;

// Init



// Statics




// Export

exports.default = HuffTools;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/zip/Huffman.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/zip/Huffman.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: haxe.zip.Huffman

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var Huffman = $hxEnums["haxe.zip.Huffman"] = { __ename__ : "haxe.zip.Huffman", __constructs__ : ["Found","NeedBit","NeedBits"]
  ,NeedBits: ($_=function(n,table) { return {_hx_index:2,n:n,table:table,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["n","table"],$_)
  ,NeedBit: ($_=function(left,right) { return {_hx_index:1,left:left,right:right,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["left","right"],$_)
  ,Found: ($_=function(i) { return {_hx_index:0,i:i,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["i"],$_)
};

exports.default = Huffman;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/zip/InflateImpl.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/zip/InflateImpl.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.zip.InflateImpl

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_zip__$InflateImpl_State() {return __webpack_require__(/*! ./../../haxe/zip/_InflateImpl/State */ "./node_modules/openfl/lib/_gen/haxe/zip/_InflateImpl/State.js");}
function haxe_crypto_Adler32() {return __webpack_require__(/*! ./../../haxe/crypto/Adler32 */ "./node_modules/openfl/lib/_gen/haxe/crypto/Adler32.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function haxe_io_BytesBuffer() {return __webpack_require__(/*! ./../../haxe/io/BytesBuffer */ "./node_modules/openfl/lib/_gen/haxe/io/BytesBuffer.js");}
function haxe_zip_HuffTools() {return __webpack_require__(/*! ./../../haxe/zip/HuffTools */ "./node_modules/openfl/lib/_gen/haxe/zip/HuffTools.js");}
function haxe_zip__$InflateImpl_Window() {return __webpack_require__(/*! ./../../haxe/zip/_InflateImpl/Window */ "./node_modules/openfl/lib/_gen/haxe/zip/_InflateImpl/Window.js");}

// Constructor

var InflateImpl = function(i,header,crc) {
	if(crc == null) {
		crc = true;
	}
	if(header == null) {
		header = true;
	}
	this.isFinal = false;
	this.htools = new (haxe_zip_HuffTools().default)();
	this.huffman = this.buildFixedHuffman();
	this.huffdist = null;
	this.len = 0;
	this.dist = 0;
	this.state = header ? (haxe_zip__$InflateImpl_State().default).Head : (haxe_zip__$InflateImpl_State().default).Block;
	this.input = i;
	this.bits = 0;
	this.nbits = 0;
	this.needed = 0;
	this.output = null;
	this.outpos = 0;
	this.lengths = [];
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.window = new (haxe_zip__$InflateImpl_Window().default)(crc);
}

// Meta

InflateImpl.__name__ = "haxe.zip.InflateImpl";
InflateImpl.__isInterface__ = false;
InflateImpl.prototype = {
	buildFixedHuffman: function() {
		if(InflateImpl.FIXED_HUFFMAN != null) {
			return InflateImpl.FIXED_HUFFMAN;
		}
		var a = [];
		var _g = 0;
		while(_g < 288) {
			var n = _g++;
			a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
		}
		InflateImpl.FIXED_HUFFMAN = this.htools.make(a,0,288,10);
		return InflateImpl.FIXED_HUFFMAN;
	},
	readBytes: function(b,pos,len) {
		this.needed = len;
		this.outpos = pos;
		this.output = b;
		if(len > 0) {
			while(this.inflateLoop()) {
			}
		}
		return len - this.needed;
	},
	getBits: function(n) {
		while(this.nbits < n) {
			this.bits |= this.input.readByte() << this.nbits;
			this.nbits += 8;
		}
		var b = this.bits & (1 << n) - 1;
		this.nbits -= n;
		this.bits >>= n;
		return b;
	},
	getBit: function() {
		if(this.nbits == 0) {
			this.nbits = 8;
			this.bits = this.input.readByte();
		}
		var b = (this.bits & 1) == 1;
		this.nbits--;
		this.bits >>= 1;
		return b;
	},
	getRevBits: function(n) {
		if(n == 0) {
			return 0;
		} else if(this.getBit()) {
			return 1 << n - 1 | this.getRevBits(n - 1);
		} else {
			return this.getRevBits(n - 1);
		}
	},
	resetBits: function() {
		this.bits = 0;
		this.nbits = 0;
	},
	addBytes: function(b,p,len) {
		this.window.addBytes(b,p,len);
		this.output.blit(this.outpos,b,p,len);
		this.needed -= len;
		this.outpos += len;
	},
	addByte: function(b) {
		this.window.addByte(b);
		this.output.set(this.outpos,b);
		this.needed--;
		this.outpos++;
	},
	addDistOne: function(n) {
		var c = this.window.getLastChar();
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			this.addByte(c);
		}
	},
	addDist: function(d,len) {
		this.addBytes(this.window.buffer,this.window.pos - d,len);
	},
	applyHuffman: function(h) {
		switch(h._hx_index) {
		case 0:
			var n = h.i;
			return n;
		case 1:
			var b = h.right;
			var a = h.left;
			return this.applyHuffman(this.getBit() ? b : a);
		case 2:
			var tbl = h.table;
			var n1 = h.n;
			return this.applyHuffman(tbl[this.getBits(n1)]);
		}
	},
	inflateLengths: function(a,max) {
		var i = 0;
		var prev = 0;
		while(i < max) {
			var n = this.applyHuffman(this.huffman);
			switch(n) {
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				prev = n;
				a[i] = n;
				++i;
				break;
			case 16:
				var end = i + 3 + this.getBits(2);
				if(end > max) {
					throw new (js__$Boot_HaxeError().default)("Invalid data");
				}
				while(i < end) {
					a[i] = prev;
					++i;
				}
				break;
			case 17:
				i += 3 + this.getBits(3);
				if(i > max) {
					throw new (js__$Boot_HaxeError().default)("Invalid data");
				}
				break;
			case 18:
				i += 11 + this.getBits(7);
				if(i > max) {
					throw new (js__$Boot_HaxeError().default)("Invalid data");
				}
				break;
			default:
				throw new (js__$Boot_HaxeError().default)("Invalid data");
			}
		}
	},
	inflateLoop: function() {
		switch(this.state._hx_index) {
		case 0:
			var cmf = this.input.readByte();
			var cm = cmf & 15;
			var cinfo = cmf >> 4;
			if(cm != 8) {
				throw new (js__$Boot_HaxeError().default)("Invalid data");
			}
			var flg = this.input.readByte();
			var fdict = (flg & 32) != 0;
			if(((cmf << 8) + flg) % 31 != 0) {
				throw new (js__$Boot_HaxeError().default)("Invalid data");
			}
			if(fdict) {
				throw new (js__$Boot_HaxeError().default)("Unsupported dictionary");
			}
			this.state = (haxe_zip__$InflateImpl_State().default).Block;
			return true;
		case 1:
			this.isFinal = this.getBit();
			switch(this.getBits(2)) {
			case 0:
				this.len = this.input.readUInt16();
				var nlen = this.input.readUInt16();
				if(nlen != 65535 - this.len) {
					throw new (js__$Boot_HaxeError().default)("Invalid data");
				}
				this.state = (haxe_zip__$InflateImpl_State().default).Flat;
				var r = this.inflateLoop();
				this.resetBits();
				return r;
			case 1:
				this.huffman = this.buildFixedHuffman();
				this.huffdist = null;
				this.state = (haxe_zip__$InflateImpl_State().default).CData;
				return true;
			case 2:
				var hlit = this.getBits(5) + 257;
				var hdist = this.getBits(5) + 1;
				var hclen = this.getBits(4) + 4;
				var _g = 0;
				var _g1 = hclen;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[InflateImpl.CODE_LENGTHS_POS[i]] = this.getBits(3);
				}
				var _g2 = hclen;
				var _g3 = 19;
				while(_g2 < _g3) {
					var i1 = _g2++;
					this.lengths[InflateImpl.CODE_LENGTHS_POS[i1]] = 0;
				}
				this.huffman = this.htools.make(this.lengths,0,19,8);
				var lengths = [];
				var _g4 = 0;
				var _g5 = hlit + hdist;
				while(_g4 < _g5) {
					var i2 = _g4++;
					lengths.push(0);
				}
				this.inflateLengths(lengths,hlit + hdist);
				this.huffdist = this.htools.make(lengths,hlit,hdist,16);
				this.huffman = this.htools.make(lengths,0,hlit,16);
				this.state = (haxe_zip__$InflateImpl_State().default).CData;
				return true;
			default:
				throw new (js__$Boot_HaxeError().default)("Invalid data");
			}
			break;
		case 2:
			var n = this.applyHuffman(this.huffman);
			if(n < 256) {
				this.addByte(n);
				return this.needed > 0;
			} else if(n == 256) {
				this.state = this.isFinal ? (haxe_zip__$InflateImpl_State().default).Crc : (haxe_zip__$InflateImpl_State().default).Block;
				return true;
			} else {
				n -= 257;
				var extra_bits = InflateImpl.LEN_EXTRA_BITS_TBL[n];
				if(extra_bits == -1) {
					throw new (js__$Boot_HaxeError().default)("Invalid data");
				}
				this.len = InflateImpl.LEN_BASE_VAL_TBL[n] + this.getBits(extra_bits);
				var dist_code = this.huffdist == null ? this.getRevBits(5) : this.applyHuffman(this.huffdist);
				extra_bits = InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
				if(extra_bits == -1) {
					throw new (js__$Boot_HaxeError().default)("Invalid data");
				}
				this.dist = InflateImpl.DIST_BASE_VAL_TBL[dist_code] + this.getBits(extra_bits);
				if(this.dist > this.window.available()) {
					throw new (js__$Boot_HaxeError().default)("Invalid data");
				}
				this.state = this.dist == 1 ? (haxe_zip__$InflateImpl_State().default).DistOne : (haxe_zip__$InflateImpl_State().default).Dist;
				return true;
			}
			break;
		case 3:
			var rlen = this.len < this.needed ? this.len : this.needed;
			var bytes = this.input.read(rlen);
			this.len -= rlen;
			this.addBytes(bytes,0,rlen);
			if(this.len == 0) {
				this.state = this.isFinal ? (haxe_zip__$InflateImpl_State().default).Crc : (haxe_zip__$InflateImpl_State().default).Block;
			}
			return this.needed > 0;
		case 4:
			var calc = this.window.checksum();
			if(calc == null) {
				this.state = (haxe_zip__$InflateImpl_State().default).Done;
				return true;
			}
			var crc = (haxe_crypto_Adler32().default).read(this.input);
			if(!calc.equals(crc)) {
				throw new (js__$Boot_HaxeError().default)("Invalid CRC");
			}
			this.state = (haxe_zip__$InflateImpl_State().default).Done;
			return true;
		case 5:
			while(this.len > 0 && this.needed > 0) {
				var rdist = this.len < this.dist ? this.len : this.dist;
				var rlen1 = this.needed < rdist ? this.needed : rdist;
				this.addDist(this.dist,rlen1);
				this.len -= rlen1;
			}
			if(this.len == 0) {
				this.state = (haxe_zip__$InflateImpl_State().default).CData;
			}
			return this.needed > 0;
		case 6:
			var rlen2 = this.len < this.needed ? this.len : this.needed;
			this.addDistOne(rlen2);
			this.len -= rlen2;
			if(this.len == 0) {
				this.state = (haxe_zip__$InflateImpl_State().default).CData;
			}
			return this.needed > 0;
		case 7:
			return false;
		}
	}
};
InflateImpl.prototype.__class__ = InflateImpl.prototype.constructor = $hxClasses["haxe.zip.InflateImpl"] = InflateImpl;

// Init



// Statics

InflateImpl.run = function(i,bufsize) {
	if(bufsize == null) {
		bufsize = 65536;
	}
	var buf = (haxe_io_Bytes().default).alloc(bufsize);
	var output = new (haxe_io_BytesBuffer().default)();
	var inflate = new InflateImpl(i);
	while(true) {
		var len = inflate.readBytes(buf,0,bufsize);
		output.addBytes(buf,0,len);
		if(len < bufsize) {
			break;
		}
	}
	return output.getBytes();
}
InflateImpl.LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1]
InflateImpl.LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258]
InflateImpl.DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1]
InflateImpl.DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577]
InflateImpl.CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]
InflateImpl.FIXED_HUFFMAN = null

// Export

exports.default = InflateImpl;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/zip/Reader.js":
/*!*********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/zip/Reader.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.zip.Reader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_List() {return __webpack_require__(/*! ./../../haxe/ds/List */ "./node_modules/openfl/lib/_gen/haxe/ds/List.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function haxe_io_BytesBuffer() {return __webpack_require__(/*! ./../../haxe/io/BytesBuffer */ "./node_modules/openfl/lib/_gen/haxe/io/BytesBuffer.js");}
function haxe_zip_ExtraField() {return __webpack_require__(/*! ./../../haxe/zip/ExtraField */ "./node_modules/openfl/lib/_gen/haxe/zip/ExtraField.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function haxe_zip_InflateImpl() {return __webpack_require__(/*! ./../../haxe/zip/InflateImpl */ "./node_modules/openfl/lib/_gen/haxe/zip/InflateImpl.js");}

// Constructor

var Reader = function(i) {
	this.i = i;
}

// Meta

Reader.__name__ = "haxe.zip.Reader";
Reader.__isInterface__ = false;
Reader.prototype = {
	readZipDate: function() {
		var t = this.i.readUInt16();
		var hour = t >> 11 & 31;
		var min = t >> 5 & 63;
		var sec = t & 31;
		var d = this.i.readUInt16();
		var year = d >> 9;
		var month = d >> 5 & 15;
		var day = d & 31;
		return new Date(year + 1980,month - 1,day,hour,min,sec << 1);
	},
	readExtraFields: function(length) {
		var fields = new (haxe_ds_List().default)();
		while(length > 0) {
			if(length < 4) {
				throw new (js__$Boot_HaxeError().default)("Invalid extra fields data");
			}
			var tag = this.i.readUInt16();
			var len = this.i.readUInt16();
			if(length < len) {
				throw new (js__$Boot_HaxeError().default)("Invalid extra fields data");
			}
			if(tag == 28789) {
				var version = this.i.readByte();
				if(version != 1) {
					var data = new (haxe_io_BytesBuffer().default)();
					data.addByte(version);
					data.add(this.i.read(len - 1));
					fields.add((haxe_zip_ExtraField().default).FUnknown(tag,data.getBytes()));
				} else {
					var crc = this.i.readInt32();
					var name = this.i.read(len - 5).toString();
					fields.add((haxe_zip_ExtraField().default).FInfoZipUnicodePath(name,crc));
				}
			} else {
				fields.add((haxe_zip_ExtraField().default).FUnknown(tag,this.i.read(len)));
			}
			length -= 4 + len;
		}
		return fields;
	},
	readEntryHeader: function() {
		var i = this.i;
		var h = i.readInt32();
		if(h == 33639248 || h == 101010256) {
			return null;
		}
		if(h != 67324752) {
			throw new (js__$Boot_HaxeError().default)("Invalid Zip Data");
		}
		var version = i.readUInt16();
		var flags = i.readUInt16();
		var utf8 = (flags & 2048) != 0;
		var compression = i.readUInt16();
		var compressed = compression != 0;
		if(compressed && compression != 8) {
			throw new (js__$Boot_HaxeError().default)("Unsupported compression " + compression);
		}
		var mtime = this.readZipDate();
		var crc32 = i.readInt32();
		var csize = i.readInt32();
		var usize = i.readInt32();
		var fnamelen = i.readInt16();
		var elen = i.readInt16();
		var fname = i.readString(fnamelen);
		var fields = this.readExtraFields(elen);
		if(utf8) {
			fields.push((haxe_zip_ExtraField().default).FUtf8);
		}
		var data = null;
		if((flags & 8) != 0) {
			csize = -1;
		}
		return { fileName : fname, fileSize : usize, fileTime : mtime, compressed : compressed, dataSize : csize, data : data, crc32 : crc32, extraFields : fields};
	},
	read: function() {
		var l = new (haxe_ds_List().default)();
		var buf = null;
		var tmp = null;
		while(true) {
			var e = this.readEntryHeader();
			if(e == null) {
				break;
			}
			if(e.dataSize < 0) {
				var bufSize = 65536;
				if(tmp == null) {
					tmp = (haxe_io_Bytes().default).alloc(bufSize);
				}
				var out = new (haxe_io_BytesBuffer().default)();
				var z = new (haxe_zip_InflateImpl().default)(this.i,false,false);
				while(true) {
					var n = z.readBytes(tmp,0,bufSize);
					out.addBytes(tmp,0,n);
					if(n < bufSize) {
						break;
					}
				}
				e.data = out.getBytes();
				e.crc32 = this.i.readInt32();
				if(e.crc32 == 134695760) {
					e.crc32 = this.i.readInt32();
				}
				e.dataSize = this.i.readInt32();
				e.fileSize = this.i.readInt32();
				e.dataSize = e.fileSize;
				e.compressed = false;
			} else {
				e.data = this.i.read(e.dataSize);
			}
			l.add(e);
		}
		return l;
	}
};
Reader.prototype.__class__ = Reader.prototype.constructor = $hxClasses["haxe.zip.Reader"] = Reader;

// Init



// Statics

Reader.readZip = function(i) {
	var r = new Reader(i);
	return r.read();
}
Reader.unzip = function(f) {
	if(!f.compressed) {
		return f.data;
	}
	throw new (js__$Boot_HaxeError().default)("No uncompress support");
}


// Export

exports.default = Reader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/zip/_InflateImpl/State.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/zip/_InflateImpl/State.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: haxe.zip._InflateImpl.State

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var State = $hxEnums["haxe.zip._InflateImpl.State"] = { __ename__ : "haxe.zip._InflateImpl.State", __constructs__ : ["Head","Block","CData","Flat","Crc","Dist","DistOne","Done"]
  ,Head: {_hx_index:0,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
  ,Flat: {_hx_index:3,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
  ,Done: {_hx_index:7,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
  ,DistOne: {_hx_index:6,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
  ,Dist: {_hx_index:5,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
  ,Crc: {_hx_index:4,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
  ,CData: {_hx_index:2,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
  ,Block: {_hx_index:1,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
};

exports.default = State;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/haxe/zip/_InflateImpl/Window.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/haxe/zip/_InflateImpl/Window.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: haxe.zip._InflateImpl.Window

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function haxe_crypto_Adler32() {return __webpack_require__(/*! ./../../../haxe/crypto/Adler32 */ "./node_modules/openfl/lib/_gen/haxe/crypto/Adler32.js");}

// Constructor

var Window = function(hasCrc) {
	this.buffer = (haxe_io_Bytes().default).alloc(65536);
	this.pos = 0;
	if(hasCrc) {
		this.crc = new (haxe_crypto_Adler32().default)();
	}
}

// Meta

Window.__name__ = "haxe.zip._InflateImpl.Window";
Window.__isInterface__ = false;
Window.prototype = {
	slide: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,32768);
		}
		var b = (haxe_io_Bytes().default).alloc(65536);
		this.pos -= 32768;
		b.blit(0,this.buffer,32768,this.pos);
		this.buffer = b;
	},
	addBytes: function(b,p,len) {
		if(this.pos + len > 65536) {
			this.slide();
		}
		this.buffer.blit(this.pos,b,p,len);
		this.pos += len;
	},
	addByte: function(c) {
		if(this.pos == 65536) {
			this.slide();
		}
		this.buffer.set(this.pos,c);
		this.pos++;
	},
	getLastChar: function() {
		return this.buffer.get(this.pos - 1);
	},
	available: function() {
		return this.pos;
	},
	checksum: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,this.pos);
		}
		return this.crc;
	}
};
Window.prototype.__class__ = Window.prototype.constructor = $hxClasses["haxe.zip._InflateImpl.Window"] = Window;

// Init



// Statics




// Export

exports.default = Window;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/hxClasses_stub.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/hxClasses_stub.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {value: true});

exports.default = {
	Enum: {}
};

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/hxEnums_stub.js":
/*!******************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/hxEnums_stub.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {value: true});

exports.default = {};

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/import_stub.js":
/*!*****************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/import_stub.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {value: true});

// exports.default = function $import(obj) {
// 	if(obj && obj.__esModule) {
// 		// if(!obj.hasOwnProperty('default')) obj.default = obj;
// 		return obj;
// 	} else { 
// 		var newObj = {};
// 		if (obj != null) {
// 			for (var key in obj) {
// 				if (Object.prototype.hasOwnProperty.call(obj, key))
// 					newObj[key] = obj[key];
// 			}
// 		} 
// 		newObj.default = obj;
// 		return newObj;
// 	}
// }
exports.default = function $import(obj) {
	return obj && obj.__esModule ? obj : {default: obj};
}


/***/ }),

/***/ "./node_modules/openfl/lib/_gen/js/Boot.js":
/*!*************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/js/Boot.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: js.Boot

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_CallStack() {return __webpack_require__(/*! ./../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function Std() {return __webpack_require__(/*! ./../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Boot = function(){}

// Meta

Boot.__name__ = "js.Boot";
Boot.__isInterface__ = false;
Boot.prototype = {
	
};
Boot.prototype.__class__ = Boot.prototype.constructor = $hxClasses["js.Boot"] = Boot;

// Init

Boot.__toStr = ({ }).toString;

// Statics

Boot.isClass = function(o) {
	return o.__name__;
}
Boot.isInterface = function(o) {
	return o.__isInterface__;
}
Boot.isEnum = function(e) {
	return e.__ename__;
}
Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = Boot.__nativeClassName(o);
		if(name != null) {
			return Boot.__resolveNativeClass(name);
		}
		return null;
	}
}
Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (Boot.isClass(o) || Boot.isEnum(o))) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			(haxe_CallStack().default).lastException = e1;
			var e2 = ((e1) instanceof (js__$Boot_HaxeError().default)) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
}
Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	if(Object.prototype.hasOwnProperty.call(cc,"__interfaces__")) {
		var intf = cc.__interfaces__;
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return Boot.__interfLoop(cc.__super__,cl);
}
Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case $hxClasses["Bool"]:
		return typeof(o) == "boolean";
	case $hxClasses["Dynamic"]:
		return o != null;
	case $hxClasses["Float"]:
		return typeof(o) == "number";
	case $hxClasses["Int"]:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == $hxClasses["Class"] ? o.__name__ != null : false) {
			return true;
		}
		if(cl == $hxClasses["Enum"] ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
}
Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(Boot.isInterface(cl)) {
			return Boot.__interfLoop(Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
}
Boot.__implements = function(o,iface) {
	return Boot.__interfLoop(Boot.getClass(o),iface);
}
Boot.__cast = function(o,t) {
	if(o == null || Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new (js__$Boot_HaxeError().default)("Cannot cast " + (Std().default).string(o) + " to " + (Std().default).string(t));
	}
}
Boot.__nativeClassName = function(o) {
	var name = Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
}
Boot.__isNativeObj = function(o) {
	return Boot.__nativeClassName(o) != null;
}
Boot.__resolveNativeClass = function(name) {
	return $global[name];
}


// Export

exports.default = Boot;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/js/Browser.js":
/*!****************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/js/Browser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: js.Browser

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_CallStack() {return __webpack_require__(/*! ./../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function Std() {return __webpack_require__(/*! ./../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Browser = function(){}

// Meta

Browser.__name__ = "js.Browser";
Browser.__isInterface__ = false;
Browser.prototype = {
	
};
Browser.prototype.__class__ = Browser.prototype.constructor = $hxClasses["js.Browser"] = Browser;

// Init



// Statics

Browser.getLocalStorage = function() {
	try {
		var s = window.localStorage;
		s.getItem("");
		if(s.length == 0) {
			var key = "_hx_" + Math.random();
			s.setItem(key,key);
			s.removeItem(key);
		}
		return s;
	} catch( e ) {
		(haxe_CallStack().default).lastException = e;
		var e1 = ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e;
		return null;
	}
}
Browser.alert = function(v) {
	window.alert((Std().default).string(v));
}


// Export

exports.default = Browser;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/js/Lib.js":
/*!************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/js/Lib.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: js.Lib

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var Lib = function(){}

// Meta

Lib.__name__ = "js.Lib";
Lib.__isInterface__ = false;
Lib.prototype = {
	
};
Lib.prototype.__class__ = Lib.prototype.constructor = $hxClasses["js.Lib"] = Lib;

// Init



// Statics

Lib.eval = function(code) {
	return eval(code);
}
Lib.get_undefined = function() {
	return undefined;
}
Lib.getNextHaxeUID = function() {
	return $global.$haxeUID++;
}


// Export

exports.default = Lib;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: js._Boot.HaxeError

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;

// Constructor

var HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,HaxeError);
	}
}

// Meta

HaxeError.__name__ = "js._Boot.HaxeError";
HaxeError.__isInterface__ = false;
HaxeError.__super__ = Error;
HaxeError.prototype = $extend(Error.prototype, {
	
});
HaxeError.prototype.__class__ = HaxeError.prototype.constructor = $hxClasses["js._Boot.HaxeError"] = HaxeError;

// Init

Object.defineProperty(HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});

// Statics

HaxeError.wrap = function(val) {
	if(((val) instanceof Error)) {
		return val;
	} else {
		return new HaxeError(val);
	}
}


// Export

exports.default = HaxeError;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/js/html/_CanvasElement/CanvasUtil.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/js/html/_CanvasElement/CanvasUtil.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: js.html._CanvasElement.CanvasUtil

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var CanvasUtil = function(){}

// Meta

CanvasUtil.__name__ = "js.html._CanvasElement.CanvasUtil";
CanvasUtil.__isInterface__ = false;
CanvasUtil.prototype = {
	
};
CanvasUtil.prototype.__class__ = CanvasUtil.prototype.constructor = $hxClasses["js.html._CanvasElement.CanvasUtil"] = CanvasUtil;

// Init



// Statics

CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var name = "webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	var name1 = "experimental-webgl";
	var ctx1 = canvas.getContext(name1,attribs);
	if(ctx1 != null) {
		return ctx1;
	}
	return null;
}


// Export

exports.default = CanvasUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/GameDeviceData.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/GameDeviceData.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.backend.html5.GameDeviceData

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var GameDeviceData = function() {
	this.connected = true;
	this.buttons = [];
	this.axes = [];
}

// Meta

GameDeviceData.__name__ = "lime._internal.backend.html5.GameDeviceData";
GameDeviceData.__isInterface__ = false;
GameDeviceData.prototype = {
	
};
GameDeviceData.prototype.__class__ = GameDeviceData.prototype.constructor = $hxClasses["lime._internal.backend.html5.GameDeviceData"] = GameDeviceData;

// Init



// Statics




// Export

exports.default = GameDeviceData;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5Application.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5Application.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.backend.html5.HTML5Application

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_ui_Joystick() {return __webpack_require__(/*! ./../../../../lime/ui/Joystick */ "./node_modules/openfl/lib/_gen/lime/ui/Joystick.js");}
function lime__$internal_backend_html5_GameDeviceData() {return __webpack_require__(/*! ./../../../../lime/_internal/backend/html5/GameDeviceData */ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/GameDeviceData.js");}
function lime_ui_Gamepad() {return __webpack_require__(/*! ./../../../../lime/ui/Gamepad */ "./node_modules/openfl/lib/_gen/lime/ui/Gamepad.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function lime_media_AudioManager() {return __webpack_require__(/*! ./../../../../lime/media/AudioManager */ "./node_modules/openfl/lib/_gen/lime/media/AudioManager.js");}
function lime_system_Sensor() {return __webpack_require__(/*! ./../../../../lime/system/Sensor */ "./node_modules/openfl/lib/_gen/lime/system/Sensor.js");}
function lime_system_SensorType() {return __webpack_require__(/*! ./../../../../lime/system/SensorType */ "./node_modules/openfl/lib/_gen/lime/system/SensorType.js");}

// Constructor

var HTML5Application = function(parent) {
	this.gameDeviceCache = new (haxe_ds_IntMap().default)();
	this.parent = parent;
	this.currentUpdate = 0;
	this.lastUpdate = 0;
	this.nextUpdate = 0;
	this.framePeriod = -1;
	(lime_media_AudioManager().default).init();
	this.accelerometer = (lime_system_Sensor().default).registerSensor((lime_system_SensorType().default).ACCELEROMETER,0);
}

// Meta

HTML5Application.__name__ = "lime._internal.backend.html5.HTML5Application";
HTML5Application.__isInterface__ = false;
HTML5Application.prototype = {
	convertKeyCode: function(keyCode) {
		if(keyCode >= 65 && keyCode <= 90) {
			return keyCode + 32;
		}
		switch(keyCode) {
		case 12:
			return 1073741980;
		case 16:
			return 1073742049;
		case 17:
			return 1073742048;
		case 18:
			return 1073742050;
		case 19:
			return 1073741896;
		case 20:
			return 1073741881;
		case 33:
			return 1073741899;
		case 34:
			return 1073741902;
		case 35:
			return 1073741901;
		case 36:
			return 1073741898;
		case 37:
			return 1073741904;
		case 38:
			return 1073741906;
		case 39:
			return 1073741903;
		case 40:
			return 1073741905;
		case 41:
			return 1073741943;
		case 43:
			return 1073741940;
		case 44:
			return 1073741894;
		case 45:
			return 1073741897;
		case 46:
			return 127;
		case 91:
			return 1073742051;
		case 92:
			return 1073742055;
		case 93:
			return 1073742055;
		case 95:
			return 1073742106;
		case 96:
			return 1073741922;
		case 97:
			return 1073741913;
		case 98:
			return 1073741914;
		case 99:
			return 1073741915;
		case 100:
			return 1073741916;
		case 101:
			return 1073741917;
		case 102:
			return 1073741918;
		case 103:
			return 1073741919;
		case 104:
			return 1073741920;
		case 105:
			return 1073741921;
		case 106:
			return 1073741909;
		case 107:
			return 1073741911;
		case 108:
			return 1073741923;
		case 109:
			return 1073741910;
		case 110:
			return 1073741923;
		case 111:
			return 1073741908;
		case 112:
			return 1073741882;
		case 113:
			return 1073741883;
		case 114:
			return 1073741884;
		case 115:
			return 1073741885;
		case 116:
			return 1073741886;
		case 117:
			return 1073741887;
		case 118:
			return 1073741888;
		case 119:
			return 1073741889;
		case 120:
			return 1073741890;
		case 121:
			return 1073741891;
		case 122:
			return 1073741892;
		case 123:
			return 1073741893;
		case 124:
			return 1073741928;
		case 125:
			return 1073741929;
		case 126:
			return 1073741930;
		case 127:
			return 1073741931;
		case 128:
			return 1073741932;
		case 129:
			return 1073741933;
		case 130:
			return 1073741934;
		case 131:
			return 1073741935;
		case 132:
			return 1073741936;
		case 133:
			return 1073741937;
		case 134:
			return 1073741938;
		case 135:
			return 1073741939;
		case 144:
			return 1073741907;
		case 145:
			return 1073741895;
		case 160:
			return 94;
		case 161:
			return 33;
		case 163:
			return 35;
		case 164:
			return 36;
		case 166:
			return 1073742094;
		case 167:
			return 1073742095;
		case 168:
			return 1073742097;
		case 169:
			return 41;
		case 170:
			return 42;
		case 171:
			return 96;
		case 172:
			return 1073741898;
		case 173:
			return 45;
		case 174:
			return 1073741953;
		case 175:
			return 1073741952;
		case 176:
			return 1073742082;
		case 177:
			return 1073742083;
		case 178:
			return 1073742084;
		case 179:
			return 1073742085;
		case 180:
			return 1073742089;
		case 181:
			return 1073742086;
		case 182:
			return 1073741953;
		case 183:
			return 1073741952;
		case 186:
			return 59;
		case 187:
			return 61;
		case 188:
			return 44;
		case 189:
			return 45;
		case 190:
			return 46;
		case 191:
			return 47;
		case 192:
			return 96;
		case 193:
			return 63;
		case 194:
			return 1073741923;
		case 219:
			return 91;
		case 220:
			return 92;
		case 221:
			return 93;
		case 222:
			return 39;
		case 223:
			return 96;
		case 224:
			return 1073742051;
		case 226:
			return 92;
		}
		return keyCode;
	},
	exec: function() {
		window.addEventListener("keydown",$bind(this,this.handleKeyEvent),false);
		window.addEventListener("keyup",$bind(this,this.handleKeyEvent),false);
		window.addEventListener("focus",$bind(this,this.handleWindowEvent),false);
		window.addEventListener("blur",$bind(this,this.handleWindowEvent),false);
		window.addEventListener("resize",$bind(this,this.handleWindowEvent),false);
		window.addEventListener("beforeunload",$bind(this,this.handleWindowEvent),false);
		window.addEventListener("devicemotion",$bind(this,this.handleSensorEvent),false);
		
				if (!CanvasRenderingContext2D.prototype.isPointInStroke) {
					CanvasRenderingContext2D.prototype.isPointInStroke = function (path, x, y) {
						return false;
					};
				}
				if (!CanvasRenderingContext2D.prototype.isPointInPath) {
					CanvasRenderingContext2D.prototype.isPointInPath = function (path, x, y) {
						return false;
					};
				}
	
				if ('performance' in window == false) {
					window.performance = {};
				}
	
				if ('now' in window.performance == false) {
					var offset = Date.now();
					if (performance.timing && performance.timing.navigationStart) {
						offset = performance.timing.navigationStart
					}
					window.performance.now = function now() {
						return Date.now() - offset;
					}
				}
	
				var lastTime = 0;
				var vendors = ['ms', 'moz', 'webkit', 'o'];
				for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
					window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
					window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
				}
	
				if (!window.requestAnimationFrame)
					window.requestAnimationFrame = function(callback, element) {
						var currTime = new Date().getTime();
						var timeToCall = Math.max(0, 16 - (currTime - lastTime));
						var id = window.setTimeout(function() { callback(currTime + timeToCall); },
						  timeToCall);
						lastTime = currTime + timeToCall;
						return id;
					};
	
				if (!window.cancelAnimationFrame)
					window.cancelAnimationFrame = function(id) {
						clearTimeout(id);
					};
	
				window.requestAnimFrame = window.requestAnimationFrame;
			;
		this.lastUpdate = new Date().getTime();
		this.handleApplicationEvent();
		return 0;
	},
	exit: function() {
	},
	handleApplicationEvent: function(__) {
		var _g = 0;
		var _g1 = this.parent.__windows;
		while(_g < _g1.length) {
			var $window = _g1[_g];
			++_g;
			$window.__backend.updateSize();
		}
		this.updateGameDevices();
		this.currentUpdate = new Date().getTime();
		if(this.currentUpdate >= this.nextUpdate) {
			this.deltaTime = this.currentUpdate - this.lastUpdate;
			var _g2 = 0;
			var _g3 = this.parent.__windows;
			while(_g2 < _g3.length) {
				var window1 = _g3[_g2];
				++_g2;
				this.parent.onUpdate.dispatch((Std().default).int(this.deltaTime));
				if(window1.context != null) {
					window1.onRender.dispatch(window1.context);
				}
			}
			if(this.framePeriod < 0) {
				this.nextUpdate = this.currentUpdate;
			} else {
				this.nextUpdate = this.currentUpdate - this.currentUpdate % this.framePeriod + this.framePeriod;
			}
			this.lastUpdate = this.currentUpdate;
		}
		window.requestAnimationFrame($bind(this,this.handleApplicationEvent));
	},
	handleKeyEvent: function(event) {
		if(this.parent.get_window() != null) {
			var keyCode = this.convertKeyCode(event.keyCode != null ? event.keyCode : event.which);
			var modifier = (event.shiftKey ? 3 : 0) | (event.ctrlKey ? 192 : 0) | (event.altKey ? 768 : 0) | (event.metaKey ? 3072 : 0);
			if(event.type == "keydown") {
				this.parent.get_window().onKeyDown.dispatch(keyCode,modifier);
				if(this.parent.get_window().onKeyDown.canceled && event.cancelable) {
					event.preventDefault();
				}
			} else {
				this.parent.get_window().onKeyUp.dispatch(keyCode,modifier);
				if(this.parent.get_window().onKeyUp.canceled && event.cancelable) {
					event.preventDefault();
				}
			}
		}
	},
	handleSensorEvent: function(event) {
		this.accelerometer.onUpdate.dispatch(event.accelerationIncludingGravity.x,event.accelerationIncludingGravity.y,event.accelerationIncludingGravity.z);
	},
	handleWindowEvent: function(event) {
		if(this.parent.get_window() != null) {
			switch(event.type) {
			case "beforeunload":
				break;
			case "blur":
				this.parent.get_window().onFocusOut.dispatch();
				this.parent.get_window().onDeactivate.dispatch();
				break;
			case "focus":
				this.parent.get_window().onFocusIn.dispatch();
				this.parent.get_window().onActivate.dispatch();
				break;
			case "resize":
				this.parent.get_window().__backend.handleResizeEvent(event);
				break;
			}
		}
	},
	updateGameDevices: function() {
		var devices = (lime_ui_Joystick().default).__getDeviceData();
		if(devices == null) {
			return;
		}
		var id;
		var gamepad;
		var joystick;
		var data;
		var cache;
		var _g = 0;
		var _g1 = devices.length;
		while(_g < _g1) {
			var i = _g++;
			id = i;
			data = devices[id];
			if(data == null) {
				continue;
			}
			if(!this.gameDeviceCache.exists(id)) {
				cache = new (lime__$internal_backend_html5_GameDeviceData().default)();
				cache.id = id;
				cache.connected = data.connected;
				var _g2 = 0;
				var _g11 = data.buttons.length;
				while(_g2 < _g11) {
					var i1 = _g2++;
					cache.buttons.push(data.buttons[i1].value);
				}
				var _g21 = 0;
				var _g3 = data.axes.length;
				while(_g21 < _g3) {
					var i2 = _g21++;
					cache.axes.push(data.axes[i2]);
				}
				if(data.mapping == "standard") {
					cache.isGamepad = true;
				}
				this.gameDeviceCache.set(id,cache);
				if(data.connected) {
					(lime_ui_Joystick().default).__connect(id);
					if(cache.isGamepad) {
						(lime_ui_Gamepad().default).__connect(id);
					}
				}
			}
			cache = this.gameDeviceCache.get(id);
			joystick = (lime_ui_Joystick().default).devices.get(id);
			gamepad = (lime_ui_Gamepad().default).devices.get(id);
			if(data.connected) {
				var button;
				var value;
				var _g4 = 0;
				var _g12 = data.buttons.length;
				while(_g4 < _g12) {
					var i3 = _g4++;
					value = data.buttons[i3].value;
					if(value != cache.buttons[i3]) {
						if(i3 == 6) {
							joystick.onAxisMove.dispatch(data.axes.length,value);
							if(gamepad != null) {
								gamepad.onAxisMove.dispatch(4,value);
							}
						} else if(i3 == 7) {
							joystick.onAxisMove.dispatch(data.axes.length + 1,value);
							if(gamepad != null) {
								gamepad.onAxisMove.dispatch(5,value);
							}
						} else {
							if(value > 0) {
								joystick.onButtonDown.dispatch(i3);
							} else {
								joystick.onButtonUp.dispatch(i3);
							}
							if(gamepad != null) {
								switch(i3) {
								case 0:
									button = 0;
									break;
								case 1:
									button = 1;
									break;
								case 2:
									button = 2;
									break;
								case 3:
									button = 3;
									break;
								case 4:
									button = 9;
									break;
								case 5:
									button = 10;
									break;
								case 8:
									button = 4;
									break;
								case 9:
									button = 6;
									break;
								case 10:
									button = 7;
									break;
								case 11:
									button = 8;
									break;
								case 12:
									button = 11;
									break;
								case 13:
									button = 12;
									break;
								case 14:
									button = 13;
									break;
								case 15:
									button = 14;
									break;
								case 16:
									button = 5;
									break;
								default:
									continue;
								}
								if(value > 0) {
									gamepad.onButtonDown.dispatch(button);
								} else {
									gamepad.onButtonUp.dispatch(button);
								}
							}
						}
						cache.buttons[i3] = value;
					}
				}
				var _g22 = 0;
				var _g31 = data.axes.length;
				while(_g22 < _g31) {
					var i4 = _g22++;
					if(data.axes[i4] != cache.axes[i4]) {
						joystick.onAxisMove.dispatch(i4,data.axes[i4]);
						if(gamepad != null) {
							gamepad.onAxisMove.dispatch(i4,data.axes[i4]);
						}
						cache.axes[i4] = data.axes[i4];
					}
				}
			} else if(cache.connected) {
				cache.connected = false;
				(lime_ui_Joystick().default).__disconnect(id);
				(lime_ui_Gamepad().default).__disconnect(id);
			}
		}
	}
};
HTML5Application.prototype.__class__ = HTML5Application.prototype.constructor = $hxClasses["lime._internal.backend.html5.HTML5Application"] = HTML5Application;

// Init



// Statics




// Export

exports.default = HTML5Application;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5AudioSource.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5AudioSource.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.backend.html5.HTML5AudioSource

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $bind = __webpack_require__(/*! ./../../../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_math_Vector4() {return __webpack_require__(/*! ./../../../../lime/math/Vector4 */ "./node_modules/openfl/lib/_gen/lime/math/Vector4.js");}

// Constructor

var HTML5AudioSource = function(parent) {
	this.parent = parent;
	this.id = -1;
	this.gain = 1;
	this.position = new (lime_math_Vector4().default)();
}

// Meta

HTML5AudioSource.__name__ = "lime._internal.backend.html5.HTML5AudioSource";
HTML5AudioSource.__isInterface__ = false;
HTML5AudioSource.prototype = {
	dispose: function() {
	},
	init: function() {
	},
	play: function() {
		if(this.playing || this.parent.buffer == null || this.parent.buffer.__srcHowl == null) {
			return;
		}
		this.playing = true;
		var time = this.getCurrentTime();
		this.completed = false;
		var cacheVolume = this.parent.buffer.__srcHowl._volume;
		this.parent.buffer.__srcHowl._volume = this.parent.get_gain();
		this.id = this.parent.buffer.__srcHowl.play();
		this.parent.buffer.__srcHowl._volume = cacheVolume;
		this.setPosition(this.parent.get_position());
		this.parent.buffer.__srcHowl.on("end",$bind(this,this.howl_onEnd),this.id);
		this.setCurrentTime(time);
	},
	pause: function() {
		this.playing = false;
		if(this.parent.buffer != null && this.parent.buffer.__srcHowl != null) {
			this.parent.buffer.__srcHowl.pause(this.id);
		}
	},
	stop: function() {
		this.playing = false;
		if(this.parent.buffer != null && this.parent.buffer.__srcHowl != null) {
			this.parent.buffer.__srcHowl.stop(this.id);
			this.parent.buffer.__srcHowl.off("end",$bind(this,this.howl_onEnd),this.id);
		}
	},
	howl_onEnd: function() {
		this.playing = false;
		if(this.loops > 0) {
			this.loops--;
			this.stop();
			this.play();
			return;
		} else if(this.parent.buffer != null && this.parent.buffer.__srcHowl != null) {
			this.parent.buffer.__srcHowl.stop(this.id);
			this.parent.buffer.__srcHowl.off("end",$bind(this,this.howl_onEnd),this.id);
		}
		this.completed = true;
		this.parent.onComplete.dispatch();
	},
	getCurrentTime: function() {
		if(this.id == -1) {
			return 0;
		}
		if(this.completed) {
			return this.getLength();
		} else if(this.parent.buffer != null && this.parent.buffer.__srcHowl != null) {
			var time = (Std().default).int(this.parent.buffer.__srcHowl.seek(this.id) * 1000) - this.parent.offset;
			if(time < 0) {
				return 0;
			}
			return time;
		}
		return 0;
	},
	setCurrentTime: function(value) {
		if(this.parent.buffer != null && this.parent.buffer.__srcHowl != null) {
			var pos = (value + this.parent.offset) / 1000;
			if(pos < 0) {
				pos = 0;
			}
			this.parent.buffer.__srcHowl.seek(pos,this.id);
		}
		return value;
	},
	getGain: function() {
		return this.gain;
	},
	setGain: function(value) {
		if(this.parent.buffer != null && this.parent.buffer.__srcHowl != null && this.id != -1) {
			this.parent.buffer.__srcHowl.volume(value,this.id);
		}
		return this.gain = value;
	},
	getLength: function() {
		if(this.length != 0) {
			return this.length;
		}
		if(this.parent.buffer != null && this.parent.buffer.__srcHowl != null) {
			return (Std().default).int(this.parent.buffer.__srcHowl.duration() * 1000);
		}
		return 0;
	},
	setLength: function(value) {
		return this.length = value;
	},
	getLoops: function() {
		return this.loops;
	},
	setLoops: function(value) {
		return this.loops = value;
	},
	getPosition: function() {
		return this.position;
	},
	setPosition: function(value) {
		this.position.x = value.x;
		this.position.y = value.y;
		this.position.z = value.z;
		this.position.w = value.w;
		if(this.parent.buffer.__srcHowl != null && this.parent.buffer.__srcHowl.pos != null) {
			this.parent.buffer.__srcHowl.pos(this.position.x,this.position.y,this.position.z,this.id);
		}
		return this.position;
	}
};
HTML5AudioSource.prototype.__class__ = HTML5AudioSource.prototype.constructor = $hxClasses["lime._internal.backend.html5.HTML5AudioSource"] = HTML5AudioSource;

// Init



// Statics




// Export

exports.default = HTML5AudioSource;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5HTTPRequest.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5HTTPRequest.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.backend.html5.HTML5HTTPRequest

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Lambda() {return __webpack_require__(/*! ./../../../../Lambda */ "./node_modules/openfl/lib/_gen/Lambda.js");}
function StringTools() {return __webpack_require__(/*! ./../../../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function Std() {return __webpack_require__(/*! ./../../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_app_Promise() {return __webpack_require__(/*! ./../../../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function lime_net_HTTPRequestHeader() {return __webpack_require__(/*! ./../../../../lime/net/HTTPRequestHeader */ "./node_modules/openfl/lib/_gen/lime/net/HTTPRequestHeader.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function haxe_ds_List() {return __webpack_require__(/*! ./../../../../haxe/ds/List */ "./node_modules/openfl/lib/_gen/haxe/ds/List.js");}
function lime__$internal_format_Base64() {return __webpack_require__(/*! ./../../../../lime/_internal/format/Base64 */ "./node_modules/openfl/lib/_gen/lime/_internal/format/Base64.js");}
function lime_graphics_ImageBuffer() {return __webpack_require__(/*! ./../../../../lime/graphics/ImageBuffer */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageBuffer.js");}
function lime_graphics_Image() {return __webpack_require__(/*! ./../../../../lime/graphics/Image */ "./node_modules/openfl/lib/_gen/lime/graphics/Image.js");}
function EReg() {return __webpack_require__(/*! ./../../../../EReg */ "./node_modules/openfl/lib/_gen/EReg.js");}

// Constructor

var HTML5HTTPRequest = function() {
	this.validStatus0 = new (EReg().default)("Tizen","gi").match(window.navigator.userAgent);
}

// Meta

HTML5HTTPRequest.__name__ = "lime._internal.backend.html5.HTML5HTTPRequest";
HTML5HTTPRequest.__isInterface__ = false;
HTML5HTTPRequest.prototype = {
	cancel: function() {
		if(this.request != null) {
			this.request.abort();
		}
	},
	init: function(parent) {
		this.parent = parent;
	},
	load: function(uri,progress,readyStateChange) {
		this.request = new XMLHttpRequest();
		if(this.parent.method == "POST") {
			this.request.upload.addEventListener("progress",progress,false);
		} else {
			this.request.addEventListener("progress",progress,false);
		}
		this.request.onreadystatechange = readyStateChange;
		var query = "";
		if(this.parent.data == null) {
			var key = this.parent.formData.keys();
			while(key.hasNext()) {
				var key1 = key.next();
				if(query.length > 0) {
					query += "&";
				}
				var value = this.parent.formData.get(key1);
				if(key1.indexOf("[]") > -1 && ((value) instanceof Array)) {
					var arrayValue = (Lambda().default).map(value,function(v) {
						return (StringTools().default).urlEncode(v);
					}).join("&amp;" + key1 + "=");
					query += (StringTools().default).urlEncode(key1) + "=" + arrayValue;
				} else {
					query += (StringTools().default).urlEncode(key1) + "=" + (StringTools().default).urlEncode((Std().default).string(value));
				}
			}
			if(this.parent.method == "GET" && query != "") {
				if(uri.indexOf("?") > -1) {
					uri += "&" + query;
				} else {
					uri += "?" + query;
				}
				query = "";
			}
		}
		this.request.open((Std().default).string(this.parent.method),uri,true);
		if(this.parent.timeout > 0) {
			this.request.timeout = this.parent.timeout;
		}
		if(this.binary) {
			this.request.responseType = "arraybuffer";
		}
		var contentType = null;
		var _g = 0;
		var _g1 = this.parent.headers;
		while(_g < _g1.length) {
			var header = _g1[_g];
			++_g;
			if(header.name == "Content-Type") {
				contentType = header.value;
			} else {
				this.request.setRequestHeader(header.name,header.value);
			}
		}
		if(this.parent.contentType != null) {
			contentType = this.parent.contentType;
		}
		if(contentType == null) {
			if(this.parent.data != null) {
				contentType = "application/octet-stream";
			} else if(query != "") {
				contentType = "application/x-www-form-urlencoded";
			}
		}
		if(contentType != null) {
			this.request.setRequestHeader("Content-Type",contentType);
		}
		if(this.parent.withCredentials) {
			this.request.withCredentials = true;
		}
		if(this.parent.data != null) {
			this.request.send(this.parent.data.getData());
		} else {
			this.request.send(query);
		}
	},
	loadData: function(uri) {
		var promise = new (lime_app_Promise().default)();
		if(HTML5HTTPRequest.activeRequests < HTML5HTTPRequest.requestLimit) {
			HTML5HTTPRequest.activeRequests++;
			this.__loadData(uri,promise);
		} else {
			HTML5HTTPRequest.requestQueue.add({ instance : this, uri : uri, promise : promise, type : "BINARY", options : 0});
		}
		return promise.future;
	},
	loadText: function(uri) {
		var promise = new (lime_app_Promise().default)();
		if(HTML5HTTPRequest.activeRequests < HTML5HTTPRequest.requestLimit) {
			HTML5HTTPRequest.activeRequests++;
			this.__loadText(uri,promise);
		} else {
			HTML5HTTPRequest.requestQueue.add({ instance : this, uri : uri, promise : promise, type : "TEXT", options : 0});
		}
		return promise.future;
	},
	processResponse: function() {
		if(this.parent.enableResponseHeaders) {
			this.parent.responseHeaders = [];
			var name;
			var value;
			var _g = 0;
			var _g1 = this.request.getAllResponseHeaders().split("\n");
			while(_g < _g1.length) {
				var line = _g1[_g];
				++_g;
				name = (StringTools().default).trim((HxOverrides().default).substr(line,0,line.indexOf(":")));
				value = (StringTools().default).trim((HxOverrides().default).substr(line,line.indexOf(":") + 1,null));
				if(name != "") {
					this.parent.responseHeaders.push(new (lime_net_HTTPRequestHeader().default)(name,value));
				}
			}
		}
		this.parent.responseStatus = this.request.status;
	},
	__loadData: function(uri,promise) {
		var _gthis = this;
		var progress = function(event) {
			promise.progress(event.loaded,event.total);
		};
		var readyStateChange = function(event1) {
			if(_gthis.request.readyState != 4) {
				return;
			}
			if(_gthis.request.status != null && (_gthis.request.status >= 200 && _gthis.request.status < 400 || _gthis.validStatus0 && _gthis.request.status == 0)) {
				var bytes = null;
				if(_gthis.request.responseType == "") {
					if(_gthis.request.responseText != null) {
						bytes = (haxe_io_Bytes().default).ofString(_gthis.request.responseText);
					}
				} else if(_gthis.request.response != null) {
					bytes = (haxe_io_Bytes().default).ofData(_gthis.request.response);
				}
				_gthis.processResponse();
				promise.complete(bytes);
			} else {
				_gthis.processResponse();
				promise.error(_gthis.request.status);
			}
			_gthis.request = null;
			HTML5HTTPRequest.activeRequests--;
			HTML5HTTPRequest.processQueue();
		};
		this.binary = true;
		this.load(uri,progress,readyStateChange);
	},
	__loadText: function(uri,promise) {
		var _gthis = this;
		var progress = function(event) {
			promise.progress(event.loaded,event.total);
		};
		var readyStateChange = function(event1) {
			if(_gthis.request.readyState != 4) {
				return;
			}
			if(_gthis.request.status != null && (_gthis.request.status >= 200 && _gthis.request.status <= 400 || _gthis.validStatus0 && _gthis.request.status == 0)) {
				_gthis.processResponse();
				promise.complete(_gthis.request.responseText);
			} else {
				_gthis.processResponse();
				promise.error(_gthis.request.status);
			}
			_gthis.request = null;
			HTML5HTTPRequest.activeRequests--;
			HTML5HTTPRequest.processQueue();
		};
		this.binary = false;
		this.load(uri,progress,readyStateChange);
	}
};
HTML5HTTPRequest.prototype.__class__ = HTML5HTTPRequest.prototype.constructor = $hxClasses["lime._internal.backend.html5.HTML5HTTPRequest"] = HTML5HTTPRequest;

// Init



// Statics

HTML5HTTPRequest.loadImage = function(uri) {
	var promise = new (lime_app_Promise().default)();
	if(HTML5HTTPRequest.activeRequests < HTML5HTTPRequest.requestLimit) {
		HTML5HTTPRequest.activeRequests++;
		HTML5HTTPRequest.__loadImage(uri,promise,0);
	} else {
		HTML5HTTPRequest.requestQueue.add({ instance : null, uri : uri, promise : promise, type : "IMAGE", options : 0});
	}
	return promise.future;
}
HTML5HTTPRequest.loadImageFromBytes = function(bytes,type) {
	var uri = HTML5HTTPRequest.__createBlobURIFromBytes(bytes,type);
	if(uri != null) {
		var promise = new (lime_app_Promise().default)();
		if(HTML5HTTPRequest.activeRequests < HTML5HTTPRequest.requestLimit) {
			HTML5HTTPRequest.activeRequests++;
			HTML5HTTPRequest.__loadImage(uri,promise,1);
		} else {
			HTML5HTTPRequest.requestQueue.add({ instance : null, uri : uri, promise : promise, type : "IMAGE", options : 1});
		}
		return promise.future;
	} else {
		return HTML5HTTPRequest.loadImage("data:" + type + ";base64," + (lime__$internal_format_Base64().default).encode(bytes));
	}
}
HTML5HTTPRequest.processQueue = function() {
	if(HTML5HTTPRequest.activeRequests < HTML5HTTPRequest.requestLimit && HTML5HTTPRequest.requestQueue.length > 0) {
		HTML5HTTPRequest.activeRequests++;
		var queueItem = HTML5HTTPRequest.requestQueue.pop();
		switch(queueItem.type) {
		case "BINARY":
			queueItem.instance.__loadData(queueItem.uri,queueItem.promise);
			break;
		case "IMAGE":
			HTML5HTTPRequest.__loadImage(queueItem.uri,queueItem.promise,queueItem.options);
			break;
		case "TEXT":
			queueItem.instance.__loadText(queueItem.uri,queueItem.promise);
			break;
		default:
			HTML5HTTPRequest.activeRequests--;
		}
	}
}
HTML5HTTPRequest.__createBlobURIFromBytes = function(bytes,type) {
	return URL.createObjectURL(new Blob([bytes.getData()],{ type : type}));
}
HTML5HTTPRequest.__fixHostname = function(hostname) {
	if(hostname == null) {
		return "";
	} else {
		return hostname;
	}
}
HTML5HTTPRequest.__fixPort = function(port,protocol) {
	if(port == null || port == "") {
		switch(protocol) {
		case "ftp:":
			return "21";
		case "gopher:":
			return "70";
		case "http:":
			return "80";
		case "https:":
			return "443";
		case "ws:":
			return "80";
		case "wss:":
			return "443";
		default:
			return "";
		}
	}
	return port;
}
HTML5HTTPRequest.__fixProtocol = function(protocol) {
	if(protocol == null || protocol == "") {
		return "http:";
	} else {
		return protocol;
	}
}
HTML5HTTPRequest.__isInMemoryURI = function(uri) {
	if(!(StringTools().default).startsWith(uri,"data:")) {
		return (StringTools().default).startsWith(uri,"blob:");
	} else {
		return true;
	}
}
HTML5HTTPRequest.__isSameOrigin = function(path) {
	if(path == null || path == "") {
		return true;
	}
	if(HTML5HTTPRequest.__isInMemoryURI(path)) {
		return true;
	}
	if(HTML5HTTPRequest.originElement == null) {
		HTML5HTTPRequest.originElement = window.document.createElement("a");
		HTML5HTTPRequest.originHostname = HTML5HTTPRequest.__fixHostname(window.location.hostname);
		HTML5HTTPRequest.originProtocol = HTML5HTTPRequest.__fixProtocol(window.location.protocol);
		HTML5HTTPRequest.originPort = HTML5HTTPRequest.__fixPort(window.location.port,HTML5HTTPRequest.originProtocol);
	}
	var a = HTML5HTTPRequest.originElement;
	a.href = path;
	if(a.hostname == "") {
		a.href = a.href;
	}
	var hostname = HTML5HTTPRequest.__fixHostname(a.hostname);
	var protocol = HTML5HTTPRequest.__fixProtocol(a.protocol);
	var port = HTML5HTTPRequest.__fixPort(a.port,protocol);
	var sameHost = hostname == "" || hostname == HTML5HTTPRequest.originHostname;
	var samePort = port == "" || port == HTML5HTTPRequest.originPort;
	if(protocol != "file:" && sameHost) {
		return samePort;
	} else {
		return false;
	}
}
HTML5HTTPRequest.__loadImage = function(uri,promise,options) {
	var image = new Image();
	if(!HTML5HTTPRequest.__isSameOrigin(uri)) {
		image.crossOrigin = "Anonymous";
	}
	if(HTML5HTTPRequest.supportsImageProgress == null) {
		HTML5HTTPRequest.supportsImageProgress = 'onprogress' in image;
	}
	if(HTML5HTTPRequest.supportsImageProgress || HTML5HTTPRequest.__isInMemoryURI(uri)) {
		image.addEventListener("load",function(event) {
			HTML5HTTPRequest.__revokeBlobURI(uri,options);
			var buffer = new (lime_graphics_ImageBuffer().default)(null,image.width,image.height);
			buffer.__srcImage = image;
			HTML5HTTPRequest.activeRequests--;
			HTML5HTTPRequest.processQueue();
			promise.complete(new (lime_graphics_Image().default)(buffer));
		},false);
		image.addEventListener("progress",function(event1) {
			promise.progress(event1.loaded,event1.total);
		},false);
		image.addEventListener("error",function(event2) {
			HTML5HTTPRequest.__revokeBlobURI(uri,options);
			HTML5HTTPRequest.activeRequests--;
			HTML5HTTPRequest.processQueue();
			promise.error(event2.detail);
		},false);
		image.src = uri;
	} else {
		var request = new XMLHttpRequest();
		request.onload = function(_) {
			HTML5HTTPRequest.activeRequests--;
			HTML5HTTPRequest.processQueue();
			var img = new (lime_graphics_Image().default)();
			img.__fromBytes((haxe_io_Bytes().default).ofData(request.response),function(img1) {
				promise.complete(img1);
			});
		};
		request.onerror = function(event3) {
			promise.error(event3.message);
		};
		request.onprogress = function(event4) {
			if(event4.lengthComputable) {
				promise.progress(event4.loaded,event4.total);
			}
		};
		request.open("GET",uri,true);
		request.responseType = "arraybuffer";
		request.overrideMimeType("text/plain; charset=x-user-defined");
		request.send(null);
	}
}
HTML5HTTPRequest.__revokeBlobURI = function(uri,options) {
	if((options & 1) != 0) {
		URL.revokeObjectURL(uri);
	}
}
HTML5HTTPRequest.OPTION_REVOKE_URL = 1
HTML5HTTPRequest.activeRequests = 0
HTML5HTTPRequest.requestLimit = 17
HTML5HTTPRequest.requestQueue = new (haxe_ds_List().default)()

// Export

exports.default = HTML5HTTPRequest;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5Window.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5Window.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.backend.html5.HTML5Window

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function js_Browser() {return __webpack_require__(/*! ./../../../../js/Browser */ "./node_modules/openfl/lib/_gen/js/Browser.js");}
function lime_graphics_RenderContext() {return __webpack_require__(/*! ./../../../../lime/graphics/RenderContext */ "./node_modules/openfl/lib/_gen/lime/graphics/RenderContext.js");}
function Reflect() {return __webpack_require__(/*! ./../../../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function lime_graphics_opengl_GL() {return __webpack_require__(/*! ./../../../../lime/graphics/opengl/GL */ "./node_modules/openfl/lib/_gen/lime/graphics/opengl/GL.js");}
function lime_system_System() {return __webpack_require__(/*! ./../../../../lime/system/System */ "./node_modules/openfl/lib/_gen/lime/system/System.js");}
function lime_system_Clipboard() {return __webpack_require__(/*! ./../../../../lime/system/Clipboard */ "./node_modules/openfl/lib/_gen/lime/system/Clipboard.js");}
function js_Boot() {return __webpack_require__(/*! ./../../../../js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}
function haxe_Timer() {return __webpack_require__(/*! ./../../../../haxe/Timer */ "./node_modules/openfl/lib/_gen/haxe/Timer.js");}
function lime_ui_Joystick() {return __webpack_require__(/*! ./../../../../lime/ui/Joystick */ "./node_modules/openfl/lib/_gen/lime/ui/Joystick.js");}
function lime_ui_Gamepad() {return __webpack_require__(/*! ./../../../../lime/ui/Gamepad */ "./node_modules/openfl/lib/_gen/lime/ui/Gamepad.js");}
function StringTools() {return __webpack_require__(/*! ./../../../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function lime_ui_MouseWheelMode() {return __webpack_require__(/*! ./../../../../lime/ui/MouseWheelMode */ "./node_modules/openfl/lib/_gen/lime/ui/MouseWheelMode.js");}
function lime_ui_Touch() {return __webpack_require__(/*! ./../../../../lime/ui/Touch */ "./node_modules/openfl/lib/_gen/lime/ui/Touch.js");}
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}
function Std() {return __webpack_require__(/*! ./../../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_graphics_Image() {return __webpack_require__(/*! ./../../../../lime/graphics/Image */ "./node_modules/openfl/lib/_gen/lime/graphics/Image.js");}
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function EReg() {return __webpack_require__(/*! ./../../../../EReg */ "./node_modules/openfl/lib/_gen/EReg.js");}
function haxe_ds_List() {return __webpack_require__(/*! ./../../../../haxe/ds/List */ "./node_modules/openfl/lib/_gen/haxe/ds/List.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function lime_ui_MouseCursor() {return __webpack_require__(/*! ./../../../../lime/ui/MouseCursor */ "./node_modules/openfl/lib/_gen/lime/ui/MouseCursor.js");}

// Constructor

var HTML5Window = function(parent) {
	this.unusedTouchesPool = new (haxe_ds_List().default)();
	this.scale = 1.0;
	this.currentTouches = new (haxe_ds_IntMap().default)();
	this.parent = parent;
	this.cursor = (lime_ui_MouseCursor().default).DEFAULT;
	this.cacheMouseX = 0;
	this.cacheMouseY = 0;
	var attributes = parent.__attributes;
	if(!(Reflect().default).hasField(attributes,"context")) {
		attributes.context = { };
	}
	this.renderType = attributes.context.type;
	if((Reflect().default).hasField(attributes,"element")) {
		parent.element = attributes.element;
	}
	var element = parent.element;
	if((Reflect().default).hasField(attributes,"allowHighDPI") && attributes.allowHighDPI && this.renderType != "dom") {
		this.scale = window.devicePixelRatio;
	}
	parent.__scale = this.scale;
	this.setWidth = (Reflect().default).hasField(attributes,"width") ? attributes.width : 0;
	this.setHeight = (Reflect().default).hasField(attributes,"height") ? attributes.height : 0;
	parent.__width = this.setWidth;
	parent.__height = this.setHeight;
	parent.id = HTML5Window.windowID++;
	if(((element) instanceof HTMLCanvasElement)) {
		this.canvas = element;
	} else if(this.renderType == "dom") {
		this.div = window.document.createElement("div");
	} else {
		this.canvas = window.document.createElement("canvas");
	}
	if(this.canvas != null) {
		var style = this.canvas.style;
		style.setProperty("-webkit-transform","translateZ(0)",null);
		style.setProperty("transform","translateZ(0)",null);
	} else if(this.div != null) {
		var style1 = this.div.style;
		style1.setProperty("-webkit-transform","translate3D(0,0,0)",null);
		style1.setProperty("transform","translate3D(0,0,0)",null);
		style1.position = "relative";
		style1.overflow = "hidden";
		style1.setProperty("-webkit-user-select","none",null);
		style1.setProperty("-moz-user-select","none",null);
		style1.setProperty("-ms-user-select","none",null);
		style1.setProperty("-o-user-select","none",null);
	}
	if(parent.__width == 0 && parent.__height == 0) {
		if(element != null) {
			parent.__width = element.clientWidth;
			parent.__height = element.clientHeight;
		} else {
			parent.__width = window.innerWidth;
			parent.__height = window.innerHeight;
		}
		this.cacheElementWidth = parent.__width;
		this.cacheElementHeight = parent.__height;
		this.resizeElement = true;
	}
	if(this.canvas != null) {
		this.canvas.width = Math.round(parent.__width * this.scale);
		this.canvas.height = Math.round(parent.__height * this.scale);
		this.canvas.style.width = parent.__width + "px";
		this.canvas.style.height = parent.__height + "px";
	} else {
		this.div.style.width = parent.__width + "px";
		this.div.style.height = parent.__height + "px";
	}
	if((Reflect().default).hasField(attributes,"resizable") && attributes.resizable || !(Reflect().default).hasField(attributes,"width") && this.setWidth == 0 && this.setHeight == 0) {
		parent.__resizable = true;
	}
	this.updateSize();
	if(element != null) {
		if(this.canvas != null) {
			if(element != this.canvas) {
				element.appendChild(this.canvas);
			}
		} else {
			element.appendChild(this.div);
		}
		var events = ["mousedown","mouseenter","mouseleave","mousemove","mouseup","wheel"];
		var _g = 0;
		while(_g < events.length) {
			var event = events[_g];
			++_g;
			element.addEventListener(event,$bind(this,this.handleMouseEvent),true);
		}
		element.addEventListener("contextmenu",$bind(this,this.handleContextMenuEvent),true);
		element.addEventListener("dragstart",$bind(this,this.handleDragEvent),true);
		element.addEventListener("dragover",$bind(this,this.handleDragEvent),true);
		element.addEventListener("drop",$bind(this,this.handleDragEvent),true);
		element.addEventListener("touchstart",$bind(this,this.handleTouchEvent),true);
		element.addEventListener("touchmove",$bind(this,this.handleTouchEvent),true);
		element.addEventListener("touchend",$bind(this,this.handleTouchEvent),true);
		element.addEventListener("touchcancel",$bind(this,this.handleTouchEvent),true);
		element.addEventListener("gamepadconnected",$bind(this,this.handleGamepadEvent),true);
		element.addEventListener("gamepaddisconnected",$bind(this,this.handleGamepadEvent),true);
	}
	this.createContext();
	if(parent.context.type == "webgl") {
		this.canvas.addEventListener("webglcontextlost",$bind(this,this.handleContextEvent),false);
		this.canvas.addEventListener("webglcontextrestored",$bind(this,this.handleContextEvent),false);
	}
}

// Meta

HTML5Window.__name__ = "lime._internal.backend.html5.HTML5Window";
HTML5Window.__isInterface__ = false;
HTML5Window.prototype = {
	alert: function(message,title) {
		if(message != null) {
			(js_Browser().default).alert(message);
		}
	},
	close: function() {
		this.parent.application.__removeWindow(this.parent);
	},
	createContext: function() {
		var context = new (lime_graphics_RenderContext().default)();
		var contextAttributes = this.parent.__attributes.context;
		context.window = this.parent;
		context.attributes = contextAttributes;
		if(this.div != null) {
			context.dom = this.div;
			context.type = "dom";
			context.version = "";
		} else if(this.canvas != null) {
			var webgl = null;
			var forceCanvas = this.renderType == "canvas";
			var forceWebGL = this.renderType == "opengl" || this.renderType == "opengles" || this.renderType == "webgl";
			var allowWebGL2 = false;
			var isWebGL2 = false;
			if(forceWebGL || !forceCanvas && (!(Reflect().default).hasField(contextAttributes,"hardware") || contextAttributes.hardware)) {
				var transparentBackground = (Reflect().default).hasField(contextAttributes,"background") && contextAttributes.background == null;
				var colorDepth = (Reflect().default).hasField(contextAttributes,"colorDepth") ? contextAttributes.colorDepth : 16;
				var options = { alpha : transparentBackground || colorDepth > 16, antialias : (Reflect().default).hasField(contextAttributes,"antialiasing") && contextAttributes.antialiasing > 0, depth : (Reflect().default).hasField(contextAttributes,"depth") ? contextAttributes.depth : true, premultipliedAlpha : true, stencil : (Reflect().default).hasField(contextAttributes,"stencil") && contextAttributes.stencil, preserveDrawingBuffer : false, failIfMajorPerformanceCaveat : true};
				var glContextType = ["webgl","experimental-webgl"];
				if(allowWebGL2) {
					glContextType.unshift("webgl2");
				}
				var _g = 0;
				while(_g < glContextType.length) {
					var name = glContextType[_g];
					++_g;
					webgl = this.canvas.getContext(name,options);
					if(webgl != null && name == "webgl2") {
						isWebGL2 = true;
					}
					if(webgl != null) {
						break;
					}
				}
			}
			if(webgl == null) {
				context.canvas2D = this.canvas.getContext("2d");
				context.type = "canvas";
				context.version = "";
			} else {
				context.webgl = (lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).fromWebGL2RenderContext(webgl);
				if(isWebGL2) {
					context.webgl2 = webgl;
				}
				if((lime_graphics_opengl_GL().default).context == null) {
					(lime_graphics_opengl_GL().default).context = webgl;
					(lime_graphics_opengl_GL().default).type = "webgl";
					(lime_graphics_opengl_GL().default).version = isWebGL2 ? 2 : 1;
				}
				context.type = "webgl";
				context.version = isWebGL2 ? "2" : "1";
			}
		}
		this.parent.context = context;
	},
	focus: function() {
	},
	getCursor: function() {
		return this.cursor;
	},
	getDisplay: function() {
		return (lime_system_System().default).getDisplay(0);
	},
	getDisplayMode: function() {
		return (lime_system_System().default).getDisplay(0).currentMode;
	},
	getFrameRate: function() {
		if(this.parent.application == null) {
			return 0;
		}
		if(this.parent.application.__backend.framePeriod < 0) {
			return 60;
		} else if(this.parent.application.__backend.framePeriod == 1000) {
			return 0;
		} else {
			return 1000 / this.parent.application.__backend.framePeriod;
		}
	},
	getMouseLock: function() {
		return false;
	},
	getTextInputEnabled: function() {
		return this.textInputEnabled;
	},
	handleContextEvent: function(event) {
		switch(event.type) {
		case "webglcontextlost":
			if(event.cancelable) {
				event.preventDefault();
			}
			var tmp = (lime_graphics_opengl_GL().default).context != null;
			this.parent.context = null;
			this.parent.onRenderContextLost.dispatch();
			break;
		case "webglcontextrestored":
			this.createContext();
			this.parent.onRenderContextRestored.dispatch(this.parent.context);
			break;
		default:
		}
	},
	handleContextMenuEvent: function(event) {
		if((this.parent.onMouseUp.canceled || this.parent.onMouseDown.canceled) && event.cancelable) {
			event.preventDefault();
		}
	},
	handleCutOrCopyEvent: function(event) {
		event.clipboardData.setData("text/plain",(lime_system_Clipboard().default).get_text());
		if(event.cancelable) {
			event.preventDefault();
		}
	},
	handleDragEvent: function(event) {
		switch(event.type) {
		case "dragover":
			event.preventDefault();
			return false;
		case "dragstart":
			if(((js_Boot().default).__cast(event.target , HTMLElement)).nodeName.toLowerCase() == "img" && event.cancelable) {
				event.preventDefault();
				return false;
			}
			break;
		case "drop":
			if(event.dataTransfer != null && event.dataTransfer.files.length > 0) {
				this.parent.onDropFile.dispatch(event.dataTransfer.files);
				event.preventDefault();
				return false;
			}
			break;
		}
		return true;
	},
	handleFocusEvent: function(event) {
		var _gthis = this;
		if(this.textInputEnabled) {
			if(event.relatedTarget == null || this.isDescendent(event.relatedTarget)) {
				(haxe_Timer().default).delay(function() {
					if(_gthis.textInputEnabled) {
						HTML5Window.textInput.focus();
					}
				},20);
			}
		}
	},
	handleFullscreenEvent: function(event) {
		var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
		if(fullscreenElement != null) {
			this.isFullscreen = true;
			this.parent.__fullscreen = true;
			if(this.requestedFullscreen) {
				this.requestedFullscreen = false;
				this.parent.onFullscreen.dispatch();
			}
		} else {
			this.isFullscreen = false;
			this.parent.__fullscreen = false;
			this.parent.onRestore.dispatch();
			var changeEvents = ["fullscreenchange","mozfullscreenchange","webkitfullscreenchange","MSFullscreenChange"];
			var errorEvents = ["fullscreenerror","mozfullscreenerror","webkitfullscreenerror","MSFullscreenError"];
			var _g = 0;
			var _g1 = changeEvents.length;
			while(_g < _g1) {
				var i = _g++;
				window.document.removeEventListener(changeEvents[i],$bind(this,this.handleFullscreenEvent),false);
				window.document.removeEventListener(errorEvents[i],$bind(this,this.handleFullscreenEvent),false);
			}
		}
	},
	handleGamepadEvent: function(event) {
		switch(event.type) {
		case "gamepadconnected":
			(lime_ui_Joystick().default).__connect(event.gamepad.index);
			if(event.gamepad.mapping == "standard") {
				(lime_ui_Gamepad().default).__connect(event.gamepad.index);
			}
			break;
		case "gamepaddisconnected":
			(lime_ui_Joystick().default).__disconnect(event.gamepad.index);
			(lime_ui_Gamepad().default).__disconnect(event.gamepad.index);
			break;
		default:
		}
	},
	handleInputEvent: function(event) {
		if(HTML5Window.textInput.value != HTML5Window.dummyCharacter) {
			var value = (StringTools().default).replace(HTML5Window.textInput.value,HTML5Window.dummyCharacter,"");
			if(value.length > 0) {
				this.parent.onTextInput.dispatch(value);
			}
			HTML5Window.textInput.value = HTML5Window.dummyCharacter;
		}
	},
	handleMouseEvent: function(event) {
		var x = 0.0;
		var y = 0.0;
		if(event.type != "wheel") {
			if(this.parent.element != null) {
				if(this.canvas != null) {
					var rect = this.canvas.getBoundingClientRect();
					x = (event.clientX - rect.left) * (this.parent.__width / rect.width);
					y = (event.clientY - rect.top) * (this.parent.__height / rect.height);
				} else if(this.div != null) {
					var rect1 = this.div.getBoundingClientRect();
					x = event.clientX - rect1.left;
					y = event.clientY - rect1.top;
				} else {
					var rect2 = this.parent.element.getBoundingClientRect();
					x = (event.clientX - rect2.left) * (this.parent.__width / rect2.width);
					y = (event.clientY - rect2.top) * (this.parent.__height / rect2.height);
				}
			} else {
				x = event.clientX;
				y = event.clientY;
			}
			switch(event.type) {
			case "mousedown":
				if(event.currentTarget == this.parent.element) {
					window.addEventListener("mouseup",$bind(this,this.handleMouseEvent));
				}
				this.parent.onMouseDown.dispatch(x,y,event.button);
				if(this.parent.onMouseDown.canceled && event.cancelable) {
					event.preventDefault();
				}
				break;
			case "mouseenter":
				if(event.target == this.parent.element) {
					this.parent.onEnter.dispatch();
					if(this.parent.onEnter.canceled && event.cancelable) {
						event.preventDefault();
					}
				}
				break;
			case "mouseleave":
				if(event.target == this.parent.element) {
					this.parent.onLeave.dispatch();
					if(this.parent.onLeave.canceled && event.cancelable) {
						event.preventDefault();
					}
				}
				break;
			case "mousemove":
				if(x != this.cacheMouseX || y != this.cacheMouseY) {
					this.parent.onMouseMove.dispatch(x,y);
					this.parent.onMouseMoveRelative.dispatch(x - this.cacheMouseX,y - this.cacheMouseY);
					if((this.parent.onMouseMove.canceled || this.parent.onMouseMoveRelative.canceled) && event.cancelable) {
						event.preventDefault();
					}
				}
				break;
			case "mouseup":
				window.removeEventListener("mouseup",$bind(this,this.handleMouseEvent));
				if(event.currentTarget == this.parent.element) {
					event.stopPropagation();
				}
				this.parent.onMouseUp.dispatch(x,y,event.button);
				if(this.parent.onMouseUp.canceled && event.cancelable) {
					event.preventDefault();
				}
				break;
			default:
			}
			this.cacheMouseX = x;
			this.cacheMouseY = y;
		} else {
			var deltaMode;
			switch(event.deltaMode) {
			case 0:
				deltaMode = (lime_ui_MouseWheelMode().default).PIXELS;
				break;
			case 1:
				deltaMode = (lime_ui_MouseWheelMode().default).LINES;
				break;
			case 2:
				deltaMode = (lime_ui_MouseWheelMode().default).PAGES;
				break;
			default:
				deltaMode = (lime_ui_MouseWheelMode().default).UNKNOWN;
			}
			this.parent.onMouseWheel.dispatch(event.deltaX,-event.deltaY,deltaMode);
			if(this.parent.onMouseWheel.canceled && event.cancelable) {
				event.preventDefault();
			}
		}
	},
	handlePasteEvent: function(event) {
		if(event.clipboardData.types.indexOf("text/plain") > -1) {
			var text = event.clipboardData.getData("text/plain");
			(lime_system_Clipboard().default).set_text(text);
			if(this.textInputEnabled) {
				this.parent.onTextInput.dispatch(text);
			}
			if(event.cancelable) {
				event.preventDefault();
			}
		}
	},
	handleResizeEvent: function(event) {
		this.primaryTouch = null;
		this.updateSize();
	},
	handleTouchEvent: function(event) {
		if(event.cancelable) {
			event.preventDefault();
		}
		var rect = null;
		if(this.parent.element != null) {
			if(this.canvas != null) {
				rect = this.canvas.getBoundingClientRect();
			} else if(this.div != null) {
				rect = this.div.getBoundingClientRect();
			} else {
				rect = this.parent.element.getBoundingClientRect();
			}
		}
		var windowWidth = this.setWidth;
		var windowHeight = this.setHeight;
		if(windowWidth == 0 || windowHeight == 0) {
			if(rect != null) {
				windowWidth = rect.width;
				windowHeight = rect.height;
			} else {
				windowWidth = 1;
				windowHeight = 1;
			}
		}
		var touch;
		var x;
		var y;
		var cacheX;
		var cacheY;
		var _g = 0;
		var _g1 = event.changedTouches;
		while(_g < _g1.length) {
			var data = _g1[_g];
			++_g;
			x = 0.0;
			y = 0.0;
			if(rect != null) {
				x = (data.clientX - rect.left) * (windowWidth / rect.width);
				y = (data.clientY - rect.top) * (windowHeight / rect.height);
			} else {
				x = data.clientX;
				y = data.clientY;
			}
			if(event.type == "touchstart") {
				touch = this.unusedTouchesPool.pop();
				if(touch == null) {
					touch = new (lime_ui_Touch().default)(x / windowWidth,y / windowHeight,data.identifier,0,0,data.force,this.parent.id);
				} else {
					touch.x = x / windowWidth;
					touch.y = y / windowHeight;
					touch.id = data.identifier;
					touch.dx = 0;
					touch.dy = 0;
					touch.pressure = data.force;
					touch.device = this.parent.id;
				}
				this.currentTouches.set(data.identifier,touch);
				(lime_ui_Touch().default).onStart.dispatch(touch);
				if(this.primaryTouch == null) {
					this.primaryTouch = touch;
				}
				if(touch == this.primaryTouch) {
					this.parent.onMouseDown.dispatch(x,y,0);
				}
			} else {
				touch = this.currentTouches.get(data.identifier);
				if(touch != null) {
					cacheX = touch.x;
					cacheY = touch.y;
					touch.x = x / windowWidth;
					touch.y = y / windowHeight;
					touch.dx = touch.x - cacheX;
					touch.dy = touch.y - cacheY;
					touch.pressure = data.force;
					switch(event.type) {
					case "touchcancel":
						(lime_ui_Touch().default).onCancel.dispatch(touch);
						this.currentTouches.remove(data.identifier);
						this.unusedTouchesPool.add(touch);
						if(touch == this.primaryTouch) {
							this.primaryTouch = null;
						}
						break;
					case "touchend":
						(lime_ui_Touch().default).onEnd.dispatch(touch);
						this.currentTouches.remove(data.identifier);
						this.unusedTouchesPool.add(touch);
						if(touch == this.primaryTouch) {
							this.parent.onMouseUp.dispatch(x,y,0);
							this.primaryTouch = null;
						}
						break;
					case "touchmove":
						(lime_ui_Touch().default).onMove.dispatch(touch);
						if(touch == this.primaryTouch) {
							this.parent.onMouseMove.dispatch(x,y);
						}
						break;
					default:
					}
				}
			}
		}
	},
	isDescendent: function(node) {
		if(node == this.parent.element) {
			return true;
		}
		while(node != null) {
			if(node.parentNode == this.parent.element) {
				return true;
			}
			node = node.parentNode;
		}
		return false;
	},
	move: function(x,y) {
	},
	readPixels: function(rect) {
		if(this.canvas != null) {
			var stageRect = new (lime_math_Rectangle().default)(0,0,this.canvas.width,this.canvas.height);
			if(rect == null) {
				rect = stageRect;
			} else {
				rect.intersection(stageRect,rect);
			}
			if(rect.width > 0 && rect.height > 0) {
				var canvas2 = window.document.createElement("canvas");
				canvas2.width = (Std().default).int(rect.width);
				canvas2.height = (Std().default).int(rect.height);
				var context = canvas2.getContext("2d");
				context.drawImage(this.canvas,-rect.x,-rect.y);
				return (lime_graphics_Image().default).fromCanvas(canvas2);
			}
		}
		return null;
	},
	resize: function(width,height) {
	},
	setBorderless: function(value) {
		return value;
	},
	setClipboard: function(value) {
		if(HTML5Window.textArea == null) {
			HTML5Window.textArea = window.document.createElement("textarea");
			HTML5Window.textArea.style.height = "0px";
			HTML5Window.textArea.style.left = "-100px";
			HTML5Window.textArea.style.opacity = "0";
			HTML5Window.textArea.style.position = "fixed";
			HTML5Window.textArea.style.top = "-100px";
			HTML5Window.textArea.style.width = "0px";
			window.document.body.appendChild(HTML5Window.textArea);
		}
		HTML5Window.textArea.value = value;
		HTML5Window.textArea.focus();
		HTML5Window.textArea.select();
		if(window.document.queryCommandEnabled("copy")) {
			window.document.execCommand("copy");
		}
	},
	setCursor: function(value) {
		if(this.cursor != value) {
			if(value == null) {
				this.parent.element.style.cursor = "none";
			} else {
				var tmp;
				switch(value._hx_index) {
				case 0:
					tmp = "default";
					break;
				case 1:
					tmp = "crosshair";
					break;
				case 3:
					tmp = "move";
					break;
				case 4:
					tmp = "pointer";
					break;
				case 5:
					tmp = "nesw-resize";
					break;
				case 6:
					tmp = "ns-resize";
					break;
				case 7:
					tmp = "nwse-resize";
					break;
				case 8:
					tmp = "ew-resize";
					break;
				case 9:
					tmp = "text";
					break;
				case 10:
					tmp = "wait";
					break;
				case 11:
					tmp = "wait";
					break;
				default:
					tmp = "auto";
				}
				this.parent.element.style.cursor = tmp;
			}
			this.cursor = value;
		}
		return this.cursor;
	},
	setDisplayMode: function(value) {
		return value;
	},
	setFrameRate: function(value) {
		if(this.parent.application != null) {
			if(value >= 60) {
				if(this.parent == this.parent.application.get_window()) {
					this.parent.application.__backend.framePeriod = -1;
				}
			} else if(value > 0) {
				if(this.parent == this.parent.application.get_window()) {
					this.parent.application.__backend.framePeriod = 1000 / value;
				}
			} else if(this.parent == this.parent.application.get_window()) {
				this.parent.application.__backend.framePeriod = 1000;
			}
		}
		return value;
	},
	setFullscreen: function(value) {
		if(value) {
			if(!this.requestedFullscreen && !this.isFullscreen) {
				this.requestedFullscreen = true;
				if(($_=this.parent.element,$bind($_,$_.requestFullscreen))) {
					document.addEventListener("fullscreenchange",$bind(this,this.handleFullscreenEvent),false);
					document.addEventListener("fullscreenerror",$bind(this,this.handleFullscreenEvent),false);
					this.parent.element.requestFullscreen();
				} else if(this.parent.element.mozRequestFullScreen) {
					document.addEventListener("mozfullscreenchange",$bind(this,this.handleFullscreenEvent),false);
					document.addEventListener("mozfullscreenerror",$bind(this,this.handleFullscreenEvent),false);
					this.parent.element.mozRequestFullScreen();
				} else if(this.parent.element.webkitRequestFullscreen) {
					document.addEventListener("webkitfullscreenchange",$bind(this,this.handleFullscreenEvent),false);
					document.addEventListener("webkitfullscreenerror",$bind(this,this.handleFullscreenEvent),false);
					this.parent.element.webkitRequestFullscreen();
				} else if(this.parent.element.msRequestFullscreen) {
					document.addEventListener("MSFullscreenChange",$bind(this,this.handleFullscreenEvent),false);
					document.addEventListener("MSFullscreenError",$bind(this,this.handleFullscreenEvent),false);
					this.parent.element.msRequestFullscreen();
				}
			}
		} else if(this.isFullscreen) {
			this.requestedFullscreen = false;
			if(document.exitFullscreen) {
				document.exitFullscreen();
			} else if(document.mozCancelFullScreen) {
				document.mozCancelFullScreen();
			} else if(document.webkitExitFullscreen) {
				document.webkitExitFullscreen();
			} else if(document.msExitFullscreen) {
				document.msExitFullscreen();
			}
		}
		return value;
	},
	setIcon: function(image) {
		(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(image);
		var link = window.document.querySelector("link[rel*='icon']");
		if(link == null) {
			link = window.document.createElement("link");
		}
		link.type = "image/x-icon";
		link.rel = "shortcut icon";
		link.href = image.buffer.get_src().toDataURL("image/x-icon");
		window.document.getElementsByTagName("head")[0].appendChild(link);
	},
	setMaximized: function(value) {
		return false;
	},
	setMinimized: function(value) {
		return false;
	},
	setMouseLock: function(value) {
	},
	setResizable: function(value) {
		return value;
	},
	setTextInputEnabled: function(value) {
		if(value) {
			if(HTML5Window.textInput == null) {
				HTML5Window.textInput = window.document.createElement("input");
				HTML5Window.textInput.type = "text";
				HTML5Window.textInput.style.position = "absolute";
				HTML5Window.textInput.style.opacity = "0";
				HTML5Window.textInput.style.color = "transparent";
				HTML5Window.textInput.value = HTML5Window.dummyCharacter;
				HTML5Window.textInput.autocapitalize = "off";
				HTML5Window.textInput.autocorrect = "off";
				HTML5Window.textInput.autocomplete = "off";
				HTML5Window.textInput.style.left = "0px";
				HTML5Window.textInput.style.top = "50%";
				if(new (EReg().default)("(iPad|iPhone|iPod).*OS 8_","gi").match(window.navigator.userAgent)) {
					HTML5Window.textInput.style.fontSize = "0px";
					HTML5Window.textInput.style.width = "0px";
					HTML5Window.textInput.style.height = "0px";
				} else {
					HTML5Window.textInput.style.width = "1px";
					HTML5Window.textInput.style.height = "1px";
				}
				HTML5Window.textInput.style.pointerEvents = "none";
				HTML5Window.textInput.style.zIndex = "-10000000";
			}
			if(HTML5Window.textInput.parentNode == null) {
				this.parent.element.appendChild(HTML5Window.textInput);
			}
			if(!this.textInputEnabled) {
				HTML5Window.textInput.addEventListener("input",$bind(this,this.handleInputEvent),true);
				HTML5Window.textInput.addEventListener("blur",$bind(this,this.handleFocusEvent),true);
				HTML5Window.textInput.addEventListener("cut",$bind(this,this.handleCutOrCopyEvent),true);
				HTML5Window.textInput.addEventListener("copy",$bind(this,this.handleCutOrCopyEvent),true);
				HTML5Window.textInput.addEventListener("paste",$bind(this,this.handlePasteEvent),true);
			}
			HTML5Window.textInput.focus();
			HTML5Window.textInput.select();
		} else if(HTML5Window.textInput != null) {
			HTML5Window.textInput.removeEventListener("input",$bind(this,this.handleInputEvent),true);
			HTML5Window.textInput.removeEventListener("blur",$bind(this,this.handleFocusEvent),true);
			HTML5Window.textInput.removeEventListener("cut",$bind(this,this.handleCutOrCopyEvent),true);
			HTML5Window.textInput.removeEventListener("copy",$bind(this,this.handleCutOrCopyEvent),true);
			HTML5Window.textInput.removeEventListener("paste",$bind(this,this.handlePasteEvent),true);
			HTML5Window.textInput.blur();
		}
		return this.textInputEnabled = value;
	},
	setTitle: function(value) {
		if(value != null) {
			window.document.title = value;
		}
		return value;
	},
	updateSize: function() {
		if(!this.parent.__resizable) {
			return;
		}
		var elementWidth;
		var elementHeight;
		if(this.parent.element != null) {
			elementWidth = this.parent.element.clientWidth;
			elementHeight = this.parent.element.clientHeight;
		} else {
			elementWidth = window.innerWidth;
			elementHeight = window.innerHeight;
		}
		if(elementWidth != this.cacheElementWidth || elementHeight != this.cacheElementHeight) {
			this.cacheElementWidth = elementWidth;
			this.cacheElementHeight = elementHeight;
			var stretch = this.resizeElement || this.setWidth == 0 && this.setHeight == 0;
			if(this.parent.element != null && (this.div == null || this.div != null && stretch)) {
				if(stretch) {
					if(this.parent.__width != elementWidth || this.parent.__height != elementHeight) {
						this.parent.__width = elementWidth;
						this.parent.__height = elementHeight;
						if(this.canvas != null) {
							if(this.parent.element != this.canvas) {
								this.canvas.width = Math.round(elementWidth * this.scale);
								this.canvas.height = Math.round(elementHeight * this.scale);
								this.canvas.style.width = elementWidth + "px";
								this.canvas.style.height = elementHeight + "px";
							}
						} else {
							this.div.style.width = elementWidth + "px";
							this.div.style.height = elementHeight + "px";
						}
						this.parent.onResize.dispatch(elementWidth,elementHeight);
					}
				} else {
					var scaleX = this.setWidth != 0 ? elementWidth / this.setWidth : 1;
					var scaleY = this.setHeight != 0 ? elementHeight / this.setHeight : 1;
					var targetWidth = elementWidth;
					var targetHeight = elementHeight;
					var marginLeft = 0;
					var marginTop = 0;
					if(scaleX < scaleY) {
						targetHeight = Math.floor(this.setHeight * scaleX);
						marginTop = Math.floor((elementHeight - targetHeight) / 2);
					} else {
						targetWidth = Math.floor(this.setWidth * scaleY);
						marginLeft = Math.floor((elementWidth - targetWidth) / 2);
					}
					if(this.canvas != null) {
						if(this.parent.element != this.canvas) {
							this.canvas.style.width = targetWidth + "px";
							this.canvas.style.height = targetHeight + "px";
							this.canvas.style.marginLeft = marginLeft + "px";
							this.canvas.style.marginTop = marginTop + "px";
						}
					} else {
						this.div.style.width = targetWidth + "px";
						this.div.style.height = targetHeight + "px";
						this.div.style.marginLeft = marginLeft + "px";
						this.div.style.marginTop = marginTop + "px";
					}
				}
			}
		}
	},
	warpMouse: function(x,y) {
	}
};
HTML5Window.prototype.__class__ = HTML5Window.prototype.constructor = $hxClasses["lime._internal.backend.html5.HTML5Window"] = HTML5Window;

// Init



// Statics


HTML5Window.dummyCharacter = ""
HTML5Window.windowID = 0

// Export

exports.default = HTML5Window;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/BMP.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/BMP.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.format.BMP

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime__$internal_format_BMPType() {return __webpack_require__(/*! ./../../../lime/_internal/format/BMPType */ "./node_modules/openfl/lib/_gen/lime/_internal/format/BMPType.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}

// Constructor

var BMP = function(){}

// Meta

BMP.__name__ = "lime._internal.format.BMP";
BMP.__isInterface__ = false;
BMP.prototype = {
	
};
BMP.prototype.__class__ = BMP.prototype.constructor = $hxClasses["lime._internal.format.BMP"] = BMP;

// Init



// Statics

BMP.encode = function(image,type) {
	if(image.get_premultiplied() || image.get_format() != 0) {
		image = image.clone();
		image.set_premultiplied(false);
		image.set_format(0);
	}
	if(type == null) {
		type = (lime__$internal_format_BMPType().default).RGB;
	}
	var fileHeaderLength = 14;
	var infoHeaderLength = 40;
	var pixelValuesLength = image.width * image.height * 4;
	if(type != null) {
		switch(type._hx_index) {
		case 0:
			pixelValuesLength = (image.width * 3 + image.width * 3 % 4) * image.height;
			break;
		case 1:
			infoHeaderLength = 108;
			break;
		case 2:
			fileHeaderLength = 0;
			pixelValuesLength += image.width * image.height;
			break;
		}
	}
	var data = (haxe_io_Bytes().default).alloc(fileHeaderLength + infoHeaderLength + pixelValuesLength);
	var position = 0;
	if(fileHeaderLength > 0) {
		data.set(position++,66);
		data.set(position++,77);
		data.setInt32(position,data.get_length());
		position += 4;
		data.setUInt16(position,0);
		position += 2;
		data.setUInt16(position,0);
		position += 2;
		data.setInt32(position,fileHeaderLength + infoHeaderLength);
		position += 4;
	}
	data.setInt32(position,infoHeaderLength);
	position += 4;
	data.setInt32(position,image.width);
	position += 4;
	data.setInt32(position,type == (lime__$internal_format_BMPType().default).ICO ? image.height * 2 : image.height);
	position += 4;
	data.setUInt16(position,1);
	position += 2;
	data.setUInt16(position,type == (lime__$internal_format_BMPType().default).RGB ? 24 : 32);
	position += 2;
	data.setInt32(position,type == (lime__$internal_format_BMPType().default).BITFIELD ? 3 : 0);
	position += 4;
	data.setInt32(position,pixelValuesLength);
	position += 4;
	data.setInt32(position,11824);
	position += 4;
	data.setInt32(position,11824);
	position += 4;
	data.setInt32(position,0);
	position += 4;
	data.setInt32(position,0);
	position += 4;
	if(type == (lime__$internal_format_BMPType().default).BITFIELD) {
		data.setInt32(position,16711680);
		position += 4;
		data.setInt32(position,65280);
		position += 4;
		data.setInt32(position,255);
		position += 4;
		data.setInt32(position,-16777216);
		position += 4;
		data.set(position++,32);
		data.set(position++,110);
		data.set(position++,105);
		data.set(position++,87);
		var _g = 0;
		while(_g < 48) {
			var i = _g++;
			data.set(position++,0);
		}
	}
	var pixels = image.getPixels(new (lime_math_Rectangle().default)(0,0,image.width,image.height),1);
	var readPosition = 0;
	var a;
	var r;
	var g;
	var b;
	if(type != null) {
		switch(type._hx_index) {
		case 0:
			var _g1 = 0;
			var _g11 = image.height;
			while(_g1 < _g11) {
				var y = _g1++;
				readPosition = (image.height - 1 - y) * 4 * image.width;
				var _g2 = 0;
				var _g12 = image.width;
				while(_g2 < _g12) {
					var x = _g2++;
					a = pixels.get(readPosition++);
					r = pixels.get(readPosition++);
					g = pixels.get(readPosition++);
					b = pixels.get(readPosition++);
					data.set(position++,b);
					data.set(position++,g);
					data.set(position++,r);
				}
				var _g21 = 0;
				var _g3 = image.width * 3 % 4;
				while(_g21 < _g3) {
					var i1 = _g21++;
					data.set(position++,0);
				}
			}
			break;
		case 1:
			var _g4 = 0;
			var _g13 = image.height;
			while(_g4 < _g13) {
				var y1 = _g4++;
				readPosition = (image.height - 1 - y1) * 4 * image.width;
				var _g5 = 0;
				var _g14 = image.width;
				while(_g5 < _g14) {
					var x1 = _g5++;
					a = pixels.get(readPosition++);
					r = pixels.get(readPosition++);
					g = pixels.get(readPosition++);
					b = pixels.get(readPosition++);
					data.set(position++,b);
					data.set(position++,g);
					data.set(position++,r);
					data.set(position++,a);
				}
			}
			break;
		case 2:
			var andMask = (haxe_io_Bytes().default).alloc(image.width * image.height);
			var maskPosition = 0;
			var _g6 = 0;
			var _g15 = image.height;
			while(_g6 < _g15) {
				var y2 = _g6++;
				readPosition = (image.height - 1 - y2) * 4 * image.width;
				var _g7 = 0;
				var _g16 = image.width;
				while(_g7 < _g16) {
					var x2 = _g7++;
					a = pixels.get(readPosition++);
					r = pixels.get(readPosition++);
					g = pixels.get(readPosition++);
					b = pixels.get(readPosition++);
					data.set(position++,b);
					data.set(position++,g);
					data.set(position++,r);
					data.set(position++,a);
					andMask.set(maskPosition++,0);
				}
			}
			data.blit(position,andMask,0,image.width * image.height);
			break;
		}
	}
	return data;
}


// Export

exports.default = BMP;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/BMPType.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/BMPType.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime._internal.format.BMPType

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var BMPType = $hxEnums["lime._internal.format.BMPType"] = { __ename__ : "lime._internal.format.BMPType", __constructs__ : ["RGB","BITFIELD","ICO"]
  ,RGB: {_hx_index:0,__enum__:"lime._internal.format.BMPType",toString:$estr}
  ,ICO: {_hx_index:2,__enum__:"lime._internal.format.BMPType",toString:$estr}
  ,BITFIELD: {_hx_index:1,__enum__:"lime._internal.format.BMPType",toString:$estr}
};

exports.default = BMPType;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/Base64.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/Base64.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.format.Base64

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_crypto_Base64() {return __webpack_require__(/*! ./../../../haxe/crypto/Base64 */ "./node_modules/openfl/lib/_gen/haxe/crypto/Base64.js");}

// Constructor

var Base64 = function(){}

// Meta

Base64.__name__ = "lime._internal.format.Base64";
Base64.__isInterface__ = false;
Base64.prototype = {
	
};
Base64.prototype.__class__ = Base64.prototype.constructor = $hxClasses["lime._internal.format.Base64"] = Base64;

// Init



// Statics

Base64.decode = function(source) {
	return (haxe_crypto_Base64().default).decode(source);
}
Base64.encode = function(source) {
	var result = [];
	var dictionary = Base64.DICTIONARY;
	var extendedDictionary = Base64.EXTENDED_DICTIONARY;
	var numBytes = source.get_length();
	var numInputTriplets = Math.floor(numBytes / 3);
	var numChunksToWrite = numInputTriplets * 2;
	result.length = Math.ceil(numBytes / 3) * 2;
	var numBytesRead = 0;
	var numChunksWritten = 0;
	var inputTriplet;
	while(numChunksWritten < numChunksToWrite) {
		inputTriplet = source.get(numBytesRead) << 16 | source.get(numBytesRead + 1) << 8 | source.get(numBytesRead + 2);
		result[numChunksWritten] = extendedDictionary[inputTriplet >> 12 & 4095];
		result[numChunksWritten + 1] = extendedDictionary[inputTriplet & 4095];
		numBytesRead += 3;
		numChunksWritten += 2;
	}
	switch(numBytes - numInputTriplets * 3) {
	case 1:
		inputTriplet = source.get(numBytesRead) << 16;
		result[numChunksWritten] = extendedDictionary[inputTriplet >> 12 & 4095];
		result[numChunksWritten + 1] = "==";
		break;
	case 2:
		inputTriplet = source.get(numBytesRead) << 16 | source.get(numBytesRead + 1) << 8;
		result[numChunksWritten] = extendedDictionary[inputTriplet >> 12 & 4095];
		result[numChunksWritten + 1] = dictionary[inputTriplet >> 6 & 63] + "=";
		break;
	default:
	}
	return result.join("");
}
Base64.DICTIONARY = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("")
Base64.EXTENDED_DICTIONARY = (function($this) {
	var $r;
	var result = [];
	{
		var _g = 0;
		var _g1 = Base64.DICTIONARY;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g11 = Base64.DICTIONARY;
			while(_g2 < _g11.length) {
				var b = _g11[_g2];
				++_g2;
				result.push(a + b);
			}
		}
	}
	$r = result;
	return $r;
}(this))

// Export

exports.default = Base64;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/Deflate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/Deflate.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.format.Deflate

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}

// Constructor

var Deflate = function(){}

// Meta

Deflate.__name__ = "lime._internal.format.Deflate";
Deflate.__isInterface__ = false;
Deflate.prototype = {
	
};
Deflate.prototype.__class__ = Deflate.prototype.constructor = $hxClasses["lime._internal.format.Deflate"] = Deflate;

// Init



// Statics

Deflate.compress = function(bytes) {
	var data = __webpack_require__ (/*! pako */ "./node_modules/pako/index.js").deflateRaw(bytes.getData());
	return (haxe_io_Bytes().default).ofData(data);
}
Deflate.decompress = function(bytes) {
	var data = __webpack_require__ (/*! pako */ "./node_modules/pako/index.js").inflateRaw(bytes.getData());
	return (haxe_io_Bytes().default).ofData(data);
}


// Export

exports.default = Deflate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/GZip.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/GZip.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.format.GZip

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}

// Constructor

var GZip = function(){}

// Meta

GZip.__name__ = "lime._internal.format.GZip";
GZip.__isInterface__ = false;
GZip.prototype = {
	
};
GZip.prototype.__class__ = GZip.prototype.constructor = $hxClasses["lime._internal.format.GZip"] = GZip;

// Init



// Statics

GZip.compress = function(bytes) {
	var data = __webpack_require__ (/*! pako */ "./node_modules/pako/index.js").gzip(bytes.getData());
	return (haxe_io_Bytes().default).ofData(data);
}
GZip.decompress = function(bytes) {
	var data = __webpack_require__ (/*! pako */ "./node_modules/pako/index.js").ungzip(bytes.getData());
	return (haxe_io_Bytes().default).ofData(data);
}


// Export

exports.default = GZip;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/JPEG.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/JPEG.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.format.JPEG

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var JPEG = function(){}

// Meta

JPEG.__name__ = "lime._internal.format.JPEG";
JPEG.__isInterface__ = false;
JPEG.prototype = {
	
};
JPEG.prototype.__class__ = JPEG.prototype.constructor = $hxClasses["lime._internal.format.JPEG"] = JPEG;

// Init



// Statics

JPEG.decodeBytes = function(bytes,decodeData) {
	if(decodeData == null) {
		decodeData = true;
	}
	return null;
}
JPEG.decodeFile = function(path,decodeData) {
	if(decodeData == null) {
		decodeData = true;
	}
	return null;
}
JPEG.encode = function(image,quality) {
	if(image.get_premultiplied() || image.get_format() != 0) {
		image = image.clone();
		image.set_premultiplied(false);
		image.set_format(0);
	}
	(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(image,false);
	if(image.buffer.__srcCanvas != null) {
		var data = image.buffer.__srcCanvas.toDataURL("image/jpeg",quality / 100);
		var buffer = window.atob(data.split(";base64,")[1]);
		var bytes = (haxe_io_Bytes().default).alloc(buffer.length);
		var _g = 0;
		var _g1 = buffer.length;
		while(_g < _g1) {
			var i = _g++;
			bytes.set(i,(HxOverrides().default).cca(buffer,i));
		}
		return bytes;
	}
	return null;
}


// Export

exports.default = JPEG;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/LZMA.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/LZMA.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.format.LZMA

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var LZMA = function(){}

// Meta

LZMA.__name__ = "lime._internal.format.LZMA";
LZMA.__isInterface__ = false;
LZMA.prototype = {
	
};
LZMA.prototype.__class__ = LZMA.prototype.constructor = $hxClasses["lime._internal.format.LZMA"] = LZMA;

// Init



// Statics

LZMA.compress = function(bytes) {
	return null;
}
LZMA.decompress = function(bytes) {
	return null;
}


// Export

exports.default = LZMA;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/PNG.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/PNG.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.format.PNG

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var PNG = function(){}

// Meta

PNG.__name__ = "lime._internal.format.PNG";
PNG.__isInterface__ = false;
PNG.prototype = {
	
};
PNG.prototype.__class__ = PNG.prototype.constructor = $hxClasses["lime._internal.format.PNG"] = PNG;

// Init



// Statics

PNG.decodeBytes = function(bytes,decodeData) {
	if(decodeData == null) {
		decodeData = true;
	}
	return null;
}
PNG.decodeFile = function(path,decodeData) {
	if(decodeData == null) {
		decodeData = true;
	}
	return null;
}
PNG.encode = function(image) {
	if(image.get_premultiplied() || image.get_format() != 0) {
		image = image.clone();
		image.set_premultiplied(false);
		image.set_format(0);
	}
	(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(image,false);
	if(image.buffer.__srcCanvas != null) {
		var data = image.buffer.__srcCanvas.toDataURL("image/png");
		var buffer = window.atob(data.split(";base64,")[1]);
		var bytes = (haxe_io_Bytes().default).alloc(buffer.length);
		var _g = 0;
		var _g1 = buffer.length;
		while(_g < _g1) {
			var i = _g++;
			bytes.set(i,(HxOverrides().default).cca(buffer,i));
		}
		return bytes;
	}
	return null;
}


// Export

exports.default = PNG;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/format/Zlib.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/format/Zlib.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.format.Zlib

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}

// Constructor

var Zlib = function(){}

// Meta

Zlib.__name__ = "lime._internal.format.Zlib";
Zlib.__isInterface__ = false;
Zlib.prototype = {
	
};
Zlib.prototype.__class__ = Zlib.prototype.constructor = $hxClasses["lime._internal.format.Zlib"] = Zlib;

// Init



// Statics

Zlib.compress = function(bytes) {
	var data = __webpack_require__ (/*! pako */ "./node_modules/pako/index.js").deflate(bytes.getData());
	return (haxe_io_Bytes().default).ofData(data);
}
Zlib.decompress = function(bytes) {
	var data = __webpack_require__ (/*! pako */ "./node_modules/pako/index.js").inflate(bytes.getData());
	return (haxe_io_Bytes().default).ofData(data);
}


// Export

exports.default = Zlib;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/BlurStack.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/graphics/BlurStack.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.graphics.BlurStack

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var BlurStack = function() {
	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 0;
	this.n = null;
}

// Meta

BlurStack.__name__ = "lime._internal.graphics.BlurStack";
BlurStack.__isInterface__ = false;
BlurStack.prototype = {
	
};
BlurStack.prototype.__class__ = BlurStack.prototype.constructor = $hxClasses["lime._internal.graphics.BlurStack"] = BlurStack;

// Init



// Statics




// Export

exports.default = BlurStack;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.graphics.ImageCanvasUtil

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime__$internal_graphics_ImageDataUtil() {return __webpack_require__(/*! ./../../../lime/_internal/graphics/ImageDataUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageDataUtil.js");}
function lime_graphics_ImageType() {return __webpack_require__(/*! ./../../../lime/graphics/ImageType */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageType.js");}
function lime_math_Vector2() {return __webpack_require__(/*! ./../../../lime/math/Vector2 */ "./node_modules/openfl/lib/_gen/lime/math/Vector2.js");}
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}
function lime_graphics_ImageChannel() {return __webpack_require__(/*! ./../../../lime/graphics/ImageChannel */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageChannel.js");}
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var ImageCanvasUtil = function(){}

// Meta

ImageCanvasUtil.__name__ = "lime._internal.graphics.ImageCanvasUtil";
ImageCanvasUtil.__isInterface__ = false;
ImageCanvasUtil.prototype = {
	
};
ImageCanvasUtil.prototype.__class__ = ImageCanvasUtil.prototype.constructor = $hxClasses["lime._internal.graphics.ImageCanvasUtil"] = ImageCanvasUtil;

// Init



// Statics

ImageCanvasUtil.colorTransform = function(image,rect,colorMatrix) {
	ImageCanvasUtil.convertToData(image);
	(lime__$internal_graphics_ImageDataUtil().default).colorTransform(image,rect,colorMatrix);
}
ImageCanvasUtil.convertToCanvas = function(image,clear) {
	if(clear == null) {
		clear = false;
	}
	var buffer = image.buffer;
	if(buffer.__srcImage != null) {
		if(buffer.__srcCanvas == null) {
			ImageCanvasUtil.createCanvas(image,buffer.__srcImage.width,buffer.__srcImage.height);
			buffer.__srcContext.drawImage(buffer.__srcImage,0,0);
		}
		buffer.__srcImage = null;
	} else if(buffer.__srcCanvas == null && buffer.data != null) {
		image.set_transparent(true);
		ImageCanvasUtil.createCanvas(image,buffer.width,buffer.height);
		ImageCanvasUtil.createImageData(image);
		buffer.__srcContext.putImageData(buffer.__srcImageData,0,0);
	} else if(image.type == (lime_graphics_ImageType().default).DATA && buffer.__srcImageData != null && image.dirty) {
		buffer.__srcContext.putImageData(buffer.__srcImageData,0,0);
		image.dirty = false;
	}
	if(clear) {
		buffer.data = null;
		buffer.__srcImageData = null;
	} else if(buffer.data == null && buffer.__srcImageData != null) {
		buffer.data = buffer.__srcImageData.data;
	}
	image.type = (lime_graphics_ImageType().default).CANVAS;
}
ImageCanvasUtil.convertToData = function(image,clear) {
	if(clear == null) {
		clear = false;
	}
	var buffer = image.buffer;
	if(buffer.__srcImage != null) {
		ImageCanvasUtil.convertToCanvas(image);
	}
	if(buffer.__srcCanvas != null && buffer.data == null) {
		ImageCanvasUtil.createImageData(image);
		if(image.type == (lime_graphics_ImageType().default).CANVAS) {
			image.dirty = false;
		}
	} else if(image.type == (lime_graphics_ImageType().default).CANVAS && buffer.__srcCanvas != null && image.dirty) {
		if(buffer.__srcImageData == null) {
			ImageCanvasUtil.createImageData(image);
		} else {
			buffer.__srcImageData = buffer.__srcContext.getImageData(0,0,buffer.width,buffer.height);
			var elements = buffer.__srcImageData.data.buffer;
			var array = null;
			var view = null;
			var buffer1 = null;
			var len = null;
			var this1;
			if(elements != null) {
				this1 = new Uint8Array(elements);
			} else if(array != null) {
				this1 = new Uint8Array(array);
			} else if(view != null) {
				this1 = new Uint8Array(view);
			} else if(buffer1 != null) {
				if(len == null) {
					this1 = new Uint8Array(buffer1,0);
				} else {
					this1 = new Uint8Array(buffer1,0,len);
				}
			} else {
				this1 = null;
			}
			buffer.data = this1;
		}
		image.dirty = false;
	}
	if(clear) {
		image.buffer.__srcCanvas = null;
		image.buffer.__srcContext = null;
	}
	image.type = (lime_graphics_ImageType().default).DATA;
}
ImageCanvasUtil.copyChannel = function(image,sourceImage,sourceRect,destPoint,sourceChannel,destChannel) {
	ImageCanvasUtil.convertToData(sourceImage);
	ImageCanvasUtil.convertToData(image);
	(lime__$internal_graphics_ImageDataUtil().default).copyChannel(image,sourceImage,sourceRect,destPoint,sourceChannel,destChannel);
}
ImageCanvasUtil.copyPixels = function(image,sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha) {
	if(mergeAlpha == null) {
		mergeAlpha = false;
	}
	if(destPoint == null || destPoint.x >= image.width || destPoint.y >= image.height || sourceRect == null || sourceRect.width < 1 || sourceRect.height < 1) {
		return;
	}
	if(alphaImage != null && alphaImage.get_transparent()) {
		if(alphaPoint == null) {
			alphaPoint = new (lime_math_Vector2().default)();
		}
		var tempData = sourceImage.clone();
		tempData.copyChannel(alphaImage,new (lime_math_Rectangle().default)(sourceRect.x + alphaPoint.x,sourceRect.y + alphaPoint.y,sourceRect.width,sourceRect.height),new (lime_math_Vector2().default)(sourceRect.x,sourceRect.y),(lime_graphics_ImageChannel().default).ALPHA,(lime_graphics_ImageChannel().default).ALPHA);
		sourceImage = tempData;
	}
	ImageCanvasUtil.convertToCanvas(image,true);
	if(!mergeAlpha) {
		if(image.get_transparent() && sourceImage.get_transparent()) {
			image.buffer.__srcContext.clearRect(destPoint.x + image.offsetX,destPoint.y + image.offsetY,sourceRect.width + image.offsetX,sourceRect.height + image.offsetY);
		}
	}
	ImageCanvasUtil.convertToCanvas(sourceImage);
	if(sourceImage.buffer.get_src() != null) {
		image.buffer.__srcContext.globalCompositeOperation = "source-over";
		image.buffer.__srcContext.drawImage(sourceImage.buffer.get_src(),(Std().default).int(sourceRect.x + sourceImage.offsetX),(Std().default).int(sourceRect.y + sourceImage.offsetY),(Std().default).int(sourceRect.width),(Std().default).int(sourceRect.height),(Std().default).int(destPoint.x + image.offsetX),(Std().default).int(destPoint.y + image.offsetY),(Std().default).int(sourceRect.width),(Std().default).int(sourceRect.height));
	}
	image.dirty = true;
	image.version++;
}
ImageCanvasUtil.createCanvas = function(image,width,height) {
	var buffer = image.buffer;
	if(buffer.__srcCanvas == null) {
		buffer.__srcCanvas = window.document.createElement("canvas");
		buffer.__srcCanvas.width = width;
		buffer.__srcCanvas.height = height;
		if(!image.get_transparent()) {
			if(!image.get_transparent()) {
				buffer.__srcCanvas.setAttribute("moz-opaque","true");
			}
			buffer.__srcContext = buffer.__srcCanvas.getContext ("2d", { alpha: false });
		} else {
			buffer.__srcContext = buffer.__srcCanvas.getContext("2d");
		}
	}
}
ImageCanvasUtil.createImageData = function(image) {
	var buffer = image.buffer;
	if(buffer.__srcImageData == null) {
		if(buffer.data == null) {
			buffer.__srcImageData = buffer.__srcContext.getImageData(0,0,buffer.width,buffer.height);
		} else {
			buffer.__srcImageData = buffer.__srcContext.createImageData(buffer.width,buffer.height);
			buffer.__srcImageData.data.set(buffer.data);
		}
		var elements = buffer.__srcImageData.data.buffer;
		var array = null;
		var view = null;
		var buffer1 = null;
		var len = null;
		var this1;
		if(elements != null) {
			this1 = new Uint8Array(elements);
		} else if(array != null) {
			this1 = new Uint8Array(array);
		} else if(view != null) {
			this1 = new Uint8Array(view);
		} else if(buffer1 != null) {
			if(len == null) {
				this1 = new Uint8Array(buffer1,0);
			} else {
				this1 = new Uint8Array(buffer1,0,len);
			}
		} else {
			this1 = null;
		}
		buffer.data = this1;
	}
}
ImageCanvasUtil.fillRect = function(image,rect,color,format) {
	ImageCanvasUtil.convertToCanvas(image);
	var r;
	var g;
	var b;
	var a;
	if(format == 1) {
		r = color >> 16 & 255;
		g = color >> 8 & 255;
		b = color & 255;
		a = image.get_transparent() ? color >> 24 & 255 : 255;
	} else {
		r = color >> 24 & 255;
		g = color >> 16 & 255;
		b = color >> 8 & 255;
		a = image.get_transparent() ? color & 255 : 255;
	}
	if(rect.x == 0 && rect.y == 0 && rect.width == image.width && rect.height == image.height) {
		if(image.get_transparent() && a == 0) {
			image.buffer.__srcCanvas.width = image.buffer.width;
			return;
		}
	}
	if(a < 255) {
		image.buffer.__srcContext.clearRect(rect.x + image.offsetX,rect.y + image.offsetY,rect.width + image.offsetX,rect.height + image.offsetY);
	}
	if(a > 0) {
		image.buffer.__srcContext.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a / 255 + ")";
		image.buffer.__srcContext.fillRect(rect.x + image.offsetX,rect.y + image.offsetY,rect.width + image.offsetX,rect.height + image.offsetY);
	}
	image.dirty = true;
	image.version++;
}
ImageCanvasUtil.floodFill = function(image,x,y,color,format) {
	ImageCanvasUtil.convertToData(image);
	(lime__$internal_graphics_ImageDataUtil().default).floodFill(image,x,y,color,format);
}
ImageCanvasUtil.getPixel = function(image,x,y,format) {
	ImageCanvasUtil.convertToData(image);
	return (lime__$internal_graphics_ImageDataUtil().default).getPixel(image,x,y,format);
}
ImageCanvasUtil.getPixel32 = function(image,x,y,format) {
	ImageCanvasUtil.convertToData(image);
	return (lime__$internal_graphics_ImageDataUtil().default).getPixel32(image,x,y,format);
}
ImageCanvasUtil.getPixels = function(image,rect,format) {
	ImageCanvasUtil.convertToData(image);
	return (lime__$internal_graphics_ImageDataUtil().default).getPixels(image,rect,format);
}
ImageCanvasUtil.merge = function(image,sourceImage,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier) {
	ImageCanvasUtil.convertToData(sourceImage);
	ImageCanvasUtil.convertToData(image);
	(lime__$internal_graphics_ImageDataUtil().default).merge(image,sourceImage,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier);
}
ImageCanvasUtil.resize = function(image,newWidth,newHeight) {
	var buffer = image.buffer;
	if(buffer.__srcCanvas == null) {
		ImageCanvasUtil.createCanvas(image,newWidth,newHeight);
		buffer.__srcContext.drawImage(buffer.get_src(),0,0,newWidth,newHeight);
	} else {
		ImageCanvasUtil.convertToCanvas(image,true);
		var sourceCanvas = buffer.__srcCanvas;
		buffer.__srcCanvas = null;
		ImageCanvasUtil.createCanvas(image,newWidth,newHeight);
		buffer.__srcContext.drawImage(sourceCanvas,0,0,newWidth,newHeight);
	}
	buffer.__srcImageData = null;
	buffer.data = null;
	image.dirty = true;
	image.version++;
}
ImageCanvasUtil.scroll = function(image,x,y) {
	if(x % image.width == 0 && y % image.height == 0) {
		return;
	}
	var copy = image.clone();
	ImageCanvasUtil.convertToCanvas(image,true);
	image.buffer.__srcContext.clearRect(x,y,image.width,image.height);
	image.buffer.__srcContext.drawImage(copy.get_src(),x,y);
	image.dirty = true;
	image.version++;
}
ImageCanvasUtil.setPixel = function(image,x,y,color,format) {
	ImageCanvasUtil.convertToData(image);
	(lime__$internal_graphics_ImageDataUtil().default).setPixel(image,x,y,color,format);
}
ImageCanvasUtil.setPixel32 = function(image,x,y,color,format) {
	ImageCanvasUtil.convertToData(image);
	(lime__$internal_graphics_ImageDataUtil().default).setPixel32(image,x,y,color,format);
}
ImageCanvasUtil.setPixels = function(image,rect,bytePointer,format,endian) {
	ImageCanvasUtil.convertToData(image);
	(lime__$internal_graphics_ImageDataUtil().default).setPixels(image,rect,bytePointer,format,endian);
}
ImageCanvasUtil.sync = function(image,clear) {
	if(image == null) {
		return;
	}
	if(image.type == (lime_graphics_ImageType().default).CANVAS && (image.buffer.__srcCanvas != null || image.buffer.data != null)) {
		ImageCanvasUtil.convertToCanvas(image,clear);
	} else if(image.type == (lime_graphics_ImageType().default).DATA) {
		ImageCanvasUtil.convertToData(image,clear);
	}
}


// Export

exports.default = ImageCanvasUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageDataUtil.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageDataUtil.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.graphics.ImageDataUtil

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime__$internal_graphics__$ImageDataUtil_ImageDataView() {return __webpack_require__(/*! ./../../../lime/_internal/graphics/_ImageDataUtil/ImageDataView */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/_ImageDataUtil/ImageDataView.js");}
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_math__$RGBA_RGBA_$Impl_$() {return __webpack_require__(/*! ./../../../lime/math/_RGBA/RGBA_Impl_ */ "./node_modules/openfl/lib/_gen/lime/math/_RGBA/RGBA_Impl_.js");}
function lime_math_Vector4() {return __webpack_require__(/*! ./../../../lime/math/Vector4 */ "./node_modules/openfl/lib/_gen/lime/math/Vector4.js");}
function lime_math__$ColorMatrix_ColorMatrix_$Impl_$() {return __webpack_require__(/*! ./../../../lime/math/_ColorMatrix/ColorMatrix_Impl_ */ "./node_modules/openfl/lib/_gen/lime/math/_ColorMatrix/ColorMatrix_Impl_.js");}
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}
function lime__$internal_graphics_StackBlur() {return __webpack_require__(/*! ./../../../lime/_internal/graphics/StackBlur */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/StackBlur.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function lime_graphics_ImageBuffer() {return __webpack_require__(/*! ./../../../lime/graphics/ImageBuffer */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageBuffer.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}
function lime_system_Endian() {return __webpack_require__(/*! ./../../../lime/system/Endian */ "./node_modules/openfl/lib/_gen/lime/system/Endian.js");}

// Constructor

var ImageDataUtil = function(){}

// Meta

ImageDataUtil.__name__ = "lime._internal.graphics.ImageDataUtil";
ImageDataUtil.__isInterface__ = false;
ImageDataUtil.prototype = {
	
};
ImageDataUtil.prototype.__class__ = ImageDataUtil.prototype.constructor = $hxClasses["lime._internal.graphics.ImageDataUtil"] = ImageDataUtil;

// Init



// Statics

ImageDataUtil.displaceMap = function(target,source,map,mapPoint,componentX,componentY,smooth) {
	var targetData = target.buffer.data;
	var sourceData = source.buffer.data;
	var mapData = map.buffer.data;
	var targetFormat = target.buffer.format;
	var sourceFormat = source.buffer.format;
	var mapFormat = map.buffer.format;
	var targetPremultiplied = target.get_premultiplied();
	var sourcePremultiplied = source.get_premultiplied();
	var mapPremultiplied = map.get_premultiplied();
	var sourceView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(source);
	var mapView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(map);
	var row;
	var sourceOffset;
	var sourcePixel;
	var mapPixel;
	var targetPixel;
	var mapPixelX;
	var mapPixelY;
	var mapPixelA;
	var s1;
	var s2;
	var s3;
	var s4;
	var mPointXFloor;
	var mPointYFloor;
	var disOffsetXFloor;
	var disOffsetYFloor;
	var disX;
	var disY;
	var _g = 0;
	var _g1 = sourceView.height;
	while(_g < _g1) {
		var y = _g++;
		row = sourceView.row(y);
		var _g2 = 0;
		var _g11 = sourceView.width;
		while(_g2 < _g11) {
			var x = _g2++;
			sourceOffset = row + x * 4;
			mPointXFloor = (Std().default).int(mapPoint.x);
			mPointYFloor = (Std().default).int(mapPoint.y);
			if(smooth) {
				var offset = sourceView.row(y - mPointYFloor + 1) + (x - mPointXFloor) * 4;
				var format = mapFormat;
				var premultiplied = mapPremultiplied;
				if(premultiplied == null) {
					premultiplied = false;
				}
				if(format == null) {
					format = 0;
				}
				switch(format) {
				case 0:
					s1 = (mapData[offset] & 255) << 24 | (mapData[offset + 1] & 255) << 16 | (mapData[offset + 2] & 255) << 8 | mapData[offset + 3] & 255;
					break;
				case 1:
					s1 = (mapData[offset + 1] & 255) << 24 | (mapData[offset + 2] & 255) << 16 | (mapData[offset + 3] & 255) << 8 | mapData[offset] & 255;
					break;
				case 2:
					s1 = (mapData[offset + 2] & 255) << 24 | (mapData[offset + 1] & 255) << 16 | (mapData[offset] & 255) << 8 | mapData[offset + 3] & 255;
					break;
				}
				if(premultiplied) {
					if((s1 & 255) != 0 && (s1 & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (s1 & 255);
						s1 = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s1 >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s1 >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s1 >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | s1 & 255 & 255;
					}
				}
				var offset1 = sourceView.row(y - mPointYFloor) + (x - mPointXFloor + 1) * 4;
				var format1 = mapFormat;
				var premultiplied1 = mapPremultiplied;
				if(premultiplied1 == null) {
					premultiplied1 = false;
				}
				if(format1 == null) {
					format1 = 0;
				}
				switch(format1) {
				case 0:
					s2 = (mapData[offset1] & 255) << 24 | (mapData[offset1 + 1] & 255) << 16 | (mapData[offset1 + 2] & 255) << 8 | mapData[offset1 + 3] & 255;
					break;
				case 1:
					s2 = (mapData[offset1 + 1] & 255) << 24 | (mapData[offset1 + 2] & 255) << 16 | (mapData[offset1 + 3] & 255) << 8 | mapData[offset1] & 255;
					break;
				case 2:
					s2 = (mapData[offset1 + 2] & 255) << 24 | (mapData[offset1 + 1] & 255) << 16 | (mapData[offset1] & 255) << 8 | mapData[offset1 + 3] & 255;
					break;
				}
				if(premultiplied1) {
					if((s2 & 255) != 0 && (s2 & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (s2 & 255);
						s2 = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s2 >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s2 >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s2 >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | s2 & 255 & 255;
					}
				}
				var offset2 = sourceView.row(y - mPointYFloor + 1) + (x - mPointXFloor + 1) * 4;
				var format2 = mapFormat;
				var premultiplied2 = mapPremultiplied;
				if(premultiplied2 == null) {
					premultiplied2 = false;
				}
				if(format2 == null) {
					format2 = 0;
				}
				switch(format2) {
				case 0:
					s3 = (mapData[offset2] & 255) << 24 | (mapData[offset2 + 1] & 255) << 16 | (mapData[offset2 + 2] & 255) << 8 | mapData[offset2 + 3] & 255;
					break;
				case 1:
					s3 = (mapData[offset2 + 1] & 255) << 24 | (mapData[offset2 + 2] & 255) << 16 | (mapData[offset2 + 3] & 255) << 8 | mapData[offset2] & 255;
					break;
				case 2:
					s3 = (mapData[offset2 + 2] & 255) << 24 | (mapData[offset2 + 1] & 255) << 16 | (mapData[offset2] & 255) << 8 | mapData[offset2 + 3] & 255;
					break;
				}
				if(premultiplied2) {
					if((s3 & 255) != 0 && (s3 & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (s3 & 255);
						s3 = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s3 >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s3 >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s3 >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | s3 & 255 & 255;
					}
				}
				var offset3 = sourceView.row(y - mPointYFloor) + (x - mPointXFloor) * 4;
				var format3 = mapFormat;
				var premultiplied3 = mapPremultiplied;
				if(premultiplied3 == null) {
					premultiplied3 = false;
				}
				if(format3 == null) {
					format3 = 0;
				}
				switch(format3) {
				case 0:
					s4 = (mapData[offset3] & 255) << 24 | (mapData[offset3 + 1] & 255) << 16 | (mapData[offset3 + 2] & 255) << 8 | mapData[offset3 + 3] & 255;
					break;
				case 1:
					s4 = (mapData[offset3 + 1] & 255) << 24 | (mapData[offset3 + 2] & 255) << 16 | (mapData[offset3 + 3] & 255) << 8 | mapData[offset3] & 255;
					break;
				case 2:
					s4 = (mapData[offset3 + 2] & 255) << 24 | (mapData[offset3 + 1] & 255) << 16 | (mapData[offset3] & 255) << 8 | mapData[offset3 + 3] & 255;
					break;
				}
				if(premultiplied3) {
					if((s4 & 255) != 0 && (s4 & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (s4 & 255);
						s4 = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s4 >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s4 >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s4 >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | s4 & 255 & 255;
					}
				}
				mapPixel = ImageDataUtil.bilinear(s1,s2,s3,s4,mapPoint.x - mPointXFloor,mapPoint.y - mPointYFloor);
			} else {
				var offset4 = mapView.row(y - mPointYFloor) + (x - mPointXFloor) * 4;
				var format4 = mapFormat;
				var premultiplied4 = mapPremultiplied;
				if(premultiplied4 == null) {
					premultiplied4 = false;
				}
				if(format4 == null) {
					format4 = 0;
				}
				switch(format4) {
				case 0:
					mapPixel = (mapData[offset4] & 255) << 24 | (mapData[offset4 + 1] & 255) << 16 | (mapData[offset4 + 2] & 255) << 8 | mapData[offset4 + 3] & 255;
					break;
				case 1:
					mapPixel = (mapData[offset4 + 1] & 255) << 24 | (mapData[offset4 + 2] & 255) << 16 | (mapData[offset4 + 3] & 255) << 8 | mapData[offset4] & 255;
					break;
				case 2:
					mapPixel = (mapData[offset4 + 2] & 255) << 24 | (mapData[offset4 + 1] & 255) << 16 | (mapData[offset4] & 255) << 8 | mapData[offset4 + 3] & 255;
					break;
				}
				if(premultiplied4) {
					if((mapPixel & 255) != 0 && (mapPixel & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (mapPixel & 255);
						mapPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((mapPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((mapPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((mapPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | mapPixel & 255 & 255;
					}
				}
			}
			mapPixelA = (mapPixel & 255) / 255.0;
			mapPixelX = ((mapPixel >>> 24 & 255) - 128) / 255.0 * mapPixelA;
			mapPixelY = ((mapPixel >>> 16 & 255) - 128) / 255.0 * mapPixelA;
			disX = mapPixelX * componentX.x + mapPixelY * componentY.x;
			disY = mapPixelX * componentX.y + mapPixelY * componentY.y;
			disOffsetXFloor = Math.floor(disX * sourceView.width);
			disOffsetYFloor = Math.floor(disY * sourceView.height);
			if(smooth) {
				var offset5 = sourceView.row(y + disOffsetYFloor + 1) + (x + disOffsetXFloor) * 4;
				var format5 = sourceFormat;
				var premultiplied5 = sourcePremultiplied;
				if(premultiplied5 == null) {
					premultiplied5 = false;
				}
				if(format5 == null) {
					format5 = 0;
				}
				switch(format5) {
				case 0:
					s1 = (sourceData[offset5] & 255) << 24 | (sourceData[offset5 + 1] & 255) << 16 | (sourceData[offset5 + 2] & 255) << 8 | sourceData[offset5 + 3] & 255;
					break;
				case 1:
					s1 = (sourceData[offset5 + 1] & 255) << 24 | (sourceData[offset5 + 2] & 255) << 16 | (sourceData[offset5 + 3] & 255) << 8 | sourceData[offset5] & 255;
					break;
				case 2:
					s1 = (sourceData[offset5 + 2] & 255) << 24 | (sourceData[offset5 + 1] & 255) << 16 | (sourceData[offset5] & 255) << 8 | sourceData[offset5 + 3] & 255;
					break;
				}
				if(premultiplied5) {
					if((s1 & 255) != 0 && (s1 & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (s1 & 255);
						s1 = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s1 >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s1 >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s1 >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | s1 & 255 & 255;
					}
				}
				var offset6 = sourceView.row(y + disOffsetYFloor) + (x + disOffsetXFloor + 1) * 4;
				var format6 = sourceFormat;
				var premultiplied6 = sourcePremultiplied;
				if(premultiplied6 == null) {
					premultiplied6 = false;
				}
				if(format6 == null) {
					format6 = 0;
				}
				switch(format6) {
				case 0:
					s2 = (sourceData[offset6] & 255) << 24 | (sourceData[offset6 + 1] & 255) << 16 | (sourceData[offset6 + 2] & 255) << 8 | sourceData[offset6 + 3] & 255;
					break;
				case 1:
					s2 = (sourceData[offset6 + 1] & 255) << 24 | (sourceData[offset6 + 2] & 255) << 16 | (sourceData[offset6 + 3] & 255) << 8 | sourceData[offset6] & 255;
					break;
				case 2:
					s2 = (sourceData[offset6 + 2] & 255) << 24 | (sourceData[offset6 + 1] & 255) << 16 | (sourceData[offset6] & 255) << 8 | sourceData[offset6 + 3] & 255;
					break;
				}
				if(premultiplied6) {
					if((s2 & 255) != 0 && (s2 & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (s2 & 255);
						s2 = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s2 >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s2 >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s2 >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | s2 & 255 & 255;
					}
				}
				var offset7 = sourceView.row(y + disOffsetYFloor + 1) + (x + disOffsetXFloor + 1) * 4;
				var format7 = sourceFormat;
				var premultiplied7 = sourcePremultiplied;
				if(premultiplied7 == null) {
					premultiplied7 = false;
				}
				if(format7 == null) {
					format7 = 0;
				}
				switch(format7) {
				case 0:
					s3 = (sourceData[offset7] & 255) << 24 | (sourceData[offset7 + 1] & 255) << 16 | (sourceData[offset7 + 2] & 255) << 8 | sourceData[offset7 + 3] & 255;
					break;
				case 1:
					s3 = (sourceData[offset7 + 1] & 255) << 24 | (sourceData[offset7 + 2] & 255) << 16 | (sourceData[offset7 + 3] & 255) << 8 | sourceData[offset7] & 255;
					break;
				case 2:
					s3 = (sourceData[offset7 + 2] & 255) << 24 | (sourceData[offset7 + 1] & 255) << 16 | (sourceData[offset7] & 255) << 8 | sourceData[offset7 + 3] & 255;
					break;
				}
				if(premultiplied7) {
					if((s3 & 255) != 0 && (s3 & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (s3 & 255);
						s3 = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s3 >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s3 >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s3 >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | s3 & 255 & 255;
					}
				}
				var offset8 = sourceView.row(y + disOffsetYFloor) + (x + disOffsetXFloor) * 4;
				var format8 = sourceFormat;
				var premultiplied8 = sourcePremultiplied;
				if(premultiplied8 == null) {
					premultiplied8 = false;
				}
				if(format8 == null) {
					format8 = 0;
				}
				switch(format8) {
				case 0:
					s4 = (sourceData[offset8] & 255) << 24 | (sourceData[offset8 + 1] & 255) << 16 | (sourceData[offset8 + 2] & 255) << 8 | sourceData[offset8 + 3] & 255;
					break;
				case 1:
					s4 = (sourceData[offset8 + 1] & 255) << 24 | (sourceData[offset8 + 2] & 255) << 16 | (sourceData[offset8 + 3] & 255) << 8 | sourceData[offset8] & 255;
					break;
				case 2:
					s4 = (sourceData[offset8 + 2] & 255) << 24 | (sourceData[offset8 + 1] & 255) << 16 | (sourceData[offset8] & 255) << 8 | sourceData[offset8 + 3] & 255;
					break;
				}
				if(premultiplied8) {
					if((s4 & 255) != 0 && (s4 & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (s4 & 255);
						s4 = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s4 >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s4 >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((s4 >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | s4 & 255 & 255;
					}
				}
				sourcePixel = ImageDataUtil.bilinear(s1,s2,s3,s4,disX * sourceView.width - disOffsetXFloor,disY * sourceView.height - disOffsetYFloor);
			} else {
				var offset9 = sourceView.row(y + disOffsetYFloor) + (x + disOffsetXFloor) * 4;
				var format9 = sourceFormat;
				var premultiplied9 = sourcePremultiplied;
				if(premultiplied9 == null) {
					premultiplied9 = false;
				}
				if(format9 == null) {
					format9 = 0;
				}
				switch(format9) {
				case 0:
					sourcePixel = (sourceData[offset9] & 255) << 24 | (sourceData[offset9 + 1] & 255) << 16 | (sourceData[offset9 + 2] & 255) << 8 | sourceData[offset9 + 3] & 255;
					break;
				case 1:
					sourcePixel = (sourceData[offset9 + 1] & 255) << 24 | (sourceData[offset9 + 2] & 255) << 16 | (sourceData[offset9 + 3] & 255) << 8 | sourceData[offset9] & 255;
					break;
				case 2:
					sourcePixel = (sourceData[offset9 + 2] & 255) << 24 | (sourceData[offset9 + 1] & 255) << 16 | (sourceData[offset9] & 255) << 8 | sourceData[offset9 + 3] & 255;
					break;
				}
				if(premultiplied9) {
					if((sourcePixel & 255) != 0 && (sourcePixel & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (sourcePixel & 255);
						sourcePixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | sourcePixel & 255 & 255;
					}
				}
			}
			var format10 = targetFormat;
			var premultiplied10 = targetPremultiplied;
			if(premultiplied10 == null) {
				premultiplied10 = false;
			}
			if(format10 == null) {
				format10 = 0;
			}
			if(premultiplied10) {
				if((sourcePixel & 255) == 0) {
					if(sourcePixel != 0) {
						sourcePixel = 0;
					}
				} else if((sourcePixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[sourcePixel & 255];
					sourcePixel = ((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | sourcePixel & 255 & 255;
				}
			}
			switch(format10) {
			case 0:
				targetData[sourceOffset] = sourcePixel >>> 24 & 255;
				targetData[sourceOffset + 1] = sourcePixel >>> 16 & 255;
				targetData[sourceOffset + 2] = sourcePixel >>> 8 & 255;
				targetData[sourceOffset + 3] = sourcePixel & 255;
				break;
			case 1:
				targetData[sourceOffset] = sourcePixel & 255;
				targetData[sourceOffset + 1] = sourcePixel >>> 24 & 255;
				targetData[sourceOffset + 2] = sourcePixel >>> 16 & 255;
				targetData[sourceOffset + 3] = sourcePixel >>> 8 & 255;
				break;
			case 2:
				targetData[sourceOffset] = sourcePixel >>> 8 & 255;
				targetData[sourceOffset + 1] = sourcePixel >>> 16 & 255;
				targetData[sourceOffset + 2] = sourcePixel >>> 24 & 255;
				targetData[sourceOffset + 3] = sourcePixel & 255;
				break;
			}
		}
	}
	target.dirty = true;
	target.version++;
}
ImageDataUtil.bilinear = function(s1,s2,s3,s4,su,sv) {
	return ImageDataUtil.lerpRGBA(ImageDataUtil.lerpRGBA(s4,s2,su),ImageDataUtil.lerpRGBA(s1,s3,su),sv);
}
ImageDataUtil.lerpRGBA = function(v0,v1,x) {
	var this1 = 0;
	var result = this1;
	var value = Math.floor(ImageDataUtil.lerp(v0 >>> 24 & 255,v1 >>> 24 & 255,x));
	result = (value & 255) << 24 | (result >>> 16 & 255 & 255) << 16 | (result >>> 8 & 255 & 255) << 8 | result & 255 & 255;
	var value1 = Math.floor(ImageDataUtil.lerp(v0 >>> 16 & 255,v1 >>> 16 & 255,x));
	result = (result >>> 24 & 255 & 255) << 24 | (value1 & 255) << 16 | (result >>> 8 & 255 & 255) << 8 | result & 255 & 255;
	var value2 = Math.floor(ImageDataUtil.lerp(v0 >>> 8 & 255,v1 >>> 8 & 255,x));
	result = (result >>> 24 & 255 & 255) << 24 | (result >>> 16 & 255 & 255) << 16 | (value2 & 255) << 8 | result & 255 & 255;
	var value3 = Math.floor(ImageDataUtil.lerp(v0 & 255,v1 & 255,x));
	result = (result >>> 24 & 255 & 255) << 24 | (result >>> 16 & 255 & 255) << 16 | (result >>> 8 & 255 & 255) << 8 | value3 & 255;
	return result;
}
ImageDataUtil.lerp4f = function(v0,v1,x) {
	return new (lime_math_Vector4().default)(ImageDataUtil.lerp(v0.x,v1.x,x),ImageDataUtil.lerp(v0.y,v1.y,x),ImageDataUtil.lerp(v0.z,v1.z,x),ImageDataUtil.lerp(v0.w,v1.w,x));
}
ImageDataUtil.lerp = function(v0,v1,x) {
	return (1.0 - x) * v0 + x * v1;
}
ImageDataUtil.colorTransform = function(image,rect,colorMatrix) {
	var data = image.buffer.data;
	if(data == null) {
		return;
	}
	var format = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	var dataView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(image,rect);
	var alphaTable = (lime_math__$ColorMatrix_ColorMatrix_$Impl_$().default).getAlphaTable(colorMatrix);
	var redTable = (lime_math__$ColorMatrix_ColorMatrix_$Impl_$().default).getRedTable(colorMatrix);
	var greenTable = (lime_math__$ColorMatrix_ColorMatrix_$Impl_$().default).getGreenTable(colorMatrix);
	var blueTable = (lime_math__$ColorMatrix_ColorMatrix_$Impl_$().default).getBlueTable(colorMatrix);
	var row;
	var offset;
	var pixel;
	var _g = 0;
	var _g1 = dataView.height;
	while(_g < _g1) {
		var y = _g++;
		row = dataView.row(y);
		var _g2 = 0;
		var _g11 = dataView.width;
		while(_g2 < _g11) {
			var x = _g2++;
			offset = row + x * 4;
			var format1 = format;
			var premultiplied1 = premultiplied;
			if(premultiplied1 == null) {
				premultiplied1 = false;
			}
			if(format1 == null) {
				format1 = 0;
			}
			switch(format1) {
			case 0:
				pixel = (data[offset] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset + 2] & 255) << 8 | data[offset + 3] & 255;
				break;
			case 1:
				pixel = (data[offset + 1] & 255) << 24 | (data[offset + 2] & 255) << 16 | (data[offset + 3] & 255) << 8 | data[offset] & 255;
				break;
			case 2:
				pixel = (data[offset + 2] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset] & 255) << 8 | data[offset + 3] & 255;
				break;
			}
			if(premultiplied1) {
				if((pixel & 255) != 0 && (pixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (pixel & 255);
					pixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | pixel & 255 & 255;
				}
			}
			pixel = (redTable[pixel >>> 24 & 255] & 255) << 24 | (greenTable[pixel >>> 16 & 255] & 255) << 16 | (blueTable[pixel >>> 8 & 255] & 255) << 8 | alphaTable[pixel & 255] & 255;
			var format2 = format;
			var premultiplied2 = premultiplied;
			if(premultiplied2 == null) {
				premultiplied2 = false;
			}
			if(format2 == null) {
				format2 = 0;
			}
			if(premultiplied2) {
				if((pixel & 255) == 0) {
					if(pixel != 0) {
						pixel = 0;
					}
				} else if((pixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[pixel & 255];
					pixel = ((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | pixel & 255 & 255;
				}
			}
			switch(format2) {
			case 0:
				data[offset] = pixel >>> 24 & 255;
				data[offset + 1] = pixel >>> 16 & 255;
				data[offset + 2] = pixel >>> 8 & 255;
				data[offset + 3] = pixel & 255;
				break;
			case 1:
				data[offset] = pixel & 255;
				data[offset + 1] = pixel >>> 24 & 255;
				data[offset + 2] = pixel >>> 16 & 255;
				data[offset + 3] = pixel >>> 8 & 255;
				break;
			case 2:
				data[offset] = pixel >>> 8 & 255;
				data[offset + 1] = pixel >>> 16 & 255;
				data[offset + 2] = pixel >>> 24 & 255;
				data[offset + 3] = pixel & 255;
				break;
			}
		}
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.copyChannel = function(image,sourceImage,sourceRect,destPoint,sourceChannel,destChannel) {
	var destIdx;
	switch(destChannel._hx_index) {
	case 0:
		destIdx = 0;
		break;
	case 1:
		destIdx = 1;
		break;
	case 2:
		destIdx = 2;
		break;
	case 3:
		destIdx = 3;
		break;
	}
	var srcIdx;
	switch(sourceChannel._hx_index) {
	case 0:
		srcIdx = 0;
		break;
	case 1:
		srcIdx = 1;
		break;
	case 2:
		srcIdx = 2;
		break;
	case 3:
		srcIdx = 3;
		break;
	}
	var srcData = sourceImage.buffer.data;
	var destData = image.buffer.data;
	if(srcData == null || destData == null) {
		return;
	}
	var srcView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(sourceImage,sourceRect);
	var destView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(image,new (lime_math_Rectangle().default)(destPoint.x,destPoint.y,srcView.width,srcView.height));
	var srcFormat = sourceImage.buffer.format;
	var destFormat = image.buffer.format;
	var srcPremultiplied = sourceImage.buffer.premultiplied;
	var destPremultiplied = image.buffer.premultiplied;
	var srcPosition;
	var destPosition;
	var srcPixel;
	var destPixel;
	var value = 0;
	var _g = 0;
	var _g1 = destView.height;
	while(_g < _g1) {
		var y = _g++;
		srcPosition = srcView.row(y);
		destPosition = destView.row(y);
		var _g2 = 0;
		var _g11 = destView.width;
		while(_g2 < _g11) {
			var x = _g2++;
			var format = srcFormat;
			var premultiplied = srcPremultiplied;
			if(premultiplied == null) {
				premultiplied = false;
			}
			if(format == null) {
				format = 0;
			}
			switch(format) {
			case 0:
				srcPixel = (srcData[srcPosition] & 255) << 24 | (srcData[srcPosition + 1] & 255) << 16 | (srcData[srcPosition + 2] & 255) << 8 | srcData[srcPosition + 3] & 255;
				break;
			case 1:
				srcPixel = (srcData[srcPosition + 1] & 255) << 24 | (srcData[srcPosition + 2] & 255) << 16 | (srcData[srcPosition + 3] & 255) << 8 | srcData[srcPosition] & 255;
				break;
			case 2:
				srcPixel = (srcData[srcPosition + 2] & 255) << 24 | (srcData[srcPosition + 1] & 255) << 16 | (srcData[srcPosition] & 255) << 8 | srcData[srcPosition + 3] & 255;
				break;
			}
			if(premultiplied) {
				if((srcPixel & 255) != 0 && (srcPixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (srcPixel & 255);
					srcPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((srcPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((srcPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((srcPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | srcPixel & 255 & 255;
				}
			}
			var format1 = destFormat;
			var premultiplied1 = destPremultiplied;
			if(premultiplied1 == null) {
				premultiplied1 = false;
			}
			if(format1 == null) {
				format1 = 0;
			}
			switch(format1) {
			case 0:
				destPixel = (destData[destPosition] & 255) << 24 | (destData[destPosition + 1] & 255) << 16 | (destData[destPosition + 2] & 255) << 8 | destData[destPosition + 3] & 255;
				break;
			case 1:
				destPixel = (destData[destPosition + 1] & 255) << 24 | (destData[destPosition + 2] & 255) << 16 | (destData[destPosition + 3] & 255) << 8 | destData[destPosition] & 255;
				break;
			case 2:
				destPixel = (destData[destPosition + 2] & 255) << 24 | (destData[destPosition + 1] & 255) << 16 | (destData[destPosition] & 255) << 8 | destData[destPosition + 3] & 255;
				break;
			}
			if(premultiplied1) {
				if((destPixel & 255) != 0 && (destPixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (destPixel & 255);
					destPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | destPixel & 255 & 255;
				}
			}
			switch(srcIdx) {
			case 0:
				value = srcPixel >>> 24 & 255;
				break;
			case 1:
				value = srcPixel >>> 16 & 255;
				break;
			case 2:
				value = srcPixel >>> 8 & 255;
				break;
			case 3:
				value = srcPixel & 255;
				break;
			}
			switch(destIdx) {
			case 0:
				destPixel = (value & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
				break;
			case 1:
				destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (value & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
				break;
			case 2:
				destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (value & 255) << 8 | destPixel & 255 & 255;
				break;
			case 3:
				destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | value & 255;
				break;
			}
			var format2 = destFormat;
			var premultiplied2 = destPremultiplied;
			if(premultiplied2 == null) {
				premultiplied2 = false;
			}
			if(format2 == null) {
				format2 = 0;
			}
			if(premultiplied2) {
				if((destPixel & 255) == 0) {
					if(destPixel != 0) {
						destPixel = 0;
					}
				} else if((destPixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[destPixel & 255];
					destPixel = ((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | destPixel & 255 & 255;
				}
			}
			switch(format2) {
			case 0:
				destData[destPosition] = destPixel >>> 24 & 255;
				destData[destPosition + 1] = destPixel >>> 16 & 255;
				destData[destPosition + 2] = destPixel >>> 8 & 255;
				destData[destPosition + 3] = destPixel & 255;
				break;
			case 1:
				destData[destPosition] = destPixel & 255;
				destData[destPosition + 1] = destPixel >>> 24 & 255;
				destData[destPosition + 2] = destPixel >>> 16 & 255;
				destData[destPosition + 3] = destPixel >>> 8 & 255;
				break;
			case 2:
				destData[destPosition] = destPixel >>> 8 & 255;
				destData[destPosition + 1] = destPixel >>> 16 & 255;
				destData[destPosition + 2] = destPixel >>> 24 & 255;
				destData[destPosition + 3] = destPixel & 255;
				break;
			}
			srcPosition += 4;
			destPosition += 4;
		}
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.copyPixels = function(image,sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha) {
	if(mergeAlpha == null) {
		mergeAlpha = false;
	}
	if(image.width == sourceImage.width && image.height == sourceImage.height && sourceRect.width == sourceImage.width && sourceRect.height == sourceImage.height && sourceRect.x == 0 && sourceRect.y == 0 && destPoint.x == 0 && destPoint.y == 0 && alphaImage == null && alphaPoint == null && mergeAlpha == false && image.get_format() == sourceImage.get_format()) {
		image.buffer.data.set(sourceImage.buffer.data);
	} else {
		var sourceData = sourceImage.buffer.data;
		var destData = image.buffer.data;
		if(sourceData == null || destData == null) {
			return;
		}
		var sourceView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(sourceImage,sourceRect);
		var destRect = new (lime_math_Rectangle().default)(destPoint.x,destPoint.y,sourceView.width,sourceView.height);
		var destView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(image,destRect);
		var sourceFormat = sourceImage.buffer.format;
		var destFormat = image.buffer.format;
		var sourcePosition;
		var destPosition;
		var sourceAlpha;
		var destAlpha;
		var oneMinusSourceAlpha;
		var blendAlpha;
		var sourcePixel;
		var destPixel;
		var sourcePremultiplied = sourceImage.buffer.premultiplied;
		var destPremultiplied = image.buffer.premultiplied;
		var sourceBytesPerPixel = (Std().default).int(sourceImage.buffer.bitsPerPixel / 8);
		var destBytesPerPixel = (Std().default).int(image.buffer.bitsPerPixel / 8);
		var useAlphaImage = alphaImage != null && alphaImage.get_transparent();
		var blend = mergeAlpha || useAlphaImage && !image.get_transparent() || !mergeAlpha && !image.get_transparent() && sourceImage.get_transparent();
		if(!useAlphaImage) {
			if(blend) {
				var _g = 0;
				var _g1 = destView.height;
				while(_g < _g1) {
					var y = _g++;
					sourcePosition = sourceView.row(y);
					destPosition = destView.row(y);
					var _g2 = 0;
					var _g11 = destView.width;
					while(_g2 < _g11) {
						var x = _g2++;
						var format = sourceFormat;
						var premultiplied = sourcePremultiplied;
						if(premultiplied == null) {
							premultiplied = false;
						}
						if(format == null) {
							format = 0;
						}
						switch(format) {
						case 0:
							sourcePixel = (sourceData[sourcePosition] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition + 2] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
							break;
						case 1:
							sourcePixel = (sourceData[sourcePosition + 1] & 255) << 24 | (sourceData[sourcePosition + 2] & 255) << 16 | (sourceData[sourcePosition + 3] & 255) << 8 | sourceData[sourcePosition] & 255;
							break;
						case 2:
							sourcePixel = (sourceData[sourcePosition + 2] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
							break;
						}
						if(premultiplied) {
							if((sourcePixel & 255) != 0 && (sourcePixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (sourcePixel & 255);
								sourcePixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | sourcePixel & 255 & 255;
							}
						}
						var format1 = destFormat;
						var premultiplied1 = destPremultiplied;
						if(premultiplied1 == null) {
							premultiplied1 = false;
						}
						if(format1 == null) {
							format1 = 0;
						}
						switch(format1) {
						case 0:
							destPixel = (destData[destPosition] & 255) << 24 | (destData[destPosition + 1] & 255) << 16 | (destData[destPosition + 2] & 255) << 8 | destData[destPosition + 3] & 255;
							break;
						case 1:
							destPixel = (destData[destPosition + 1] & 255) << 24 | (destData[destPosition + 2] & 255) << 16 | (destData[destPosition + 3] & 255) << 8 | destData[destPosition] & 255;
							break;
						case 2:
							destPixel = (destData[destPosition + 2] & 255) << 24 | (destData[destPosition + 1] & 255) << 16 | (destData[destPosition] & 255) << 8 | destData[destPosition + 3] & 255;
							break;
						}
						if(premultiplied1) {
							if((destPixel & 255) != 0 && (destPixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (destPixel & 255);
								destPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | destPixel & 255 & 255;
							}
						}
						sourceAlpha = (sourcePixel & 255) / 255.0;
						destAlpha = (destPixel & 255) / 255.0;
						oneMinusSourceAlpha = 1 - sourceAlpha;
						blendAlpha = sourceAlpha + destAlpha * oneMinusSourceAlpha;
						if(blendAlpha == 0) {
							destPixel = 0;
						} else {
							var value = (lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round(((sourcePixel >>> 24 & 255) * sourceAlpha + (destPixel >>> 24 & 255) * destAlpha * oneMinusSourceAlpha) / blendAlpha)];
							destPixel = (value & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
							var value1 = (lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round(((sourcePixel >>> 16 & 255) * sourceAlpha + (destPixel >>> 16 & 255) * destAlpha * oneMinusSourceAlpha) / blendAlpha)];
							destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (value1 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
							var value2 = (lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round(((sourcePixel >>> 8 & 255) * sourceAlpha + (destPixel >>> 8 & 255) * destAlpha * oneMinusSourceAlpha) / blendAlpha)];
							destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (value2 & 255) << 8 | destPixel & 255 & 255;
							var value3 = (lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round(blendAlpha * 255.0)];
							destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | value3 & 255;
						}
						var format2 = destFormat;
						var premultiplied2 = destPremultiplied;
						if(premultiplied2 == null) {
							premultiplied2 = false;
						}
						if(format2 == null) {
							format2 = 0;
						}
						if(premultiplied2) {
							if((destPixel & 255) == 0) {
								if(destPixel != 0) {
									destPixel = 0;
								}
							} else if((destPixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[destPixel & 255];
								destPixel = ((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | destPixel & 255 & 255;
							}
						}
						switch(format2) {
						case 0:
							destData[destPosition] = destPixel >>> 24 & 255;
							destData[destPosition + 1] = destPixel >>> 16 & 255;
							destData[destPosition + 2] = destPixel >>> 8 & 255;
							destData[destPosition + 3] = destPixel & 255;
							break;
						case 1:
							destData[destPosition] = destPixel & 255;
							destData[destPosition + 1] = destPixel >>> 24 & 255;
							destData[destPosition + 2] = destPixel >>> 16 & 255;
							destData[destPosition + 3] = destPixel >>> 8 & 255;
							break;
						case 2:
							destData[destPosition] = destPixel >>> 8 & 255;
							destData[destPosition + 1] = destPixel >>> 16 & 255;
							destData[destPosition + 2] = destPixel >>> 24 & 255;
							destData[destPosition + 3] = destPixel & 255;
							break;
						}
						sourcePosition += 4;
						destPosition += 4;
					}
				}
			} else if(sourceFormat == destFormat && sourcePremultiplied == destPremultiplied && sourceBytesPerPixel == destBytesPerPixel) {
				var _g3 = 0;
				var _g12 = destView.height;
				while(_g3 < _g12) {
					var y1 = _g3++;
					sourcePosition = sourceView.row(y1);
					destPosition = destView.row(y1);
					destData.set(sourceData.subarray(sourcePosition,sourcePosition + destView.width * destBytesPerPixel),destPosition);
				}
			} else {
				var _g4 = 0;
				var _g13 = destView.height;
				while(_g4 < _g13) {
					var y2 = _g4++;
					sourcePosition = sourceView.row(y2);
					destPosition = destView.row(y2);
					var _g5 = 0;
					var _g14 = destView.width;
					while(_g5 < _g14) {
						var x1 = _g5++;
						var format3 = sourceFormat;
						var premultiplied3 = sourcePremultiplied;
						if(premultiplied3 == null) {
							premultiplied3 = false;
						}
						if(format3 == null) {
							format3 = 0;
						}
						switch(format3) {
						case 0:
							sourcePixel = (sourceData[sourcePosition] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition + 2] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
							break;
						case 1:
							sourcePixel = (sourceData[sourcePosition + 1] & 255) << 24 | (sourceData[sourcePosition + 2] & 255) << 16 | (sourceData[sourcePosition + 3] & 255) << 8 | sourceData[sourcePosition] & 255;
							break;
						case 2:
							sourcePixel = (sourceData[sourcePosition + 2] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
							break;
						}
						if(premultiplied3) {
							if((sourcePixel & 255) != 0 && (sourcePixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (sourcePixel & 255);
								sourcePixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | sourcePixel & 255 & 255;
							}
						}
						var format4 = destFormat;
						var premultiplied4 = destPremultiplied;
						if(premultiplied4 == null) {
							premultiplied4 = false;
						}
						if(format4 == null) {
							format4 = 0;
						}
						if(premultiplied4) {
							if((sourcePixel & 255) == 0) {
								if(sourcePixel != 0) {
									sourcePixel = 0;
								}
							} else if((sourcePixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[sourcePixel & 255];
								sourcePixel = ((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | sourcePixel & 255 & 255;
							}
						}
						switch(format4) {
						case 0:
							destData[destPosition] = sourcePixel >>> 24 & 255;
							destData[destPosition + 1] = sourcePixel >>> 16 & 255;
							destData[destPosition + 2] = sourcePixel >>> 8 & 255;
							destData[destPosition + 3] = sourcePixel & 255;
							break;
						case 1:
							destData[destPosition] = sourcePixel & 255;
							destData[destPosition + 1] = sourcePixel >>> 24 & 255;
							destData[destPosition + 2] = sourcePixel >>> 16 & 255;
							destData[destPosition + 3] = sourcePixel >>> 8 & 255;
							break;
						case 2:
							destData[destPosition] = sourcePixel >>> 8 & 255;
							destData[destPosition + 1] = sourcePixel >>> 16 & 255;
							destData[destPosition + 2] = sourcePixel >>> 24 & 255;
							destData[destPosition + 3] = sourcePixel & 255;
							break;
						}
						sourcePosition += 4;
						destPosition += 4;
					}
				}
			}
		} else {
			var alphaData = alphaImage.buffer.data;
			var alphaFormat = alphaImage.buffer.format;
			var alphaPosition;
			var alphaPixel;
			var alphaView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(alphaImage,new (lime_math_Rectangle().default)(sourceView.x + (alphaPoint == null ? 0 : alphaPoint.x),sourceView.y + (alphaPoint == null ? 0 : alphaPoint.y),sourceView.width,sourceView.height));
			destView.clip((Std().default).int(destPoint.x),(Std().default).int(destPoint.y),alphaView.width,alphaView.height);
			if(blend) {
				var _g6 = 0;
				var _g15 = destView.height;
				while(_g6 < _g15) {
					var y3 = _g6++;
					sourcePosition = sourceView.row(y3);
					destPosition = destView.row(y3);
					alphaPosition = alphaView.row(y3);
					var _g7 = 0;
					var _g16 = destView.width;
					while(_g7 < _g16) {
						var x2 = _g7++;
						var format5 = sourceFormat;
						var premultiplied5 = sourcePremultiplied;
						if(premultiplied5 == null) {
							premultiplied5 = false;
						}
						if(format5 == null) {
							format5 = 0;
						}
						switch(format5) {
						case 0:
							sourcePixel = (sourceData[sourcePosition] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition + 2] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
							break;
						case 1:
							sourcePixel = (sourceData[sourcePosition + 1] & 255) << 24 | (sourceData[sourcePosition + 2] & 255) << 16 | (sourceData[sourcePosition + 3] & 255) << 8 | sourceData[sourcePosition] & 255;
							break;
						case 2:
							sourcePixel = (sourceData[sourcePosition + 2] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
							break;
						}
						if(premultiplied5) {
							if((sourcePixel & 255) != 0 && (sourcePixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (sourcePixel & 255);
								sourcePixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | sourcePixel & 255 & 255;
							}
						}
						var format6 = destFormat;
						var premultiplied6 = destPremultiplied;
						if(premultiplied6 == null) {
							premultiplied6 = false;
						}
						if(format6 == null) {
							format6 = 0;
						}
						switch(format6) {
						case 0:
							destPixel = (destData[destPosition] & 255) << 24 | (destData[destPosition + 1] & 255) << 16 | (destData[destPosition + 2] & 255) << 8 | destData[destPosition + 3] & 255;
							break;
						case 1:
							destPixel = (destData[destPosition + 1] & 255) << 24 | (destData[destPosition + 2] & 255) << 16 | (destData[destPosition + 3] & 255) << 8 | destData[destPosition] & 255;
							break;
						case 2:
							destPixel = (destData[destPosition + 2] & 255) << 24 | (destData[destPosition + 1] & 255) << 16 | (destData[destPosition] & 255) << 8 | destData[destPosition + 3] & 255;
							break;
						}
						if(premultiplied6) {
							if((destPixel & 255) != 0 && (destPixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (destPixel & 255);
								destPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | destPixel & 255 & 255;
							}
						}
						var format7 = alphaFormat;
						var premultiplied7 = false;
						if(premultiplied7 == null) {
							premultiplied7 = false;
						}
						if(format7 == null) {
							format7 = 0;
						}
						switch(format7) {
						case 0:
							alphaPixel = (alphaData[alphaPosition] & 255) << 24 | (alphaData[alphaPosition + 1] & 255) << 16 | (alphaData[alphaPosition + 2] & 255) << 8 | alphaData[alphaPosition + 3] & 255;
							break;
						case 1:
							alphaPixel = (alphaData[alphaPosition + 1] & 255) << 24 | (alphaData[alphaPosition + 2] & 255) << 16 | (alphaData[alphaPosition + 3] & 255) << 8 | alphaData[alphaPosition] & 255;
							break;
						case 2:
							alphaPixel = (alphaData[alphaPosition + 2] & 255) << 24 | (alphaData[alphaPosition + 1] & 255) << 16 | (alphaData[alphaPosition] & 255) << 8 | alphaData[alphaPosition + 3] & 255;
							break;
						}
						if(premultiplied7) {
							if((alphaPixel & 255) != 0 && (alphaPixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (alphaPixel & 255);
								alphaPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((alphaPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((alphaPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((alphaPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | alphaPixel & 255 & 255;
							}
						}
						sourceAlpha = (alphaPixel & 255) / 255.0 * ((sourcePixel & 255) / 255.0);
						if(sourceAlpha > 0) {
							destAlpha = (destPixel & 255) / 255.0;
							oneMinusSourceAlpha = 1 - sourceAlpha;
							blendAlpha = sourceAlpha + destAlpha * oneMinusSourceAlpha;
							var value4 = (lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round(((sourcePixel >>> 24 & 255) * sourceAlpha + (destPixel >>> 24 & 255) * destAlpha * oneMinusSourceAlpha) / blendAlpha)];
							destPixel = (value4 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
							var value5 = (lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round(((sourcePixel >>> 16 & 255) * sourceAlpha + (destPixel >>> 16 & 255) * destAlpha * oneMinusSourceAlpha) / blendAlpha)];
							destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (value5 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
							var value6 = (lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round(((sourcePixel >>> 8 & 255) * sourceAlpha + (destPixel >>> 8 & 255) * destAlpha * oneMinusSourceAlpha) / blendAlpha)];
							destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (value6 & 255) << 8 | destPixel & 255 & 255;
							var value7 = (lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round(blendAlpha * 255.0)];
							destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | value7 & 255;
							var format8 = destFormat;
							var premultiplied8 = destPremultiplied;
							if(premultiplied8 == null) {
								premultiplied8 = false;
							}
							if(format8 == null) {
								format8 = 0;
							}
							if(premultiplied8) {
								if((destPixel & 255) == 0) {
									if(destPixel != 0) {
										destPixel = 0;
									}
								} else if((destPixel & 255) != 255) {
									(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[destPixel & 255];
									destPixel = ((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | destPixel & 255 & 255;
								}
							}
							switch(format8) {
							case 0:
								destData[destPosition] = destPixel >>> 24 & 255;
								destData[destPosition + 1] = destPixel >>> 16 & 255;
								destData[destPosition + 2] = destPixel >>> 8 & 255;
								destData[destPosition + 3] = destPixel & 255;
								break;
							case 1:
								destData[destPosition] = destPixel & 255;
								destData[destPosition + 1] = destPixel >>> 24 & 255;
								destData[destPosition + 2] = destPixel >>> 16 & 255;
								destData[destPosition + 3] = destPixel >>> 8 & 255;
								break;
							case 2:
								destData[destPosition] = destPixel >>> 8 & 255;
								destData[destPosition + 1] = destPixel >>> 16 & 255;
								destData[destPosition + 2] = destPixel >>> 24 & 255;
								destData[destPosition + 3] = destPixel & 255;
								break;
							}
						}
						sourcePosition += 4;
						destPosition += 4;
						alphaPosition += 4;
					}
				}
			} else {
				var _g8 = 0;
				var _g17 = destView.height;
				while(_g8 < _g17) {
					var y4 = _g8++;
					sourcePosition = sourceView.row(y4);
					destPosition = destView.row(y4);
					alphaPosition = alphaView.row(y4);
					var _g9 = 0;
					var _g18 = destView.width;
					while(_g9 < _g18) {
						var x3 = _g9++;
						var format9 = sourceFormat;
						var premultiplied9 = sourcePremultiplied;
						if(premultiplied9 == null) {
							premultiplied9 = false;
						}
						if(format9 == null) {
							format9 = 0;
						}
						switch(format9) {
						case 0:
							sourcePixel = (sourceData[sourcePosition] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition + 2] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
							break;
						case 1:
							sourcePixel = (sourceData[sourcePosition + 1] & 255) << 24 | (sourceData[sourcePosition + 2] & 255) << 16 | (sourceData[sourcePosition + 3] & 255) << 8 | sourceData[sourcePosition] & 255;
							break;
						case 2:
							sourcePixel = (sourceData[sourcePosition + 2] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
							break;
						}
						if(premultiplied9) {
							if((sourcePixel & 255) != 0 && (sourcePixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (sourcePixel & 255);
								sourcePixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | sourcePixel & 255 & 255;
							}
						}
						var format10 = alphaFormat;
						var premultiplied10 = false;
						if(premultiplied10 == null) {
							premultiplied10 = false;
						}
						if(format10 == null) {
							format10 = 0;
						}
						switch(format10) {
						case 0:
							alphaPixel = (alphaData[alphaPosition] & 255) << 24 | (alphaData[alphaPosition + 1] & 255) << 16 | (alphaData[alphaPosition + 2] & 255) << 8 | alphaData[alphaPosition + 3] & 255;
							break;
						case 1:
							alphaPixel = (alphaData[alphaPosition + 1] & 255) << 24 | (alphaData[alphaPosition + 2] & 255) << 16 | (alphaData[alphaPosition + 3] & 255) << 8 | alphaData[alphaPosition] & 255;
							break;
						case 2:
							alphaPixel = (alphaData[alphaPosition + 2] & 255) << 24 | (alphaData[alphaPosition + 1] & 255) << 16 | (alphaData[alphaPosition] & 255) << 8 | alphaData[alphaPosition + 3] & 255;
							break;
						}
						if(premultiplied10) {
							if((alphaPixel & 255) != 0 && (alphaPixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (alphaPixel & 255);
								alphaPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((alphaPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((alphaPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((alphaPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | alphaPixel & 255 & 255;
							}
						}
						var value8 = Math.round((sourcePixel & 255) * ((alphaPixel & 255) / 255));
						sourcePixel = (sourcePixel >>> 24 & 255 & 255) << 24 | (sourcePixel >>> 16 & 255 & 255) << 16 | (sourcePixel >>> 8 & 255 & 255) << 8 | value8 & 255;
						var format11 = destFormat;
						var premultiplied11 = destPremultiplied;
						if(premultiplied11 == null) {
							premultiplied11 = false;
						}
						if(format11 == null) {
							format11 = 0;
						}
						if(premultiplied11) {
							if((sourcePixel & 255) == 0) {
								if(sourcePixel != 0) {
									sourcePixel = 0;
								}
							} else if((sourcePixel & 255) != 255) {
								(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[sourcePixel & 255];
								sourcePixel = ((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | sourcePixel & 255 & 255;
							}
						}
						switch(format11) {
						case 0:
							destData[destPosition] = sourcePixel >>> 24 & 255;
							destData[destPosition + 1] = sourcePixel >>> 16 & 255;
							destData[destPosition + 2] = sourcePixel >>> 8 & 255;
							destData[destPosition + 3] = sourcePixel & 255;
							break;
						case 1:
							destData[destPosition] = sourcePixel & 255;
							destData[destPosition + 1] = sourcePixel >>> 24 & 255;
							destData[destPosition + 2] = sourcePixel >>> 16 & 255;
							destData[destPosition + 3] = sourcePixel >>> 8 & 255;
							break;
						case 2:
							destData[destPosition] = sourcePixel >>> 8 & 255;
							destData[destPosition + 1] = sourcePixel >>> 16 & 255;
							destData[destPosition + 2] = sourcePixel >>> 24 & 255;
							destData[destPosition + 3] = sourcePixel & 255;
							break;
						}
						sourcePosition += 4;
						destPosition += 4;
						alphaPosition += 4;
					}
				}
			}
		}
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.fillRect = function(image,rect,color,format) {
	var fillColor;
	switch(format) {
	case 1:
		var argb = color;
		var this1 = 0;
		var rgba = this1;
		rgba = (argb >>> 16 & 255 & 255) << 24 | (argb >>> 8 & 255 & 255) << 16 | (argb & 255 & 255) << 8 | argb >>> 24 & 255 & 255;
		fillColor = rgba;
		break;
	case 2:
		var bgra = color;
		var this2 = 0;
		var rgba1 = this2;
		rgba1 = (bgra >>> 8 & 255 & 255) << 24 | (bgra >>> 16 & 255 & 255) << 16 | (bgra >>> 24 & 255 & 255) << 8 | bgra & 255 & 255;
		fillColor = rgba1;
		break;
	default:
		fillColor = color;
	}
	if(!image.get_transparent()) {
		fillColor = (fillColor >>> 24 & 255 & 255) << 24 | (fillColor >>> 16 & 255 & 255) << 16 | (fillColor >>> 8 & 255 & 255) << 8 | 255;
	}
	var data = image.buffer.data;
	if(data == null) {
		return;
	}
	var format1 = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	if(premultiplied) {
		if((fillColor & 255) == 0) {
			if(fillColor != 0) {
				fillColor = 0;
			}
		} else if((fillColor & 255) != 255) {
			(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[fillColor & 255];
			fillColor = ((fillColor >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((fillColor >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((fillColor >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | fillColor & 255 & 255;
		}
	}
	var dataView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(image,rect);
	var row;
	var _g = 0;
	var _g1 = dataView.height;
	while(_g < _g1) {
		var y = _g++;
		row = dataView.row(y);
		var _g2 = 0;
		var _g11 = dataView.width;
		while(_g2 < _g11) {
			var x = _g2++;
			var offset = row + x * 4;
			var format2 = format1;
			var premultiplied1 = false;
			if(premultiplied1 == null) {
				premultiplied1 = false;
			}
			if(format2 == null) {
				format2 = 0;
			}
			if(premultiplied1) {
				if((fillColor & 255) == 0) {
					if(fillColor != 0) {
						fillColor = 0;
					}
				} else if((fillColor & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[fillColor & 255];
					fillColor = ((fillColor >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((fillColor >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((fillColor >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | fillColor & 255 & 255;
				}
			}
			switch(format2) {
			case 0:
				data[offset] = fillColor >>> 24 & 255;
				data[offset + 1] = fillColor >>> 16 & 255;
				data[offset + 2] = fillColor >>> 8 & 255;
				data[offset + 3] = fillColor & 255;
				break;
			case 1:
				data[offset] = fillColor & 255;
				data[offset + 1] = fillColor >>> 24 & 255;
				data[offset + 2] = fillColor >>> 16 & 255;
				data[offset + 3] = fillColor >>> 8 & 255;
				break;
			case 2:
				data[offset] = fillColor >>> 8 & 255;
				data[offset + 1] = fillColor >>> 16 & 255;
				data[offset + 2] = fillColor >>> 24 & 255;
				data[offset + 3] = fillColor & 255;
				break;
			}
		}
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.floodFill = function(image,x,y,color,format) {
	var data = image.buffer.data;
	if(data == null) {
		return;
	}
	if(format == 1) {
		color = (color & 16777215) << 8 | color >> 24 & 255;
	}
	var format1 = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	var fillColor = color;
	var hitColor;
	var offset = (y + image.offsetY) * (image.buffer.width * 4) + (x + image.offsetX) * 4;
	var format2 = format1;
	var premultiplied1 = premultiplied;
	if(premultiplied1 == null) {
		premultiplied1 = false;
	}
	if(format2 == null) {
		format2 = 0;
	}
	switch(format2) {
	case 0:
		hitColor = (data[offset] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset + 2] & 255) << 8 | data[offset + 3] & 255;
		break;
	case 1:
		hitColor = (data[offset + 1] & 255) << 24 | (data[offset + 2] & 255) << 16 | (data[offset + 3] & 255) << 8 | data[offset] & 255;
		break;
	case 2:
		hitColor = (data[offset + 2] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset] & 255) << 8 | data[offset + 3] & 255;
		break;
	}
	if(premultiplied1) {
		if((hitColor & 255) != 0 && (hitColor & 255) != 255) {
			(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (hitColor & 255);
			hitColor = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((hitColor >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((hitColor >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((hitColor >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | hitColor & 255 & 255;
		}
	}
	if(!image.get_transparent()) {
		fillColor = (fillColor >>> 24 & 255 & 255) << 24 | (fillColor >>> 16 & 255 & 255) << 16 | (fillColor >>> 8 & 255 & 255) << 8 | 255;
		hitColor = (hitColor >>> 24 & 255 & 255) << 24 | (hitColor >>> 16 & 255 & 255) << 16 | (hitColor >>> 8 & 255 & 255) << 8 | 255;
	}
	if(fillColor == hitColor) {
		return;
	}
	if(premultiplied) {
		if((fillColor & 255) == 0) {
			if(fillColor != 0) {
				fillColor = 0;
			}
		} else if((fillColor & 255) != 255) {
			(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[fillColor & 255];
			fillColor = ((fillColor >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((fillColor >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((fillColor >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | fillColor & 255 & 255;
		}
	}
	var dx = [0,-1,1,0];
	var dy = [-1,0,0,1];
	var minX = -image.offsetX;
	var minY = -image.offsetY;
	var maxX = minX + image.width;
	var maxY = minY + image.height;
	var queue = [];
	queue.push(x);
	queue.push(y);
	var curPointX;
	var curPointY;
	var nextPointX;
	var nextPointY;
	var nextPointOffset;
	var readColor;
	while(queue.length > 0) {
		curPointY = queue.pop();
		curPointX = queue.pop();
		var _g = 0;
		while(_g < 4) {
			var i = _g++;
			nextPointX = curPointX + dx[i];
			nextPointY = curPointY + dy[i];
			if(nextPointX < minX || nextPointY < minY || nextPointX >= maxX || nextPointY >= maxY) {
				continue;
			}
			nextPointOffset = (nextPointY * image.width + nextPointX) * 4;
			var format3 = format1;
			var premultiplied2 = premultiplied;
			if(premultiplied2 == null) {
				premultiplied2 = false;
			}
			if(format3 == null) {
				format3 = 0;
			}
			switch(format3) {
			case 0:
				readColor = (data[nextPointOffset] & 255) << 24 | (data[nextPointOffset + 1] & 255) << 16 | (data[nextPointOffset + 2] & 255) << 8 | data[nextPointOffset + 3] & 255;
				break;
			case 1:
				readColor = (data[nextPointOffset + 1] & 255) << 24 | (data[nextPointOffset + 2] & 255) << 16 | (data[nextPointOffset + 3] & 255) << 8 | data[nextPointOffset] & 255;
				break;
			case 2:
				readColor = (data[nextPointOffset + 2] & 255) << 24 | (data[nextPointOffset + 1] & 255) << 16 | (data[nextPointOffset] & 255) << 8 | data[nextPointOffset + 3] & 255;
				break;
			}
			if(premultiplied2) {
				if((readColor & 255) != 0 && (readColor & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (readColor & 255);
					readColor = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((readColor >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((readColor >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((readColor >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | readColor & 255 & 255;
				}
			}
			if(readColor == hitColor) {
				var format4 = format1;
				var premultiplied3 = false;
				if(premultiplied3 == null) {
					premultiplied3 = false;
				}
				if(format4 == null) {
					format4 = 0;
				}
				if(premultiplied3) {
					if((fillColor & 255) == 0) {
						if(fillColor != 0) {
							fillColor = 0;
						}
					} else if((fillColor & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[fillColor & 255];
						fillColor = ((fillColor >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((fillColor >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((fillColor >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | fillColor & 255 & 255;
					}
				}
				switch(format4) {
				case 0:
					data[nextPointOffset] = fillColor >>> 24 & 255;
					data[nextPointOffset + 1] = fillColor >>> 16 & 255;
					data[nextPointOffset + 2] = fillColor >>> 8 & 255;
					data[nextPointOffset + 3] = fillColor & 255;
					break;
				case 1:
					data[nextPointOffset] = fillColor & 255;
					data[nextPointOffset + 1] = fillColor >>> 24 & 255;
					data[nextPointOffset + 2] = fillColor >>> 16 & 255;
					data[nextPointOffset + 3] = fillColor >>> 8 & 255;
					break;
				case 2:
					data[nextPointOffset] = fillColor >>> 8 & 255;
					data[nextPointOffset + 1] = fillColor >>> 16 & 255;
					data[nextPointOffset + 2] = fillColor >>> 24 & 255;
					data[nextPointOffset + 3] = fillColor & 255;
					break;
				}
				queue.push(nextPointX);
				queue.push(nextPointY);
			}
		}
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.gaussianBlur = function(image,sourceImage,sourceRect,destPoint,blurX,blurY,quality,strength,color) {
	if(strength == null) {
		strength = 1;
	}
	if(quality == null) {
		quality = 1;
	}
	if(blurY == null) {
		blurY = 4;
	}
	if(blurX == null) {
		blurX = 4;
	}
	var imagePremultiplied = image.get_premultiplied();
	if(imagePremultiplied) {
		image.set_premultiplied(false);
	}
	(lime__$internal_graphics_StackBlur().default).blur(image,sourceImage,sourceRect,destPoint,blurX,blurY,quality);
	image.dirty = true;
	image.version++;
	if(imagePremultiplied) {
		image.set_premultiplied(true);
	}
	return image;
}
ImageDataUtil.getColorBoundsRect = function(image,mask,color,findColor,format) {
	var left = image.width + 1;
	var right = 0;
	var top = image.height + 1;
	var bottom = 0;
	var _color;
	var _mask;
	switch(format) {
	case 1:
		var argb = color;
		var this1 = 0;
		var rgba = this1;
		rgba = (argb >>> 16 & 255 & 255) << 24 | (argb >>> 8 & 255 & 255) << 16 | (argb & 255 & 255) << 8 | argb >>> 24 & 255 & 255;
		_color = rgba;
		var argb1 = mask;
		var this2 = 0;
		var rgba1 = this2;
		rgba1 = (argb1 >>> 16 & 255 & 255) << 24 | (argb1 >>> 8 & 255 & 255) << 16 | (argb1 & 255 & 255) << 8 | argb1 >>> 24 & 255 & 255;
		_mask = rgba1;
		break;
	case 2:
		var bgra = color;
		var this3 = 0;
		var rgba2 = this3;
		rgba2 = (bgra >>> 8 & 255 & 255) << 24 | (bgra >>> 16 & 255 & 255) << 16 | (bgra >>> 24 & 255 & 255) << 8 | bgra & 255 & 255;
		_color = rgba2;
		var bgra1 = mask;
		var this4 = 0;
		var rgba3 = this4;
		rgba3 = (bgra1 >>> 8 & 255 & 255) << 24 | (bgra1 >>> 16 & 255 & 255) << 16 | (bgra1 >>> 24 & 255 & 255) << 8 | bgra1 & 255 & 255;
		_mask = rgba3;
		break;
	default:
		_color = color;
		_mask = mask;
	}
	if(!image.get_transparent()) {
		_color = (_color >>> 24 & 255 & 255) << 24 | (_color >>> 16 & 255 & 255) << 16 | (_color >>> 8 & 255 & 255) << 8 | 255;
		_mask = (_mask >>> 24 & 255 & 255) << 24 | (_mask >>> 16 & 255 & 255) << 16 | (_mask >>> 8 & 255 & 255) << 8 | 255;
	}
	var pixel;
	var hit;
	var _g = 0;
	var _g1 = image.width;
	while(_g < _g1) {
		var x = _g++;
		hit = false;
		var _g2 = 0;
		var _g11 = image.height;
		while(_g2 < _g11) {
			var y = _g2++;
			pixel = image.getPixel32(x,y,0);
			hit = findColor ? (pixel & _mask) == _color : (pixel & _mask) != _color;
			if(hit) {
				if(x < left) {
					left = x;
				}
				break;
			}
		}
		if(hit) {
			break;
		}
	}
	var ix;
	var _g21 = 0;
	var _g3 = image.width;
	while(_g21 < _g3) {
		var x1 = _g21++;
		ix = image.width - 1 - x1;
		hit = false;
		var _g22 = 0;
		var _g31 = image.height;
		while(_g22 < _g31) {
			var y1 = _g22++;
			pixel = image.getPixel32(ix,y1,0);
			hit = findColor ? (pixel & _mask) == _color : (pixel & _mask) != _color;
			if(hit) {
				if(ix > right) {
					right = ix;
				}
				break;
			}
		}
		if(hit) {
			break;
		}
	}
	var _g4 = 0;
	var _g5 = image.height;
	while(_g4 < _g5) {
		var y2 = _g4++;
		hit = false;
		var _g41 = 0;
		var _g51 = image.width;
		while(_g41 < _g51) {
			var x2 = _g41++;
			pixel = image.getPixel32(x2,y2,0);
			hit = findColor ? (pixel & _mask) == _color : (pixel & _mask) != _color;
			if(hit) {
				if(y2 < top) {
					top = y2;
				}
				break;
			}
		}
		if(hit) {
			break;
		}
	}
	var iy;
	var _g6 = 0;
	var _g7 = image.height;
	while(_g6 < _g7) {
		var y3 = _g6++;
		iy = image.height - 1 - y3;
		hit = false;
		var _g61 = 0;
		var _g71 = image.width;
		while(_g61 < _g71) {
			var x3 = _g61++;
			pixel = image.getPixel32(x3,iy,0);
			hit = findColor ? (pixel & _mask) == _color : (pixel & _mask) != _color;
			if(hit) {
				if(iy > bottom) {
					bottom = iy;
				}
				break;
			}
		}
		if(hit) {
			break;
		}
	}
	var w = right - left;
	var h = bottom - top;
	if(w > 0) {
		++w;
	}
	if(h > 0) {
		++h;
	}
	if(w < 0) {
		w = 0;
	}
	if(h < 0) {
		h = 0;
	}
	if(left == right) {
		w = 1;
	}
	if(top == bottom) {
		h = 1;
	}
	if(left > image.width) {
		left = 0;
	}
	if(top > image.height) {
		top = 0;
	}
	return new (lime_math_Rectangle().default)(left,top,w,h);
}
ImageDataUtil.getPixel = function(image,x,y,format) {
	var pixel;
	var data = image.buffer.data;
	var offset = 4 * (y + image.offsetY) * image.buffer.width + (x + image.offsetX) * 4;
	var format1 = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	if(premultiplied == null) {
		premultiplied = false;
	}
	if(format1 == null) {
		format1 = 0;
	}
	switch(format1) {
	case 0:
		pixel = (data[offset] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset + 2] & 255) << 8 | data[offset + 3] & 255;
		break;
	case 1:
		pixel = (data[offset + 1] & 255) << 24 | (data[offset + 2] & 255) << 16 | (data[offset + 3] & 255) << 8 | data[offset] & 255;
		break;
	case 2:
		pixel = (data[offset + 2] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset] & 255) << 8 | data[offset + 3] & 255;
		break;
	}
	if(premultiplied) {
		if((pixel & 255) != 0 && (pixel & 255) != 255) {
			(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (pixel & 255);
			pixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | pixel & 255 & 255;
		}
	}
	pixel = (pixel >>> 24 & 255 & 255) << 24 | (pixel >>> 16 & 255 & 255) << 16 | (pixel >>> 8 & 255 & 255) << 8 | 0;
	switch(format) {
	case 1:
		var this1 = 0;
		var argb = this1;
		argb = (pixel & 255 & 255) << 24 | (pixel >>> 24 & 255 & 255) << 16 | (pixel >>> 16 & 255 & 255) << 8 | pixel >>> 8 & 255 & 255;
		return argb;
	case 2:
		var this2 = 0;
		var bgra = this2;
		bgra = (pixel >>> 8 & 255 & 255) << 24 | (pixel >>> 16 & 255 & 255) << 16 | (pixel >>> 24 & 255 & 255) << 8 | pixel & 255 & 255;
		return bgra;
	default:
		return pixel;
	}
}
ImageDataUtil.getPixel32 = function(image,x,y,format) {
	var pixel;
	var data = image.buffer.data;
	var offset = 4 * (y + image.offsetY) * image.buffer.width + (x + image.offsetX) * 4;
	var format1 = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	if(premultiplied == null) {
		premultiplied = false;
	}
	if(format1 == null) {
		format1 = 0;
	}
	switch(format1) {
	case 0:
		pixel = (data[offset] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset + 2] & 255) << 8 | data[offset + 3] & 255;
		break;
	case 1:
		pixel = (data[offset + 1] & 255) << 24 | (data[offset + 2] & 255) << 16 | (data[offset + 3] & 255) << 8 | data[offset] & 255;
		break;
	case 2:
		pixel = (data[offset + 2] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset] & 255) << 8 | data[offset + 3] & 255;
		break;
	}
	if(premultiplied) {
		if((pixel & 255) != 0 && (pixel & 255) != 255) {
			(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (pixel & 255);
			pixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | pixel & 255 & 255;
		}
	}
	switch(format) {
	case 1:
		var this1 = 0;
		var argb = this1;
		argb = (pixel & 255 & 255) << 24 | (pixel >>> 24 & 255 & 255) << 16 | (pixel >>> 16 & 255 & 255) << 8 | pixel >>> 8 & 255 & 255;
		return argb;
	case 2:
		var this2 = 0;
		var bgra = this2;
		bgra = (pixel >>> 8 & 255 & 255) << 24 | (pixel >>> 16 & 255 & 255) << 16 | (pixel >>> 24 & 255 & 255) << 8 | pixel & 255 & 255;
		return bgra;
	default:
		return pixel;
	}
}
ImageDataUtil.getPixels = function(image,rect,format) {
	if(image.buffer.data == null) {
		return null;
	}
	var length = (Std().default).int(rect.width * rect.height);
	var bytes = (haxe_io_Bytes().default).alloc(length * 4);
	var data = image.buffer.data;
	var sourceFormat = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	var dataView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(image,rect);
	var position;
	var argb;
	var bgra;
	var pixel;
	var destPosition = 0;
	var _g = 0;
	var _g1 = dataView.height;
	while(_g < _g1) {
		var y = _g++;
		position = dataView.row(y);
		var _g2 = 0;
		var _g11 = dataView.width;
		while(_g2 < _g11) {
			var x = _g2++;
			var format1 = sourceFormat;
			var premultiplied1 = premultiplied;
			if(premultiplied1 == null) {
				premultiplied1 = false;
			}
			if(format1 == null) {
				format1 = 0;
			}
			switch(format1) {
			case 0:
				pixel = (data[position] & 255) << 24 | (data[position + 1] & 255) << 16 | (data[position + 2] & 255) << 8 | data[position + 3] & 255;
				break;
			case 1:
				pixel = (data[position + 1] & 255) << 24 | (data[position + 2] & 255) << 16 | (data[position + 3] & 255) << 8 | data[position] & 255;
				break;
			case 2:
				pixel = (data[position + 2] & 255) << 24 | (data[position + 1] & 255) << 16 | (data[position] & 255) << 8 | data[position + 3] & 255;
				break;
			}
			if(premultiplied1) {
				if((pixel & 255) != 0 && (pixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (pixel & 255);
					pixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | pixel & 255 & 255;
				}
			}
			switch(format) {
			case 1:
				var this1 = 0;
				var argb1 = this1;
				argb1 = (pixel & 255 & 255) << 24 | (pixel >>> 24 & 255 & 255) << 16 | (pixel >>> 16 & 255 & 255) << 8 | pixel >>> 8 & 255 & 255;
				argb = argb1;
				pixel = argb;
				break;
			case 2:
				var this2 = 0;
				var bgra1 = this2;
				bgra1 = (pixel >>> 8 & 255 & 255) << 24 | (pixel >>> 16 & 255 & 255) << 16 | (pixel >>> 24 & 255 & 255) << 8 | pixel & 255 & 255;
				bgra = bgra1;
				pixel = bgra;
				break;
			default:
			}
			bytes.set(destPosition++,pixel >>> 24 & 255);
			bytes.set(destPosition++,pixel >>> 16 & 255);
			bytes.set(destPosition++,pixel >>> 8 & 255);
			bytes.set(destPosition++,pixel & 255);
			position += 4;
		}
	}
	return bytes;
}
ImageDataUtil.merge = function(image,sourceImage,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier) {
	if(image.buffer.data == null || sourceImage.buffer.data == null) {
		return;
	}
	var sourceView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(sourceImage,sourceRect);
	var destView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(image,new (lime_math_Rectangle().default)(destPoint.x,destPoint.y,sourceView.width,sourceView.height));
	var sourceData = sourceImage.buffer.data;
	var destData = image.buffer.data;
	var sourceFormat = sourceImage.buffer.format;
	var destFormat = image.buffer.format;
	var sourcePremultiplied = sourceImage.buffer.premultiplied;
	var destPremultiplied = image.buffer.premultiplied;
	var sourcePosition;
	var destPosition;
	var sourcePixel;
	var destPixel;
	var _g = 0;
	var _g1 = destView.height;
	while(_g < _g1) {
		var y = _g++;
		sourcePosition = sourceView.row(y);
		destPosition = destView.row(y);
		var _g2 = 0;
		var _g11 = destView.width;
		while(_g2 < _g11) {
			var x = _g2++;
			var format = sourceFormat;
			var premultiplied = sourcePremultiplied;
			if(premultiplied == null) {
				premultiplied = false;
			}
			if(format == null) {
				format = 0;
			}
			switch(format) {
			case 0:
				sourcePixel = (sourceData[sourcePosition] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition + 2] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
				break;
			case 1:
				sourcePixel = (sourceData[sourcePosition + 1] & 255) << 24 | (sourceData[sourcePosition + 2] & 255) << 16 | (sourceData[sourcePosition + 3] & 255) << 8 | sourceData[sourcePosition] & 255;
				break;
			case 2:
				sourcePixel = (sourceData[sourcePosition + 2] & 255) << 24 | (sourceData[sourcePosition + 1] & 255) << 16 | (sourceData[sourcePosition] & 255) << 8 | sourceData[sourcePosition + 3] & 255;
				break;
			}
			if(premultiplied) {
				if((sourcePixel & 255) != 0 && (sourcePixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (sourcePixel & 255);
					sourcePixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | sourcePixel & 255 & 255;
				}
			}
			var format1 = destFormat;
			var premultiplied1 = destPremultiplied;
			if(premultiplied1 == null) {
				premultiplied1 = false;
			}
			if(format1 == null) {
				format1 = 0;
			}
			switch(format1) {
			case 0:
				destPixel = (destData[destPosition] & 255) << 24 | (destData[destPosition + 1] & 255) << 16 | (destData[destPosition + 2] & 255) << 8 | destData[destPosition + 3] & 255;
				break;
			case 1:
				destPixel = (destData[destPosition + 1] & 255) << 24 | (destData[destPosition + 2] & 255) << 16 | (destData[destPosition + 3] & 255) << 8 | destData[destPosition] & 255;
				break;
			case 2:
				destPixel = (destData[destPosition + 2] & 255) << 24 | (destData[destPosition + 1] & 255) << 16 | (destData[destPosition] & 255) << 8 | destData[destPosition + 3] & 255;
				break;
			}
			if(premultiplied1) {
				if((destPixel & 255) != 0 && (destPixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (destPixel & 255);
					destPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | destPixel & 255 & 255;
				}
			}
			var value = (Std().default).int(((sourcePixel >>> 24 & 255) * redMultiplier + (destPixel >>> 24 & 255) * (256 - redMultiplier)) / 256);
			destPixel = (value & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
			var value1 = (Std().default).int(((sourcePixel >>> 16 & 255) * greenMultiplier + (destPixel >>> 16 & 255) * (256 - greenMultiplier)) / 256);
			destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (value1 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
			var value2 = (Std().default).int(((sourcePixel >>> 8 & 255) * blueMultiplier + (destPixel >>> 8 & 255) * (256 - blueMultiplier)) / 256);
			destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (value2 & 255) << 8 | destPixel & 255 & 255;
			var value3 = (Std().default).int(((sourcePixel & 255) * alphaMultiplier + (destPixel & 255) * (256 - alphaMultiplier)) / 256);
			destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | value3 & 255;
			var format2 = destFormat;
			var premultiplied2 = destPremultiplied;
			if(premultiplied2 == null) {
				premultiplied2 = false;
			}
			if(format2 == null) {
				format2 = 0;
			}
			if(premultiplied2) {
				if((destPixel & 255) == 0) {
					if(destPixel != 0) {
						destPixel = 0;
					}
				} else if((destPixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[destPixel & 255];
					destPixel = ((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | destPixel & 255 & 255;
				}
			}
			switch(format2) {
			case 0:
				destData[destPosition] = destPixel >>> 24 & 255;
				destData[destPosition + 1] = destPixel >>> 16 & 255;
				destData[destPosition + 2] = destPixel >>> 8 & 255;
				destData[destPosition + 3] = destPixel & 255;
				break;
			case 1:
				destData[destPosition] = destPixel & 255;
				destData[destPosition + 1] = destPixel >>> 24 & 255;
				destData[destPosition + 2] = destPixel >>> 16 & 255;
				destData[destPosition + 3] = destPixel >>> 8 & 255;
				break;
			case 2:
				destData[destPosition] = destPixel >>> 8 & 255;
				destData[destPosition + 1] = destPixel >>> 16 & 255;
				destData[destPosition + 2] = destPixel >>> 24 & 255;
				destData[destPosition + 3] = destPixel & 255;
				break;
			}
			sourcePosition += 4;
			destPosition += 4;
		}
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.multiplyAlpha = function(image) {
	var data = image.buffer.data;
	if(data == null || !image.buffer.transparent) {
		return;
	}
	var format = image.buffer.format;
	var length = (Std().default).int(data.length / 4);
	var pixel;
	var _g = 0;
	var _g1 = length;
	while(_g < _g1) {
		var i = _g++;
		var offset = i * 4;
		var format1 = format;
		var premultiplied = false;
		if(premultiplied == null) {
			premultiplied = false;
		}
		if(format1 == null) {
			format1 = 0;
		}
		switch(format1) {
		case 0:
			pixel = (data[offset] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset + 2] & 255) << 8 | data[offset + 3] & 255;
			break;
		case 1:
			pixel = (data[offset + 1] & 255) << 24 | (data[offset + 2] & 255) << 16 | (data[offset + 3] & 255) << 8 | data[offset] & 255;
			break;
		case 2:
			pixel = (data[offset + 2] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset] & 255) << 8 | data[offset + 3] & 255;
			break;
		}
		if(premultiplied) {
			if((pixel & 255) != 0 && (pixel & 255) != 255) {
				(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (pixel & 255);
				pixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | pixel & 255 & 255;
			}
		}
		var offset1 = i * 4;
		var format2 = format;
		var premultiplied1 = true;
		if(premultiplied1 == null) {
			premultiplied1 = false;
		}
		if(format2 == null) {
			format2 = 0;
		}
		if(premultiplied1) {
			if((pixel & 255) == 0) {
				if(pixel != 0) {
					pixel = 0;
				}
			} else if((pixel & 255) != 255) {
				(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[pixel & 255];
				pixel = ((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | pixel & 255 & 255;
			}
		}
		switch(format2) {
		case 0:
			data[offset1] = pixel >>> 24 & 255;
			data[offset1 + 1] = pixel >>> 16 & 255;
			data[offset1 + 2] = pixel >>> 8 & 255;
			data[offset1 + 3] = pixel & 255;
			break;
		case 1:
			data[offset1] = pixel & 255;
			data[offset1 + 1] = pixel >>> 24 & 255;
			data[offset1 + 2] = pixel >>> 16 & 255;
			data[offset1 + 3] = pixel >>> 8 & 255;
			break;
		case 2:
			data[offset1] = pixel >>> 8 & 255;
			data[offset1 + 1] = pixel >>> 16 & 255;
			data[offset1 + 2] = pixel >>> 24 & 255;
			data[offset1 + 3] = pixel & 255;
			break;
		}
	}
	image.buffer.premultiplied = true;
	image.dirty = true;
	image.version++;
}
ImageDataUtil.resize = function(image,newWidth,newHeight) {
	var buffer = image.buffer;
	if(buffer.width == newWidth && buffer.height == newHeight) {
		return;
	}
	var elements = newWidth * newHeight * 4;
	var array = null;
	var view = null;
	var buffer1 = null;
	var len = null;
	var this1;
	if(elements != null) {
		this1 = new Uint8Array(elements);
	} else if(array != null) {
		this1 = new Uint8Array(array);
	} else if(view != null) {
		this1 = new Uint8Array(view);
	} else if(buffer1 != null) {
		if(len == null) {
			this1 = new Uint8Array(buffer1,0);
		} else {
			this1 = new Uint8Array(buffer1,0,len);
		}
	} else {
		this1 = null;
	}
	var newBuffer = new (lime_graphics_ImageBuffer().default)(this1,newWidth,newHeight);
	var imageWidth = image.width;
	var imageHeight = image.height;
	var data = image.get_data();
	var newData = newBuffer.data;
	var sourceIndex;
	var sourceIndexX;
	var sourceIndexY;
	var sourceIndexXY;
	var index;
	var sourceX;
	var sourceY;
	var u;
	var v;
	var uRatio;
	var vRatio;
	var uOpposite;
	var vOpposite;
	var _g = 0;
	var _g1 = newHeight;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g11 = newWidth;
		while(_g2 < _g11) {
			var x = _g2++;
			u = (x + 0.5) / newWidth * imageWidth - 0.5;
			v = (y + 0.5) / newHeight * imageHeight - 0.5;
			sourceX = (Std().default).int(u);
			sourceY = (Std().default).int(v);
			sourceIndex = (sourceY * imageWidth + sourceX) * 4;
			sourceIndexX = sourceX < imageWidth - 1 ? sourceIndex + 4 : sourceIndex;
			sourceIndexY = sourceY < imageHeight - 1 ? sourceIndex + imageWidth * 4 : sourceIndex;
			sourceIndexXY = sourceIndexX != sourceIndex ? sourceIndexY + 4 : sourceIndexY;
			index = (y * newWidth + x) * 4;
			uRatio = u - sourceX;
			vRatio = v - sourceY;
			uOpposite = 1 - uRatio;
			vOpposite = 1 - vRatio;
			newData[index] = (Std().default).int(((_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndex]) * uOpposite + (_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexX]) * uRatio) * vOpposite + ((_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexY]) * uOpposite + (_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexXY]) * uRatio) * vRatio);
			newData[index + 1] = (Std().default).int(((_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndex + 1]) * uOpposite + (_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexX + 1]) * uRatio) * vOpposite + ((_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexY + 1]) * uOpposite + (_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexXY + 1]) * uRatio) * vRatio);
			newData[index + 2] = (Std().default).int(((_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndex + 2]) * uOpposite + (_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexX + 2]) * uRatio) * vOpposite + ((_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexY + 2]) * uOpposite + (_$UInt_UInt_$Impl_$().default).toFloat(data[sourceIndexXY + 2]) * uRatio) * vRatio);
			if(data[sourceIndexX + 3] == 0 || data[sourceIndexY + 3] == 0 || data[sourceIndexXY + 3] == 0) {
				newData[index + 3] = 0;
			} else {
				newData[index + 3] = data[sourceIndex + 3];
			}
		}
	}
	buffer.data = newBuffer.data;
	buffer.width = newWidth;
	buffer.height = newHeight;
	buffer.__srcImage = null;
	buffer.__srcImageData = null;
	buffer.__srcCanvas = null;
	buffer.__srcContext = null;
	image.dirty = true;
	image.version++;
}
ImageDataUtil.resizeBuffer = function(image,newWidth,newHeight) {
	var buffer = image.buffer;
	var data = image.get_data();
	var elements = newWidth * newHeight * 4;
	var array = null;
	var view = null;
	var buffer1 = null;
	var len = null;
	var this1;
	if(elements != null) {
		this1 = new Uint8Array(elements);
	} else if(array != null) {
		this1 = new Uint8Array(array);
	} else if(view != null) {
		this1 = new Uint8Array(view);
	} else if(buffer1 != null) {
		if(len == null) {
			this1 = new Uint8Array(buffer1,0);
		} else {
			this1 = new Uint8Array(buffer1,0,len);
		}
	} else {
		this1 = null;
	}
	var newData = this1;
	var sourceIndex;
	var index;
	var _g = 0;
	var _g1 = buffer.height;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g11 = buffer.width;
		while(_g2 < _g11) {
			var x = _g2++;
			sourceIndex = (y * buffer.width + x) * 4;
			index = (y * newWidth + x) * 4;
			newData[index] = data[sourceIndex];
			newData[index + 1] = data[sourceIndex + 1];
			newData[index + 2] = data[sourceIndex + 2];
			newData[index + 3] = data[sourceIndex + 3];
		}
	}
	buffer.data = newData;
	buffer.width = newWidth;
	buffer.height = newHeight;
	buffer.__srcImage = null;
	buffer.__srcImageData = null;
	buffer.__srcCanvas = null;
	buffer.__srcContext = null;
	image.dirty = true;
	image.version++;
}
ImageDataUtil.setFormat = function(image,format) {
	var data = image.buffer.data;
	if(data == null) {
		return;
	}
	var index;
	var a16;
	var length = (Std().default).int(data.length / 4);
	var r1;
	var g1;
	var b1;
	var a1;
	var r2;
	var g2;
	var b2;
	var a2;
	var r;
	var g;
	var b;
	var a;
	switch(image.get_format()) {
	case 0:
		r1 = 0;
		g1 = 1;
		b1 = 2;
		a1 = 3;
		break;
	case 1:
		r1 = 1;
		g1 = 2;
		b1 = 3;
		a1 = 0;
		break;
	case 2:
		r1 = 2;
		g1 = 1;
		b1 = 0;
		a1 = 3;
		break;
	}
	switch(format) {
	case 0:
		r2 = 0;
		g2 = 1;
		b2 = 2;
		a2 = 3;
		break;
	case 1:
		r2 = 1;
		g2 = 2;
		b2 = 3;
		a2 = 0;
		break;
	case 2:
		r2 = 2;
		g2 = 1;
		b2 = 0;
		a2 = 3;
		break;
	}
	var _g1 = 0;
	var _g2 = length;
	while(_g1 < _g2) {
		var i = _g1++;
		index = i * 4;
		r = data[index + r1];
		g = data[index + g1];
		b = data[index + b1];
		a = data[index + a1];
		data[index + r2] = r;
		data[index + g2] = g;
		data[index + b2] = b;
		data[index + a2] = a;
	}
	image.buffer.format = format;
	image.dirty = true;
	image.version++;
}
ImageDataUtil.setPixel = function(image,x,y,color,format) {
	var pixel;
	switch(format) {
	case 1:
		var argb = color;
		var this1 = 0;
		var rgba = this1;
		rgba = (argb >>> 16 & 255 & 255) << 24 | (argb >>> 8 & 255 & 255) << 16 | (argb & 255 & 255) << 8 | argb >>> 24 & 255 & 255;
		pixel = rgba;
		break;
	case 2:
		var bgra = color;
		var this2 = 0;
		var rgba1 = this2;
		rgba1 = (bgra >>> 8 & 255 & 255) << 24 | (bgra >>> 16 & 255 & 255) << 16 | (bgra >>> 24 & 255 & 255) << 8 | bgra & 255 & 255;
		pixel = rgba1;
		break;
	default:
		pixel = color;
	}
	var this3 = 0;
	var source = this3;
	var data = image.buffer.data;
	var offset = 4 * (y + image.offsetY) * image.buffer.width + (x + image.offsetX) * 4;
	var format1 = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	if(premultiplied == null) {
		premultiplied = false;
	}
	if(format1 == null) {
		format1 = 0;
	}
	switch(format1) {
	case 0:
		source = (data[offset] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset + 2] & 255) << 8 | data[offset + 3] & 255;
		break;
	case 1:
		source = (data[offset + 1] & 255) << 24 | (data[offset + 2] & 255) << 16 | (data[offset + 3] & 255) << 8 | data[offset] & 255;
		break;
	case 2:
		source = (data[offset + 2] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset] & 255) << 8 | data[offset + 3] & 255;
		break;
	}
	if(premultiplied) {
		if((source & 255) != 0 && (source & 255) != 255) {
			(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (source & 255);
			source = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((source >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((source >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((source >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | source & 255 & 255;
		}
	}
	var value = source & 255;
	pixel = (pixel >>> 24 & 255 & 255) << 24 | (pixel >>> 16 & 255 & 255) << 16 | (pixel >>> 8 & 255 & 255) << 8 | value & 255;
	var data1 = image.buffer.data;
	var offset1 = 4 * (y + image.offsetY) * image.buffer.width + (x + image.offsetX) * 4;
	var format2 = image.buffer.format;
	var premultiplied1 = image.buffer.premultiplied;
	if(premultiplied1 == null) {
		premultiplied1 = false;
	}
	if(format2 == null) {
		format2 = 0;
	}
	if(premultiplied1) {
		if((pixel & 255) == 0) {
			if(pixel != 0) {
				pixel = 0;
			}
		} else if((pixel & 255) != 255) {
			(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[pixel & 255];
			pixel = ((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | pixel & 255 & 255;
		}
	}
	switch(format2) {
	case 0:
		data1[offset1] = pixel >>> 24 & 255;
		data1[offset1 + 1] = pixel >>> 16 & 255;
		data1[offset1 + 2] = pixel >>> 8 & 255;
		data1[offset1 + 3] = pixel & 255;
		break;
	case 1:
		data1[offset1] = pixel & 255;
		data1[offset1 + 1] = pixel >>> 24 & 255;
		data1[offset1 + 2] = pixel >>> 16 & 255;
		data1[offset1 + 3] = pixel >>> 8 & 255;
		break;
	case 2:
		data1[offset1] = pixel >>> 8 & 255;
		data1[offset1 + 1] = pixel >>> 16 & 255;
		data1[offset1 + 2] = pixel >>> 24 & 255;
		data1[offset1 + 3] = pixel & 255;
		break;
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.setPixel32 = function(image,x,y,color,format) {
	var pixel;
	switch(format) {
	case 1:
		var argb = color;
		var this1 = 0;
		var rgba = this1;
		rgba = (argb >>> 16 & 255 & 255) << 24 | (argb >>> 8 & 255 & 255) << 16 | (argb & 255 & 255) << 8 | argb >>> 24 & 255 & 255;
		pixel = rgba;
		break;
	case 2:
		var bgra = color;
		var this2 = 0;
		var rgba1 = this2;
		rgba1 = (bgra >>> 8 & 255 & 255) << 24 | (bgra >>> 16 & 255 & 255) << 16 | (bgra >>> 24 & 255 & 255) << 8 | bgra & 255 & 255;
		pixel = rgba1;
		break;
	default:
		pixel = color;
	}
	if(!image.get_transparent()) {
		pixel = (pixel >>> 24 & 255 & 255) << 24 | (pixel >>> 16 & 255 & 255) << 16 | (pixel >>> 8 & 255 & 255) << 8 | 255;
	}
	var data = image.buffer.data;
	var offset = 4 * (y + image.offsetY) * image.buffer.width + (x + image.offsetX) * 4;
	var format1 = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	if(premultiplied == null) {
		premultiplied = false;
	}
	if(format1 == null) {
		format1 = 0;
	}
	if(premultiplied) {
		if((pixel & 255) == 0) {
			if(pixel != 0) {
				pixel = 0;
			}
		} else if((pixel & 255) != 255) {
			(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[pixel & 255];
			pixel = ((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | pixel & 255 & 255;
		}
	}
	switch(format1) {
	case 0:
		data[offset] = pixel >>> 24 & 255;
		data[offset + 1] = pixel >>> 16 & 255;
		data[offset + 2] = pixel >>> 8 & 255;
		data[offset + 3] = pixel & 255;
		break;
	case 1:
		data[offset] = pixel & 255;
		data[offset + 1] = pixel >>> 24 & 255;
		data[offset + 2] = pixel >>> 16 & 255;
		data[offset + 3] = pixel >>> 8 & 255;
		break;
	case 2:
		data[offset] = pixel >>> 8 & 255;
		data[offset + 1] = pixel >>> 16 & 255;
		data[offset + 2] = pixel >>> 24 & 255;
		data[offset + 3] = pixel & 255;
		break;
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.setPixels = function(image,rect,bytePointer,format,endian) {
	if(image.buffer.data == null) {
		return;
	}
	var data = image.buffer.data;
	var sourceFormat = image.buffer.format;
	var premultiplied = image.buffer.premultiplied;
	var dataView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(image,rect);
	var row;
	var color;
	var pixel;
	var transparent = image.get_transparent();
	var bytes = bytePointer.bytes;
	var dataPosition = bytePointer.offset;
	var littleEndian = endian != (lime_system_Endian().default).BIG_ENDIAN;
	var _g = 0;
	var _g1 = dataView.height;
	while(_g < _g1) {
		var y = _g++;
		row = dataView.row(y);
		var _g2 = 0;
		var _g11 = dataView.width;
		while(_g2 < _g11) {
			var x = _g2++;
			if(littleEndian) {
				color = bytes.getInt32(dataPosition);
			} else {
				color = bytes.get(dataPosition + 3) | bytes.get(dataPosition + 2) << 8 | bytes.get(dataPosition + 1) << 16 | bytes.get(dataPosition) << 24;
			}
			dataPosition += 4;
			switch(format) {
			case 1:
				var argb = color;
				var this1 = 0;
				var rgba = this1;
				rgba = (argb >>> 16 & 255 & 255) << 24 | (argb >>> 8 & 255 & 255) << 16 | (argb & 255 & 255) << 8 | argb >>> 24 & 255 & 255;
				pixel = rgba;
				break;
			case 2:
				var bgra = color;
				var this2 = 0;
				var rgba1 = this2;
				rgba1 = (bgra >>> 8 & 255 & 255) << 24 | (bgra >>> 16 & 255 & 255) << 16 | (bgra >>> 24 & 255 & 255) << 8 | bgra & 255 & 255;
				pixel = rgba1;
				break;
			default:
				pixel = color;
			}
			if(!transparent) {
				pixel = (pixel >>> 24 & 255 & 255) << 24 | (pixel >>> 16 & 255 & 255) << 16 | (pixel >>> 8 & 255 & 255) << 8 | 255;
			}
			var offset = row + x * 4;
			var format1 = sourceFormat;
			var premultiplied1 = premultiplied;
			if(premultiplied1 == null) {
				premultiplied1 = false;
			}
			if(format1 == null) {
				format1 = 0;
			}
			if(premultiplied1) {
				if((pixel & 255) == 0) {
					if(pixel != 0) {
						pixel = 0;
					}
				} else if((pixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[pixel & 255];
					pixel = ((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | pixel & 255 & 255;
				}
			}
			switch(format1) {
			case 0:
				data[offset] = pixel >>> 24 & 255;
				data[offset + 1] = pixel >>> 16 & 255;
				data[offset + 2] = pixel >>> 8 & 255;
				data[offset + 3] = pixel & 255;
				break;
			case 1:
				data[offset] = pixel & 255;
				data[offset + 1] = pixel >>> 24 & 255;
				data[offset + 2] = pixel >>> 16 & 255;
				data[offset + 3] = pixel >>> 8 & 255;
				break;
			case 2:
				data[offset] = pixel >>> 8 & 255;
				data[offset + 1] = pixel >>> 16 & 255;
				data[offset + 2] = pixel >>> 24 & 255;
				data[offset + 3] = pixel & 255;
				break;
			}
		}
	}
	image.dirty = true;
	image.version++;
}
ImageDataUtil.threshold = function(image,sourceImage,sourceRect,destPoint,operation,threshold,color,mask,copySource,format) {
	var _color;
	var _mask;
	var _threshold;
	switch(format) {
	case 1:
		var argb = color;
		var this1 = 0;
		var rgba = this1;
		rgba = (argb >>> 16 & 255 & 255) << 24 | (argb >>> 8 & 255 & 255) << 16 | (argb & 255 & 255) << 8 | argb >>> 24 & 255 & 255;
		_color = rgba;
		var argb1 = mask;
		var this2 = 0;
		var rgba1 = this2;
		rgba1 = (argb1 >>> 16 & 255 & 255) << 24 | (argb1 >>> 8 & 255 & 255) << 16 | (argb1 & 255 & 255) << 8 | argb1 >>> 24 & 255 & 255;
		_mask = rgba1;
		var argb2 = threshold;
		var this3 = 0;
		var rgba2 = this3;
		rgba2 = (argb2 >>> 16 & 255 & 255) << 24 | (argb2 >>> 8 & 255 & 255) << 16 | (argb2 & 255 & 255) << 8 | argb2 >>> 24 & 255 & 255;
		_threshold = rgba2;
		break;
	case 2:
		var bgra = color;
		var this4 = 0;
		var rgba3 = this4;
		rgba3 = (bgra >>> 8 & 255 & 255) << 24 | (bgra >>> 16 & 255 & 255) << 16 | (bgra >>> 24 & 255 & 255) << 8 | bgra & 255 & 255;
		_color = rgba3;
		var bgra1 = mask;
		var this5 = 0;
		var rgba4 = this5;
		rgba4 = (bgra1 >>> 8 & 255 & 255) << 24 | (bgra1 >>> 16 & 255 & 255) << 16 | (bgra1 >>> 24 & 255 & 255) << 8 | bgra1 & 255 & 255;
		_mask = rgba4;
		var bgra2 = threshold;
		var this6 = 0;
		var rgba5 = this6;
		rgba5 = (bgra2 >>> 8 & 255 & 255) << 24 | (bgra2 >>> 16 & 255 & 255) << 16 | (bgra2 >>> 24 & 255 & 255) << 8 | bgra2 & 255 & 255;
		_threshold = rgba5;
		break;
	default:
		_color = color;
		_mask = mask;
		_threshold = threshold;
	}
	var _operation;
	switch(operation) {
	case "!=":
		_operation = 0;
		break;
	case "<":
		_operation = 2;
		break;
	case "<=":
		_operation = 3;
		break;
	case "==":
		_operation = 1;
		break;
	case ">":
		_operation = 4;
		break;
	case ">=":
		_operation = 5;
		break;
	default:
		_operation = -1;
	}
	if(_operation == -1) {
		return 0;
	}
	var srcData = sourceImage.buffer.data;
	var destData = image.buffer.data;
	if(srcData == null || destData == null) {
		return 0;
	}
	var hits = 0;
	var srcView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(sourceImage,sourceRect);
	var destView = new (lime__$internal_graphics__$ImageDataUtil_ImageDataView().default)(image,new (lime_math_Rectangle().default)(destPoint.x,destPoint.y,srcView.width,srcView.height));
	var srcFormat = sourceImage.buffer.format;
	var destFormat = image.buffer.format;
	var srcPremultiplied = sourceImage.buffer.premultiplied;
	var destPremultiplied = image.buffer.premultiplied;
	var srcPosition;
	var destPosition;
	var srcPixel;
	var destPixel;
	var pixelMask;
	var test;
	var value;
	var _g = 0;
	var _g1 = destView.height;
	while(_g < _g1) {
		var y = _g++;
		srcPosition = srcView.row(y);
		destPosition = destView.row(y);
		var _g2 = 0;
		var _g11 = destView.width;
		while(_g2 < _g11) {
			var x = _g2++;
			var format1 = srcFormat;
			var premultiplied = srcPremultiplied;
			if(premultiplied == null) {
				premultiplied = false;
			}
			if(format1 == null) {
				format1 = 0;
			}
			switch(format1) {
			case 0:
				srcPixel = (srcData[srcPosition] & 255) << 24 | (srcData[srcPosition + 1] & 255) << 16 | (srcData[srcPosition + 2] & 255) << 8 | srcData[srcPosition + 3] & 255;
				break;
			case 1:
				srcPixel = (srcData[srcPosition + 1] & 255) << 24 | (srcData[srcPosition + 2] & 255) << 16 | (srcData[srcPosition + 3] & 255) << 8 | srcData[srcPosition] & 255;
				break;
			case 2:
				srcPixel = (srcData[srcPosition + 2] & 255) << 24 | (srcData[srcPosition + 1] & 255) << 16 | (srcData[srcPosition] & 255) << 8 | srcData[srcPosition + 3] & 255;
				break;
			}
			if(premultiplied) {
				if((srcPixel & 255) != 0 && (srcPixel & 255) != 255) {
					(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (srcPixel & 255);
					srcPixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((srcPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((srcPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((srcPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | srcPixel & 255 & 255;
				}
			}
			pixelMask = srcPixel & _mask;
			value = ImageDataUtil.__pixelCompare(pixelMask,_threshold);
			switch(_operation) {
			case 0:
				test = value != 0;
				break;
			case 1:
				test = value == 0;
				break;
			case 2:
				test = value == -1;
				break;
			case 3:
				test = value == 0 || value == -1;
				break;
			case 4:
				test = value == 1;
				break;
			case 5:
				test = value == 0 || value == 1;
				break;
			default:
				test = false;
			}
			if(test) {
				var format2 = destFormat;
				var premultiplied1 = destPremultiplied;
				if(premultiplied1 == null) {
					premultiplied1 = false;
				}
				if(format2 == null) {
					format2 = 0;
				}
				if(premultiplied1) {
					if((_color & 255) == 0) {
						if(_color != 0) {
							_color = 0;
						}
					} else if((_color & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[_color & 255];
						_color = ((_color >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((_color >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((_color >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | _color & 255 & 255;
					}
				}
				switch(format2) {
				case 0:
					destData[destPosition] = _color >>> 24 & 255;
					destData[destPosition + 1] = _color >>> 16 & 255;
					destData[destPosition + 2] = _color >>> 8 & 255;
					destData[destPosition + 3] = _color & 255;
					break;
				case 1:
					destData[destPosition] = _color & 255;
					destData[destPosition + 1] = _color >>> 24 & 255;
					destData[destPosition + 2] = _color >>> 16 & 255;
					destData[destPosition + 3] = _color >>> 8 & 255;
					break;
				case 2:
					destData[destPosition] = _color >>> 8 & 255;
					destData[destPosition + 1] = _color >>> 16 & 255;
					destData[destPosition + 2] = _color >>> 24 & 255;
					destData[destPosition + 3] = _color & 255;
					break;
				}
				++hits;
			} else if(copySource) {
				var format3 = destFormat;
				var premultiplied2 = destPremultiplied;
				if(premultiplied2 == null) {
					premultiplied2 = false;
				}
				if(format3 == null) {
					format3 = 0;
				}
				if(premultiplied2) {
					if((srcPixel & 255) == 0) {
						if(srcPixel != 0) {
							srcPixel = 0;
						}
					} else if((srcPixel & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[srcPixel & 255];
						srcPixel = ((srcPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((srcPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((srcPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | srcPixel & 255 & 255;
					}
				}
				switch(format3) {
				case 0:
					destData[destPosition] = srcPixel >>> 24 & 255;
					destData[destPosition + 1] = srcPixel >>> 16 & 255;
					destData[destPosition + 2] = srcPixel >>> 8 & 255;
					destData[destPosition + 3] = srcPixel & 255;
					break;
				case 1:
					destData[destPosition] = srcPixel & 255;
					destData[destPosition + 1] = srcPixel >>> 24 & 255;
					destData[destPosition + 2] = srcPixel >>> 16 & 255;
					destData[destPosition + 3] = srcPixel >>> 8 & 255;
					break;
				case 2:
					destData[destPosition] = srcPixel >>> 8 & 255;
					destData[destPosition + 1] = srcPixel >>> 16 & 255;
					destData[destPosition + 2] = srcPixel >>> 24 & 255;
					destData[destPosition + 3] = srcPixel & 255;
					break;
				}
			}
			srcPosition += 4;
			destPosition += 4;
		}
	}
	if(hits > 0) {
		image.dirty = true;
		image.version++;
	}
	return hits;
}
ImageDataUtil.unmultiplyAlpha = function(image) {
	var data = image.buffer.data;
	if(data == null) {
		return;
	}
	var format = image.buffer.format;
	var length = (Std().default).int(data.length / 4);
	var pixel;
	var _g = 0;
	var _g1 = length;
	while(_g < _g1) {
		var i = _g++;
		var offset = i * 4;
		var format1 = format;
		var premultiplied = true;
		if(premultiplied == null) {
			premultiplied = false;
		}
		if(format1 == null) {
			format1 = 0;
		}
		switch(format1) {
		case 0:
			pixel = (data[offset] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset + 2] & 255) << 8 | data[offset + 3] & 255;
			break;
		case 1:
			pixel = (data[offset + 1] & 255) << 24 | (data[offset + 2] & 255) << 16 | (data[offset + 3] & 255) << 8 | data[offset] & 255;
			break;
		case 2:
			pixel = (data[offset + 2] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset] & 255) << 8 | data[offset + 3] & 255;
			break;
		}
		if(premultiplied) {
			if((pixel & 255) != 0 && (pixel & 255) != 255) {
				(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (pixel & 255);
				pixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | pixel & 255 & 255;
			}
		}
		var offset1 = i * 4;
		var format2 = format;
		var premultiplied1 = false;
		if(premultiplied1 == null) {
			premultiplied1 = false;
		}
		if(format2 == null) {
			format2 = 0;
		}
		if(premultiplied1) {
			if((pixel & 255) == 0) {
				if(pixel != 0) {
					pixel = 0;
				}
			} else if((pixel & 255) != 255) {
				(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[pixel & 255];
				pixel = ((pixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((pixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((pixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | pixel & 255 & 255;
			}
		}
		switch(format2) {
		case 0:
			data[offset1] = pixel >>> 24 & 255;
			data[offset1 + 1] = pixel >>> 16 & 255;
			data[offset1 + 2] = pixel >>> 8 & 255;
			data[offset1 + 3] = pixel & 255;
			break;
		case 1:
			data[offset1] = pixel & 255;
			data[offset1 + 1] = pixel >>> 24 & 255;
			data[offset1 + 2] = pixel >>> 16 & 255;
			data[offset1 + 3] = pixel >>> 8 & 255;
			break;
		case 2:
			data[offset1] = pixel >>> 8 & 255;
			data[offset1 + 1] = pixel >>> 16 & 255;
			data[offset1 + 2] = pixel >>> 24 & 255;
			data[offset1 + 3] = pixel & 255;
			break;
		}
	}
	image.buffer.premultiplied = false;
	image.dirty = true;
	image.version++;
}
ImageDataUtil.__boxBlur = function(imgA,imgB,w,h,bx,by) {
	imgB.set(imgA);
	var bx1 = (Std().default).int(bx);
	var by1 = (Std().default).int(by);
	ImageDataUtil.__boxBlurH(imgB,imgA,w,h,bx1,0);
	ImageDataUtil.__boxBlurH(imgB,imgA,w,h,bx1,1);
	ImageDataUtil.__boxBlurH(imgB,imgA,w,h,bx1,2);
	ImageDataUtil.__boxBlurH(imgB,imgA,w,h,bx1,3);
	ImageDataUtil.__boxBlurT(imgA,imgB,w,h,by1,0);
	ImageDataUtil.__boxBlurT(imgA,imgB,w,h,by1,1);
	ImageDataUtil.__boxBlurT(imgA,imgB,w,h,by1,2);
	ImageDataUtil.__boxBlurT(imgA,imgB,w,h,by1,3);
}
ImageDataUtil.__boxBlurH = function(imgA,imgB,w,h,r,off) {
	var iarr = 1 / (r + r + 1);
	var ti;
	var li;
	var ri;
	var fv;
	var lv;
	var val;
	var _g = 0;
	var _g1 = h;
	while(_g < _g1) {
		var i = _g++;
		ti = i * w;
		li = ti;
		ri = ti + r;
		fv = imgA[ti * 4 + off];
		lv = imgA[(ti + w - 1) * 4 + off];
		val = (r + 1) * fv;
		var _g2 = 0;
		var _g11 = r;
		while(_g2 < _g11) {
			var j = _g2++;
			val = val + imgA[(ti + j) * 4 + off];
		}
		var _g21 = 0;
		var _g3 = r + 1;
		while(_g21 < _g3) {
			var j1 = _g21++;
			val = val + (imgA[ri * 4 + off] - fv);
			imgB[ti * 4 + off] = Math.round((_$UInt_UInt_$Impl_$().default).toFloat(val) * iarr);
			++ri;
			++ti;
		}
		var _g4 = r + 1;
		var _g5 = w - r;
		while(_g4 < _g5) {
			var j2 = _g4++;
			val = val + (imgA[ri * 4 + off] - imgA[li * 4 + off]);
			imgB[ti * 4 + off] = Math.round((_$UInt_UInt_$Impl_$().default).toFloat(val) * iarr);
			++ri;
			++li;
			++ti;
		}
		var _g6 = w - r;
		var _g7 = w;
		while(_g6 < _g7) {
			var j3 = _g6++;
			val = val + (lv - imgA[li * 4 + off]);
			imgB[ti * 4 + off] = Math.round((_$UInt_UInt_$Impl_$().default).toFloat(val) * iarr);
			++li;
			++ti;
		}
	}
}
ImageDataUtil.__boxBlurT = function(imgA,imgB,w,h,r,off) {
	var iarr = 1 / (r + r + 1);
	var ws = w * 4;
	var ti;
	var li;
	var ri;
	var fv;
	var lv;
	var val;
	var _g = 0;
	var _g1 = w;
	while(_g < _g1) {
		var i = _g++;
		ti = i * 4 + off;
		li = ti;
		ri = ti + r * ws;
		fv = imgA[ti];
		lv = imgA[ti + ws * (h - 1)];
		val = (r + 1) * fv;
		var _g2 = 0;
		var _g11 = r;
		while(_g2 < _g11) {
			var j = _g2++;
			val = val + imgA[ti + j * ws];
		}
		var _g21 = 0;
		var _g3 = r + 1;
		while(_g21 < _g3) {
			var j1 = _g21++;
			val = val + (imgA[ri] - fv);
			imgB[ti] = Math.round((_$UInt_UInt_$Impl_$().default).toFloat(val) * iarr);
			ri += ws;
			ti += ws;
		}
		var _g4 = r + 1;
		var _g5 = h - r;
		while(_g4 < _g5) {
			var j2 = _g4++;
			val = val + (imgA[ri] - imgA[li]);
			imgB[ti] = Math.round((_$UInt_UInt_$Impl_$().default).toFloat(val) * iarr);
			li += ws;
			ri += ws;
			ti += ws;
		}
		var _g6 = h - r;
		var _g7 = h;
		while(_g6 < _g7) {
			var j3 = _g6++;
			val = val + (lv - imgA[li]);
			imgB[ti] = Math.round((_$UInt_UInt_$Impl_$().default).toFloat(val) * iarr);
			li += ws;
			ti += ws;
		}
	}
}
ImageDataUtil.__calculateSourceOffset = function(sourceRect,destPoint,destX,destY) {
	var sourceX = destX - (Std().default).int(destPoint.x);
	var sourceY = destY - (Std().default).int(destPoint.y);
	var offset = 0;
	if(sourceX < 0 || sourceY < 0 || sourceX >= sourceRect.width || sourceY >= sourceRect.height) {
		offset = -1;
	} else {
		offset = 4 * (sourceY * (Std().default).int(sourceRect.width) + sourceX);
	}
	return offset;
}
ImageDataUtil.__getBoxesForGaussianBlur = function(sigma,n) {
	var wIdeal = Math.sqrt(12 * sigma * sigma / n + 1);
	var wl = Math.floor(wIdeal);
	if(wl % 2 == 0) {
		--wl;
	}
	var wu = wl + 2;
	var mIdeal = (12 * sigma * sigma - n * wl * wl - 4 * n * wl - 3 * n) / (-4 * wl - 4);
	var m = Math.round(mIdeal);
	var sizes = [];
	var _g = 0;
	var _g1 = n;
	while(_g < _g1) {
		var i = _g++;
		sizes.push(i < m ? wl : wu);
	}
	return sizes;
}
ImageDataUtil.__pixelCompare = function(n1,n2) {
	var tmp1 = n1 >>> 24 & 255;
	var tmp2 = n2 >>> 24 & 255;
	if(tmp1 != tmp2) {
		if((_$UInt_UInt_$Impl_$().default).gt(tmp1,tmp2)) {
			return 1;
		} else {
			return -1;
		}
	} else {
		tmp1 = n1 >>> 16 & 255;
		tmp2 = n2 >>> 16 & 255;
		if(tmp1 != tmp2) {
			if((_$UInt_UInt_$Impl_$().default).gt(tmp1,tmp2)) {
				return 1;
			} else {
				return -1;
			}
		} else {
			tmp1 = n1 >>> 8 & 255;
			tmp2 = n2 >>> 8 & 255;
			if(tmp1 != tmp2) {
				if((_$UInt_UInt_$Impl_$().default).gt(tmp1,tmp2)) {
					return 1;
				} else {
					return -1;
				}
			} else {
				tmp1 = n1 & 255;
				tmp2 = n2 & 255;
				if(tmp1 != tmp2) {
					if((_$UInt_UInt_$Impl_$().default).gt(tmp1,tmp2)) {
						return 1;
					} else {
						return -1;
					}
				} else {
					return 0;
				}
			}
		}
	}
}
ImageDataUtil.__translatePixel = function(imgB,sourceRect,destRect,destPoint,destX,destY,strength) {
	var d = 4 * (destY * (Std().default).int(destRect.width) + destX);
	var s = ImageDataUtil.__calculateSourceOffset(sourceRect,destPoint,destX,destY);
	if(s < 0) {
		imgB[d] = imgB[d + 1] = imgB[d + 2] = imgB[d + 3] = 0;
	} else {
		imgB[d] = imgB[s];
		imgB[d + 1] = imgB[s + 1];
		imgB[d + 2] = imgB[s + 2];
		var a = (Std().default).int((_$UInt_UInt_$Impl_$().default).toFloat(imgB[s + 3]) * strength);
		imgB[d + 3] = a < 0 ? 0 : a > 255 ? 255 : a;
	}
}


// Export

exports.default = ImageDataUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/StackBlur.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/graphics/StackBlur.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.graphics.StackBlur

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime__$internal_graphics_BlurStack() {return __webpack_require__(/*! ./../../../lime/_internal/graphics/BlurStack */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/BlurStack.js");}

// Constructor

var StackBlur = function(){}

// Meta

StackBlur.__name__ = "lime._internal.graphics.StackBlur";
StackBlur.__isInterface__ = false;
StackBlur.prototype = {
	
};
StackBlur.prototype.__class__ = StackBlur.prototype.constructor = $hxClasses["lime._internal.graphics.StackBlur"] = StackBlur;

// Init



// Statics

StackBlur.blur = function(dest,source,sourceRect,destPoint,blurX,blurY,quality) {
	dest.copyPixels(source,sourceRect,destPoint);
	StackBlur.__stackBlurCanvasRGBA(dest,(Std().default).int(sourceRect.width),(Std().default).int(sourceRect.height),blurX,blurY,quality);
}
StackBlur.__stackBlurCanvasRGBA = function(image,width,height,blurX,blurY,quality) {
	var radiusX = Math.round(blurX) >> 1;
	var radiusY = Math.round(blurY) >> 1;
	if(StackBlur.MUL_TABLE == null) {
		return;
	}
	if(radiusX >= StackBlur.MUL_TABLE.length) {
		radiusX = StackBlur.MUL_TABLE.length - 1;
	}
	if(radiusY >= StackBlur.MUL_TABLE.length) {
		radiusY = StackBlur.MUL_TABLE.length - 1;
	}
	if(radiusX < 0 || radiusY < 0) {
		return;
	}
	var iterations = quality;
	if(iterations < 1) {
		iterations = 1;
	}
	if(iterations > 3) {
		iterations = 3;
	}
	var px = image.get_data();
	var x;
	var y;
	var i;
	var p;
	var yp;
	var yi;
	var yw;
	var r;
	var g;
	var b;
	var a;
	var pr;
	var pg;
	var pb;
	var pa;
	var f;
	var divx = radiusX + radiusX + 1;
	var divy = radiusY + radiusY + 1;
	var w = width;
	var h = height;
	var w1 = w - 1;
	var h1 = h - 1;
	var rxp1 = radiusX + 1;
	var ryp1 = radiusY + 1;
	var ssx = new (lime__$internal_graphics_BlurStack().default)();
	var sx = ssx;
	var _g = 1;
	var _g1 = divx;
	while(_g < _g1) {
		var i1 = _g++;
		sx = sx.n = new (lime__$internal_graphics_BlurStack().default)();
	}
	sx.n = ssx;
	var ssy = new (lime__$internal_graphics_BlurStack().default)();
	var sy = ssy;
	var _g2 = 1;
	var _g3 = divy;
	while(_g2 < _g3) {
		var i2 = _g2++;
		sy = sy.n = new (lime__$internal_graphics_BlurStack().default)();
	}
	sy.n = ssy;
	var si = null;
	var mtx = StackBlur.MUL_TABLE[radiusX];
	var stx = StackBlur.SHG_TABLE[radiusX];
	var mty = StackBlur.MUL_TABLE[radiusY];
	var sty = StackBlur.SHG_TABLE[radiusY];
	while(iterations > 0) {
		--iterations;
		yi = 0;
		yw = yi;
		var ms = mtx;
		var ss = stx;
		y = h;
		while(true) {
			pr = px[yi];
			r = rxp1 * pr;
			pg = px[yi + 1];
			g = rxp1 * pg;
			pb = px[yi + 2];
			b = rxp1 * pb;
			pa = px[yi + 3];
			a = rxp1 * pa;
			sx = ssx;
			i = rxp1;
			while(true) {
				sx.r = pr;
				sx.g = pg;
				sx.b = pb;
				sx.a = pa;
				sx = sx.n;
				if(!(--i > -1)) {
					break;
				}
			}
			var _g4 = 1;
			var _g5 = rxp1;
			while(_g4 < _g5) {
				var i3 = _g4++;
				p = yi + ((w1 < i3 ? w1 : i3) << 2);
				r += sx.r = px[p];
				g += sx.g = px[p + 1];
				b += sx.b = px[p + 2];
				a += sx.a = px[p + 3];
				sx = sx.n;
			}
			si = ssx;
			var _g6 = 0;
			var _g7 = w;
			while(_g6 < _g7) {
				var x1 = _g6++;
				px[yi++] = r * ms >>> ss;
				px[yi++] = g * ms >>> ss;
				px[yi++] = b * ms >>> ss;
				px[yi++] = a * ms >>> ss;
				p = x1 + radiusX + 1;
				p = yw + (p < w1 ? p : w1) << 2;
				r -= si.r - (si.r = px[p]);
				g -= si.g - (si.g = px[p + 1]);
				b -= si.b - (si.b = px[p + 2]);
				a -= si.a - (si.a = px[p + 3]);
				si = si.n;
			}
			yw += w;
			if(!(--y > 0)) {
				break;
			}
		}
		ms = mty;
		ss = sty;
		var _g41 = 0;
		var _g51 = w;
		while(_g41 < _g51) {
			var x2 = _g41++;
			yi = x2 << 2;
			pr = px[yi];
			r = ryp1 * pr;
			pg = px[yi + 1];
			g = ryp1 * pg;
			pb = px[yi + 2];
			b = ryp1 * pb;
			pa = px[yi + 3];
			a = ryp1 * pa;
			sy = ssy;
			var _g42 = 0;
			var _g52 = ryp1;
			while(_g42 < _g52) {
				var i4 = _g42++;
				sy.r = pr;
				sy.g = pg;
				sy.b = pb;
				sy.a = pa;
				sy = sy.n;
			}
			yp = w;
			var _g61 = 1;
			var _g71 = radiusY + 1;
			while(_g61 < _g71) {
				var i5 = _g61++;
				yi = yp + x2 << 2;
				r += sy.r = px[yi];
				g += sy.g = px[yi + 1];
				b += sy.b = px[yi + 2];
				a += sy.a = px[yi + 3];
				sy = sy.n;
				if(i5 < h1) {
					yp += w;
				}
			}
			yi = x2;
			si = ssy;
			if(iterations > 0) {
				var _g8 = 0;
				var _g9 = h;
				while(_g8 < _g9) {
					var y1 = _g8++;
					p = yi << 2;
					pa = a * ms >>> ss;
					px[p + 3] = pa;
					if(pa > 0) {
						px[p] = r * ms >>> ss;
						px[p + 1] = g * ms >>> ss;
						px[p + 2] = b * ms >>> ss;
					} else {
						px[p] = px[p + 1] = px[p + 2] = 0;
					}
					p = y1 + ryp1;
					p = x2 + (p < h1 ? p : h1) * w << 2;
					r -= si.r - (si.r = px[p]);
					g -= si.g - (si.g = px[p + 1]);
					b -= si.b - (si.b = px[p + 2]);
					a -= si.a - (si.a = px[p + 3]);
					si = si.n;
					yi += w;
				}
			} else {
				var _g81 = 0;
				var _g91 = h;
				while(_g81 < _g91) {
					var y2 = _g81++;
					p = yi << 2;
					pa = a * ms >>> ss;
					px[p + 3] = pa;
					if(pa > 0) {
						f = 255 / pa;
						pr = (Std().default).int((r * ms >>> ss) * f);
						pg = (Std().default).int((g * ms >>> ss) * f);
						pb = (Std().default).int((b * ms >>> ss) * f);
						px[p] = pr > 255 ? 255 : pr;
						px[p + 1] = pg > 255 ? 255 : pg;
						px[p + 2] = pb > 255 ? 255 : pb;
					} else {
						px[p] = px[p + 1] = px[p + 2] = 0;
					}
					p = y2 + ryp1;
					p = x2 + (p < h1 ? p : h1) * w << 2;
					r -= si.r - (si.r = px[p]);
					g -= si.g - (si.g = px[p + 1]);
					b -= si.b - (si.b = px[p + 2]);
					a -= si.a - (si.a = px[p + 3]);
					si = si.n;
					yi += w;
				}
			}
		}
	}
}
StackBlur.MUL_TABLE = [1,171,205,293,57,373,79,137,241,27,391,357,41,19,283,265,497,469,443,421,25,191,365,349,335,161,155,149,9,278,269,261,505,245,475,231,449,437,213,415,405,395,193,377,369,361,353,345,169,331,325,319,313,307,301,37,145,285,281,69,271,267,263,259,509,501,493,243,479,118,465,459,113,446,55,435,429,423,209,413,51,403,199,393,97,3,379,375,371,367,363,359,355,351,347,43,85,337,333,165,327,323,5,317,157,311,77,305,303,75,297,294,73,289,287,71,141,279,277,275,68,135,67,133,33,262,260,129,511,507,503,499,495,491,61,121,481,477,237,235,467,232,115,457,227,451,7,445,221,439,218,433,215,427,425,211,419,417,207,411,409,203,202,401,399,396,197,49,389,387,385,383,95,189,47,187,93,185,23,183,91,181,45,179,89,177,11,175,87,173,345,343,341,339,337,21,167,83,331,329,327,163,81,323,321,319,159,79,315,313,39,155,309,307,153,305,303,151,75,299,149,37,295,147,73,291,145,289,287,143,285,71,141,281,35,279,139,69,275,137,273,17,271,135,269,267,133,265,33,263,131,261,130,259,129,257,1]
StackBlur.SHG_TABLE = [0,9,10,11,9,12,10,11,12,9,13,13,10,9,13,13,14,14,14,14,10,13,14,14,14,13,13,13,9,14,14,14,15,14,15,14,15,15,14,15,15,15,14,15,15,15,15,15,14,15,15,15,15,15,15,12,14,15,15,13,15,15,15,15,16,16,16,15,16,14,16,16,14,16,13,16,16,16,15,16,13,16,15,16,14,9,16,16,16,16,16,16,16,16,16,13,14,16,16,15,16,16,10,16,15,16,14,16,16,14,16,16,14,16,16,14,15,16,16,16,14,15,14,15,13,16,16,15,17,17,17,17,17,17,14,15,17,17,16,16,17,16,15,17,16,17,11,17,16,17,16,17,16,17,17,16,17,17,16,17,17,16,16,17,17,17,16,14,17,17,17,17,15,16,14,16,15,16,13,16,15,16,14,16,15,16,12,16,15,16,17,17,17,17,17,13,16,15,17,17,17,16,15,17,17,17,16,15,17,17,14,16,17,17,16,17,17,16,15,17,16,14,17,16,15,17,16,17,17,16,17,15,16,17,14,17,16,15,17,16,17,13,17,16,17,17,16,17,14,17,16,17,16,17,16,17,9]

// Export

exports.default = StackBlur;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/_ImageDataUtil/ImageDataView.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/_internal/graphics/_ImageDataUtil/ImageDataView.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime._internal.graphics._ImageDataUtil.ImageDataView

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}

// Constructor

var ImageDataView = function(image,rect) {
	this.image = image;
	if(rect == null) {
		this.rect = image.get_rect();
	} else {
		if(rect.x < 0) {
			rect.x = 0;
		}
		if(rect.y < 0) {
			rect.y = 0;
		}
		if(rect.x + rect.width > image.width) {
			rect.width = image.width - rect.x;
		}
		if(rect.y + rect.height > image.height) {
			rect.height = image.height - rect.y;
		}
		if(rect.width < 0) {
			rect.width = 0;
		}
		if(rect.height < 0) {
			rect.height = 0;
		}
		this.rect = rect;
	}
	this.stride = image.buffer.get_stride();
	this.__update();
}

// Meta

ImageDataView.__name__ = "lime._internal.graphics._ImageDataUtil.ImageDataView";
ImageDataView.__isInterface__ = false;
ImageDataView.prototype = {
	clip: function(x,y,width,height) {
		if(this.tempRect == null) {
			this.tempRect = new (lime_math_Rectangle().default)();
		}
		this.tempRect.setTo(x,y,width,height);
		this.rect.intersection(this.tempRect,this.rect);
		this.__update();
	},
	hasRow: function(y) {
		if(y >= 0) {
			return y < this.height;
		} else {
			return false;
		}
	},
	offset: function(x,y) {
		if(x < 0) {
			this.rect.x += x;
			if(this.rect.x < 0) {
				this.rect.x = 0;
			}
		} else {
			this.rect.x += x;
			this.rect.width -= x;
		}
		if(y < 0) {
			this.rect.y += y;
			if(this.rect.y < 0) {
				this.rect.y = 0;
			}
		} else {
			this.rect.y += y;
			this.rect.height -= y;
		}
		this.__update();
	},
	row: function(y) {
		return this.byteOffset + this.stride * y;
	},
	__update: function() {
		this.x = Math.ceil(this.rect.x);
		this.y = Math.ceil(this.rect.y);
		this.width = Math.floor(this.rect.width);
		this.height = Math.floor(this.rect.height);
		this.byteOffset = this.stride * (this.y + this.image.offsetY) + (this.x + this.image.offsetX) * 4;
	}
};
ImageDataView.prototype.__class__ = ImageDataView.prototype.constructor = $hxClasses["lime._internal.graphics._ImageDataUtil.ImageDataView"] = ImageDataView;

// Init



// Statics




// Export

exports.default = ImageDataView;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/Application.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/Application.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app.Application

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_app_Module() {return __webpack_require__(/*! ./../../lime/app/Module */ "./node_modules/openfl/lib/_gen/lime/app/Module.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function lime_ui_Window() {return __webpack_require__(/*! ./../../lime/ui/Window */ "./node_modules/openfl/lib/_gen/lime/ui/Window.js");}
function lime_ui_Gamepad() {return __webpack_require__(/*! ./../../lime/ui/Gamepad */ "./node_modules/openfl/lib/_gen/lime/ui/Gamepad.js");}
function lime_ui_Joystick() {return __webpack_require__(/*! ./../../lime/ui/Joystick */ "./node_modules/openfl/lib/_gen/lime/ui/Joystick.js");}
function lime_ui_Touch() {return __webpack_require__(/*! ./../../lime/ui/Touch */ "./node_modules/openfl/lib/_gen/lime/ui/Touch.js");}
function lime_system_System() {return __webpack_require__(/*! ./../../lime/system/System */ "./node_modules/openfl/lib/_gen/lime/system/System.js");}
function lime_app__$Event_$lime_$ui_$Window_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_lime_ui_Window_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Window_Void.js");}
function lime_app__$Event_$Int_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Int_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Void.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function lime__$internal_backend_html5_HTML5Application() {return __webpack_require__(/*! ./../../lime/_internal/backend/html5/HTML5Application */ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5Application.js");}
function lime_utils_Preloader() {return __webpack_require__(/*! ./../../lime/utils/Preloader */ "./node_modules/openfl/lib/_gen/lime/utils/Preloader.js");}

// Constructor

var Application = function() {
	this.onCreateWindow = new (lime_app__$Event_$lime_$ui_$Window_$Void().default)();
	this.onUpdate = new (lime_app__$Event_$Int_$Void().default)();
	(lime_app_Module().default).call(this);
	if(Application.current == null) {
		Application.current = this;
	}
	this.meta = new (haxe_ds_StringMap().default)();
	this.modules = [];
	this.__windowByID = new (haxe_ds_IntMap().default)();
	this.__windows = [];
	this.__backend = new (lime__$internal_backend_html5_HTML5Application().default)(this);
	this.__registerLimeModule(this);
	this.__preloader = new (lime_utils_Preloader().default)();
	this.__preloader.onProgress.add($bind(this,this.onPreloadProgress));
	this.__preloader.onComplete.add($bind(this,this.onPreloadComplete));
}

// Meta

Application.__name__ = "lime.app.Application";
Application.__isInterface__ = false;
Application.__super__ = (lime_app_Module().default);
Application.prototype = $extend((lime_app_Module().default).prototype, {
	addModule: function(module) {
		module.__registerLimeModule(this);
		this.modules.push(module);
	},
	createWindow: function(attributes) {
		var $window = this.__createWindow(attributes);
		this.__addWindow($window);
		return $window;
	},
	exec: function() {
		Application.current = this;
		return this.__backend.exec();
	},
	onGamepadAxisMove: function(gamepad,axis,value) {
	},
	onGamepadButtonDown: function(gamepad,button) {
	},
	onGamepadButtonUp: function(gamepad,button) {
	},
	onGamepadConnect: function(gamepad) {
	},
	onGamepadDisconnect: function(gamepad) {
	},
	onJoystickAxisMove: function(joystick,axis,value) {
	},
	onJoystickButtonDown: function(joystick,button) {
	},
	onJoystickButtonUp: function(joystick,button) {
	},
	onJoystickConnect: function(joystick) {
	},
	onJoystickDisconnect: function(joystick) {
	},
	onJoystickHatMove: function(joystick,hat,position) {
	},
	onJoystickTrackballMove: function(joystick,trackball,x,y) {
	},
	onKeyDown: function(keyCode,modifier) {
	},
	onKeyUp: function(keyCode,modifier) {
	},
	onModuleExit: function(code) {
	},
	onMouseDown: function(x,y,button) {
	},
	onMouseMove: function(x,y) {
	},
	onMouseMoveRelative: function(x,y) {
	},
	onMouseUp: function(x,y,button) {
	},
	onMouseWheel: function(deltaX,deltaY,deltaMode) {
	},
	onPreloadComplete: function() {
	},
	onPreloadProgress: function(loaded,total) {
	},
	onRenderContextLost: function() {
	},
	onRenderContextRestored: function(context) {
	},
	onTextEdit: function(text,start,length) {
	},
	onTextInput: function(text) {
	},
	onTouchCancel: function(touch) {
	},
	onTouchEnd: function(touch) {
	},
	onTouchMove: function(touch) {
	},
	onTouchStart: function(touch) {
	},
	onWindowActivate: function() {
	},
	onWindowClose: function() {
	},
	onWindowCreate: function() {
	},
	onWindowDeactivate: function() {
	},
	onWindowDropFile: function(file) {
	},
	onWindowEnter: function() {
	},
	onWindowExpose: function() {
	},
	onWindowFocusIn: function() {
	},
	onWindowFocusOut: function() {
	},
	onWindowFullscreen: function() {
	},
	onWindowLeave: function() {
	},
	onWindowMove: function(x,y) {
	},
	onWindowMinimize: function() {
	},
	onWindowResize: function(width,height) {
	},
	onWindowRestore: function() {
	},
	removeModule: function(module) {
		if(module != null) {
			module.__unregisterLimeModule(this);
			(HxOverrides().default).remove(this.modules,module);
		}
	},
	render: function(context) {
	},
	update: function(deltaTime) {
	},
	__addWindow: function($window) {
		if($window != null) {
			this.__windows.push($window);
			this.__windowByID.set($window.id,$window);
			var f = $bind(this,this.__onWindowClose);
			var window1 = $window;
			var tmp = function() {
				f(window1);
			};
			$window.onClose.add(tmp,false,-10000);
			if(this.__window == null) {
				this.__window = $window;
				$window.onActivate.add($bind(this,this.onWindowActivate));
				$window.onRenderContextLost.add($bind(this,this.onRenderContextLost));
				$window.onRenderContextRestored.add($bind(this,this.onRenderContextRestored));
				$window.onDeactivate.add($bind(this,this.onWindowDeactivate));
				$window.onDropFile.add($bind(this,this.onWindowDropFile));
				$window.onEnter.add($bind(this,this.onWindowEnter));
				$window.onExpose.add($bind(this,this.onWindowExpose));
				$window.onFocusIn.add($bind(this,this.onWindowFocusIn));
				$window.onFocusOut.add($bind(this,this.onWindowFocusOut));
				$window.onFullscreen.add($bind(this,this.onWindowFullscreen));
				$window.onKeyDown.add($bind(this,this.onKeyDown));
				$window.onKeyUp.add($bind(this,this.onKeyUp));
				$window.onLeave.add($bind(this,this.onWindowLeave));
				$window.onMinimize.add($bind(this,this.onWindowMinimize));
				$window.onMouseDown.add($bind(this,this.onMouseDown));
				$window.onMouseMove.add($bind(this,this.onMouseMove));
				$window.onMouseMoveRelative.add($bind(this,this.onMouseMoveRelative));
				$window.onMouseUp.add($bind(this,this.onMouseUp));
				$window.onMouseWheel.add($bind(this,this.onMouseWheel));
				$window.onMove.add($bind(this,this.onWindowMove));
				$window.onRender.add($bind(this,this.render));
				$window.onResize.add($bind(this,this.onWindowResize));
				$window.onRestore.add($bind(this,this.onWindowRestore));
				$window.onTextEdit.add($bind(this,this.onTextEdit));
				$window.onTextInput.add($bind(this,this.onTextInput));
				this.onWindowCreate();
			}
			this.onCreateWindow.dispatch($window);
		}
	},
	__createWindow: function(attributes) {
		var $window = new (lime_ui_Window().default)(this,attributes);
		if($window.id == -1) {
			return null;
		}
		return $window;
	},
	__registerLimeModule: function(application) {
		application.onUpdate.add($bind(this,this.update));
		application.onExit.add($bind(this,this.onModuleExit),false,0);
		application.onExit.add($bind(this,this.__onModuleExit),false,0);
		var gamepad = (lime_ui_Gamepad().default).devices.iterator();
		while(gamepad.hasNext()) {
			var gamepad1 = gamepad.next();
			this.__onGamepadConnect(gamepad1);
		}
		(lime_ui_Gamepad().default).onConnect.add($bind(this,this.__onGamepadConnect));
		var joystick = (lime_ui_Joystick().default).devices.iterator();
		while(joystick.hasNext()) {
			var joystick1 = joystick.next();
			this.__onJoystickConnect(joystick1);
		}
		(lime_ui_Joystick().default).onConnect.add($bind(this,this.__onJoystickConnect));
		(lime_ui_Touch().default).onCancel.add($bind(this,this.onTouchCancel));
		(lime_ui_Touch().default).onStart.add($bind(this,this.onTouchStart));
		(lime_ui_Touch().default).onMove.add($bind(this,this.onTouchMove));
		(lime_ui_Touch().default).onEnd.add($bind(this,this.onTouchEnd));
	},
	__removeWindow: function($window) {
		if($window != null && this.__windowByID.exists($window.id)) {
			if(this.__window == $window) {
				this.__window = null;
			}
			(HxOverrides().default).remove(this.__windows,$window);
			this.__windowByID.remove($window.id);
			$window.close();
			if(this.__windows.length == 0) {
				(lime_system_System().default).exit(0);
			}
		}
	},
	__onGamepadConnect: function(gamepad) {
		this.onGamepadConnect(gamepad);
		var f = $bind(this,this.onGamepadAxisMove);
		var gamepad1 = gamepad;
		var tmp = function(axis,value) {
			f(gamepad1,axis,value);
		};
		gamepad.onAxisMove.add(tmp);
		var f1 = $bind(this,this.onGamepadButtonDown);
		var gamepad2 = gamepad;
		var tmp1 = function(button) {
			f1(gamepad2,button);
		};
		gamepad.onButtonDown.add(tmp1);
		var f2 = $bind(this,this.onGamepadButtonUp);
		var gamepad3 = gamepad;
		var tmp2 = function(button1) {
			f2(gamepad3,button1);
		};
		gamepad.onButtonUp.add(tmp2);
		var f3 = $bind(this,this.onGamepadDisconnect);
		var gamepad4 = gamepad;
		var tmp3 = function() {
			f3(gamepad4);
		};
		gamepad.onDisconnect.add(tmp3);
	},
	__onJoystickConnect: function(joystick) {
		this.onJoystickConnect(joystick);
		var f = $bind(this,this.onJoystickAxisMove);
		var joystick1 = joystick;
		var tmp = function(axis,value) {
			f(joystick1,axis,value);
		};
		joystick.onAxisMove.add(tmp);
		var f1 = $bind(this,this.onJoystickButtonDown);
		var joystick2 = joystick;
		var tmp1 = function(button) {
			f1(joystick2,button);
		};
		joystick.onButtonDown.add(tmp1);
		var f2 = $bind(this,this.onJoystickButtonUp);
		var joystick3 = joystick;
		var tmp2 = function(button1) {
			f2(joystick3,button1);
		};
		joystick.onButtonUp.add(tmp2);
		var f3 = $bind(this,this.onJoystickDisconnect);
		var joystick4 = joystick;
		var tmp3 = function() {
			f3(joystick4);
		};
		joystick.onDisconnect.add(tmp3);
		var f4 = $bind(this,this.onJoystickHatMove);
		var joystick5 = joystick;
		var tmp4 = function(hat,position) {
			f4(joystick5,hat,position);
		};
		joystick.onHatMove.add(tmp4);
		var f5 = $bind(this,this.onJoystickTrackballMove);
		var joystick6 = joystick;
		var tmp5 = function(trackball,x,y) {
			f5(joystick6,trackball,x,y);
		};
		joystick.onTrackballMove.add(tmp5);
	},
	__onModuleExit: function(code) {
		this.__backend.exit();
	},
	__onWindowClose: function($window) {
		if(this.get_window() == $window) {
			this.onWindowClose();
		}
		this.__removeWindow($window);
	},
	__unregisterLimeModule: function(application) {
		application.onUpdate.remove($bind(this,this.update));
		application.onExit.remove($bind(this,this.__onModuleExit));
		application.onExit.remove($bind(this,this.onModuleExit));
		(lime_ui_Gamepad().default).onConnect.remove($bind(this,this.__onGamepadConnect));
		(lime_ui_Joystick().default).onConnect.remove($bind(this,this.__onJoystickConnect));
		(lime_ui_Touch().default).onCancel.remove($bind(this,this.onTouchCancel));
		(lime_ui_Touch().default).onStart.remove($bind(this,this.onTouchStart));
		(lime_ui_Touch().default).onMove.remove($bind(this,this.onTouchMove));
		(lime_ui_Touch().default).onEnd.remove($bind(this,this.onTouchEnd));
		this.onModuleExit(0);
	},
	get_preloader: function() {
		return this.__preloader;
	},
	get_window: function() {
		return this.__window;
	},
	get_windows: function() {
		return this.__windows;
	}
});
Application.prototype.__class__ = Application.prototype.constructor = $hxClasses["lime.app.Application"] = Application;

// Init

{
	var init = (lime__$internal_backend_html5_HTML5Application().default)
	var p = Application.prototype;
	Object.defineProperties(p,{ preloader : { get : p.get_preloader}, window : { get : p.get_window}, windows : { get : p.get_windows}});
};

// Statics




// Export

exports.default = Application;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/Future.js":
/*!*********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/Future.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app.Future

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function lime_app_Promise() {return __webpack_require__(/*! ./../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}
function lime_app__$Future_FutureWork() {return __webpack_require__(/*! ./../../lime/app/_Future/FutureWork */ "./node_modules/openfl/lib/_gen/lime/app/_Future/FutureWork.js");}
function haxe_CallStack() {return __webpack_require__(/*! ./../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}

// Constructor

var Future = function(work,async) {
	if(async == null) {
		async = false;
	}
	if(work != null) {
		if(async) {
			var promise = new (lime_app_Promise().default)();
			promise.future = this;
			(lime_app__$Future_FutureWork().default).queue({ promise : promise, work : work});
		} else {
			try {
				this.value = work();
				this.isComplete = true;
			} catch( e ) {
				(haxe_CallStack().default).lastException = e;
				this.error = ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e;
				this.isError = true;
			}
		}
	}
}

// Meta

Future.__name__ = "lime.app.Future";
Future.__isInterface__ = false;
Future.prototype = {
	onComplete: function(listener) {
		if(listener != null) {
			if(this.isComplete) {
				listener(this.value);
			} else if(!this.isError) {
				if(this.__completeListeners == null) {
					this.__completeListeners = [];
				}
				this.__completeListeners.push(listener);
			}
		}
		return this;
	},
	onError: function(listener) {
		if(listener != null) {
			if(this.isError) {
				listener(this.error);
			} else if(!this.isComplete) {
				if(this.__errorListeners == null) {
					this.__errorListeners = [];
				}
				this.__errorListeners.push(listener);
			}
		}
		return this;
	},
	onProgress: function(listener) {
		if(listener != null) {
			if(this.__progressListeners == null) {
				this.__progressListeners = [];
			}
			this.__progressListeners.push(listener);
		}
		return this;
	},
	ready: function(waitTime) {
		if(waitTime == null) {
			waitTime = -1;
		}
		if(this.isComplete || this.isError) {
			return this;
		} else {
			(lime_utils_Log().default).warn("Cannot block thread in JavaScript",{ fileName : "../node_modules/lime/src/lime/app/Future.hx", lineNumber : 209, className : "lime.app.Future", methodName : "ready"});
			return this;
		}
	},
	result: function(waitTime) {
		if(waitTime == null) {
			waitTime = -1;
		}
		this.ready(waitTime);
		if(this.isComplete) {
			return this.value;
		} else {
			return null;
		}
	},
	then: function(next) {
		if(this.isComplete) {
			return next(this.value);
		} else if(this.isError) {
			var future = new Future();
			future.isError = true;
			future.error = this.error;
			return future;
		} else {
			var promise = new (lime_app_Promise().default)();
			this.onError($bind(promise,promise.error));
			this.onProgress($bind(promise,promise.progress));
			this.onComplete(function(val) {
				var future1 = next(val);
				future1.onError($bind(promise,promise.error));
				future1.onComplete($bind(promise,promise.complete));
			});
			return promise.future;
		}
	}
};
Future.prototype.__class__ = Future.prototype.constructor = $hxClasses["lime.app.Future"] = Future;

// Init



// Statics

Future.ofEvents = function(onComplete,onError,onProgress) {
	var promise = new (lime_app_Promise().default)();
	onComplete.add(function(data) {
		promise.complete(data);
	},true);
	if(onError != null) {
		onError.add(function(error) {
			promise.error(error);
		},true);
	}
	if(onProgress != null) {
		onProgress.add(function(progress,total) {
			promise.progress(progress,total);
		},true);
	}
	return promise.future;
}
Future.withError = function(error) {
	var future = new Future();
	future.isError = true;
	future.error = error;
	return future;
}
Future.withValue = function(value) {
	var future = new Future();
	future.isComplete = true;
	future.value = value;
	return future;
}


// Export

exports.default = Future;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/IModule.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/IModule.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app.IModule

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IModule = function() {}

// Meta

IModule.__name__ = "lime.app.IModule";
IModule.__isInterface__ = true;
IModule.prototype = {
	
};
IModule.prototype.__class__ = IModule.prototype.constructor = $hxClasses["lime.app.IModule"] = IModule;

// Init



// Statics




// Export

exports.default = IModule;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/Module.js":
/*!*********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/Module.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app.Module

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_app_IModule() {return __webpack_require__(/*! ./../../lime/app/IModule */ "./node_modules/openfl/lib/_gen/lime/app/IModule.js");}
function lime_app__$Event_$Int_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Int_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Void.js");}

// Constructor

var Module = function() {
	this.onExit = new (lime_app__$Event_$Int_$Void().default)();
}

// Meta

Module.__name__ = "lime.app.Module";
Module.__isInterface__ = false;
Module.__interfaces__ = [(lime_app_IModule().default)];
Module.prototype = {
	__registerLimeModule: function(application) {
	},
	__unregisterLimeModule: function(application) {
	}
};
Module.prototype.__class__ = Module.prototype.constructor = $hxClasses["lime.app.Module"] = Module;

// Init



// Statics




// Export

exports.default = Module;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/Promise.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/Promise.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app.Promise

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}

// Constructor

var Promise = function() {
	this.future = new (lime_app_Future().default)();
}

// Meta

Promise.__name__ = "lime.app.Promise";
Promise.__isInterface__ = false;
Promise.prototype = {
	complete: function(data) {
		if(!this.future.isError) {
			this.future.isComplete = true;
			this.future.value = data;
			if(this.future.__completeListeners != null) {
				var _g = 0;
				var _g1 = this.future.__completeListeners;
				while(_g < _g1.length) {
					var listener = _g1[_g];
					++_g;
					listener(data);
				}
				this.future.__completeListeners = null;
			}
		}
		return this;
	},
	completeWith: function(future) {
		future.onComplete($bind(this,this.complete));
		future.onError($bind(this,this.error));
		future.onProgress($bind(this,this.progress));
		return this;
	},
	error: function(msg) {
		if(!this.future.isComplete) {
			this.future.isError = true;
			this.future.error = msg;
			if(this.future.__errorListeners != null) {
				var _g = 0;
				var _g1 = this.future.__errorListeners;
				while(_g < _g1.length) {
					var listener = _g1[_g];
					++_g;
					listener(msg);
				}
				this.future.__errorListeners = null;
			}
		}
		return this;
	},
	progress: function(progress,total) {
		if(!this.future.isError && !this.future.isComplete) {
			if(this.future.__progressListeners != null) {
				var _g = 0;
				var _g1 = this.future.__progressListeners;
				while(_g < _g1.length) {
					var listener = _g1[_g];
					++_g;
					listener(progress,total);
				}
			}
		}
		return this;
	},
	get_isComplete: function() {
		return this.future.isComplete;
	},
	get_isError: function() {
		return this.future.isError;
	}
};
Promise.prototype.__class__ = Promise.prototype.constructor = $hxClasses["lime.app.Promise"] = Promise;

// Init

{
	var p = Promise.prototype;
	Object.defineProperties(p,{ isComplete : { get : p.get_isComplete}, isError : { get : p.get_isError}});
};

// Statics




// Export

exports.default = Promise;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Dynamic_Void.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Dynamic_Void.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Dynamic_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Dynamic_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Dynamic_Void.__name__ = "lime.app._Event_Dynamic_Void";
_Event_Dynamic_Void.__isInterface__ = false;
_Event_Dynamic_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Dynamic_Void.prototype.__class__ = _Event_Dynamic_Void.prototype.constructor = $hxClasses["lime.app._Event_Dynamic_Void"] = _Event_Dynamic_Void;

// Init



// Statics




// Export

exports.default = _Event_Dynamic_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Float_Void.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Float_Void.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Float_Float_Float_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Float_Float_Float_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Float_Float_Float_Void.__name__ = "lime.app._Event_Float_Float_Float_Void";
_Event_Float_Float_Float_Void.__isInterface__ = false;
_Event_Float_Float_Float_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1,a2) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1,a2);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Float_Float_Float_Void.prototype.__class__ = _Event_Float_Float_Float_Void.prototype.constructor = $hxClasses["lime.app._Event_Float_Float_Float_Void"] = _Event_Float_Float_Float_Void;

// Init



// Statics




// Export

exports.default = _Event_Float_Float_Float_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Int_Void.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Int_Void.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Float_Float_Int_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Float_Float_Int_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Float_Float_Int_Void.__name__ = "lime.app._Event_Float_Float_Int_Void";
_Event_Float_Float_Int_Void.__isInterface__ = false;
_Event_Float_Float_Int_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1,a2) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1,a2);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Float_Float_Int_Void.prototype.__class__ = _Event_Float_Float_Int_Void.prototype.constructor = $hxClasses["lime.app._Event_Float_Float_Int_Void"] = _Event_Float_Float_Int_Void;

// Init



// Statics




// Export

exports.default = _Event_Float_Float_Int_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Void.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Void.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Float_Float_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Float_Float_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Float_Float_Void.__name__ = "lime.app._Event_Float_Float_Void";
_Event_Float_Float_Void.__isInterface__ = false;
_Event_Float_Float_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Float_Float_Void.prototype.__class__ = _Event_Float_Float_Void.prototype.constructor = $hxClasses["lime.app._Event_Float_Float_Void"] = _Event_Float_Float_Void;

// Init



// Statics




// Export

exports.default = _Event_Float_Float_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_lime_ui_MouseButton_Void.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_lime_ui_MouseButton_Void.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Float_Float_lime_ui_MouseButton_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Float_Float_lime_ui_MouseButton_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Float_Float_lime_ui_MouseButton_Void.__name__ = "lime.app._Event_Float_Float_lime_ui_MouseButton_Void";
_Event_Float_Float_lime_ui_MouseButton_Void.__isInterface__ = false;
_Event_Float_Float_lime_ui_MouseButton_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1,a2) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1,a2);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Float_Float_lime_ui_MouseButton_Void.prototype.__class__ = _Event_Float_Float_lime_ui_MouseButton_Void.prototype.constructor = $hxClasses["lime.app._Event_Float_Float_lime_ui_MouseButton_Void"] = _Event_Float_Float_lime_ui_MouseButton_Void;

// Init



// Statics




// Export

exports.default = _Event_Float_Float_lime_ui_MouseButton_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_lime_ui_MouseWheelMode_Void.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_lime_ui_MouseWheelMode_Void.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Float_Float_lime_ui_MouseWheelMode_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Float_Float_lime_ui_MouseWheelMode_Void.__name__ = "lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void";
_Event_Float_Float_lime_ui_MouseWheelMode_Void.__isInterface__ = false;
_Event_Float_Float_lime_ui_MouseWheelMode_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1,a2) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1,a2);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Float_Float_lime_ui_MouseWheelMode_Void.prototype.__class__ = _Event_Float_Float_lime_ui_MouseWheelMode_Void.prototype.constructor = $hxClasses["lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void"] = _Event_Float_Float_lime_ui_MouseWheelMode_Void;

// Init



// Statics




// Export

exports.default = _Event_Float_Float_lime_ui_MouseWheelMode_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Float_Float_Void.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Float_Float_Void.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Int_Float_Float_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Int_Float_Float_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Int_Float_Float_Void.__name__ = "lime.app._Event_Int_Float_Float_Void";
_Event_Int_Float_Float_Void.__isInterface__ = false;
_Event_Int_Float_Float_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1,a2) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1,a2);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Int_Float_Float_Void.prototype.__class__ = _Event_Int_Float_Float_Void.prototype.constructor = $hxClasses["lime.app._Event_Int_Float_Float_Void"] = _Event_Int_Float_Float_Void;

// Init



// Statics




// Export

exports.default = _Event_Int_Float_Float_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Float_Void.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Float_Void.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Int_Float_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Int_Float_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Int_Float_Void.__name__ = "lime.app._Event_Int_Float_Void";
_Event_Int_Float_Void.__isInterface__ = false;
_Event_Int_Float_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Int_Float_Void.prototype.__class__ = _Event_Int_Float_Void.prototype.constructor = $hxClasses["lime.app._Event_Int_Float_Void"] = _Event_Int_Float_Void;

// Init



// Statics




// Export

exports.default = _Event_Int_Float_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Int_Void.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Int_Void.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Int_Int_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Int_Int_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Int_Int_Void.__name__ = "lime.app._Event_Int_Int_Void";
_Event_Int_Int_Void.__isInterface__ = false;
_Event_Int_Int_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Int_Int_Void.prototype.__class__ = _Event_Int_Int_Void.prototype.constructor = $hxClasses["lime.app._Event_Int_Int_Void"] = _Event_Int_Int_Void;

// Init



// Statics




// Export

exports.default = _Event_Int_Int_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Void.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Void.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Int_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Int_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Int_Void.__name__ = "lime.app._Event_Int_Void";
_Event_Int_Void.__isInterface__ = false;
_Event_Int_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Int_Void.prototype.__class__ = _Event_Int_Void.prototype.constructor = $hxClasses["lime.app._Event_Int_Void"] = _Event_Int_Void;

// Init



// Statics




// Export

exports.default = _Event_Int_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_lime_ui_JoystickHatPosition_Void.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Int_lime_ui_JoystickHatPosition_Void.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Int_lime_ui_JoystickHatPosition_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Int_lime_ui_JoystickHatPosition_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Int_lime_ui_JoystickHatPosition_Void.__name__ = "lime.app._Event_Int_lime_ui_JoystickHatPosition_Void";
_Event_Int_lime_ui_JoystickHatPosition_Void.__isInterface__ = false;
_Event_Int_lime_ui_JoystickHatPosition_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Int_lime_ui_JoystickHatPosition_Void.prototype.__class__ = _Event_Int_lime_ui_JoystickHatPosition_Void.prototype.constructor = $hxClasses["lime.app._Event_Int_lime_ui_JoystickHatPosition_Void"] = _Event_Int_lime_ui_JoystickHatPosition_Void;

// Init



// Statics




// Export

exports.default = _Event_Int_lime_ui_JoystickHatPosition_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_String_Int_Int_Void.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_String_Int_Int_Void.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_String_Int_Int_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_String_Int_Int_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_String_Int_Int_Void.__name__ = "lime.app._Event_String_Int_Int_Void";
_Event_String_Int_Int_Void.__isInterface__ = false;
_Event_String_Int_Int_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1,a2) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1,a2);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_String_Int_Int_Void.prototype.__class__ = _Event_String_Int_Int_Void.prototype.constructor = $hxClasses["lime.app._Event_String_Int_Int_Void"] = _Event_String_Int_Int_Void;

// Init



// Statics




// Export

exports.default = _Event_String_Int_Int_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_String_Void.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_String_Void.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_String_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_String_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_String_Void.__name__ = "lime.app._Event_String_Void";
_Event_String_Void.__isInterface__ = false;
_Event_String_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_String_Void.prototype.__class__ = _Event_String_Void.prototype.constructor = $hxClasses["lime.app._Event_String_Void"] = _Event_String_Void;

// Init



// Statics




// Export

exports.default = _Event_String_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_Void_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_Void_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_Void_Void.__name__ = "lime.app._Event_Void_Void";
_Event_Void_Void.__isInterface__ = false;
_Event_Void_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function() {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i]();
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_Void_Void.prototype.__class__ = _Event_Void_Void.prototype.constructor = $hxClasses["lime.app._Event_Void_Void"] = _Event_Void_Void;

// Init



// Statics




// Export

exports.default = _Event_Void_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_graphics_RenderContext_Void.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_lime_graphics_RenderContext_Void.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_lime_graphics_RenderContext_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_lime_graphics_RenderContext_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_lime_graphics_RenderContext_Void.__name__ = "lime.app._Event_lime_graphics_RenderContext_Void";
_Event_lime_graphics_RenderContext_Void.__isInterface__ = false;
_Event_lime_graphics_RenderContext_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_lime_graphics_RenderContext_Void.prototype.__class__ = _Event_lime_graphics_RenderContext_Void.prototype.constructor = $hxClasses["lime.app._Event_lime_graphics_RenderContext_Void"] = _Event_lime_graphics_RenderContext_Void;

// Init



// Statics




// Export

exports.default = _Event_lime_graphics_RenderContext_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_GamepadAxis_Float_Void.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_GamepadAxis_Float_Void.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_lime_ui_GamepadAxis_Float_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_lime_ui_GamepadAxis_Float_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_lime_ui_GamepadAxis_Float_Void.__name__ = "lime.app._Event_lime_ui_GamepadAxis_Float_Void";
_Event_lime_ui_GamepadAxis_Float_Void.__isInterface__ = false;
_Event_lime_ui_GamepadAxis_Float_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_lime_ui_GamepadAxis_Float_Void.prototype.__class__ = _Event_lime_ui_GamepadAxis_Float_Void.prototype.constructor = $hxClasses["lime.app._Event_lime_ui_GamepadAxis_Float_Void"] = _Event_lime_ui_GamepadAxis_Float_Void;

// Init



// Statics




// Export

exports.default = _Event_lime_ui_GamepadAxis_Float_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_GamepadButton_Void.js":
/*!************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_GamepadButton_Void.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_lime_ui_GamepadButton_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_lime_ui_GamepadButton_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_lime_ui_GamepadButton_Void.__name__ = "lime.app._Event_lime_ui_GamepadButton_Void";
_Event_lime_ui_GamepadButton_Void.__isInterface__ = false;
_Event_lime_ui_GamepadButton_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_lime_ui_GamepadButton_Void.prototype.__class__ = _Event_lime_ui_GamepadButton_Void.prototype.constructor = $hxClasses["lime.app._Event_lime_ui_GamepadButton_Void"] = _Event_lime_ui_GamepadButton_Void;

// Init



// Statics




// Export

exports.default = _Event_lime_ui_GamepadButton_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Gamepad_Void.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Gamepad_Void.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_lime_ui_Gamepad_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_lime_ui_Gamepad_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_lime_ui_Gamepad_Void.__name__ = "lime.app._Event_lime_ui_Gamepad_Void";
_Event_lime_ui_Gamepad_Void.__isInterface__ = false;
_Event_lime_ui_Gamepad_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_lime_ui_Gamepad_Void.prototype.__class__ = _Event_lime_ui_Gamepad_Void.prototype.constructor = $hxClasses["lime.app._Event_lime_ui_Gamepad_Void"] = _Event_lime_ui_Gamepad_Void;

// Init



// Statics




// Export

exports.default = _Event_lime_ui_Gamepad_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Joystick_Void.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Joystick_Void.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_lime_ui_Joystick_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_lime_ui_Joystick_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_lime_ui_Joystick_Void.__name__ = "lime.app._Event_lime_ui_Joystick_Void";
_Event_lime_ui_Joystick_Void.__isInterface__ = false;
_Event_lime_ui_Joystick_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_lime_ui_Joystick_Void.prototype.__class__ = _Event_lime_ui_Joystick_Void.prototype.constructor = $hxClasses["lime.app._Event_lime_ui_Joystick_Void"] = _Event_lime_ui_Joystick_Void;

// Init



// Statics




// Export

exports.default = _Event_lime_ui_Joystick_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.__name__ = "lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void";
_Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.__isInterface__ = false;
_Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a,a1) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a,a1);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.prototype.__class__ = _Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.prototype.constructor = $hxClasses["lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void"] = _Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void;

// Init



// Statics




// Export

exports.default = _Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Touch_Void.js":
/*!****************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Touch_Void.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_lime_ui_Touch_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_lime_ui_Touch_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_lime_ui_Touch_Void.__name__ = "lime.app._Event_lime_ui_Touch_Void";
_Event_lime_ui_Touch_Void.__isInterface__ = false;
_Event_lime_ui_Touch_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_lime_ui_Touch_Void.prototype.__class__ = _Event_lime_ui_Touch_Void.prototype.constructor = $hxClasses["lime.app._Event_lime_ui_Touch_Void"] = _Event_lime_ui_Touch_Void;

// Init



// Statics




// Export

exports.default = _Event_lime_ui_Touch_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Window_Void.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Window_Void.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Event_lime_ui_Window_Void

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var _Event_lime_ui_Window_Void = function() {
	this.canceled = false;
	this.__listeners = [];
	this.__priorities = [];
	this.__repeat = [];
}

// Meta

_Event_lime_ui_Window_Void.__name__ = "lime.app._Event_lime_ui_Window_Void";
_Event_lime_ui_Window_Void.__isInterface__ = false;
_Event_lime_ui_Window_Void.prototype = {
	add: function(listener,once,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(once == null) {
			once = false;
		}
		var _g = 0;
		var _g1 = this.__priorities.length;
		while(_g < _g1) {
			var i = _g++;
			if(priority > this.__priorities[i]) {
				this.__listeners.splice(i,0,listener);
				this.__priorities.splice(i,0,priority);
				this.__repeat.splice(i,0,!once);
				return;
			}
		}
		this.__listeners.push(listener);
		this.__priorities.push(priority);
		this.__repeat.push(!once);
	},
	cancel: function() {
		this.canceled = true;
	},
	has: function(listener) {
		var _g = 0;
		var _g1 = this.__listeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			if((Reflect().default).compareMethods(l,listener)) {
				return true;
			}
		}
		return false;
	},
	remove: function(listener) {
		var i = this.__listeners.length;
		while(--i >= 0) if((Reflect().default).compareMethods(this.__listeners[i],listener)) {
			this.__listeners.splice(i,1);
			this.__priorities.splice(i,1);
			this.__repeat.splice(i,1);
		}
	},
	dispatch: function(a) {
		this.canceled = false;
		var listeners = this.__listeners;
		var repeat = this.__repeat;
		var i = 0;
		while(i < listeners.length) {
			listeners[i](a);
			if(!repeat[i]) {
				this.remove(listeners[i]);
			} else {
				++i;
			}
			if(this.canceled) {
				break;
			}
		}
	}
};
_Event_lime_ui_Window_Void.prototype.__class__ = _Event_lime_ui_Window_Void.prototype.constructor = $hxClasses["lime.app._Event_lime_ui_Window_Void"] = _Event_lime_ui_Window_Void;

// Init



// Statics




// Export

exports.default = _Event_lime_ui_Window_Void;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/app/_Future/FutureWork.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/app/_Future/FutureWork.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.app._Future.FutureWork

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_system_ThreadPool() {return __webpack_require__(/*! ./../../../lime/system/ThreadPool */ "./node_modules/openfl/lib/_gen/lime/system/ThreadPool.js");}
function haxe_CallStack() {return __webpack_require__(/*! ./../../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}

// Constructor

var FutureWork = function(){}

// Meta

FutureWork.__name__ = "lime.app._Future.FutureWork";
FutureWork.__isInterface__ = false;
FutureWork.prototype = {
	
};
FutureWork.prototype.__class__ = FutureWork.prototype.constructor = $hxClasses["lime.app._Future.FutureWork"] = FutureWork;

// Init



// Statics

FutureWork.queue = function(state) {
	if(FutureWork.threadPool == null) {
		FutureWork.threadPool = new (lime_system_ThreadPool().default)();
		FutureWork.threadPool.doWork.add(FutureWork.threadPool_doWork);
		FutureWork.threadPool.onComplete.add(FutureWork.threadPool_onComplete);
		FutureWork.threadPool.onError.add(FutureWork.threadPool_onError);
	}
	FutureWork.threadPool.queue(state);
}
FutureWork.threadPool_doWork = function(state) {
	try {
		var result = state.work();
		FutureWork.threadPool.sendComplete({ promise : state.promise, result : result});
	} catch( e ) {
		(haxe_CallStack().default).lastException = e;
		FutureWork.threadPool.sendError({ promise : state.promise, error : ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e});
	}
}
FutureWork.threadPool_onComplete = function(state) {
	state.promise.complete(state.result);
}
FutureWork.threadPool_onError = function(state) {
	state.promise.error(state.error);
}


// Export

exports.default = FutureWork;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/Image.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/Image.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.graphics.Image

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_graphics_ImageType() {return __webpack_require__(/*! ./../../lime/graphics/ImageType */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageType.js");}
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function lime__$internal_graphics_ImageDataUtil() {return __webpack_require__(/*! ./../../lime/_internal/graphics/ImageDataUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageDataUtil.js");}
function lime_math__$ColorMatrix_ColorMatrix_$Impl_$() {return __webpack_require__(/*! ./../../lime/math/_ColorMatrix/ColorMatrix_Impl_ */ "./node_modules/openfl/lib/_gen/lime/math/_ColorMatrix/ColorMatrix_Impl_.js");}
function lime_graphics_ImageChannel() {return __webpack_require__(/*! ./../../lime/graphics/ImageChannel */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageChannel.js");}
function lime__$internal_format_PNG() {return __webpack_require__(/*! ./../../lime/_internal/format/PNG */ "./node_modules/openfl/lib/_gen/lime/_internal/format/PNG.js");}
function lime__$internal_format_BMP() {return __webpack_require__(/*! ./../../lime/_internal/format/BMP */ "./node_modules/openfl/lib/_gen/lime/_internal/format/BMP.js");}
function lime__$internal_format_JPEG() {return __webpack_require__(/*! ./../../lime/_internal/format/JPEG */ "./node_modules/openfl/lib/_gen/lime/_internal/format/JPEG.js");}
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}
function lime_math_Vector2() {return __webpack_require__(/*! ./../../lime/math/Vector2 */ "./node_modules/openfl/lib/_gen/lime/math/Vector2.js");}
function lime_system_Endian() {return __webpack_require__(/*! ./../../lime/system/Endian */ "./node_modules/openfl/lib/_gen/lime/system/Endian.js");}
function lime_graphics_ImageBuffer() {return __webpack_require__(/*! ./../../lime/graphics/ImageBuffer */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageBuffer.js");}
function lime__$internal_format_Base64() {return __webpack_require__(/*! ./../../lime/_internal/format/Base64 */ "./node_modules/openfl/lib/_gen/lime/_internal/format/Base64.js");}
function lime__$internal_backend_html5_HTML5HTTPRequest() {return __webpack_require__(/*! ./../../lime/_internal/backend/html5/HTML5HTTPRequest */ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5HTTPRequest.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}

// Constructor

var Image = function(buffer,offsetX,offsetY,width,height,color,type) {
	if(height == null) {
		height = -1;
	}
	if(width == null) {
		width = -1;
	}
	if(offsetY == null) {
		offsetY = 0;
	}
	if(offsetX == null) {
		offsetX = 0;
	}
	this.offsetX = offsetX;
	this.offsetY = offsetY;
	this.width = width;
	this.height = height;
	this.version = 0;
	if(type == null) {
		type = (lime_graphics_ImageType().default).CANVAS;
	}
	this.type = type;
	if(buffer == null) {
		if(width > 0 && height > 0) {
			switch(this.type._hx_index) {
			case 0:
				this.buffer = new (lime_graphics_ImageBuffer().default)(null,width,height);
				(lime__$internal_graphics_ImageCanvasUtil().default).createCanvas(this,width,height);
				if(color != null && color != 0) {
					this.fillRect(new (lime_math_Rectangle().default)(0,0,width,height),color);
				}
				break;
			case 1:
				var elements = width * height * 4;
				var array = null;
				var view = null;
				var buffer1 = null;
				var len = null;
				var this1;
				if(elements != null) {
					this1 = new Uint8Array(elements);
				} else if(array != null) {
					this1 = new Uint8Array(array);
				} else if(view != null) {
					this1 = new Uint8Array(view);
				} else if(buffer1 != null) {
					if(len == null) {
						this1 = new Uint8Array(buffer1,0);
					} else {
						this1 = new Uint8Array(buffer1,0,len);
					}
				} else {
					this1 = null;
				}
				this.buffer = new (lime_graphics_ImageBuffer().default)(this1,width,height);
				if(color != null && color != 0) {
					this.fillRect(new (lime_math_Rectangle().default)(0,0,width,height),color);
				}
				break;
			case 2:
				break;
			default:
			}
		}
	} else {
		this.__fromImageBuffer(buffer);
	}
}

// Meta

Image.__name__ = "lime.graphics.Image";
Image.__isInterface__ = false;
Image.prototype = {
	clone: function() {
		if(this.buffer != null) {
			if(this.type == (lime_graphics_ImageType().default).CANVAS) {
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(this);
			} else {
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			}
			var image = new Image(this.buffer.clone(),this.offsetX,this.offsetY,this.width,this.height,null,this.type);
			image.version = this.version;
			return image;
		} else {
			return new Image(null,this.offsetX,this.offsetY,this.width,this.height,null,this.type);
		}
	},
	colorTransform: function(rect,colorMatrix) {
		rect = this.__clipRect(rect);
		if(this.buffer == null || rect == null) {
			return;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).colorTransform(this,rect,colorMatrix);
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageDataUtil().default).colorTransform(this,rect,colorMatrix);
			break;
		case 2:
			rect.offset(this.offsetX,this.offsetY);
			this.buffer.__srcBitmapData.colorTransform(rect.__toFlashRectangle(),(lime_math__$ColorMatrix_ColorMatrix_$Impl_$().default).__toFlashColorTransform(colorMatrix));
			break;
		default:
		}
	},
	copyChannel: function(sourceImage,sourceRect,destPoint,sourceChannel,destChannel) {
		sourceRect = this.__clipRect(sourceRect);
		if(this.buffer == null || sourceRect == null) {
			return;
		}
		if(destChannel == (lime_graphics_ImageChannel().default).ALPHA && !this.get_transparent()) {
			return;
		}
		if(sourceRect.width <= 0 || sourceRect.height <= 0) {
			return;
		}
		if(sourceRect.x + sourceRect.width > sourceImage.width) {
			sourceRect.width = sourceImage.width - sourceRect.x;
		}
		if(sourceRect.y + sourceRect.height > sourceImage.height) {
			sourceRect.height = sourceImage.height - sourceRect.y;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).copyChannel(this,sourceImage,sourceRect,destPoint,sourceChannel,destChannel);
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(sourceImage);
			(lime__$internal_graphics_ImageDataUtil().default).copyChannel(this,sourceImage,sourceRect,destPoint,sourceChannel,destChannel);
			break;
		case 2:
			var srcChannel;
			switch(sourceChannel._hx_index) {
			case 0:
				srcChannel = 1;
				break;
			case 1:
				srcChannel = 2;
				break;
			case 2:
				srcChannel = 4;
				break;
			case 3:
				srcChannel = 8;
				break;
			}
			var dstChannel;
			switch(destChannel._hx_index) {
			case 0:
				dstChannel = 1;
				break;
			case 1:
				dstChannel = 2;
				break;
			case 2:
				dstChannel = 4;
				break;
			case 3:
				dstChannel = 8;
				break;
			}
			sourceRect.offset(sourceImage.offsetX,sourceImage.offsetY);
			destPoint.offset(this.offsetX,this.offsetY);
			this.buffer.__srcBitmapData.copyChannel(sourceImage.buffer.get_src(),sourceRect.__toFlashRectangle(),destPoint.__toFlashPoint(),srcChannel,dstChannel);
			break;
		default:
		}
	},
	copyPixels: function(sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha) {
		if(mergeAlpha == null) {
			mergeAlpha = false;
		}
		if(this.buffer == null || sourceImage == null) {
			return;
		}
		if(sourceRect.width <= 0 || sourceRect.height <= 0) {
			return;
		}
		if(this.width <= 0 || this.height <= 0) {
			return;
		}
		if(sourceRect.x + sourceRect.width > sourceImage.width) {
			sourceRect.width = sourceImage.width - sourceRect.x;
		}
		if(sourceRect.y + sourceRect.height > sourceImage.height) {
			sourceRect.height = sourceImage.height - sourceRect.y;
		}
		if(sourceRect.x < 0) {
			sourceRect.width += sourceRect.x;
			sourceRect.x = 0;
		}
		if(sourceRect.y < 0) {
			sourceRect.height += sourceRect.y;
			sourceRect.y = 0;
		}
		if(destPoint.x + sourceRect.width > this.width) {
			sourceRect.width = this.width - destPoint.x;
		}
		if(destPoint.y + sourceRect.height > this.height) {
			sourceRect.height = this.height - destPoint.y;
		}
		if(destPoint.x < 0) {
			sourceRect.width += destPoint.x;
			sourceRect.x -= destPoint.x;
			destPoint.x = 0;
		}
		if(destPoint.y < 0) {
			sourceRect.height += destPoint.y;
			sourceRect.y -= destPoint.y;
			destPoint.y = 0;
		}
		if(sourceImage == this && destPoint.x < sourceRect.get_right() && destPoint.y < sourceRect.get_bottom()) {
			sourceImage = this.clone();
		}
		if(alphaImage == sourceImage && (alphaPoint == null || alphaPoint.x == 0 && alphaPoint.y == 0)) {
			alphaImage = null;
			alphaPoint = null;
		}
		switch(this.type._hx_index) {
		case 0:
			if(alphaImage != null) {
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(sourceImage);
				if(alphaImage != null) {
					(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(alphaImage);
				}
				(lime__$internal_graphics_ImageDataUtil().default).copyPixels(this,sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha);
			} else {
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(this);
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(sourceImage);
				(lime__$internal_graphics_ImageCanvasUtil().default).copyPixels(this,sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha);
			}
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(sourceImage);
			if(alphaImage != null) {
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(alphaImage);
			}
			(lime__$internal_graphics_ImageDataUtil().default).copyPixels(this,sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha);
			break;
		case 2:
			sourceRect.offset(sourceImage.offsetX,sourceImage.offsetY);
			destPoint.offset(this.offsetX,this.offsetY);
			if(alphaImage != null && alphaPoint != null) {
				alphaPoint.offset(alphaImage.offsetX,alphaImage.offsetY);
			}
			this.buffer.__srcBitmapData.copyPixels(sourceImage.buffer.__srcBitmapData,sourceRect.__toFlashRectangle(),destPoint.__toFlashPoint(),alphaImage != null ? alphaImage.buffer.get_src() : null,alphaPoint != null ? alphaPoint.__toFlashPoint() : null,mergeAlpha);
			break;
		default:
		}
	},
	encode: function(format,quality) {
		if(quality == null) {
			quality = 90;
		}
		if(format == null) {
			return (lime__$internal_format_PNG().default).encode(this);
		} else {
			switch(format._hx_index) {
			case 0:
				return (lime__$internal_format_BMP().default).encode(this);
			case 1:
				return (lime__$internal_format_JPEG().default).encode(this,quality);
			case 2:
				return (lime__$internal_format_PNG().default).encode(this);
			}
		}
	},
	fillRect: function(rect,color,format) {
		rect = this.__clipRect(rect);
		if(this.buffer == null || rect == null) {
			return;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).fillRect(this,rect,color,format);
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			if(this.buffer.data.length == 0) {
				return;
			}
			(lime__$internal_graphics_ImageDataUtil().default).fillRect(this,rect,color,format);
			break;
		case 2:
			rect.offset(this.offsetX,this.offsetY);
			var argb;
			if(format == null) {
				var rgba = color;
				var this1 = 0;
				var argb1 = this1;
				argb1 = (rgba & 255 & 255) << 24 | (rgba >>> 24 & 255 & 255) << 16 | (rgba >>> 16 & 255 & 255) << 8 | rgba >>> 8 & 255 & 255;
				argb = argb1;
			} else {
				switch(format) {
				case 1:
					argb = color;
					break;
				case 2:
					var bgra = color;
					var this2 = 0;
					var argb2 = this2;
					argb2 = (bgra & 255 & 255) << 24 | (bgra >>> 8 & 255 & 255) << 16 | (bgra >>> 16 & 255 & 255) << 8 | bgra >>> 24 & 255 & 255;
					argb = argb2;
					break;
				default:
					var rgba1 = color;
					var this3 = 0;
					var argb3 = this3;
					argb3 = (rgba1 & 255 & 255) << 24 | (rgba1 >>> 24 & 255 & 255) << 16 | (rgba1 >>> 16 & 255 & 255) << 8 | rgba1 >>> 8 & 255 & 255;
					argb = argb3;
				}
			}
			this.buffer.__srcBitmapData.fillRect(rect.__toFlashRectangle(),argb);
			break;
		default:
		}
	},
	floodFill: function(x,y,color,format) {
		if(this.buffer == null) {
			return;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).floodFill(this,x,y,color,format);
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageDataUtil().default).floodFill(this,x,y,color,format);
			break;
		case 2:
			var argb;
			if(format == null) {
				var rgba = color;
				var this1 = 0;
				var argb1 = this1;
				argb1 = (rgba & 255 & 255) << 24 | (rgba >>> 24 & 255 & 255) << 16 | (rgba >>> 16 & 255 & 255) << 8 | rgba >>> 8 & 255 & 255;
				argb = argb1;
			} else {
				switch(format) {
				case 1:
					argb = color;
					break;
				case 2:
					var bgra = color;
					var this2 = 0;
					var argb2 = this2;
					argb2 = (bgra & 255 & 255) << 24 | (bgra >>> 8 & 255 & 255) << 16 | (bgra >>> 16 & 255 & 255) << 8 | bgra >>> 24 & 255 & 255;
					argb = argb2;
					break;
				default:
					var rgba1 = color;
					var this3 = 0;
					var argb3 = this3;
					argb3 = (rgba1 & 255 & 255) << 24 | (rgba1 >>> 24 & 255 & 255) << 16 | (rgba1 >>> 16 & 255 & 255) << 8 | rgba1 >>> 8 & 255 & 255;
					argb = argb3;
				}
			}
			this.buffer.__srcBitmapData.floodFill(x + this.offsetX,y + this.offsetY,argb);
			break;
		default:
		}
	},
	getColorBoundsRect: function(mask,color,findColor,format) {
		if(findColor == null) {
			findColor = true;
		}
		if(this.buffer == null) {
			return null;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			return (lime__$internal_graphics_ImageDataUtil().default).getColorBoundsRect(this,mask,color,findColor,format);
		case 1:
			return (lime__$internal_graphics_ImageDataUtil().default).getColorBoundsRect(this,mask,color,findColor,format);
		case 2:
			var rect = this.buffer.__srcBitmapData.getColorBoundsRect(mask,color,findColor);
			return new (lime_math_Rectangle().default)(rect.x,rect.y,rect.width,rect.height);
		default:
			return null;
		}
	},
	getPixel: function(x,y,format) {
		if(this.buffer == null || x < 0 || y < 0 || x >= this.width || y >= this.height) {
			return 0;
		}
		switch(this.type._hx_index) {
		case 0:
			return (lime__$internal_graphics_ImageCanvasUtil().default).getPixel(this,x,y,format);
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			return (lime__$internal_graphics_ImageDataUtil().default).getPixel(this,x,y,format);
		case 2:
			var color = this.buffer.__srcBitmapData.getPixel(x + this.offsetX,y + this.offsetY);
			if(format == null) {
				var this1 = 0;
				var rgba = this1;
				rgba = (color >>> 16 & 255 & 255) << 24 | (color >>> 8 & 255 & 255) << 16 | (color & 255 & 255) << 8 | color >>> 24 & 255 & 255;
				var rgba1 = rgba;
				return rgba1;
			} else {
				switch(format) {
				case 1:
					return color;
				case 2:
					var this2 = 0;
					var bgra = this2;
					bgra = (color & 255 & 255) << 24 | (color >>> 8 & 255 & 255) << 16 | (color >>> 16 & 255 & 255) << 8 | color >>> 24 & 255 & 255;
					var bgra1 = bgra;
					return bgra1;
				default:
					var this3 = 0;
					var rgba2 = this3;
					rgba2 = (color >>> 16 & 255 & 255) << 24 | (color >>> 8 & 255 & 255) << 16 | (color & 255 & 255) << 8 | color >>> 24 & 255 & 255;
					var rgba3 = rgba2;
					return rgba3;
				}
			}
			break;
		default:
			return 0;
		}
	},
	getPixel32: function(x,y,format) {
		if(this.buffer == null || x < 0 || y < 0 || x >= this.width || y >= this.height) {
			return 0;
		}
		switch(this.type._hx_index) {
		case 0:
			return (lime__$internal_graphics_ImageCanvasUtil().default).getPixel32(this,x,y,format);
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			return (lime__$internal_graphics_ImageDataUtil().default).getPixel32(this,x,y,format);
		case 2:
			var color = this.buffer.__srcBitmapData.getPixel32(x + this.offsetX,y + this.offsetY);
			if(format == null) {
				var this1 = 0;
				var rgba = this1;
				rgba = (color >>> 16 & 255 & 255) << 24 | (color >>> 8 & 255 & 255) << 16 | (color & 255 & 255) << 8 | color >>> 24 & 255 & 255;
				var rgba1 = rgba;
				return rgba1;
			} else {
				switch(format) {
				case 1:
					return color;
				case 2:
					var this2 = 0;
					var bgra = this2;
					bgra = (color & 255 & 255) << 24 | (color >>> 8 & 255 & 255) << 16 | (color >>> 16 & 255 & 255) << 8 | color >>> 24 & 255 & 255;
					var bgra1 = bgra;
					return bgra1;
				default:
					var this3 = 0;
					var rgba2 = this3;
					rgba2 = (color >>> 16 & 255 & 255) << 24 | (color >>> 8 & 255 & 255) << 16 | (color & 255 & 255) << 8 | color >>> 24 & 255 & 255;
					var rgba3 = rgba2;
					return rgba3;
				}
			}
			break;
		default:
			return 0;
		}
	},
	getPixels: function(rect,format) {
		if(this.buffer == null) {
			return null;
		}
		switch(this.type._hx_index) {
		case 0:
			return (lime__$internal_graphics_ImageCanvasUtil().default).getPixels(this,rect,format);
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			return (lime__$internal_graphics_ImageDataUtil().default).getPixels(this,rect,format);
		case 2:
			return null;
		default:
			return null;
		}
	},
	merge: function(sourceImage,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier) {
		if(this.buffer == null || sourceImage == null) {
			return;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(this);
			(lime__$internal_graphics_ImageCanvasUtil().default).merge(this,sourceImage,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier);
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(sourceImage);
			(lime__$internal_graphics_ImageDataUtil().default).merge(this,sourceImage,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier);
			break;
		case 2:
			sourceRect.offset(this.offsetX,this.offsetY);
			this.buffer.__srcBitmapData.merge(sourceImage.buffer.__srcBitmapData,sourceRect.__toFlashRectangle(),destPoint.__toFlashPoint(),redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier);
			break;
		default:
			return;
		}
	},
	resize: function(newWidth,newHeight) {
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).resize(this,newWidth,newHeight);
			break;
		case 1:
			(lime__$internal_graphics_ImageDataUtil().default).resize(this,newWidth,newHeight);
			break;
		case 2:
			break;
		default:
		}
		this.buffer.width = newWidth;
		this.buffer.height = newHeight;
		this.offsetX = 0;
		this.offsetY = 0;
		this.width = newWidth;
		this.height = newHeight;
	},
	scroll: function(x,y) {
		if(this.buffer == null) {
			return;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).scroll(this,x,y);
			break;
		case 1:
			this.copyPixels(this,this.get_rect(),new (lime_math_Vector2().default)(x,y));
			break;
		case 2:
			this.buffer.__srcBitmapData.scroll(x + this.offsetX,y + this.offsetX);
			break;
		default:
		}
	},
	setPixel: function(x,y,color,format) {
		if(this.buffer == null || x < 0 || y < 0 || x >= this.width || y >= this.height) {
			return;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).setPixel(this,x,y,color,format);
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageDataUtil().default).setPixel(this,x,y,color,format);
			break;
		case 2:
			var argb;
			if(format == null) {
				var rgba = color;
				var this1 = 0;
				var argb1 = this1;
				argb1 = (rgba & 255 & 255) << 24 | (rgba >>> 24 & 255 & 255) << 16 | (rgba >>> 16 & 255 & 255) << 8 | rgba >>> 8 & 255 & 255;
				argb = argb1;
			} else {
				switch(format) {
				case 1:
					argb = color;
					break;
				case 2:
					var bgra = color;
					var this2 = 0;
					var argb2 = this2;
					argb2 = (bgra & 255 & 255) << 24 | (bgra >>> 8 & 255 & 255) << 16 | (bgra >>> 16 & 255 & 255) << 8 | bgra >>> 24 & 255 & 255;
					argb = argb2;
					break;
				default:
					var rgba1 = color;
					var this3 = 0;
					var argb3 = this3;
					argb3 = (rgba1 & 255 & 255) << 24 | (rgba1 >>> 24 & 255 & 255) << 16 | (rgba1 >>> 16 & 255 & 255) << 8 | rgba1 >>> 8 & 255 & 255;
					argb = argb3;
				}
			}
			this.buffer.__srcBitmapData.setPixel(x + this.offsetX,y + this.offsetX,argb);
			break;
		default:
		}
	},
	setPixel32: function(x,y,color,format) {
		if(this.buffer == null || x < 0 || y < 0 || x >= this.width || y >= this.height) {
			return;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).setPixel32(this,x,y,color,format);
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageDataUtil().default).setPixel32(this,x,y,color,format);
			break;
		case 2:
			var argb;
			if(format == null) {
				var rgba = color;
				var this1 = 0;
				var argb1 = this1;
				argb1 = (rgba & 255 & 255) << 24 | (rgba >>> 24 & 255 & 255) << 16 | (rgba >>> 16 & 255 & 255) << 8 | rgba >>> 8 & 255 & 255;
				argb = argb1;
			} else {
				switch(format) {
				case 1:
					argb = color;
					break;
				case 2:
					var bgra = color;
					var this2 = 0;
					var argb2 = this2;
					argb2 = (bgra & 255 & 255) << 24 | (bgra >>> 8 & 255 & 255) << 16 | (bgra >>> 16 & 255 & 255) << 8 | bgra >>> 24 & 255 & 255;
					argb = argb2;
					break;
				default:
					var rgba1 = color;
					var this3 = 0;
					var argb3 = this3;
					argb3 = (rgba1 & 255 & 255) << 24 | (rgba1 >>> 24 & 255 & 255) << 16 | (rgba1 >>> 16 & 255 & 255) << 8 | rgba1 >>> 8 & 255 & 255;
					argb = argb3;
				}
			}
			this.buffer.__srcBitmapData.setPixel32(x + this.offsetX,y + this.offsetY,argb);
			break;
		default:
		}
	},
	setPixels: function(rect,bytePointer,format,endian) {
		rect = this.__clipRect(rect);
		if(this.buffer == null || rect == null) {
			return;
		}
		if(endian == null) {
			endian = (lime_system_Endian().default).BIG_ENDIAN;
		}
		switch(this.type._hx_index) {
		case 0:
			(lime__$internal_graphics_ImageCanvasUtil().default).setPixels(this,rect,bytePointer,format,endian);
			break;
		case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageDataUtil().default).setPixels(this,rect,bytePointer,format,endian);
			break;
		case 2:
			break;
		default:
		}
	},
	threshold: function(sourceImage,sourceRect,destPoint,operation,threshold,color,mask,copySource,format) {
		if(copySource == null) {
			copySource = false;
		}
		if(mask == null) {
			mask = -1;
		}
		if(color == null) {
			color = 0;
		}
		if(this.buffer == null || sourceImage == null || sourceRect == null) {
			return 0;
		}
		switch(this.type._hx_index) {
		case 0:case 1:
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(sourceImage);
			return (lime__$internal_graphics_ImageDataUtil().default).threshold(this,sourceImage,sourceRect,destPoint,operation,threshold,color,mask,copySource,format);
		case 2:
			var _color;
			if(format == null) {
				var rgba = color;
				var this1 = 0;
				var argb = this1;
				argb = (rgba & 255 & 255) << 24 | (rgba >>> 24 & 255 & 255) << 16 | (rgba >>> 16 & 255 & 255) << 8 | rgba >>> 8 & 255 & 255;
				_color = argb;
			} else {
				switch(format) {
				case 1:
					_color = color;
					break;
				case 2:
					var bgra = color;
					var this2 = 0;
					var argb1 = this2;
					argb1 = (bgra & 255 & 255) << 24 | (bgra >>> 8 & 255 & 255) << 16 | (bgra >>> 16 & 255 & 255) << 8 | bgra >>> 24 & 255 & 255;
					_color = argb1;
					break;
				default:
					var rgba1 = color;
					var this3 = 0;
					var argb2 = this3;
					argb2 = (rgba1 & 255 & 255) << 24 | (rgba1 >>> 24 & 255 & 255) << 16 | (rgba1 >>> 16 & 255 & 255) << 8 | rgba1 >>> 8 & 255 & 255;
					_color = argb2;
				}
			}
			var _mask;
			if(format == null) {
				var rgba2 = mask;
				var this4 = 0;
				var argb3 = this4;
				argb3 = (rgba2 & 255 & 255) << 24 | (rgba2 >>> 24 & 255 & 255) << 16 | (rgba2 >>> 16 & 255 & 255) << 8 | rgba2 >>> 8 & 255 & 255;
				_mask = argb3;
			} else {
				switch(format) {
				case 1:
					_mask = mask;
					break;
				case 2:
					var bgra1 = mask;
					var this5 = 0;
					var argb4 = this5;
					argb4 = (bgra1 & 255 & 255) << 24 | (bgra1 >>> 8 & 255 & 255) << 16 | (bgra1 >>> 16 & 255 & 255) << 8 | bgra1 >>> 24 & 255 & 255;
					_mask = argb4;
					break;
				default:
					var rgba3 = mask;
					var this6 = 0;
					var argb5 = this6;
					argb5 = (rgba3 & 255 & 255) << 24 | (rgba3 >>> 24 & 255 & 255) << 16 | (rgba3 >>> 16 & 255 & 255) << 8 | rgba3 >>> 8 & 255 & 255;
					_mask = argb5;
				}
			}
			sourceRect.offset(sourceImage.offsetX,sourceImage.offsetY);
			destPoint.offset(this.offsetX,this.offsetY);
			return this.buffer.__srcBitmapData.threshold(sourceImage.buffer.get_src(),sourceRect.__toFlashRectangle(),destPoint.__toFlashPoint(),operation,threshold,_color,_mask,copySource);
		default:
		}
		return 0;
	},
	__clipRect: function(r) {
		if(r == null) {
			return null;
		}
		if(r.x < 0) {
			r.width -= -r.x;
			r.x = 0;
			if(r.x + r.width <= 0) {
				return null;
			}
		}
		if(r.y < 0) {
			r.height -= -r.y;
			r.y = 0;
			if(r.y + r.height <= 0) {
				return null;
			}
		}
		if(r.x + r.width >= this.width) {
			r.width -= r.x + r.width - this.width;
			if(r.width <= 0) {
				return null;
			}
		}
		if(r.y + r.height >= this.height) {
			r.height -= r.y + r.height - this.height;
			if(r.height <= 0) {
				return null;
			}
		}
		return r;
	},
	__fromBase64: function(base64,type,onload) {
		var _gthis = this;
		var image = new window.Image ();
		var image_onLoaded = function(event) {
			_gthis.buffer = new (lime_graphics_ImageBuffer().default)(null,image.width,image.height);
			_gthis.buffer.__srcImage = image;
			_gthis.offsetX = 0;
			_gthis.offsetY = 0;
			_gthis.width = _gthis.buffer.width;
			_gthis.height = _gthis.buffer.height;
			if(onload != null) {
				onload(_gthis);
			}
		};
		image.addEventListener("load",image_onLoaded,false);
		image.src = "data:" + type + ";base64," + base64;
	},
	__fromBytes: function(bytes,onload) {
		var type = "";
		if(Image.__isPNG(bytes)) {
			type = "image/png";
		} else if(Image.__isJPG(bytes)) {
			type = "image/jpeg";
		} else if(Image.__isGIF(bytes)) {
			type = "image/gif";
		} else {
			return false;
		}
		this.__fromBase64((lime__$internal_format_Base64().default).encode(bytes),type,onload);
		return true;
	},
	__fromFile: function(path,onload,onerror) {
		var _gthis = this;
		var image = new window.Image ();
		if(!(lime__$internal_backend_html5_HTML5HTTPRequest().default).__isSameOrigin(path)) {
			image.crossOrigin = "Anonymous";
		}
		image.onload = function(_) {
			_gthis.buffer = new (lime_graphics_ImageBuffer().default)(null,image.width,image.height);
			_gthis.buffer.__srcImage = image;
			_gthis.width = image.width;
			_gthis.height = image.height;
			if(onload != null) {
				onload(_gthis);
			}
		};
		image.onerror = function(_1) {
			if(onerror != null) {
				onerror();
			}
		};
		image.src = path;
		var image1 = image.complete;
		return true;
	},
	__fromImageBuffer: function(buffer) {
		this.buffer = buffer;
		if(buffer != null) {
			if(this.width == -1) {
				this.width = buffer.width;
			}
			if(this.height == -1) {
				this.height = buffer.height;
			}
		}
	},
	get_data: function() {
		if(this.buffer.data == null && this.buffer.width > 0 && this.buffer.height > 0) {
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
		}
		return this.buffer.data;
	},
	set_data: function(value) {
		return this.buffer.data = value;
	},
	get_format: function() {
		return this.buffer.format;
	},
	set_format: function(value) {
		if(this.buffer.format != value) {
			if(this.type._hx_index == 1) {
				(lime__$internal_graphics_ImageDataUtil().default).setFormat(this,value);
			}
		}
		return this.buffer.format = value;
	},
	get_powerOfTwo: function() {
		if(this.buffer.width != 0 && (this.buffer.width & ~this.buffer.width + 1) == this.buffer.width) {
			if(this.buffer.height != 0) {
				return (this.buffer.height & ~this.buffer.height + 1) == this.buffer.height;
			} else {
				return false;
			}
		} else {
			return false;
		}
	},
	set_powerOfTwo: function(value) {
		if(value != this.get_powerOfTwo()) {
			var newWidth = 1;
			var newHeight = 1;
			while(newWidth < this.buffer.width) newWidth <<= 1;
			while(newHeight < this.buffer.height) newHeight <<= 1;
			if(newWidth == this.buffer.width && newHeight == this.buffer.height) {
				return value;
			}
			switch(this.type._hx_index) {
			case 0:
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
				(lime__$internal_graphics_ImageDataUtil().default).resizeBuffer(this,newWidth,newHeight);
				break;
			case 1:
				(lime__$internal_graphics_ImageDataUtil().default).resizeBuffer(this,newWidth,newHeight);
				break;
			case 2:
				break;
			default:
			}
		}
		return value;
	},
	get_premultiplied: function() {
		return this.buffer.premultiplied;
	},
	set_premultiplied: function(value) {
		if(value && !this.buffer.premultiplied) {
			switch(this.type._hx_index) {
			case 0:case 1:
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
				(lime__$internal_graphics_ImageDataUtil().default).multiplyAlpha(this);
				break;
			default:
			}
		} else if(!value && this.buffer.premultiplied) {
			if(this.type._hx_index == 1) {
				(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(this);
				(lime__$internal_graphics_ImageDataUtil().default).unmultiplyAlpha(this);
			}
		}
		return value;
	},
	get_rect: function() {
		return new (lime_math_Rectangle().default)(0,0,this.width,this.height);
	},
	get_src: function() {
		if(this.buffer.__srcCanvas == null && (this.buffer.data != null || this.type == (lime_graphics_ImageType().default).DATA)) {
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(this);
		}
		return this.buffer.get_src();
	},
	set_src: function(value) {
		return this.buffer.set_src(value);
	},
	get_transparent: function() {
		if(this.buffer == null) {
			return false;
		}
		return this.buffer.transparent;
	},
	set_transparent: function(value) {
		if(this.buffer == null) {
			return false;
		}
		return this.buffer.transparent = value;
	}
};
Image.prototype.__class__ = Image.prototype.constructor = $hxClasses["lime.graphics.Image"] = Image;

// Init

{
	var p = Image.prototype;
	Object.defineProperties(p,{ data : { get : p.get_data, set : p.set_data}, format : { get : p.get_format, set : p.set_format}, powerOfTwo : { get : p.get_powerOfTwo, set : p.set_powerOfTwo}, premultiplied : { get : p.get_premultiplied, set : p.set_premultiplied}, rect : { get : p.get_rect}, src : { get : p.get_src, set : p.set_src}, transparent : { get : p.get_transparent, set : p.set_transparent}});
};

// Statics

Image.fromBase64 = function(base64,type) {
	if(base64 == null) {
		return null;
	}
	var image = new Image();
	image.__fromBase64(base64,type);
	return image;
}
Image.fromBitmapData = function(bitmapData) {
	if(bitmapData == null) {
		return null;
	}
	return bitmapData.image;
}
Image.fromBytes = function(bytes) {
	if(bytes == null) {
		return null;
	}
	var image = new Image();
	if(image.__fromBytes(bytes)) {
		return image;
	} else {
		return null;
	}
}
Image.fromCanvas = function(canvas) {
	if(canvas == null) {
		return null;
	}
	var buffer = new (lime_graphics_ImageBuffer().default)(null,canvas.width,canvas.height);
	buffer.set_src(canvas);
	var image = new Image(buffer);
	image.type = (lime_graphics_ImageType().default).CANVAS;
	return image;
}
Image.fromFile = function(path) {
	if(path == null) {
		return null;
	}
	var image = new Image();
	if(image.__fromFile(path)) {
		return image;
	} else {
		return null;
	}
}
Image.fromImageElement = function(image) {
	if(image == null) {
		return null;
	}
	var buffer = new (lime_graphics_ImageBuffer().default)(null,image.width,image.height);
	buffer.set_src(image);
	var _image = new Image(buffer);
	_image.type = (lime_graphics_ImageType().default).CANVAS;
	return _image;
}
Image.loadFromBase64 = function(base64,type) {
	if(base64 == null || type == null) {
		return (lime_app_Future().default).withValue(null);
	}
	return (lime__$internal_backend_html5_HTML5HTTPRequest().default).loadImage("data:" + type + ";base64," + base64);
}
Image.loadFromBytes = function(bytes) {
	if(bytes == null) {
		return (lime_app_Future().default).withValue(null);
	}
	var type = "";
	if(Image.__isPNG(bytes)) {
		type = "image/png";
	} else if(Image.__isJPG(bytes)) {
		type = "image/jpeg";
	} else if(Image.__isGIF(bytes)) {
		type = "image/gif";
	} else if(Image.__isWebP(bytes)) {
		type = "image/webp";
	} else {
		return (lime_app_Future().default).withValue(null);
	}
	return (lime__$internal_backend_html5_HTML5HTTPRequest().default).loadImageFromBytes(bytes,type);
}
Image.loadFromFile = function(path) {
	if(path == null) {
		return (lime_app_Future().default).withValue(null);
	}
	return (lime__$internal_backend_html5_HTML5HTTPRequest().default).loadImage(path);
}
Image.__isGIF = function(bytes) {
	if(bytes == null || bytes.get_length() < 6) {
		return false;
	}
	var header = bytes.getString(0,6);
	if(header != "GIF87a") {
		return header == "GIF89a";
	} else {
		return true;
	}
}
Image.__isJPG = function(bytes) {
	if(bytes == null || bytes.get_length() < 4) {
		return false;
	}
	if(bytes.get(0) == 255 && bytes.get(1) == 216 && bytes.get(bytes.get_length() - 2) == 255) {
		return bytes.get(bytes.get_length() - 1) == 217;
	} else {
		return false;
	}
}
Image.__isPNG = function(bytes) {
	if(bytes == null || bytes.get_length() < 8) {
		return false;
	}
	if(bytes.get(0) == 137 && bytes.get(1) == 80 && bytes.get(2) == 78 && bytes.get(3) == 71 && bytes.get(4) == 13 && bytes.get(5) == 10 && bytes.get(6) == 26) {
		return bytes.get(7) == 10;
	} else {
		return false;
	}
}
Image.__isWebP = function(bytes) {
	if(bytes == null || bytes.get_length() < 16) {
		return false;
	}
	if(bytes.getString(0,4) == "RIFF") {
		return bytes.getString(8,4) == "WEBP";
	} else {
		return false;
	}
}


// Export

exports.default = Image;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/ImageBuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/ImageBuffer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.graphics.ImageBuffer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var ImageBuffer = function(data,width,height,bitsPerPixel,format) {
	if(bitsPerPixel == null) {
		bitsPerPixel = 32;
	}
	if(height == null) {
		height = 0;
	}
	if(width == null) {
		width = 0;
	}
	this.data = data;
	this.width = width;
	this.height = height;
	this.bitsPerPixel = bitsPerPixel;
	this.format = format == null ? 0 : format;
	this.premultiplied = false;
	this.transparent = true;
}

// Meta

ImageBuffer.__name__ = "lime.graphics.ImageBuffer";
ImageBuffer.__isInterface__ = false;
ImageBuffer.prototype = {
	clone: function() {
		var buffer = new ImageBuffer(this.data,this.width,this.height,this.bitsPerPixel);
		if(this.data != null) {
			var elements = this.data.byteLength;
			var array = null;
			var view = null;
			var buffer1 = null;
			var len = null;
			var this1;
			if(elements != null) {
				this1 = new Uint8Array(elements);
			} else if(array != null) {
				this1 = new Uint8Array(array);
			} else if(view != null) {
				this1 = new Uint8Array(view);
			} else if(buffer1 != null) {
				if(len == null) {
					this1 = new Uint8Array(buffer1,0);
				} else {
					this1 = new Uint8Array(buffer1,0,len);
				}
			} else {
				this1 = null;
			}
			buffer.data = this1;
			var elements1 = null;
			var array1 = null;
			var view1 = this.data;
			var buffer2 = null;
			var len1 = null;
			var this2;
			if(elements1 != null) {
				this2 = new Uint8Array(elements1);
			} else if(array1 != null) {
				this2 = new Uint8Array(array1);
			} else if(view1 != null) {
				this2 = new Uint8Array(view1);
			} else if(buffer2 != null) {
				if(len1 == null) {
					this2 = new Uint8Array(buffer2,0);
				} else {
					this2 = new Uint8Array(buffer2,0,len1);
				}
			} else {
				this2 = null;
			}
			var copy = this2;
			buffer.data.set(copy);
		} else if(this.__srcImageData != null) {
			buffer.__srcCanvas = window.document.createElement("canvas");
			buffer.__srcContext = buffer.__srcCanvas.getContext("2d");
			buffer.__srcCanvas.width = this.__srcImageData.width;
			buffer.__srcCanvas.height = this.__srcImageData.height;
			buffer.__srcImageData = buffer.__srcContext.createImageData(this.__srcImageData.width,this.__srcImageData.height);
			var copy1 = new Uint8ClampedArray(this.__srcImageData.data);
			buffer.__srcImageData.data.set(copy1);
		} else if(this.__srcCanvas != null) {
			buffer.__srcCanvas = window.document.createElement("canvas");
			buffer.__srcContext = buffer.__srcCanvas.getContext("2d");
			buffer.__srcCanvas.width = this.__srcCanvas.width;
			buffer.__srcCanvas.height = this.__srcCanvas.height;
			buffer.__srcContext.drawImage(this.__srcCanvas,0,0);
		} else {
			buffer.__srcImage = this.__srcImage;
		}
		buffer.bitsPerPixel = this.bitsPerPixel;
		buffer.format = this.format;
		buffer.premultiplied = this.premultiplied;
		buffer.transparent = this.transparent;
		return buffer;
	},
	get_src: function() {
		if(this.__srcImage != null) {
			return this.__srcImage;
		}
		return this.__srcCanvas;
	},
	set_src: function(value) {
		if(((value) instanceof Image)) {
			this.__srcImage = value;
		} else if(((value) instanceof HTMLCanvasElement)) {
			this.__srcCanvas = value;
			this.__srcContext = this.__srcCanvas.getContext("2d");
		}
		return value;
	},
	get_stride: function() {
		return this.width * (Std().default).int(this.bitsPerPixel / 8);
	}
};
ImageBuffer.prototype.__class__ = ImageBuffer.prototype.constructor = $hxClasses["lime.graphics.ImageBuffer"] = ImageBuffer;

// Init

{
	var p = ImageBuffer.prototype;
	Object.defineProperties(p,{ src : { get : p.get_src, set : p.set_src}, stride : { get : p.get_stride}});
};

// Statics




// Export

exports.default = ImageBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/ImageChannel.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/ImageChannel.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime.graphics.ImageChannel

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var ImageChannel = $hxEnums["lime.graphics.ImageChannel"] = { __ename__ : "lime.graphics.ImageChannel", __constructs__ : ["RED","GREEN","BLUE","ALPHA"]
  ,RED: {_hx_index:0,__enum__:"lime.graphics.ImageChannel",toString:$estr}
  ,GREEN: {_hx_index:1,__enum__:"lime.graphics.ImageChannel",toString:$estr}
  ,BLUE: {_hx_index:2,__enum__:"lime.graphics.ImageChannel",toString:$estr}
  ,ALPHA: {_hx_index:3,__enum__:"lime.graphics.ImageChannel",toString:$estr}
};

exports.default = ImageChannel;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/ImageFileFormat.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/ImageFileFormat.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime.graphics.ImageFileFormat

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var ImageFileFormat = $hxEnums["lime.graphics.ImageFileFormat"] = { __ename__ : "lime.graphics.ImageFileFormat", __constructs__ : ["BMP","JPEG","PNG"]
  ,PNG: {_hx_index:2,__enum__:"lime.graphics.ImageFileFormat",toString:$estr}
  ,JPEG: {_hx_index:1,__enum__:"lime.graphics.ImageFileFormat",toString:$estr}
  ,BMP: {_hx_index:0,__enum__:"lime.graphics.ImageFileFormat",toString:$estr}
};

exports.default = ImageFileFormat;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/ImageType.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/ImageType.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime.graphics.ImageType

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var ImageType = $hxEnums["lime.graphics.ImageType"] = { __ename__ : "lime.graphics.ImageType", __constructs__ : ["CANVAS","DATA","FLASH","CUSTOM"]
  ,FLASH: {_hx_index:2,__enum__:"lime.graphics.ImageType",toString:$estr}
  ,DATA: {_hx_index:1,__enum__:"lime.graphics.ImageType",toString:$estr}
  ,CUSTOM: {_hx_index:3,__enum__:"lime.graphics.ImageType",toString:$estr}
  ,CANVAS: {_hx_index:0,__enum__:"lime.graphics.ImageType",toString:$estr}
};

exports.default = ImageType;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/RenderContext.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/RenderContext.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.graphics.RenderContext

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var RenderContext = function() {
}

// Meta

RenderContext.__name__ = "lime.graphics.RenderContext";
RenderContext.__isInterface__ = false;
RenderContext.prototype = {
	
};
RenderContext.prototype.__class__ = RenderContext.prototype.constructor = $hxClasses["lime.graphics.RenderContext"] = RenderContext;

// Init



// Statics




// Export

exports.default = RenderContext;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.graphics._WebGL2RenderContext.WebGL2RenderContext_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var WebGL2RenderContext_Impl_ = function(){}

// Meta

WebGL2RenderContext_Impl_.__name__ = "lime.graphics._WebGL2RenderContext.WebGL2RenderContext_Impl_";
WebGL2RenderContext_Impl_.__isInterface__ = false;
WebGL2RenderContext_Impl_.prototype = {
	
};
WebGL2RenderContext_Impl_.prototype.__class__ = WebGL2RenderContext_Impl_.prototype.constructor = $hxClasses["lime.graphics._WebGL2RenderContext.WebGL2RenderContext_Impl_"] = WebGL2RenderContext_Impl_;

// Init



// Statics

WebGL2RenderContext_Impl_.bufferData = function(this1,target,srcData,usage,srcOffset,length) {
	if(srcOffset != null) {
		this1.bufferData(target,srcData,usage,srcOffset,length);
	} else {
		this1.bufferData(target,srcData,usage);
	}
}
WebGL2RenderContext_Impl_.bufferSubData = function(this1,target,dstByteOffset,srcData,srcOffset,length) {
	if(srcOffset != null) {
		this1.bufferSubData(target,dstByteOffset,srcData,srcOffset,length);
	} else {
		this1.bufferSubData(target,dstByteOffset,srcData);
	}
}
WebGL2RenderContext_Impl_.compressedTexImage2D = function(this1,target,level,internalformat,width,height,border,srcData,srcOffset,srcLengthOverride) {
	if(srcOffset != null) {
		this1.compressedTexImage2D(target,level,internalformat,width,height,border,srcData,srcOffset,srcLengthOverride);
	} else {
		this1.compressedTexImage2D(target,level,internalformat,width,height,border,srcData);
	}
}
WebGL2RenderContext_Impl_.compressedTexSubImage2D = function(this1,target,level,xoffset,yoffset,width,height,format,srcData,srcOffset,srcLengthOverride) {
	if(srcOffset != null) {
		this1.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,srcData,srcOffset,srcLengthOverride);
	} else {
		this1.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,srcData);
	}
}
WebGL2RenderContext_Impl_.getBufferSubData = function(this1,target,srcByteOffset,dstData,srcOffset,length) {
	if(srcOffset != null) {
		this1.getBufferSubData(target,srcByteOffset,dstData,srcOffset,length);
	} else {
		this1.getBufferSubData(target,srcByteOffset,dstData);
	}
}
WebGL2RenderContext_Impl_.readPixels = function(this1,x,y,width,height,format,type,pixels,dstOffset) {
	if(dstOffset != null) {
		this1.readPixels(x,y,width,height,format,type,pixels,dstOffset);
	} else {
		this1.readPixels(x,y,width,height,format,type,pixels);
	}
}
WebGL2RenderContext_Impl_.texImage2D = function(this1,target,level,internalformat,width,height,border,format,type,srcData,srcOffset) {
	if(srcOffset != null) {
		this1.texImage2D(target,level,internalformat,width,height,border,format,type,srcData,srcOffset);
	} else if(format != null) {
		this1.texImage2D(target,level,internalformat,width,height,border,format,type,srcData);
	} else {
		this1.texImage2D(target,level,internalformat,width,height,border);
	}
}
WebGL2RenderContext_Impl_.texSubImage2D = function(this1,target,level,xoffset,yoffset,width,height,format,type,srcData,srcOffset) {
	if(srcOffset != null) {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,srcData,srcOffset);
	} else if(type != null) {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,srcData);
	} else {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format);
	}
}
WebGL2RenderContext_Impl_.uniform1fv = function(this1,location,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniform1fv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform1fv(location,data);
	}
}
WebGL2RenderContext_Impl_.uniform1iv = function(this1,location,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniform1iv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform1iv(location,data);
	}
}
WebGL2RenderContext_Impl_.uniform2fv = function(this1,location,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniform2fv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform2fv(location,data);
	}
}
WebGL2RenderContext_Impl_.uniform2iv = function(this1,location,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniform2iv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform2iv(location,data);
	}
}
WebGL2RenderContext_Impl_.uniform3fv = function(this1,location,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniform3fv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform3fv(location,data);
	}
}
WebGL2RenderContext_Impl_.uniform3iv = function(this1,location,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniform3iv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform3iv(location,data);
	}
}
WebGL2RenderContext_Impl_.uniform4fv = function(this1,location,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniform4fv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform4fv(location,data);
	}
}
WebGL2RenderContext_Impl_.uniform4iv = function(this1,location,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniform4iv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform4iv(location,data);
	}
}
WebGL2RenderContext_Impl_.uniformMatrix2fv = function(this1,location,transpose,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniformMatrix2fv(location,transpose,data,srcOffset,srcLength);
	} else {
		this1.uniformMatrix2fv(location,transpose,data);
	}
}
WebGL2RenderContext_Impl_.uniformMatrix3fv = function(this1,location,transpose,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniformMatrix3fv(location,transpose,data,srcOffset,srcLength);
	} else {
		this1.uniformMatrix3fv(location,transpose,data);
	}
}
WebGL2RenderContext_Impl_.uniformMatrix4fv = function(this1,location,transpose,data,srcOffset,srcLength) {
	if(srcOffset != null) {
		this1.uniformMatrix4fv(location,transpose,data,srcOffset,srcLength);
	} else {
		this1.uniformMatrix4fv(location,transpose,data);
	}
}
WebGL2RenderContext_Impl_.fromGL = function(gl) {
	return null;
}
WebGL2RenderContext_Impl_.fromRenderContext = function(context) {
	return context.webgl2;
}
WebGL2RenderContext_Impl_.toWebGLRenderContext = function(gl) {
	return gl;
}


// Export

exports.default = WebGL2RenderContext_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.graphics._WebGLRenderContext.WebGLRenderContext_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_graphics_opengl_GL() {return __webpack_require__(/*! ./../../../lime/graphics/opengl/GL */ "./node_modules/openfl/lib/_gen/lime/graphics/opengl/GL.js");}

// Constructor

var WebGLRenderContext_Impl_ = function(){}

// Meta

WebGLRenderContext_Impl_.__name__ = "lime.graphics._WebGLRenderContext.WebGLRenderContext_Impl_";
WebGLRenderContext_Impl_.__isInterface__ = false;
WebGLRenderContext_Impl_.prototype = {
	
};
WebGLRenderContext_Impl_.prototype.__class__ = WebGLRenderContext_Impl_.prototype.constructor = $hxClasses["lime.graphics._WebGLRenderContext.WebGLRenderContext_Impl_"] = WebGLRenderContext_Impl_;

// Init



// Statics

WebGLRenderContext_Impl_.bufferData = function(this1,target,srcData,usage) {
	var srcOffset = null;
	if(srcOffset != null) {
		this1.bufferData(target,srcData,usage,srcOffset,null);
	} else {
		this1.bufferData(target,srcData,usage);
	}
}
WebGLRenderContext_Impl_.bufferSubData = function(this1,target,offset,srcData) {
	var srcOffset = null;
	if(srcOffset != null) {
		this1.bufferSubData(target,offset,srcData,srcOffset,null);
	} else {
		this1.bufferSubData(target,offset,srcData);
	}
}
WebGLRenderContext_Impl_.compressedTexImage2D = function(this1,target,level,internalformat,width,height,border,srcData) {
	var srcOffset = null;
	if(srcOffset != null) {
		this1.compressedTexImage2D(target,level,internalformat,width,height,border,srcData,srcOffset,null);
	} else {
		this1.compressedTexImage2D(target,level,internalformat,width,height,border,srcData);
	}
}
WebGLRenderContext_Impl_.compressedTexSubImage2D = function(this1,target,level,xoffset,yoffset,width,height,format,srcData) {
	var srcOffset = null;
	if(srcOffset != null) {
		this1.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,srcData,srcOffset,null);
	} else {
		this1.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,srcData);
	}
}
WebGLRenderContext_Impl_.readPixels = function(this1,x,y,width,height,format,type,pixels) {
	var dstOffset = null;
	if(dstOffset != null) {
		this1.readPixels(x,y,width,height,format,type,pixels,dstOffset);
	} else {
		this1.readPixels(x,y,width,height,format,type,pixels);
	}
}
WebGLRenderContext_Impl_.texImage2D = function(this1,target,level,internalformat,width,height,border,format,type,srcData) {
	var srcOffset = null;
	if(srcOffset != null) {
		this1.texImage2D(target,level,internalformat,width,height,border,format,type,srcData,srcOffset);
	} else if(format != null) {
		this1.texImage2D(target,level,internalformat,width,height,border,format,type,srcData);
	} else {
		this1.texImage2D(target,level,internalformat,width,height,border);
	}
}
WebGLRenderContext_Impl_.texSubImage2D = function(this1,target,level,xoffset,yoffset,width,height,format,type,srcData) {
	var srcOffset = null;
	if(srcOffset != null) {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,srcData,srcOffset);
	} else if(type != null) {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,srcData);
	} else {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format);
	}
}
WebGLRenderContext_Impl_.uniformMatrix2fv = function(this1,location,transpose,v) {
	var data = v;
	var srcOffset = null;
	if(srcOffset != null) {
		this1.uniformMatrix2fv(location,transpose,data,srcOffset,null);
	} else {
		this1.uniformMatrix2fv(location,transpose,data);
	}
}
WebGLRenderContext_Impl_.uniformMatrix3fv = function(this1,location,transpose,v) {
	var data = v;
	var srcOffset = null;
	if(srcOffset != null) {
		this1.uniformMatrix3fv(location,transpose,data,srcOffset,null);
	} else {
		this1.uniformMatrix3fv(location,transpose,data);
	}
}
WebGLRenderContext_Impl_.uniformMatrix4fv = function(this1,location,transpose,v) {
	var data = v;
	var srcOffset = null;
	if(srcOffset != null) {
		this1.uniformMatrix4fv(location,transpose,data,srcOffset,null);
	} else {
		this1.uniformMatrix4fv(location,transpose,data);
	}
}
WebGLRenderContext_Impl_.fromWebGL2RenderContext = function(gl) {
	return gl;
}
WebGLRenderContext_Impl_.fromRenderContext = function(context) {
	return context.webgl;
}
WebGLRenderContext_Impl_.fromGL = function(gl) {
	return (lime_graphics_opengl_GL().default).context;
}


// Export

exports.default = WebGLRenderContext_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/cairo/_CairoImageSurface/CairoImageSurface_Impl_.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/cairo/_CairoImageSurface/CairoImageSurface_Impl_.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.graphics.cairo._CairoImageSurface.CairoImageSurface_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_utils__$DataPointer_DataPointer_$Impl_$() {return __webpack_require__(/*! ./../../../../lime/utils/_DataPointer/DataPointer_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_DataPointer/DataPointer_Impl_.js");}

// Constructor

var CairoImageSurface_Impl_ = function(){}

// Meta

CairoImageSurface_Impl_.__name__ = "lime.graphics.cairo._CairoImageSurface.CairoImageSurface_Impl_";
CairoImageSurface_Impl_.__isInterface__ = false;
CairoImageSurface_Impl_.prototype = {
	
};
CairoImageSurface_Impl_.prototype.__class__ = CairoImageSurface_Impl_.prototype.constructor = $hxClasses["lime.graphics.cairo._CairoImageSurface.CairoImageSurface_Impl_"] = CairoImageSurface_Impl_;

// Init



// Statics

CairoImageSurface_Impl_._new = function(format,width,height) {
	var this1 = 0;
	return this1;
}
CairoImageSurface_Impl_.create = function(data,format,width,height,stride) {
	return 0;
}
CairoImageSurface_Impl_.fromImage = function(image) {
	return null;
}
CairoImageSurface_Impl_.get_data = function(this1) {
	return (lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromFloat(0);
}
CairoImageSurface_Impl_.get_format = function(this1) {
	return 0;
}
CairoImageSurface_Impl_.get_height = function(this1) {
	return 0;
}
CairoImageSurface_Impl_.get_stride = function(this1) {
	return 0;
}
CairoImageSurface_Impl_.get_width = function(this1) {
	return 0;
}


// Export

exports.default = CairoImageSurface_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/cairo/_CairoSurface/CairoSurface_Impl_.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/cairo/_CairoSurface/CairoSurface_Impl_.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.graphics.cairo._CairoSurface.CairoSurface_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var CairoSurface_Impl_ = function(){}

// Meta

CairoSurface_Impl_.__name__ = "lime.graphics.cairo._CairoSurface.CairoSurface_Impl_";
CairoSurface_Impl_.__isInterface__ = false;
CairoSurface_Impl_.prototype = {
	
};
CairoSurface_Impl_.prototype.__class__ = CairoSurface_Impl_.prototype.constructor = $hxClasses["lime.graphics.cairo._CairoSurface.CairoSurface_Impl_"] = CairoSurface_Impl_;

// Init



// Statics

CairoSurface_Impl_.flush = function(this1) {
}


// Export

exports.default = CairoSurface_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/graphics/opengl/GL.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/graphics/opengl/GL.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.graphics.opengl.GL

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_utils__$DataPointer_DataPointer_$Impl_$() {return __webpack_require__(/*! ./../../../lime/utils/_DataPointer/DataPointer_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_DataPointer/DataPointer_Impl_.js");}
function lime_graphics__$WebGL2RenderContext_WebGL2RenderContext_$Impl_$() {return __webpack_require__(/*! ./../../../lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_.js");}

// Constructor

var GL = function(){}

// Meta

GL.__name__ = "lime.graphics.opengl.GL";
GL.__isInterface__ = false;
GL.prototype = {
	
};
GL.prototype.__class__ = GL.prototype.constructor = $hxClasses["lime.graphics.opengl.GL"] = GL;

// Init



// Statics

GL.activeTexture = function(texture) {
	GL.context.activeTexture(texture);
}
GL.attachShader = function(program,shader) {
	GL.context.attachShader(program,shader);
}
GL.beginQuery = function(target,query) {
	GL.context.beginQuery(target,query);
}
GL.beginTransformFeedback = function(primitiveNode) {
	GL.context.beginTransformFeedback(primitiveNode);
}
GL.bindAttribLocation = function(program,index,name) {
	GL.context.bindAttribLocation(program,index,name);
}
GL.bindBuffer = function(target,buffer) {
	GL.context.bindBuffer(target,buffer);
}
GL.bindBufferBase = function(target,index,buffer) {
	GL.context.bindBufferBase(target,index,buffer);
}
GL.bindBufferRange = function(target,index,buffer,offset,size) {
	GL.context.bindBufferRange(target,index,buffer,offset,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromFloat(size));
}
GL.bindFramebuffer = function(target,framebuffer) {
	GL.context.bindFramebuffer(target,framebuffer);
}
GL.bindRenderbuffer = function(target,renderbuffer) {
	GL.context.bindRenderbuffer(target,renderbuffer);
}
GL.bindSampler = function(unit,sampler) {
	GL.context.bindSampler(unit,sampler);
}
GL.bindTexture = function(target,texture) {
	GL.context.bindTexture(target,texture);
}
GL.bindTransformFeedback = function(target,transformFeedback) {
	GL.context.bindTransformFeedback(target,transformFeedback);
}
GL.bindVertexArray = function(vertexArray) {
	GL.context.bindVertexArray(vertexArray);
}
GL.blitFramebuffer = function(srcX0,srcY0,srcX1,srcY1,dstX0,dstY0,dstX1,dstY1,mask,filter) {
	GL.context.blitFramebuffer(srcX0,srcY0,srcX1,srcY1,dstX0,dstY0,dstX1,dstY1,mask,filter);
}
GL.blendColor = function(red,green,blue,alpha) {
	GL.context.blendColor(red,green,blue,alpha);
}
GL.blendEquation = function(mode) {
	GL.context.blendEquation(mode);
}
GL.blendEquationSeparate = function(modeRGB,modeAlpha) {
	GL.context.blendEquationSeparate(modeRGB,modeAlpha);
}
GL.blendFunc = function(sfactor,dfactor) {
	GL.context.blendFunc(sfactor,dfactor);
}
GL.blendFuncSeparate = function(srcRGB,dstRGB,srcAlpha,dstAlpha) {
	GL.context.blendFuncSeparate(srcRGB,dstRGB,srcAlpha,dstAlpha);
}
GL.bufferDataWEBGL = function(target,srcData,usage,srcOffset,length) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.bufferData(target,srcData,usage,srcOffset,length);
	} else {
		this1.bufferData(target,srcData,usage);
	}
}
GL.bufferSubDataWEBGL = function(target,dstByteOffset,srcData,srcOffset,length) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.bufferSubData(target,dstByteOffset,srcData,srcOffset,length);
	} else {
		this1.bufferSubData(target,dstByteOffset,srcData);
	}
}
GL.checkFramebufferStatus = function(target) {
	return GL.context.checkFramebufferStatus(target);
}
GL.clear = function(mask) {
	GL.context.clear(mask);
}
GL.clearBufferfi = function(buffer,drawbuffer,depth,stencil) {
	GL.context.clearBufferfi(buffer,drawbuffer,depth,stencil);
}
GL.clearBufferfvWEBGL = function(buffer,drawbuffer,values,srcOffset) {
	GL.context.clearBufferfv(buffer,drawbuffer,values,srcOffset);
}
GL.clearBufferivWEBGL = function(buffer,drawbuffer,values,srcOffset) {
	GL.context.clearBufferiv(buffer,drawbuffer,values,srcOffset);
}
GL.clearBufferuivWEBGL = function(buffer,drawbuffer,values,srcOffset) {
	GL.context.clearBufferuiv(buffer,drawbuffer,values,srcOffset);
}
GL.clearColor = function(red,green,blue,alpha) {
	GL.context.clearColor(red,green,blue,alpha);
}
GL.clearDepth = function(depth) {
	GL.context.clearDepth(depth);
}
GL.clearStencil = function(s) {
	GL.context.clearStencil(s);
}
GL.clientWaitSync = function(sync,flags,timeout) {
	return GL.context.clientWaitSync(sync,flags,timeout);
}
GL.colorMask = function(red,green,blue,alpha) {
	GL.context.colorMask(red,green,blue,alpha);
}
GL.compileShader = function(shader) {
	GL.context.compileShader(shader);
}
GL.compressedTexImage2DWEBGL = function(target,level,internalformat,width,height,border,srcData,srcOffset,srcLengthOverride) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.compressedTexImage2D(target,level,internalformat,width,height,border,srcData,srcOffset,srcLengthOverride);
	} else {
		this1.compressedTexImage2D(target,level,internalformat,width,height,border,srcData);
	}
}
GL.compressedTexImage3DWEBGL = function(target,level,internalformat,width,height,depth,border,srcData,srcOffset,srcLengthOverride) {
	GL.context.compressedTexImage3D(target,level,internalformat,width,height,depth,border,srcData,srcOffset,srcLengthOverride);
}
GL.compressedTexSubImage2DWEBGL = function(target,level,xoffset,yoffset,width,height,format,srcData,srcOffset,srcLengthOverride) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,srcData,srcOffset,srcLengthOverride);
	} else {
		this1.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,srcData);
	}
}
GL.compressedTexSubImage3DWEBGL = function(target,level,xoffset,yoffset,zoffset,width,height,depth,format,srcData,srcOffset,srcLengthOverride) {
	GL.context.compressedTexSubImage3D(target,level,xoffset,yoffset,zoffset,width,height,depth,format,srcData,srcOffset,srcLengthOverride);
}
GL.copyTexImage2D = function(target,level,internalformat,x,y,width,height,border) {
	GL.context.copyTexImage2D(target,level,internalformat,x,y,width,height,border);
}
GL.copyTexSubImage2D = function(target,level,xoffset,yoffset,x,y,width,height) {
	GL.context.copyTexSubImage2D(target,level,xoffset,yoffset,x,y,width,height);
}
GL.copyTexSubImage3D = function(target,level,xoffset,yoffset,zoffset,x,y,width,height) {
	GL.context.copyTexSubImage3D(target,level,xoffset,yoffset,zoffset,x,y,width,height);
}
GL.createBuffer = function() {
	return GL.context.createBuffer();
}
GL.createFramebuffer = function() {
	return GL.context.createFramebuffer();
}
GL.createProgram = function() {
	return GL.context.createProgram();
}
GL.createQuery = function() {
	return GL.context.createQuery();
}
GL.createRenderbuffer = function() {
	return GL.context.createRenderbuffer();
}
GL.createSampler = function() {
	return GL.context.createSampler();
}
GL.createShader = function(type) {
	return GL.context.createShader(type);
}
GL.createTexture = function() {
	return GL.context.createTexture();
}
GL.createTransformFeedback = function() {
	return GL.context.createTransformFeedback();
}
GL.createVertexArray = function() {
	return GL.context.createVertexArray();
}
GL.cullFace = function(mode) {
	GL.context.cullFace(mode);
}
GL.deleteBuffer = function(buffer) {
	GL.context.deleteBuffer(buffer);
}
GL.deleteFramebuffer = function(framebuffer) {
	GL.context.deleteFramebuffer(framebuffer);
}
GL.deleteProgram = function(program) {
	GL.context.deleteProgram(program);
}
GL.deleteQuery = function(query) {
	GL.context.deleteQuery(query);
}
GL.deleteRenderbuffer = function(renderbuffer) {
	GL.context.deleteRenderbuffer(renderbuffer);
}
GL.deleteSampler = function(sampler) {
	GL.context.deleteSampler(sampler);
}
GL.deleteShader = function(shader) {
	GL.context.deleteShader(shader);
}
GL.deleteSync = function(sync) {
	GL.context.deleteSync(sync);
}
GL.deleteTexture = function(texture) {
	GL.context.deleteTexture(texture);
}
GL.deleteTransformFeedback = function(transformFeedback) {
	GL.context.deleteTransformFeedback(transformFeedback);
}
GL.deleteVertexArray = function(vertexArray) {
	GL.context.deleteVertexArray(vertexArray);
}
GL.depthFunc = function(func) {
	GL.context.depthFunc(func);
}
GL.depthMask = function(flag) {
	GL.context.depthMask(flag);
}
GL.depthRange = function(zNear,zFar) {
	GL.context.depthRange(zNear,zFar);
}
GL.detachShader = function(program,shader) {
	GL.context.detachShader(program,shader);
}
GL.disable = function(cap) {
	GL.context.disable(cap);
}
GL.disableVertexAttribArray = function(index) {
	GL.context.disableVertexAttribArray(index);
}
GL.drawArrays = function(mode,first,count) {
	GL.context.drawArrays(mode,first,count);
}
GL.drawArraysInstanced = function(mode,first,count,instanceCount) {
	GL.context.drawArraysInstanced(mode,first,count,instanceCount);
}
GL.drawBuffers = function(buffers) {
	GL.context.drawBuffers(buffers);
}
GL.drawElements = function(mode,count,type,offset) {
	GL.context.drawElements(mode,count,type,offset);
}
GL.drawElementsInstanced = function(mode,count,type,offset,instanceCount) {
	GL.context.drawElementsInstanced(mode,count,type,offset,instanceCount);
}
GL.drawRangeElements = function(mode,start,end,count,type,offset) {
	GL.context.drawRangeElements(mode,start,end,count,type,offset);
}
GL.enable = function(cap) {
	GL.context.enable(cap);
}
GL.enableVertexAttribArray = function(index) {
	GL.context.enableVertexAttribArray(index);
}
GL.endQuery = function(target) {
	GL.context.endQuery(target);
}
GL.endTransformFeedback = function() {
	GL.context.endTransformFeedback();
}
GL.fenceSync = function(condition,flags) {
	return GL.context.fenceSync(condition,flags);
}
GL.finish = function() {
	GL.context.finish();
}
GL.flush = function() {
	GL.context.flush();
}
GL.framebufferRenderbuffer = function(target,attachment,renderbuffertarget,renderbuffer) {
	GL.context.framebufferRenderbuffer(target,attachment,renderbuffertarget,renderbuffer);
}
GL.framebufferTexture2D = function(target,attachment,textarget,texture,level) {
	GL.context.framebufferTexture2D(target,attachment,textarget,texture,level);
}
GL.framebufferTextureLayer = function(target,attachment,texture,level,layer) {
	GL.context.framebufferTextureLayer(target,attachment,texture,level,layer);
}
GL.frontFace = function(mode) {
	GL.context.frontFace(mode);
}
GL.generateMipmap = function(target) {
	GL.context.generateMipmap(target);
}
GL.getActiveAttrib = function(program,index) {
	return GL.context.getActiveAttrib(program,index);
}
GL.getActiveUniform = function(program,index) {
	return GL.context.getActiveUniform(program,index);
}
GL.getActiveUniformBlockName = function(program,uniformBlockIndex) {
	return GL.context.getActiveUniformBlockName(program,uniformBlockIndex);
}
GL.getActiveUniformBlockParameter = function(program,uniformBlockIndex,pname) {
	return GL.context.getActiveUniformBlockParameter(program,uniformBlockIndex,pname);
}
GL.getActiveUniforms = function(program,uniformIndices,pname) {
	return GL.context.getActiveUniforms(program,uniformIndices,pname);
}
GL.getAttachedShaders = function(program) {
	return GL.context.getAttachedShaders(program);
}
GL.getAttribLocation = function(program,name) {
	return GL.context.getAttribLocation(program,name);
}
GL.getBufferParameter = function(target,pname) {
	return GL.context.getBufferParameter(target,pname);
}
GL.getBufferSubDataWEBGL = function(target,srcByteOffset,dstData,srcOffset,length) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.getBufferSubData(target,srcByteOffset,dstData,srcOffset,length);
	} else {
		this1.getBufferSubData(target,srcByteOffset,dstData);
	}
}
GL.getContextAttributes = function() {
	return GL.context.getContextAttributes();
}
GL.getError = function() {
	return GL.context.getError();
}
GL.getExtension = function(name) {
	return GL.context.getExtension(name);
}
GL.getFragDataLocation = function(program,name) {
	return GL.context.getFragDataLocation(program,name);
}
GL.getFramebufferAttachmentParameter = function(target,attachment,pname) {
	return GL.context.getFramebufferAttachmentParameter(target,attachment,pname);
}
GL.getIndexedParameter = function(target,index) {
	return GL.context.getIndexedParameter(target,index);
}
GL.getInternalformatParameter = function(target,internalformat,pname) {
	return GL.context.getInternalformatParameter(target,internalformat,pname);
}
GL.getParameter = function(pname) {
	return GL.context.getParameter(pname);
}
GL.getProgramInfoLog = function(program) {
	return GL.context.getProgramInfoLog(program);
}
GL.getProgramParameter = function(program,pname) {
	return GL.context.getProgramParameter(program,pname);
}
GL.getQuery = function(target,pname) {
	return GL.context.getQuery(target,pname);
}
GL.getQueryParameter = function(query,pname) {
	return GL.context.getQueryParameter(query,pname);
}
GL.getRenderbufferParameter = function(target,pname) {
	return GL.context.getRenderbufferParameter(target,pname);
}
GL.getSamplerParameter = function(sampler,pname) {
	return GL.context.getSamplerParameter(sampler,pname);
}
GL.getShaderInfoLog = function(shader) {
	return GL.context.getShaderInfoLog(shader);
}
GL.getShaderParameter = function(shader,pname) {
	return GL.context.getShaderParameter(shader,pname);
}
GL.getShaderPrecisionFormat = function(shadertype,precisiontype) {
	return GL.context.getShaderPrecisionFormat(shadertype,precisiontype);
}
GL.getShaderSource = function(shader) {
	return GL.context.getShaderSource(shader);
}
GL.getSupportedExtensions = function() {
	return GL.context.getSupportedExtensions();
}
GL.getSyncParameter = function(sync,pname) {
	return GL.context.getSyncParameter(sync,pname);
}
GL.getTexParameter = function(target,pname) {
	return GL.context.getTexParameter(target,pname);
}
GL.getTransformFeedbackVarying = function(program,index) {
	return GL.context.getTransformFeedbackVarying(program,index);
}
GL.getUniform = function(program,location) {
	return GL.context.getUniform(program,location);
}
GL.getUniformBlockIndex = function(program,uniformBlockName) {
	return GL.context.getUniformBlockIndex(program,uniformBlockName);
}
GL.getUniformIndices = function(program,uniformNames) {
	return GL.context.getUniformIndices(program,uniformNames);
}
GL.getUniformLocation = function(program,name) {
	return GL.context.getUniformLocation(program,name);
}
GL.getVertexAttrib = function(index,pname) {
	return GL.context.getVertexAttrib(index,pname);
}
GL.getVertexAttribOffset = function(index,pname) {
	return (lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromFloat(GL.context.getVertexAttribOffset(index,pname));
}
GL.hint = function(target,mode) {
	GL.context.hint(target,mode);
}
GL.invalidateFramebuffer = function(target,attachments) {
	GL.context.invalidateFramebuffer(target,attachments);
}
GL.invalidateSubFramebuffer = function(target,attachments,x,y,width,height) {
	GL.context.invalidateSubFramebuffer(target,attachments,x,y,width,height);
}
GL.isBuffer = function(buffer) {
	return GL.context.isBuffer(buffer);
}
GL.isContextLost = function() {
	return GL.context.isContextLost();
}
GL.isEnabled = function(cap) {
	return GL.context.isEnabled(cap);
}
GL.isFramebuffer = function(framebuffer) {
	return GL.context.isFramebuffer(framebuffer);
}
GL.isProgram = function(program) {
	return GL.context.isProgram(program);
}
GL.isQuery = function(query) {
	return GL.context.isQuery(query);
}
GL.isRenderbuffer = function(renderbuffer) {
	return GL.context.isRenderbuffer(renderbuffer);
}
GL.isSampler = function(sampler) {
	return GL.context.isSampler(sampler);
}
GL.isShader = function(shader) {
	return GL.context.isShader(shader);
}
GL.isSync = function(sync) {
	return GL.context.isSync(sync);
}
GL.isTexture = function(texture) {
	return GL.context.isTexture(texture);
}
GL.isTransformFeedback = function(transformFeedback) {
	return GL.context.isTransformFeedback(transformFeedback);
}
GL.isVertexArray = function(vertexArray) {
	return GL.context.isVertexArray(vertexArray);
}
GL.lineWidth = function(width) {
	GL.context.lineWidth(width);
}
GL.linkProgram = function(program) {
	GL.context.linkProgram(program);
}
GL.pauseTransformFeedback = function() {
	GL.context.pauseTransformFeedback();
}
GL.pixelStorei = function(pname,param) {
	GL.context.pixelStorei(pname,param);
}
GL.polygonOffset = function(factor,units) {
	GL.context.polygonOffset(factor,units);
}
GL.readBuffer = function(src) {
	GL.context.readBuffer(src);
}
GL.readPixelsWEBGL = function(x,y,width,height,format,type,pixels,dstOffset) {
	var this1 = GL.context;
	if(dstOffset != null) {
		this1.readPixels(x,y,width,height,format,type,pixels,dstOffset);
	} else {
		this1.readPixels(x,y,width,height,format,type,pixels);
	}
}
GL.renderbufferStorage = function(target,internalformat,width,height) {
	GL.context.renderbufferStorage(target,internalformat,width,height);
}
GL.renderbufferStorageMultisample = function(target,samples,internalformat,width,height) {
	GL.context.renderbufferStorageMultisample(target,samples,internalformat,width,height);
}
GL.resumeTransformFeedback = function() {
	GL.context.resumeTransformFeedback();
}
GL.sampleCoverage = function(value,invert) {
	GL.context.sampleCoverage(value,invert);
}
GL.samplerParameterf = function(sampler,pname,param) {
	GL.context.samplerParameterf(sampler,pname,param);
}
GL.samplerParameteri = function(sampler,pname,param) {
	GL.context.samplerParameteri(sampler,pname,param);
}
GL.scissor = function(x,y,width,height) {
	GL.context.scissor(x,y,width,height);
}
GL.shaderSource = function(shader,source) {
	GL.context.shaderSource(shader,source);
}
GL.stencilFunc = function(func,ref,mask) {
	GL.context.stencilFunc(func,ref,mask);
}
GL.stencilFuncSeparate = function(face,func,ref,mask) {
	GL.context.stencilFuncSeparate(face,func,ref,mask);
}
GL.stencilMask = function(mask) {
	GL.context.stencilMask(mask);
}
GL.stencilMaskSeparate = function(face,mask) {
	GL.context.stencilMaskSeparate(face,mask);
}
GL.stencilOp = function(fail,zfail,zpass) {
	GL.context.stencilOp(fail,zfail,zpass);
}
GL.stencilOpSeparate = function(face,fail,zfail,zpass) {
	GL.context.stencilOpSeparate(face,fail,zfail,zpass);
}
GL.texImage2DWEBGL = function(target,level,internalformat,width,height,border,format,type,srcData,srcOffset) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.texImage2D(target,level,internalformat,width,height,border,format,type,srcData,srcOffset);
	} else if(format != null) {
		this1.texImage2D(target,level,internalformat,width,height,border,format,type,srcData);
	} else {
		this1.texImage2D(target,level,internalformat,width,height,border);
	}
}
GL.texImage3DWEBGL = function(target,level,internalformat,width,height,depth,border,format,type,srcData,srcOffset) {
	GL.context.texImage3D(target,level,internalformat,width,height,depth,border,format,type,srcData,srcOffset);
}
GL.texStorage2D = function(target,level,internalformat,width,height) {
	GL.context.texStorage2D(target,level,internalformat,width,height);
}
GL.texStorage3D = function(target,level,internalformat,width,height,depth) {
	GL.context.texStorage3D(target,level,internalformat,width,height,depth);
}
GL.texParameterf = function(target,pname,param) {
	GL.context.texParameterf(target,pname,param);
}
GL.texParameteri = function(target,pname,param) {
	GL.context.texParameteri(target,pname,param);
}
GL.texSubImage2DWEBGL = function(target,level,xoffset,yoffset,width,height,format,type,srcData,srcOffset) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,srcData,srcOffset);
	} else if(type != null) {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,srcData);
	} else {
		this1.texSubImage2D(target,level,xoffset,yoffset,width,height,format);
	}
}
GL.texSubImage3DWEBGL = function(target,level,xoffset,yoffset,zoffset,width,height,depth,format,type,source,srcOffset) {
	GL.context.texSubImage3D(target,level,xoffset,yoffset,zoffset,width,height,depth,format,type,source,srcOffset);
}
GL.transformFeedbackVaryings = function(program,varyings,bufferMode) {
	GL.context.transformFeedbackVaryings(program,varyings,bufferMode);
}
GL.uniform1f = function(location,v0) {
	GL.context.uniform1f(location,v0);
}
GL.uniform1fvWEBGL = function(location,data,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniform1fv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform1fv(location,data);
	}
}
GL.uniform1i = function(location,v0) {
	GL.context.uniform1i(location,v0);
}
GL.uniform1ivWEBGL = function(location,data,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniform1iv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform1iv(location,data);
	}
}
GL.uniform1ui = function(location,v0) {
	GL.context.uniform1ui(location,v0);
}
GL.uniform1uivWEBGL = function(location,data,srcOffset,srcLength) {
	GL.context.uniform1uiv(location,data,srcOffset,srcLength);
}
GL.uniform2f = function(location,v0,v1) {
	GL.context.uniform2f(location,v0,v1);
}
GL.uniform2fvWEBGL = function(location,data,srcOffset,srcLength) {
	(lime_graphics__$WebGL2RenderContext_WebGL2RenderContext_$Impl_$().default).uniform2fv(GL.context,location,data,srcOffset,srcLength);
}
GL.uniform2i = function(location,x,y) {
	GL.context.uniform2i(location,x,y);
}
GL.uniform2ivWEBGL = function(location,data,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniform2iv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform2iv(location,data);
	}
}
GL.uniform2ui = function(location,x,y) {
	GL.context.uniform2ui(location,x,y);
}
GL.uniform2uivWEBGL = function(location,data,srcOffset,srcLength) {
	GL.context.uniform2uiv(location,data,srcOffset,srcLength);
}
GL.uniform3f = function(location,v0,v1,v2) {
	GL.context.uniform3f(location,v0,v1,v2);
}
GL.uniform3fvWEBGL = function(location,data,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniform3fv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform3fv(location,data);
	}
}
GL.uniform3i = function(location,v0,v1,v2) {
	GL.context.uniform3i(location,v0,v1,v2);
}
GL.uniform3ivWEBGL = function(location,data,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniform3iv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform3iv(location,data);
	}
}
GL.uniform3ui = function(location,v0,v1,v2) {
	GL.context.uniform3ui(location,v0,v1,v2);
}
GL.uniform3uivWEBGL = function(location,data,srcOffset,srcLength) {
	GL.context.uniform3uiv(location,data,srcOffset,srcLength);
}
GL.uniform4f = function(location,v0,v1,v2,v3) {
	GL.context.uniform4f(location,v0,v1,v2,v3);
}
GL.uniform4fvWEBGL = function(location,data,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniform4fv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform4fv(location,data);
	}
}
GL.uniform4i = function(location,v0,v1,v2,v3) {
	GL.context.uniform4i(location,v0,v1,v2,v3);
}
GL.uniform4ivWEBGL = function(location,data,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniform4iv(location,data,srcOffset,srcLength);
	} else {
		this1.uniform4iv(location,data);
	}
}
GL.uniform4ui = function(location,v0,v1,v2,v3) {
	GL.context.uniform4ui(location,v0,v1,v2,v3);
}
GL.uniform4uivWEBGL = function(location,data,srcOffset,srcLength) {
	GL.context.uniform4uiv(location,data,srcOffset,srcLength);
}
GL.uniformBlockBinding = function(program,uniformBlockIndex,uniformBlockBinding) {
	GL.context.uniformBlockBinding(program,uniformBlockIndex,uniformBlockBinding);
}
GL.uniformMatrix2fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniformMatrix2fv(location,transpose,v,srcOffset,srcLength);
	} else {
		this1.uniformMatrix2fv(location,transpose,v);
	}
}
GL.uniformMatrix2x3fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	GL.context.uniformMatrix2x3fv(location,transpose,v,srcOffset,srcLength);
}
GL.uniformMatrix2x4fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	GL.context.uniformMatrix2x4fv(location,transpose,v,srcOffset,srcLength);
}
GL.uniformMatrix3fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniformMatrix3fv(location,transpose,v,srcOffset,srcLength);
	} else {
		this1.uniformMatrix3fv(location,transpose,v);
	}
}
GL.uniformMatrix3x2fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	GL.context.uniformMatrix3x2fv(location,transpose,v,srcOffset,srcLength);
}
GL.uniformMatrix3x4fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	GL.context.uniformMatrix3x4fv(location,transpose,v,srcOffset,srcLength);
}
GL.uniformMatrix4fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	var this1 = GL.context;
	if(srcOffset != null) {
		this1.uniformMatrix4fv(location,transpose,v,srcOffset,srcLength);
	} else {
		this1.uniformMatrix4fv(location,transpose,v);
	}
}
GL.uniformMatrix4x2fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	GL.context.uniformMatrix4x2fv(location,transpose,v,srcOffset,srcLength);
}
GL.uniformMatrix4x3fvWEBGL = function(location,transpose,v,srcOffset,srcLength) {
	GL.context.uniformMatrix4x3fv(location,transpose,v,srcOffset,srcLength);
}
GL.useProgram = function(program) {
	GL.context.useProgram(program);
}
GL.validateProgram = function(program) {
	GL.context.validateProgram(program);
}
GL.vertexAttrib1f = function(index,v0) {
	GL.context.vertexAttrib1f(index,v0);
}
GL.vertexAttrib1fv = function(index,v) {
	GL.context.vertexAttrib1fv(index,v);
}
GL.vertexAttrib1fvWEBGL = function(index,v) {
	GL.context.vertexAttrib1fv(index,v);
}
GL.vertexAttrib2f = function(index,v0,v1) {
	GL.context.vertexAttrib2f(index,v0,v1);
}
GL.vertexAttrib2fv = function(index,v) {
	GL.context.vertexAttrib2fv(index,v);
}
GL.vertexAttrib2fvWEBGL = function(index,v) {
	GL.context.vertexAttrib2fv(index,v);
}
GL.vertexAttrib3f = function(index,v0,v1,v2) {
	GL.context.vertexAttrib3f(index,v0,v1,v2);
}
GL.vertexAttrib3fv = function(index,v) {
	GL.context.vertexAttrib3fv(index,v);
}
GL.vertexAttrib3fvWEBGL = function(index,v) {
	GL.context.vertexAttrib3fv(index,v);
}
GL.vertexAttrib4f = function(index,v0,v1,v2,v3) {
	GL.context.vertexAttrib4f(index,v0,v1,v2,v3);
}
GL.vertexAttrib4fv = function(index,v) {
	GL.context.vertexAttrib4fv(index,v);
}
GL.vertexAttrib4fvWEBGL = function(index,v) {
	GL.context.vertexAttrib4fv(index,v);
}
GL.vertexAttribDivisor = function(index,divisor) {
	GL.context.vertexAttribDivisor(index,divisor);
}
GL.vertexAttribI4i = function(index,v0,v1,v2,v3) {
	GL.context.vertexAttribI4i(index,v0,v1,v2,v3);
}
GL.vertexAttribI4iv = function(index,v) {
	GL.context.vertexAttribI4iv(index,v);
}
GL.vertexAttribI4ivWEBGL = function(index,v) {
	GL.context.vertexAttribI4iv(index,v);
}
GL.vertexAttribI4ui = function(index,v0,v1,v2,v3) {
	GL.context.vertexAttribI4ui(index,v0,v1,v2,v3);
}
GL.vertexAttribI4uiv = function(index,v) {
	GL.context.vertexAttribI4uiv(index,v);
}
GL.vertexAttribI4uivWEBGL = function(index,v) {
	GL.context.vertexAttribI4uiv(index,v);
}
GL.vertexAttribIPointer = function(index,size,type,stride,offset) {
	GL.context.vertexAttribIPointer(index,size,type,stride,offset);
}
GL.vertexAttribPointer = function(index,size,type,normalized,stride,offset) {
	GL.context.vertexAttribPointer(index,size,type,normalized,stride,offset);
}
GL.viewport = function(x,y,width,height) {
	GL.context.viewport(x,y,width,height);
}
GL.waitSync = function(sync,flags,timeout) {
	GL.context.waitSync(sync,flags,timeout);
}
GL.__getObjectID = function(object) {
	if(object == null) {
		return 0;
	} else {
		return object.id;
	}
}
GL.DEPTH_BUFFER_BIT = 256
GL.STENCIL_BUFFER_BIT = 1024
GL.COLOR_BUFFER_BIT = 16384
GL.POINTS = 0
GL.LINES = 1
GL.LINE_LOOP = 2
GL.LINE_STRIP = 3
GL.TRIANGLES = 4
GL.TRIANGLE_STRIP = 5
GL.TRIANGLE_FAN = 6
GL.ZERO = 0
GL.ONE = 1
GL.SRC_COLOR = 768
GL.ONE_MINUS_SRC_COLOR = 769
GL.SRC_ALPHA = 770
GL.ONE_MINUS_SRC_ALPHA = 771
GL.DST_ALPHA = 772
GL.ONE_MINUS_DST_ALPHA = 773
GL.DST_COLOR = 774
GL.ONE_MINUS_DST_COLOR = 775
GL.SRC_ALPHA_SATURATE = 776
GL.FUNC_ADD = 32774
GL.BLEND_EQUATION = 32777
GL.BLEND_EQUATION_RGB = 32777
GL.BLEND_EQUATION_ALPHA = 34877
GL.FUNC_SUBTRACT = 32778
GL.FUNC_REVERSE_SUBTRACT = 32779
GL.BLEND_DST_RGB = 32968
GL.BLEND_SRC_RGB = 32969
GL.BLEND_DST_ALPHA = 32970
GL.BLEND_SRC_ALPHA = 32971
GL.CONSTANT_COLOR = 32769
GL.ONE_MINUS_CONSTANT_COLOR = 32770
GL.CONSTANT_ALPHA = 32771
GL.ONE_MINUS_CONSTANT_ALPHA = 32772
GL.BLEND_COLOR = 32773
GL.ARRAY_BUFFER = 34962
GL.ELEMENT_ARRAY_BUFFER = 34963
GL.ARRAY_BUFFER_BINDING = 34964
GL.ELEMENT_ARRAY_BUFFER_BINDING = 34965
GL.STREAM_DRAW = 35040
GL.STATIC_DRAW = 35044
GL.DYNAMIC_DRAW = 35048
GL.BUFFER_SIZE = 34660
GL.BUFFER_USAGE = 34661
GL.CURRENT_VERTEX_ATTRIB = 34342
GL.FRONT = 1028
GL.BACK = 1029
GL.FRONT_AND_BACK = 1032
GL.CULL_FACE = 2884
GL.BLEND = 3042
GL.DITHER = 3024
GL.STENCIL_TEST = 2960
GL.DEPTH_TEST = 2929
GL.SCISSOR_TEST = 3089
GL.POLYGON_OFFSET_FILL = 32823
GL.SAMPLE_ALPHA_TO_COVERAGE = 32926
GL.SAMPLE_COVERAGE = 32928
GL.NO_ERROR = 0
GL.INVALID_ENUM = 1280
GL.INVALID_VALUE = 1281
GL.INVALID_OPERATION = 1282
GL.OUT_OF_MEMORY = 1285
GL.CW = 2304
GL.CCW = 2305
GL.LINE_WIDTH = 2849
GL.ALIASED_POINT_SIZE_RANGE = 33901
GL.ALIASED_LINE_WIDTH_RANGE = 33902
GL.CULL_FACE_MODE = 2885
GL.FRONT_FACE = 2886
GL.DEPTH_RANGE = 2928
GL.DEPTH_WRITEMASK = 2930
GL.DEPTH_CLEAR_VALUE = 2931
GL.DEPTH_FUNC = 2932
GL.STENCIL_CLEAR_VALUE = 2961
GL.STENCIL_FUNC = 2962
GL.STENCIL_FAIL = 2964
GL.STENCIL_PASS_DEPTH_FAIL = 2965
GL.STENCIL_PASS_DEPTH_PASS = 2966
GL.STENCIL_REF = 2967
GL.STENCIL_VALUE_MASK = 2963
GL.STENCIL_WRITEMASK = 2968
GL.STENCIL_BACK_FUNC = 34816
GL.STENCIL_BACK_FAIL = 34817
GL.STENCIL_BACK_PASS_DEPTH_FAIL = 34818
GL.STENCIL_BACK_PASS_DEPTH_PASS = 34819
GL.STENCIL_BACK_REF = 36003
GL.STENCIL_BACK_VALUE_MASK = 36004
GL.STENCIL_BACK_WRITEMASK = 36005
GL.VIEWPORT = 2978
GL.SCISSOR_BOX = 3088
GL.COLOR_CLEAR_VALUE = 3106
GL.COLOR_WRITEMASK = 3107
GL.UNPACK_ALIGNMENT = 3317
GL.PACK_ALIGNMENT = 3333
GL.MAX_TEXTURE_SIZE = 3379
GL.MAX_VIEWPORT_DIMS = 3386
GL.SUBPIXEL_BITS = 3408
GL.RED_BITS = 3410
GL.GREEN_BITS = 3411
GL.BLUE_BITS = 3412
GL.ALPHA_BITS = 3413
GL.DEPTH_BITS = 3414
GL.STENCIL_BITS = 3415
GL.POLYGON_OFFSET_UNITS = 10752
GL.POLYGON_OFFSET_FACTOR = 32824
GL.TEXTURE_BINDING_2D = 32873
GL.SAMPLE_BUFFERS = 32936
GL.SAMPLES = 32937
GL.SAMPLE_COVERAGE_VALUE = 32938
GL.SAMPLE_COVERAGE_INVERT = 32939
GL.NUM_COMPRESSED_TEXTURE_FORMATS = 34466
GL.COMPRESSED_TEXTURE_FORMATS = 34467
GL.DONT_CARE = 4352
GL.FASTEST = 4353
GL.NICEST = 4354
GL.GENERATE_MIPMAP_HINT = 33170
GL.BYTE = 5120
GL.UNSIGNED_BYTE = 5121
GL.SHORT = 5122
GL.UNSIGNED_SHORT = 5123
GL.INT = 5124
GL.UNSIGNED_INT = 5125
GL.FLOAT = 5126
GL.DEPTH_COMPONENT = 6402
GL.ALPHA = 6406
GL.RGB = 6407
GL.RGBA = 6408
GL.LUMINANCE = 6409
GL.LUMINANCE_ALPHA = 6410
GL.UNSIGNED_SHORT_4_4_4_4 = 32819
GL.UNSIGNED_SHORT_5_5_5_1 = 32820
GL.UNSIGNED_SHORT_5_6_5 = 33635
GL.FRAGMENT_SHADER = 35632
GL.VERTEX_SHADER = 35633
GL.MAX_VERTEX_ATTRIBS = 34921
GL.MAX_VERTEX_UNIFORM_VECTORS = 36347
GL.MAX_VARYING_VECTORS = 36348
GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661
GL.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660
GL.MAX_TEXTURE_IMAGE_UNITS = 34930
GL.MAX_FRAGMENT_UNIFORM_VECTORS = 36349
GL.SHADER_TYPE = 35663
GL.DELETE_STATUS = 35712
GL.LINK_STATUS = 35714
GL.VALIDATE_STATUS = 35715
GL.ATTACHED_SHADERS = 35717
GL.ACTIVE_UNIFORMS = 35718
GL.ACTIVE_ATTRIBUTES = 35721
GL.SHADING_LANGUAGE_VERSION = 35724
GL.CURRENT_PROGRAM = 35725
GL.NEVER = 512
GL.LESS = 513
GL.EQUAL = 514
GL.LEQUAL = 515
GL.GREATER = 516
GL.NOTEQUAL = 517
GL.GEQUAL = 518
GL.ALWAYS = 519
GL.KEEP = 7680
GL.REPLACE = 7681
GL.INCR = 7682
GL.DECR = 7683
GL.INVERT = 5386
GL.INCR_WRAP = 34055
GL.DECR_WRAP = 34056
GL.VENDOR = 7936
GL.RENDERER = 7937
GL.VERSION = 7938
GL.EXTENSIONS = 7939
GL.NEAREST = 9728
GL.LINEAR = 9729
GL.NEAREST_MIPMAP_NEAREST = 9984
GL.LINEAR_MIPMAP_NEAREST = 9985
GL.NEAREST_MIPMAP_LINEAR = 9986
GL.LINEAR_MIPMAP_LINEAR = 9987
GL.TEXTURE_MAG_FILTER = 10240
GL.TEXTURE_MIN_FILTER = 10241
GL.TEXTURE_WRAP_S = 10242
GL.TEXTURE_WRAP_T = 10243
GL.TEXTURE_2D = 3553
GL.TEXTURE = 5890
GL.TEXTURE_CUBE_MAP = 34067
GL.TEXTURE_BINDING_CUBE_MAP = 34068
GL.TEXTURE_CUBE_MAP_POSITIVE_X = 34069
GL.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070
GL.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071
GL.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072
GL.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073
GL.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074
GL.MAX_CUBE_MAP_TEXTURE_SIZE = 34076
GL.TEXTURE0 = 33984
GL.TEXTURE1 = 33985
GL.TEXTURE2 = 33986
GL.TEXTURE3 = 33987
GL.TEXTURE4 = 33988
GL.TEXTURE5 = 33989
GL.TEXTURE6 = 33990
GL.TEXTURE7 = 33991
GL.TEXTURE8 = 33992
GL.TEXTURE9 = 33993
GL.TEXTURE10 = 33994
GL.TEXTURE11 = 33995
GL.TEXTURE12 = 33996
GL.TEXTURE13 = 33997
GL.TEXTURE14 = 33998
GL.TEXTURE15 = 33999
GL.TEXTURE16 = 34000
GL.TEXTURE17 = 34001
GL.TEXTURE18 = 34002
GL.TEXTURE19 = 34003
GL.TEXTURE20 = 34004
GL.TEXTURE21 = 34005
GL.TEXTURE22 = 34006
GL.TEXTURE23 = 34007
GL.TEXTURE24 = 34008
GL.TEXTURE25 = 34009
GL.TEXTURE26 = 34010
GL.TEXTURE27 = 34011
GL.TEXTURE28 = 34012
GL.TEXTURE29 = 34013
GL.TEXTURE30 = 34014
GL.TEXTURE31 = 34015
GL.ACTIVE_TEXTURE = 34016
GL.REPEAT = 10497
GL.CLAMP_TO_EDGE = 33071
GL.MIRRORED_REPEAT = 33648
GL.FLOAT_VEC2 = 35664
GL.FLOAT_VEC3 = 35665
GL.FLOAT_VEC4 = 35666
GL.INT_VEC2 = 35667
GL.INT_VEC3 = 35668
GL.INT_VEC4 = 35669
GL.BOOL = 35670
GL.BOOL_VEC2 = 35671
GL.BOOL_VEC3 = 35672
GL.BOOL_VEC4 = 35673
GL.FLOAT_MAT2 = 35674
GL.FLOAT_MAT3 = 35675
GL.FLOAT_MAT4 = 35676
GL.SAMPLER_2D = 35678
GL.SAMPLER_CUBE = 35680
GL.VERTEX_ATTRIB_ARRAY_ENABLED = 34338
GL.VERTEX_ATTRIB_ARRAY_SIZE = 34339
GL.VERTEX_ATTRIB_ARRAY_STRIDE = 34340
GL.VERTEX_ATTRIB_ARRAY_TYPE = 34341
GL.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922
GL.VERTEX_ATTRIB_ARRAY_POINTER = 34373
GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975
GL.IMPLEMENTATION_COLOR_READ_TYPE = 35738
GL.IMPLEMENTATION_COLOR_READ_FORMAT = 35739
GL.VERTEX_PROGRAM_POINT_SIZE = 34370
GL.POINT_SPRITE = 34913
GL.COMPILE_STATUS = 35713
GL.LOW_FLOAT = 36336
GL.MEDIUM_FLOAT = 36337
GL.HIGH_FLOAT = 36338
GL.LOW_INT = 36339
GL.MEDIUM_INT = 36340
GL.HIGH_INT = 36341
GL.FRAMEBUFFER = 36160
GL.RENDERBUFFER = 36161
GL.RGBA4 = 32854
GL.RGB5_A1 = 32855
GL.RGB565 = 36194
GL.DEPTH_COMPONENT16 = 33189
GL.STENCIL_INDEX = 6401
GL.STENCIL_INDEX8 = 36168
GL.DEPTH_STENCIL = 34041
GL.RENDERBUFFER_WIDTH = 36162
GL.RENDERBUFFER_HEIGHT = 36163
GL.RENDERBUFFER_INTERNAL_FORMAT = 36164
GL.RENDERBUFFER_RED_SIZE = 36176
GL.RENDERBUFFER_GREEN_SIZE = 36177
GL.RENDERBUFFER_BLUE_SIZE = 36178
GL.RENDERBUFFER_ALPHA_SIZE = 36179
GL.RENDERBUFFER_DEPTH_SIZE = 36180
GL.RENDERBUFFER_STENCIL_SIZE = 36181
GL.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048
GL.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049
GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050
GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051
GL.COLOR_ATTACHMENT0 = 36064
GL.DEPTH_ATTACHMENT = 36096
GL.STENCIL_ATTACHMENT = 36128
GL.DEPTH_STENCIL_ATTACHMENT = 33306
GL.NONE = 0
GL.FRAMEBUFFER_COMPLETE = 36053
GL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054
GL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055
GL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057
GL.FRAMEBUFFER_UNSUPPORTED = 36061
GL.FRAMEBUFFER_BINDING = 36006
GL.RENDERBUFFER_BINDING = 36007
GL.MAX_RENDERBUFFER_SIZE = 34024
GL.INVALID_FRAMEBUFFER_OPERATION = 1286
GL.UNPACK_FLIP_Y_WEBGL = 37440
GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441
GL.CONTEXT_LOST_WEBGL = 37442
GL.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443
GL.BROWSER_DEFAULT_WEBGL = 37444
GL.READ_BUFFER = 3074
GL.UNPACK_ROW_LENGTH = 3314
GL.UNPACK_SKIP_ROWS = 3315
GL.UNPACK_SKIP_PIXELS = 3316
GL.PACK_ROW_LENGTH = 3330
GL.PACK_SKIP_ROWS = 3331
GL.PACK_SKIP_PIXELS = 3332
GL.TEXTURE_BINDING_3D = 32874
GL.UNPACK_SKIP_IMAGES = 32877
GL.UNPACK_IMAGE_HEIGHT = 32878
GL.MAX_3D_TEXTURE_SIZE = 32883
GL.MAX_ELEMENTS_VERTICES = 33000
GL.MAX_ELEMENTS_INDICES = 33001
GL.MAX_TEXTURE_LOD_BIAS = 34045
GL.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657
GL.MAX_VERTEX_UNIFORM_COMPONENTS = 35658
GL.MAX_ARRAY_TEXTURE_LAYERS = 35071
GL.MIN_PROGRAM_TEXEL_OFFSET = 35076
GL.MAX_PROGRAM_TEXEL_OFFSET = 35077
GL.MAX_VARYING_COMPONENTS = 35659
GL.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723
GL.RASTERIZER_DISCARD = 35977
GL.VERTEX_ARRAY_BINDING = 34229
GL.MAX_VERTEX_OUTPUT_COMPONENTS = 37154
GL.MAX_FRAGMENT_INPUT_COMPONENTS = 37157
GL.MAX_SERVER_WAIT_TIMEOUT = 37137
GL.MAX_ELEMENT_INDEX = 36203
GL.RED = 6403
GL.RGB8 = 32849
GL.RGBA8 = 32856
GL.RGB10_A2 = 32857
GL.TEXTURE_3D = 32879
GL.TEXTURE_WRAP_R = 32882
GL.TEXTURE_MIN_LOD = 33082
GL.TEXTURE_MAX_LOD = 33083
GL.TEXTURE_BASE_LEVEL = 33084
GL.TEXTURE_MAX_LEVEL = 33085
GL.TEXTURE_COMPARE_MODE = 34892
GL.TEXTURE_COMPARE_FUNC = 34893
GL.SRGB = 35904
GL.SRGB8 = 35905
GL.SRGB8_ALPHA8 = 35907
GL.COMPARE_REF_TO_TEXTURE = 34894
GL.RGBA32F = 34836
GL.RGB32F = 34837
GL.RGBA16F = 34842
GL.RGB16F = 34843
GL.TEXTURE_2D_ARRAY = 35866
GL.TEXTURE_BINDING_2D_ARRAY = 35869
GL.R11F_G11F_B10F = 35898
GL.RGB9_E5 = 35901
GL.RGBA32UI = 36208
GL.RGB32UI = 36209
GL.RGBA16UI = 36214
GL.RGB16UI = 36215
GL.RGBA8UI = 36220
GL.RGB8UI = 36221
GL.RGBA32I = 36226
GL.RGB32I = 36227
GL.RGBA16I = 36232
GL.RGB16I = 36233
GL.RGBA8I = 36238
GL.RGB8I = 36239
GL.RED_INTEGER = 36244
GL.RGB_INTEGER = 36248
GL.RGBA_INTEGER = 36249
GL.R8 = 33321
GL.RG8 = 33323
GL.R16F = 33325
GL.R32F = 33326
GL.RG16F = 33327
GL.RG32F = 33328
GL.R8I = 33329
GL.R8UI = 33330
GL.R16I = 33331
GL.R16UI = 33332
GL.R32I = 33333
GL.R32UI = 33334
GL.RG8I = 33335
GL.RG8UI = 33336
GL.RG16I = 33337
GL.RG16UI = 33338
GL.RG32I = 33339
GL.RG32UI = 33340
GL.R8_SNORM = 36756
GL.RG8_SNORM = 36757
GL.RGB8_SNORM = 36758
GL.RGBA8_SNORM = 36759
GL.RGB10_A2UI = 36975
GL.TEXTURE_IMMUTABLE_FORMAT = 37167
GL.TEXTURE_IMMUTABLE_LEVELS = 33503
GL.UNSIGNED_INT_2_10_10_10_REV = 33640
GL.UNSIGNED_INT_10F_11F_11F_REV = 35899
GL.UNSIGNED_INT_5_9_9_9_REV = 35902
GL.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269
GL.UNSIGNED_INT_24_8 = 34042
GL.HALF_FLOAT = 5131
GL.RG = 33319
GL.RG_INTEGER = 33320
GL.INT_2_10_10_10_REV = 36255
GL.CURRENT_QUERY = 34917
GL.QUERY_RESULT = 34918
GL.QUERY_RESULT_AVAILABLE = 34919
GL.ANY_SAMPLES_PASSED = 35887
GL.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202
GL.MAX_DRAW_BUFFERS = 34852
GL.DRAW_BUFFER0 = 34853
GL.DRAW_BUFFER1 = 34854
GL.DRAW_BUFFER2 = 34855
GL.DRAW_BUFFER3 = 34856
GL.DRAW_BUFFER4 = 34857
GL.DRAW_BUFFER5 = 34858
GL.DRAW_BUFFER6 = 34859
GL.DRAW_BUFFER7 = 34860
GL.DRAW_BUFFER8 = 34861
GL.DRAW_BUFFER9 = 34862
GL.DRAW_BUFFER10 = 34863
GL.DRAW_BUFFER11 = 34864
GL.DRAW_BUFFER12 = 34865
GL.DRAW_BUFFER13 = 34866
GL.DRAW_BUFFER14 = 34867
GL.DRAW_BUFFER15 = 34868
GL.MAX_COLOR_ATTACHMENTS = 36063
GL.COLOR_ATTACHMENT1 = 36065
GL.COLOR_ATTACHMENT2 = 36066
GL.COLOR_ATTACHMENT3 = 36067
GL.COLOR_ATTACHMENT4 = 36068
GL.COLOR_ATTACHMENT5 = 36069
GL.COLOR_ATTACHMENT6 = 36070
GL.COLOR_ATTACHMENT7 = 36071
GL.COLOR_ATTACHMENT8 = 36072
GL.COLOR_ATTACHMENT9 = 36073
GL.COLOR_ATTACHMENT10 = 36074
GL.COLOR_ATTACHMENT11 = 36075
GL.COLOR_ATTACHMENT12 = 36076
GL.COLOR_ATTACHMENT13 = 36077
GL.COLOR_ATTACHMENT14 = 36078
GL.COLOR_ATTACHMENT15 = 36079
GL.SAMPLER_3D = 35679
GL.SAMPLER_2D_SHADOW = 35682
GL.SAMPLER_2D_ARRAY = 36289
GL.SAMPLER_2D_ARRAY_SHADOW = 36292
GL.SAMPLER_CUBE_SHADOW = 36293
GL.INT_SAMPLER_2D = 36298
GL.INT_SAMPLER_3D = 36299
GL.INT_SAMPLER_CUBE = 36300
GL.INT_SAMPLER_2D_ARRAY = 36303
GL.UNSIGNED_INT_SAMPLER_2D = 36306
GL.UNSIGNED_INT_SAMPLER_3D = 36307
GL.UNSIGNED_INT_SAMPLER_CUBE = 36308
GL.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311
GL.MAX_SAMPLES = 36183
GL.SAMPLER_BINDING = 35097
GL.PIXEL_PACK_BUFFER = 35051
GL.PIXEL_UNPACK_BUFFER = 35052
GL.PIXEL_PACK_BUFFER_BINDING = 35053
GL.PIXEL_UNPACK_BUFFER_BINDING = 35055
GL.COPY_READ_BUFFER = 36662
GL.COPY_WRITE_BUFFER = 36663
GL.COPY_READ_BUFFER_BINDING = 36662
GL.COPY_WRITE_BUFFER_BINDING = 36663
GL.FLOAT_MAT2x3 = 35685
GL.FLOAT_MAT2x4 = 35686
GL.FLOAT_MAT3x2 = 35687
GL.FLOAT_MAT3x4 = 35688
GL.FLOAT_MAT4x2 = 35689
GL.FLOAT_MAT4x3 = 35690
GL.UNSIGNED_INT_VEC2 = 36294
GL.UNSIGNED_INT_VEC3 = 36295
GL.UNSIGNED_INT_VEC4 = 36296
GL.UNSIGNED_NORMALIZED = 35863
GL.SIGNED_NORMALIZED = 36764
GL.VERTEX_ATTRIB_ARRAY_INTEGER = 35069
GL.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070
GL.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967
GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968
GL.TRANSFORM_FEEDBACK_VARYINGS = 35971
GL.TRANSFORM_FEEDBACK_BUFFER_START = 35972
GL.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973
GL.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976
GL.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978
GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979
GL.INTERLEAVED_ATTRIBS = 35980
GL.SEPARATE_ATTRIBS = 35981
GL.TRANSFORM_FEEDBACK_BUFFER = 35982
GL.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983
GL.TRANSFORM_FEEDBACK = 36386
GL.TRANSFORM_FEEDBACK_PAUSED = 36387
GL.TRANSFORM_FEEDBACK_ACTIVE = 36388
GL.TRANSFORM_FEEDBACK_BINDING = 36389
GL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296
GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297
GL.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298
GL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299
GL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300
GL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301
GL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302
GL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303
GL.FRAMEBUFFER_DEFAULT = 33304
GL.DEPTH24_STENCIL8 = 35056
GL.DRAW_FRAMEBUFFER_BINDING = 36006
GL.READ_FRAMEBUFFER = 36008
GL.DRAW_FRAMEBUFFER = 36009
GL.READ_FRAMEBUFFER_BINDING = 36010
GL.RENDERBUFFER_SAMPLES = 36011
GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052
GL.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182
GL.UNIFORM_BUFFER = 35345
GL.UNIFORM_BUFFER_BINDING = 35368
GL.UNIFORM_BUFFER_START = 35369
GL.UNIFORM_BUFFER_SIZE = 35370
GL.MAX_VERTEX_UNIFORM_BLOCKS = 35371
GL.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373
GL.MAX_COMBINED_UNIFORM_BLOCKS = 35374
GL.MAX_UNIFORM_BUFFER_BINDINGS = 35375
GL.MAX_UNIFORM_BLOCK_SIZE = 35376
GL.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377
GL.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379
GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380
GL.ACTIVE_UNIFORM_BLOCKS = 35382
GL.UNIFORM_TYPE = 35383
GL.UNIFORM_SIZE = 35384
GL.UNIFORM_BLOCK_INDEX = 35386
GL.UNIFORM_OFFSET = 35387
GL.UNIFORM_ARRAY_STRIDE = 35388
GL.UNIFORM_MATRIX_STRIDE = 35389
GL.UNIFORM_IS_ROW_MAJOR = 35390
GL.UNIFORM_BLOCK_BINDING = 35391
GL.UNIFORM_BLOCK_DATA_SIZE = 35392
GL.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394
GL.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395
GL.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396
GL.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398
GL.OBJECT_TYPE = 37138
GL.SYNC_CONDITION = 37139
GL.SYNC_STATUS = 37140
GL.SYNC_FLAGS = 37141
GL.SYNC_FENCE = 37142
GL.SYNC_GPU_COMMANDS_COMPLETE = 37143
GL.UNSIGNALED = 37144
GL.SIGNALED = 37145
GL.ALREADY_SIGNALED = 37146
GL.TIMEOUT_EXPIRED = 37147
GL.CONDITION_SATISFIED = 37148
GL.WAIT_FAILED = 37149
GL.SYNC_FLUSH_COMMANDS_BIT = 1
GL.COLOR = 6144
GL.DEPTH = 6145
GL.STENCIL = 6146
GL.MIN = 32775
GL.MAX = 32776
GL.DEPTH_COMPONENT24 = 33190
GL.STREAM_READ = 35041
GL.STREAM_COPY = 35042
GL.STATIC_READ = 35045
GL.STATIC_COPY = 35046
GL.DYNAMIC_READ = 35049
GL.DYNAMIC_COPY = 35050
GL.DEPTH_COMPONENT32F = 36012
GL.DEPTH32F_STENCIL8 = 36013
GL.INVALID_INDEX = -1
GL.TIMEOUT_IGNORED = -1
GL.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447

// Export

exports.default = GL;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/math/Matrix3.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/math/Matrix3.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.math.Matrix3

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function lime_math_Vector2() {return __webpack_require__(/*! ./../../lime/math/Vector2 */ "./node_modules/openfl/lib/_gen/lime/math/Vector2.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}

// Constructor

var Matrix3 = function(a,b,c,d,tx,ty) {
	if(ty == null) {
		ty = 0;
	}
	if(tx == null) {
		tx = 0;
	}
	if(d == null) {
		d = 1;
	}
	if(c == null) {
		c = 0;
	}
	if(b == null) {
		b = 0;
	}
	if(a == null) {
		a = 1;
	}
	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;
	this.tx = tx;
	this.ty = ty;
}

// Meta

Matrix3.__name__ = "lime.math.Matrix3";
Matrix3.__isInterface__ = false;
Matrix3.prototype = {
	clone: function() {
		return new Matrix3(this.a,this.b,this.c,this.d,this.tx,this.ty);
	},
	concat: function(m) {
		var a1 = this.a * m.a + this.b * m.c;
		this.b = this.a * m.b + this.b * m.d;
		this.a = a1;
		var c1 = this.c * m.a + this.d * m.c;
		this.d = this.c * m.b + this.d * m.d;
		this.c = c1;
		var tx1 = this.tx * m.a + this.ty * m.c + m.tx;
		this.ty = this.tx * m.b + this.ty * m.d + m.ty;
		this.tx = tx1;
	},
	copyColumnFrom: function(column,vector4) {
		if(column > 2) {
			throw new (js__$Boot_HaxeError().default)("Column " + column + " out of bounds (2)");
		} else if(column == 0) {
			this.a = vector4.x;
			this.b = vector4.y;
		} else if(column == 1) {
			this.c = vector4.x;
			this.d = vector4.y;
		} else {
			this.tx = vector4.x;
			this.ty = vector4.y;
		}
	},
	copyColumnTo: function(column,vector4) {
		if(column > 2) {
			throw new (js__$Boot_HaxeError().default)("Column " + column + " out of bounds (2)");
		} else if(column == 0) {
			vector4.x = this.a;
			vector4.y = this.b;
			vector4.z = 0;
		} else if(column == 1) {
			vector4.x = this.c;
			vector4.y = this.d;
			vector4.z = 0;
		} else {
			vector4.x = this.tx;
			vector4.y = this.ty;
			vector4.z = 1;
		}
	},
	copyFrom: function(sourceMatrix3) {
		this.a = sourceMatrix3.a;
		this.b = sourceMatrix3.b;
		this.c = sourceMatrix3.c;
		this.d = sourceMatrix3.d;
		this.tx = sourceMatrix3.tx;
		this.ty = sourceMatrix3.ty;
	},
	copyRowFrom: function(row,vector4) {
		if(row > 2) {
			throw new (js__$Boot_HaxeError().default)("Row " + row + " out of bounds (2)");
		} else if(row == 0) {
			this.a = vector4.x;
			this.c = vector4.y;
			this.tx = vector4.z;
		} else if(row == 1) {
			this.b = vector4.x;
			this.d = vector4.y;
			this.ty = vector4.z;
		}
	},
	copyRowTo: function(row,vector4) {
		if(row > 2) {
			throw new (js__$Boot_HaxeError().default)("Row " + row + " out of bounds (2)");
		} else if(row == 0) {
			vector4.x = this.a;
			vector4.y = this.c;
			vector4.z = this.tx;
		} else if(row == 1) {
			vector4.x = this.b;
			vector4.y = this.d;
			vector4.z = this.ty;
		} else {
			vector4.setTo(0,0,1);
		}
	},
	createBox: function(scaleX,scaleY,rotation,tx,ty) {
		if(ty == null) {
			ty = 0;
		}
		if(tx == null) {
			tx = 0;
		}
		if(rotation == null) {
			rotation = 0;
		}
		if(rotation != 0) {
			var cos = Math.cos(rotation);
			var sin = Math.sin(rotation);
			this.a = cos * scaleX;
			this.b = sin * scaleY;
			this.c = -sin * scaleX;
			this.d = cos * scaleY;
		} else {
			this.a = scaleX;
			this.b = 0;
			this.c = 0;
			this.d = scaleY;
		}
		this.tx = tx;
		this.ty = ty;
	},
	createGradientBox: function(width,height,rotation,tx,ty) {
		if(ty == null) {
			ty = 0;
		}
		if(tx == null) {
			tx = 0;
		}
		if(rotation == null) {
			rotation = 0;
		}
		this.a = width / 1638.4;
		this.d = height / 1638.4;
		if(rotation != 0) {
			var cos = Math.cos(rotation);
			var sin = Math.sin(rotation);
			this.b = sin * this.d;
			this.c = -sin * this.a;
			this.a *= cos;
			this.d *= cos;
		} else {
			this.b = 0;
			this.c = 0;
		}
		this.tx = tx + width / 2;
		this.ty = ty + height / 2;
	},
	equals: function(matrix3) {
		if(matrix3 != null && this.tx == matrix3.tx && this.ty == matrix3.ty && this.a == matrix3.a && this.b == matrix3.b && this.c == matrix3.c) {
			return this.d == matrix3.d;
		} else {
			return false;
		}
	},
	deltaTransformVector: function(Vector2,result) {
		if(result == null) {
			result = new (lime_math_Vector2().default)();
		}
		result.x = Vector2.x * this.a + Vector2.y * this.c;
		result.y = Vector2.x * this.b + Vector2.y * this.d;
		return result;
	},
	identity: function() {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.tx = 0;
		this.ty = 0;
	},
	invert: function() {
		var norm = this.a * this.d - this.b * this.c;
		if(norm == 0) {
			this.a = this.b = this.c = this.d = 0;
			this.tx = -this.tx;
			this.ty = -this.ty;
		} else {
			norm = 1.0 / norm;
			var a1 = this.d * norm;
			this.d = this.a * norm;
			this.a = a1;
			this.b *= -norm;
			this.c *= -norm;
			var tx1 = -this.a * this.tx - this.c * this.ty;
			this.ty = -this.b * this.tx - this.d * this.ty;
			this.tx = tx1;
		}
		return this;
	},
	rotate: function(theta) {
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);
		var a1 = this.a * cos - this.b * sin;
		this.b = this.a * sin + this.b * cos;
		this.a = a1;
		var c1 = this.c * cos - this.d * sin;
		this.d = this.c * sin + this.d * cos;
		this.c = c1;
		var tx1 = this.tx * cos - this.ty * sin;
		this.ty = this.tx * sin + this.ty * cos;
		this.tx = tx1;
	},
	scale: function(sx,sy) {
		this.a *= sx;
		this.b *= sy;
		this.c *= sx;
		this.d *= sy;
		this.tx *= sx;
		this.ty *= sy;
	},
	setRotation: function(theta,scale) {
		if(scale == null) {
			scale = 1;
		}
		this.a = Math.cos(theta) * scale;
		this.c = Math.sin(theta) * scale;
		this.b = -this.c;
		this.d = this.a;
	},
	setTo: function(a,b,c,d,tx,ty) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
		this.tx = tx;
		this.ty = ty;
	},
	to3DString: function(roundPixels) {
		if(roundPixels == null) {
			roundPixels = false;
		}
		if(roundPixels) {
			return "matrix3d(" + this.a + ", " + this.b + ", " + "0, 0, " + this.c + ", " + this.d + ", " + "0, 0, 0, 0, 1, 0, " + (Std().default).int(this.tx) + ", " + (Std().default).int(this.ty) + ", 0, 1)";
		} else {
			return "matrix3d(" + this.a + ", " + this.b + ", " + "0, 0, " + this.c + ", " + this.d + ", " + "0, 0, 0, 0, 1, 0, " + this.tx + ", " + this.ty + ", 0, 1)";
		}
	},
	toString: function() {
		return "matrix(" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.tx + ", " + this.ty + ")";
	},
	transformRect: function(rect,result) {
		if(result == null) {
			result = new (lime_math_Rectangle().default)();
		}
		var tx0 = this.a * rect.x + this.c * rect.y;
		var tx1 = tx0;
		var ty0 = this.b * rect.x + this.d * rect.y;
		var ty1 = ty0;
		var tx = this.a * (rect.x + rect.width) + this.c * rect.y;
		var ty = this.b * (rect.x + rect.width) + this.d * rect.y;
		if(tx < tx0) {
			tx0 = tx;
		}
		if(ty < ty0) {
			ty0 = ty;
		}
		if(tx > tx1) {
			tx1 = tx;
		}
		if(ty > ty1) {
			ty1 = ty;
		}
		tx = this.a * (rect.x + rect.width) + this.c * (rect.y + rect.height);
		ty = this.b * (rect.x + rect.width) + this.d * (rect.y + rect.height);
		if(tx < tx0) {
			tx0 = tx;
		}
		if(ty < ty0) {
			ty0 = ty;
		}
		if(tx > tx1) {
			tx1 = tx;
		}
		if(ty > ty1) {
			ty1 = ty;
		}
		tx = this.a * rect.x + this.c * (rect.y + rect.height);
		ty = this.b * rect.x + this.d * (rect.y + rect.height);
		if(tx < tx0) {
			tx0 = tx;
		}
		if(ty < ty0) {
			ty0 = ty;
		}
		if(tx > tx1) {
			tx1 = tx;
		}
		if(ty > ty1) {
			ty1 = ty;
		}
		result.setTo(tx0 + tx,ty0 + ty,tx1 - tx0,ty1 - ty0);
		return result;
	},
	transformVector: function(pos,result) {
		if(result == null) {
			result = new (lime_math_Vector2().default)();
		}
		result.x = pos.x * this.a + pos.y * this.c + this.tx;
		result.y = pos.x * this.b + pos.y * this.d + this.ty;
		return result;
	},
	translate: function(dx,dy) {
		this.tx += dx;
		this.ty += dy;
	}
};
Matrix3.prototype.__class__ = Matrix3.prototype.constructor = $hxClasses["lime.math.Matrix3"] = Matrix3;

// Init



// Statics


Matrix3.__identity = new Matrix3()

// Export

exports.default = Matrix3;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/math/Rectangle.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.math.Rectangle

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_math_Vector2() {return __webpack_require__(/*! ./../../lime/math/Vector2 */ "./node_modules/openfl/lib/_gen/lime/math/Vector2.js");}

// Constructor

var Rectangle = function(x,y,width,height) {
	if(height == null) {
		height = 0;
	}
	if(width == null) {
		width = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
}

// Meta

Rectangle.__name__ = "lime.math.Rectangle";
Rectangle.__isInterface__ = false;
Rectangle.prototype = {
	clone: function() {
		return new Rectangle(this.x,this.y,this.width,this.height);
	},
	contains: function(x,y) {
		if(x >= this.x && y >= this.y && x < this.get_right()) {
			return y < this.get_bottom();
		} else {
			return false;
		}
	},
	containsPoint: function(point) {
		return this.containsVector(point);
	},
	containsRect: function(rect) {
		if(rect.width <= 0 || rect.height <= 0) {
			if(rect.x > this.x && rect.y > this.y && rect.get_right() < this.get_right()) {
				return rect.get_bottom() < this.get_bottom();
			} else {
				return false;
			}
		} else if(rect.x >= this.x && rect.y >= this.y && rect.get_right() <= this.get_right()) {
			return rect.get_bottom() <= this.get_bottom();
		} else {
			return false;
		}
	},
	containsVector: function(vector) {
		return this.contains(vector.x,vector.y);
	},
	copyFrom: function(sourceRect) {
		this.x = sourceRect.x;
		this.y = sourceRect.y;
		this.width = sourceRect.width;
		this.height = sourceRect.height;
	},
	equals: function(toCompare) {
		if(toCompare != null && this.x == toCompare.x && this.y == toCompare.y && this.width == toCompare.width) {
			return this.height == toCompare.height;
		} else {
			return false;
		}
	},
	inflate: function(dx,dy) {
		this.x -= dx;
		this.width += dx * 2;
		this.y -= dy;
		this.height += dy * 2;
	},
	inflateVector: function(vector) {
		this.inflate(vector.x,vector.y);
	},
	intersection: function(toIntersect,result) {
		if(result == null) {
			result = new Rectangle();
		}
		var x0 = this.x < toIntersect.x ? toIntersect.x : this.x;
		var x1 = this.get_right() > toIntersect.get_right() ? toIntersect.get_right() : this.get_right();
		if(x1 <= x0) {
			result.setEmpty();
			return result;
		}
		var y0 = this.y < toIntersect.y ? toIntersect.y : this.y;
		var y1 = this.get_bottom() > toIntersect.get_bottom() ? toIntersect.get_bottom() : this.get_bottom();
		if(y1 <= y0) {
			result.setEmpty();
			return result;
		}
		result.x = x0;
		result.y = y0;
		result.width = x1 - x0;
		result.height = y1 - y0;
		return result;
	},
	intersects: function(toIntersect) {
		var x0 = this.x < toIntersect.x ? toIntersect.x : this.x;
		var x1 = this.get_right() > toIntersect.get_right() ? toIntersect.get_right() : this.get_right();
		if(x1 <= x0) {
			return false;
		}
		var y0 = this.y < toIntersect.y ? toIntersect.y : this.y;
		var y1 = this.get_bottom() > toIntersect.get_bottom() ? toIntersect.get_bottom() : this.get_bottom();
		return y1 > y0;
	},
	isEmpty: function() {
		if(!(this.width <= 0)) {
			return this.height <= 0;
		} else {
			return true;
		}
	},
	offset: function(dx,dy) {
		this.x += dx;
		this.y += dy;
	},
	offsetVector: function(vector) {
		this.x += vector.x;
		this.y += vector.y;
	},
	setEmpty: function() {
		this.x = this.y = this.width = this.height = 0;
	},
	setTo: function(xa,ya,widtha,heighta) {
		this.x = xa;
		this.y = ya;
		this.width = widtha;
		this.height = heighta;
	},
	union: function(toUnion,result) {
		if(result == null) {
			result = new Rectangle();
		}
		if(this.width == 0 || this.height == 0) {
			result.copyFrom(toUnion);
		} else if(toUnion.width == 0 || toUnion.height == 0) {
			result.copyFrom(this);
		} else {
			var x0 = this.x > toUnion.x ? toUnion.x : this.x;
			var x1 = this.get_right() < toUnion.get_right() ? toUnion.get_right() : this.get_right();
			var y0 = this.y > toUnion.y ? toUnion.y : this.y;
			var y1 = this.get_bottom() < toUnion.get_bottom() ? toUnion.get_bottom() : this.get_bottom();
			result.setTo(x0,y0,x1 - x0,y1 - y0);
		}
		return result;
	},
	__toFlashRectangle: function() {
		return null;
	},
	get_bottom: function() {
		return this.y + this.height;
	},
	set_bottom: function(b) {
		this.height = b - this.y;
		return b;
	},
	get_bottomRight: function() {
		return new (lime_math_Vector2().default)(this.x + this.width,this.y + this.height);
	},
	set_bottomRight: function(p) {
		this.width = p.x - this.x;
		this.height = p.y - this.y;
		return p.clone();
	},
	get_left: function() {
		return this.x;
	},
	set_left: function(l) {
		this.width -= l - this.x;
		this.x = l;
		return l;
	},
	get_right: function() {
		return this.x + this.width;
	},
	set_right: function(r) {
		this.width = r - this.x;
		return r;
	},
	get_size: function() {
		return new (lime_math_Vector2().default)(this.width,this.height);
	},
	set_size: function(p) {
		this.width = p.x;
		this.height = p.y;
		return p.clone();
	},
	get_top: function() {
		return this.y;
	},
	set_top: function(t) {
		this.height -= t - this.y;
		this.y = t;
		return t;
	},
	get_topLeft: function() {
		return new (lime_math_Vector2().default)(this.x,this.y);
	},
	set_topLeft: function(p) {
		this.x = p.x;
		this.y = p.y;
		return p.clone();
	}
};
Rectangle.prototype.__class__ = Rectangle.prototype.constructor = $hxClasses["lime.math.Rectangle"] = Rectangle;

// Init



// Statics




// Export

exports.default = Rectangle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/math/Vector2.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/math/Vector2.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.math.Vector2

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var Vector2 = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
}

// Meta

Vector2.__name__ = "lime.math.Vector2";
Vector2.__isInterface__ = false;
Vector2.prototype = {
	add: function(v,result) {
		if(result == null) {
			result = new Vector2();
		}
		result.setTo(v.x + this.x,v.y + this.y);
		return result;
	},
	clone: function() {
		return new Vector2(this.x,this.y);
	},
	equals: function(toCompare) {
		if(toCompare != null && toCompare.x == this.x) {
			return toCompare.y == this.y;
		} else {
			return false;
		}
	},
	normalize: function(thickness) {
		if(this.x == 0 && this.y == 0) {
			return;
		} else {
			var norm = thickness / Math.sqrt(this.x * this.x + this.y * this.y);
			this.x *= norm;
			this.y *= norm;
		}
	},
	offset: function(dx,dy) {
		this.x += dx;
		this.y += dy;
	},
	setTo: function(xa,ya) {
		this.x = xa;
		this.y = ya;
	},
	subtract: function(v,result) {
		if(result == null) {
			result = new Vector2();
		}
		result.setTo(this.x - v.x,this.y - v.y);
		return result;
	},
	__toFlashPoint: function() {
		return null;
	},
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},
	get_lengthSquared: function() {
		return this.x * this.x + this.y * this.y;
	}
};
Vector2.prototype.__class__ = Vector2.prototype.constructor = $hxClasses["lime.math.Vector2"] = Vector2;

// Init



// Statics

Vector2.distance = function(pt1,pt2) {
	var dx = pt1.x - pt2.x;
	var dy = pt1.y - pt2.y;
	return Math.sqrt(dx * dx + dy * dy);
}
Vector2.interpolate = function(pt1,pt2,f,result) {
	if(result == null) {
		result = new Vector2();
	}
	result.setTo(pt2.x + f * (pt1.x - pt2.x),pt2.y + f * (pt1.y - pt2.y));
	return result;
}
Vector2.polar = function(len,angle,result) {
	if(result == null) {
		result = new Vector2();
	}
	result.setTo(len * Math.cos(angle),len * Math.sin(angle));
	return result;
}


// Export

exports.default = Vector2;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/math/Vector4.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/math/Vector4.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.math.Vector4

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var Vector4 = function(x,y,z,w) {
	if(w == null) {
		w = 0.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.w = w;
	this.x = x;
	this.y = y;
	this.z = z;
}

// Meta

Vector4.__name__ = "lime.math.Vector4";
Vector4.__isInterface__ = false;
Vector4.prototype = {
	add: function(a,result) {
		if(result == null) {
			result = new Vector4();
		}
		result.setTo(this.x + a.x,this.y + a.y,this.z + a.z);
		return result;
	},
	clone: function() {
		return new Vector4(this.x,this.y,this.z,this.w);
	},
	copyFrom: function(sourceVector4) {
		this.x = sourceVector4.x;
		this.y = sourceVector4.y;
		this.z = sourceVector4.z;
	},
	crossProduct: function(a,result) {
		if(result == null) {
			result = new Vector4();
		}
		result.setTo(this.y * a.z - this.z * a.y,this.z * a.x - this.x * a.z,this.x * a.y - this.y * a.x);
		result.w = 1;
		return result;
	},
	decrementBy: function(a) {
		this.x -= a.x;
		this.y -= a.y;
		this.z -= a.z;
	},
	dotProduct: function(a) {
		return this.x * a.x + this.y * a.y + this.z * a.z;
	},
	equals: function(toCompare,allFour) {
		if(allFour == null) {
			allFour = false;
		}
		if(this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z) {
			if(!(!allFour)) {
				return this.w == toCompare.w;
			} else {
				return true;
			}
		} else {
			return false;
		}
	},
	incrementBy: function(a) {
		this.x += a.x;
		this.y += a.y;
		this.z += a.z;
	},
	nearEquals: function(toCompare,tolerance,allFour) {
		if(allFour == null) {
			allFour = false;
		}
		if(Math.abs(this.x - toCompare.x) < tolerance && Math.abs(this.y - toCompare.y) < tolerance && Math.abs(this.z - toCompare.z) < tolerance) {
			if(!(!allFour)) {
				return Math.abs(this.w - toCompare.w) < tolerance;
			} else {
				return true;
			}
		} else {
			return false;
		}
	},
	negate: function() {
		this.x *= -1;
		this.y *= -1;
		this.z *= -1;
	},
	normalize: function() {
		var l = this.get_length();
		if(l != 0) {
			this.x /= l;
			this.y /= l;
			this.z /= l;
		}
		return l;
	},
	project: function() {
		this.x /= this.w;
		this.y /= this.w;
		this.z /= this.w;
	},
	scaleBy: function(s) {
		this.x *= s;
		this.y *= s;
		this.z *= s;
	},
	setTo: function(xa,ya,za) {
		this.x = xa;
		this.y = ya;
		this.z = za;
	},
	subtract: function(a,result) {
		if(result == null) {
			result = new Vector4();
		}
		result.setTo(this.x - a.x,this.y - a.y,this.z - a.z);
		return result;
	},
	toString: function() {
		return "Vector4(" + this.x + ", " + this.y + ", " + this.z + ")";
	},
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	},
	get_lengthSquared: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
};
Vector4.prototype.__class__ = Vector4.prototype.constructor = $hxClasses["lime.math.Vector4"] = Vector4;

// Init



// Statics

Vector4.angleBetween = function(a,b) {
	var a0 = a.clone();
	a0.normalize();
	var b0 = b.clone();
	b0.normalize();
	return Math.acos(a0.dotProduct(b0));
}
Vector4.distance = function(pt1,pt2) {
	var x = pt2.x - pt1.x;
	var y = pt2.y - pt1.y;
	var z = pt2.z - pt1.z;
	return Math.sqrt(x * x + y * y + z * z);
}
Vector4.distanceSquared = function(pt1,pt2) {
	var x = pt2.x - pt1.x;
	var y = pt2.y - pt1.y;
	var z = pt2.z - pt1.z;
	return x * x + y * y + z * z;
}
Vector4.get_X_AXIS = function() {
	return new Vector4(1,0,0);
}
Vector4.get_Y_AXIS = function() {
	return new Vector4(0,1,0);
}
Vector4.get_Z_AXIS = function() {
	return new Vector4(0,0,1);
}


// Export

exports.default = Vector4;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/math/_ColorMatrix/ColorMatrix_Impl_.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/math/_ColorMatrix/ColorMatrix_Impl_.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.math._ColorMatrix.ColorMatrix_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var ColorMatrix_Impl_ = function(){}

// Meta

ColorMatrix_Impl_.__name__ = "lime.math._ColorMatrix.ColorMatrix_Impl_";
ColorMatrix_Impl_.__isInterface__ = false;
ColorMatrix_Impl_.prototype = {
	
};
ColorMatrix_Impl_.prototype.__class__ = ColorMatrix_Impl_.prototype.constructor = $hxClasses["lime.math._ColorMatrix.ColorMatrix_Impl_"] = ColorMatrix_Impl_;

// Init



// Statics

ColorMatrix_Impl_._new = function(data) {
	var this1;
	if(data != null && data.length == 20) {
		this1 = data;
	} else {
		var elements = null;
		var array = ColorMatrix_Impl_.__identity;
		var view = null;
		var buffer = null;
		var len = null;
		var this2;
		if(elements != null) {
			this2 = new Float32Array(elements);
		} else if(array != null) {
			this2 = new Float32Array(array);
		} else if(view != null) {
			this2 = new Float32Array(view);
		} else if(buffer != null) {
			if(len == null) {
				this2 = new Float32Array(buffer,0);
			} else {
				this2 = new Float32Array(buffer,0,len);
			}
		} else {
			this2 = null;
		}
		this1 = this2;
	}
	return this1;
}
ColorMatrix_Impl_.clone = function(this1) {
	var elements = null;
	var array = null;
	var buffer = null;
	var len = null;
	var this2;
	if(elements != null) {
		this2 = new Float32Array(elements);
	} else if(array != null) {
		this2 = new Float32Array(array);
	} else if(this1 != null) {
		this2 = new Float32Array(this1);
	} else if(buffer != null) {
		if(len == null) {
			this2 = new Float32Array(buffer,0);
		} else {
			this2 = new Float32Array(buffer,0,len);
		}
	} else {
		this2 = null;
	}
	return ColorMatrix_Impl_._new(this2);
}
ColorMatrix_Impl_.concat = function(this1,second) {
	this1[0] += second[0];
	this1[6] += second[6];
	this1[12] += second[12];
	this1[18] += second[18];
}
ColorMatrix_Impl_.copyFrom = function(this1,other) {
	this1.set(other);
}
ColorMatrix_Impl_.identity = function(this1) {
	this1[0] = 1;
	this1[1] = 0;
	this1[2] = 0;
	this1[3] = 0;
	this1[4] = 0;
	this1[5] = 0;
	this1[6] = 1;
	this1[7] = 0;
	this1[8] = 0;
	this1[9] = 0;
	this1[10] = 0;
	this1[11] = 0;
	this1[12] = 1;
	this1[13] = 0;
	this1[14] = 0;
	this1[15] = 0;
	this1[16] = 0;
	this1[17] = 0;
	this1[18] = 1;
	this1[19] = 0;
}
ColorMatrix_Impl_.getAlphaTable = function(this1) {
	if(ColorMatrix_Impl_.__alphaTable == null) {
		var array = null;
		var view = null;
		var buffer = null;
		var len = null;
		var this2 = new Uint8Array(256);
		ColorMatrix_Impl_.__alphaTable = this2;
	}
	var value;
	ColorMatrix_Impl_.__alphaTable[0] = 0;
	var _g = 1;
	while(_g < 256) {
		var i = _g++;
		value = Math.floor(i * this1[18] + this1[19] * 255);
		if(value > 255) {
			value = 255;
		}
		if(value < 0) {
			value = 0;
		}
		ColorMatrix_Impl_.__alphaTable[i] = value;
	}
	return ColorMatrix_Impl_.__alphaTable;
}
ColorMatrix_Impl_.getBlueTable = function(this1) {
	if(ColorMatrix_Impl_.__blueTable == null) {
		var array = null;
		var view = null;
		var buffer = null;
		var len = null;
		var this2 = new Uint8Array(256);
		ColorMatrix_Impl_.__blueTable = this2;
	}
	var value;
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		value = Math.floor(i * this1[12] + this1[14] * 255);
		if(value > 255) {
			value = 255;
		}
		if(value < 0) {
			value = 0;
		}
		ColorMatrix_Impl_.__blueTable[i] = value;
	}
	return ColorMatrix_Impl_.__blueTable;
}
ColorMatrix_Impl_.getGreenTable = function(this1) {
	if(ColorMatrix_Impl_.__greenTable == null) {
		var array = null;
		var view = null;
		var buffer = null;
		var len = null;
		var this2 = new Uint8Array(256);
		ColorMatrix_Impl_.__greenTable = this2;
	}
	var value;
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		value = Math.floor(i * this1[6] + this1[9] * 255);
		if(value > 255) {
			value = 255;
		}
		if(value < 0) {
			value = 0;
		}
		ColorMatrix_Impl_.__greenTable[i] = value;
	}
	return ColorMatrix_Impl_.__greenTable;
}
ColorMatrix_Impl_.getRedTable = function(this1) {
	if(ColorMatrix_Impl_.__redTable == null) {
		var array = null;
		var view = null;
		var buffer = null;
		var len = null;
		var this2 = new Uint8Array(256);
		ColorMatrix_Impl_.__redTable = this2;
	}
	var value;
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		value = Math.floor(i * this1[0] + this1[4] * 255);
		if(value > 255) {
			value = 255;
		}
		if(value < 0) {
			value = 0;
		}
		ColorMatrix_Impl_.__redTable[i] = value;
	}
	return ColorMatrix_Impl_.__redTable;
}
ColorMatrix_Impl_.__toFlashColorTransform = function(this1) {
	return null;
}
ColorMatrix_Impl_.get_alphaMultiplier = function(this1) {
	return this1[18];
}
ColorMatrix_Impl_.set_alphaMultiplier = function(this1,value) {
	return this1[18] = value;
}
ColorMatrix_Impl_.get_alphaOffset = function(this1) {
	return this1[19] * 255;
}
ColorMatrix_Impl_.set_alphaOffset = function(this1,value) {
	return this1[19] = value / 255;
}
ColorMatrix_Impl_.get_blueMultiplier = function(this1) {
	return this1[12];
}
ColorMatrix_Impl_.set_blueMultiplier = function(this1,value) {
	return this1[12] = value;
}
ColorMatrix_Impl_.get_blueOffset = function(this1) {
	return this1[14] * 255;
}
ColorMatrix_Impl_.set_blueOffset = function(this1,value) {
	return this1[14] = value / 255;
}
ColorMatrix_Impl_.get_color = function(this1) {
	return (Std().default).int(this1[4] * 255) << 16 | (Std().default).int(this1[9] * 255) << 8 | (Std().default).int(this1[14] * 255);
}
ColorMatrix_Impl_.set_color = function(this1,value) {
	this1[4] = (value >> 16 & 255) / 255;
	this1[9] = (value >> 8 & 255) / 255;
	this1[14] = (value & 255) / 255;
	this1[0] = 0;
	this1[6] = 0;
	this1[12] = 0;
	return ColorMatrix_Impl_.get_color(this1);
}
ColorMatrix_Impl_.get_greenMultiplier = function(this1) {
	return this1[6];
}
ColorMatrix_Impl_.set_greenMultiplier = function(this1,value) {
	return this1[6] = value;
}
ColorMatrix_Impl_.get_greenOffset = function(this1) {
	return this1[9] * 255;
}
ColorMatrix_Impl_.set_greenOffset = function(this1,value) {
	return this1[9] = value / 255;
}
ColorMatrix_Impl_.get_redMultiplier = function(this1) {
	return this1[0];
}
ColorMatrix_Impl_.set_redMultiplier = function(this1,value) {
	return this1[0] = value;
}
ColorMatrix_Impl_.get_redOffset = function(this1) {
	return this1[4] * 255;
}
ColorMatrix_Impl_.set_redOffset = function(this1,value) {
	return this1[4] = value / 255;
}
ColorMatrix_Impl_.get = function(this1,index) {
	return this1[index];
}
ColorMatrix_Impl_.set = function(this1,index,value) {
	return this1[index] = value;
}
ColorMatrix_Impl_.__identity = [1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0]

// Export

exports.default = ColorMatrix_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/math/_Matrix4/Matrix4_Impl_.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/math/_Matrix4/Matrix4_Impl_.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.math._Matrix4.Matrix4_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_utils_Log() {return __webpack_require__(/*! ./../../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function lime_math_Vector4() {return __webpack_require__(/*! ./../../../lime/math/Vector4 */ "./node_modules/openfl/lib/_gen/lime/math/Vector4.js");}

// Constructor

var Matrix4_Impl_ = function(){}

// Meta

Matrix4_Impl_.__name__ = "lime.math._Matrix4.Matrix4_Impl_";
Matrix4_Impl_.__isInterface__ = false;
Matrix4_Impl_.prototype = {
	
};
Matrix4_Impl_.prototype.__class__ = Matrix4_Impl_.prototype.constructor = $hxClasses["lime.math._Matrix4.Matrix4_Impl_"] = Matrix4_Impl_;

// Init



// Statics

Matrix4_Impl_._new = function(data) {
	var this1;
	if(data != null && data.length == 16) {
		this1 = data;
	} else {
		var elements = null;
		var array = Matrix4_Impl_.__identity;
		var view = null;
		var buffer = null;
		var len = null;
		var this2;
		if(elements != null) {
			this2 = new Float32Array(elements);
		} else if(array != null) {
			this2 = new Float32Array(array);
		} else if(view != null) {
			this2 = new Float32Array(view);
		} else if(buffer != null) {
			if(len == null) {
				this2 = new Float32Array(buffer,0);
			} else {
				this2 = new Float32Array(buffer,0,len);
			}
		} else {
			this2 = null;
		}
		this1 = this2;
	}
	return this1;
}
Matrix4_Impl_.append = function(this1,lhs) {
	var m111 = this1[0];
	var m121 = this1[4];
	var m131 = this1[8];
	var m141 = this1[12];
	var m112 = this1[1];
	var m122 = this1[5];
	var m132 = this1[9];
	var m142 = this1[13];
	var m113 = this1[2];
	var m123 = this1[6];
	var m133 = this1[10];
	var m143 = this1[14];
	var m114 = this1[3];
	var m124 = this1[7];
	var m134 = this1[11];
	var m144 = this1[15];
	var m211 = Matrix4_Impl_.get(lhs,0);
	var m221 = Matrix4_Impl_.get(lhs,4);
	var m231 = Matrix4_Impl_.get(lhs,8);
	var m241 = Matrix4_Impl_.get(lhs,12);
	var m212 = Matrix4_Impl_.get(lhs,1);
	var m222 = Matrix4_Impl_.get(lhs,5);
	var m232 = Matrix4_Impl_.get(lhs,9);
	var m242 = Matrix4_Impl_.get(lhs,13);
	var m213 = Matrix4_Impl_.get(lhs,2);
	var m223 = Matrix4_Impl_.get(lhs,6);
	var m233 = Matrix4_Impl_.get(lhs,10);
	var m243 = Matrix4_Impl_.get(lhs,14);
	var m214 = Matrix4_Impl_.get(lhs,3);
	var m224 = Matrix4_Impl_.get(lhs,7);
	var m234 = Matrix4_Impl_.get(lhs,11);
	var m244 = Matrix4_Impl_.get(lhs,15);
	this1[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
	this1[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
	this1[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
	this1[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
	this1[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
	this1[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
	this1[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
	this1[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
	this1[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
	this1[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
	this1[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
	this1[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
	this1[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
	this1[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
	this1[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
	this1[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
}
Matrix4_Impl_.appendRotation = function(this1,degrees,axis,pivotPoint) {
	var m = Matrix4_Impl_.__getAxisRotation(this1,axis.x,axis.y,axis.z,degrees);
	if(pivotPoint != null) {
		var p = pivotPoint;
		Matrix4_Impl_.appendTranslation(m,p.x,p.y,p.z);
	}
	Matrix4_Impl_.append(this1,m);
}
Matrix4_Impl_.appendScale = function(this1,xScale,yScale,zScale) {
	var elements = null;
	var array = [xScale,0.0,0.0,0.0,0.0,yScale,0.0,0.0,0.0,0.0,zScale,0.0,0.0,0.0,0.0,1.0];
	var view = null;
	var buffer = null;
	var len = null;
	var this2;
	if(elements != null) {
		this2 = new Float32Array(elements);
	} else if(array != null) {
		this2 = new Float32Array(array);
	} else if(view != null) {
		this2 = new Float32Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this2 = new Float32Array(buffer,0);
		} else {
			this2 = new Float32Array(buffer,0,len);
		}
	} else {
		this2 = null;
	}
	Matrix4_Impl_.append(this1,Matrix4_Impl_._new(this2));
}
Matrix4_Impl_.appendTranslation = function(this1,x,y,z) {
	this1[12] += x;
	this1[13] += y;
	this1[14] += z;
}
Matrix4_Impl_.clone = function(this1) {
	var elements = null;
	var array = null;
	var buffer = null;
	var len = null;
	var this2;
	if(elements != null) {
		this2 = new Float32Array(elements);
	} else if(array != null) {
		this2 = new Float32Array(array);
	} else if(this1 != null) {
		this2 = new Float32Array(this1);
	} else if(buffer != null) {
		if(len == null) {
			this2 = new Float32Array(buffer,0);
		} else {
			this2 = new Float32Array(buffer,0,len);
		}
	} else {
		this2 = null;
	}
	return Matrix4_Impl_._new(this2);
}
Matrix4_Impl_.copyColumnFrom = function(this1,column,vector) {
	switch(column) {
	case 0:
		this1[0] = vector.x;
		this1[1] = vector.y;
		this1[2] = vector.z;
		this1[3] = vector.w;
		break;
	case 1:
		this1[4] = vector.x;
		this1[5] = vector.y;
		this1[6] = vector.z;
		this1[7] = vector.w;
		break;
	case 2:
		this1[8] = vector.x;
		this1[9] = vector.y;
		this1[10] = vector.z;
		this1[11] = vector.w;
		break;
	case 3:
		this1[12] = vector.x;
		this1[13] = vector.y;
		this1[14] = vector.z;
		this1[15] = vector.w;
		break;
	default:
		(lime_utils_Log().default).error("Column " + column + " out of bounds [0, ..., 3]",{ fileName : "../node_modules/lime/src/lime/math/Matrix4.hx", lineNumber : 187, className : "lime.math._Matrix4.Matrix4_Impl_", methodName : "copyColumnFrom"});
	}
}
Matrix4_Impl_.copyColumnTo = function(this1,column,vector) {
	switch(column) {
	case 0:
		vector.x = this1[0];
		vector.y = this1[1];
		vector.z = this1[2];
		vector.w = this1[3];
		break;
	case 1:
		vector.x = this1[4];
		vector.y = this1[5];
		vector.z = this1[6];
		vector.w = this1[7];
		break;
	case 2:
		vector.x = this1[8];
		vector.y = this1[9];
		vector.z = this1[10];
		vector.w = this1[11];
		break;
	case 3:
		vector.x = this1[12];
		vector.y = this1[13];
		vector.z = this1[14];
		vector.w = this1[15];
		break;
	default:
		(lime_utils_Log().default).error("Column " + column + " out of bounds [0, ..., 3]",{ fileName : "../node_modules/lime/src/lime/math/Matrix4.hx", lineNumber : 225, className : "lime.math._Matrix4.Matrix4_Impl_", methodName : "copyColumnTo"});
	}
}
Matrix4_Impl_.copyFrom = function(this1,other) {
	this1.set(other);
}
Matrix4_Impl_.copyRowFrom = function(this1,row,vector) {
	switch(row) {
	case 0:
		this1[0] = vector.x;
		this1[4] = vector.y;
		this1[8] = vector.z;
		this1[12] = vector.w;
		break;
	case 1:
		this1[1] = vector.x;
		this1[5] = vector.y;
		this1[9] = vector.z;
		this1[13] = vector.w;
		break;
	case 2:
		this1[2] = vector.x;
		this1[6] = vector.y;
		this1[10] = vector.z;
		this1[14] = vector.w;
		break;
	case 3:
		this1[3] = vector.x;
		this1[7] = vector.y;
		this1[11] = vector.z;
		this1[15] = vector.w;
		break;
	default:
		(lime_utils_Log().default).error("Row " + row + " out of bounds [0, ..., 3]",{ fileName : "../node_modules/lime/src/lime/math/Matrix4.hx", lineNumber : 272, className : "lime.math._Matrix4.Matrix4_Impl_", methodName : "copyRowFrom"});
	}
}
Matrix4_Impl_.copyRowTo = function(this1,row,vector) {
	switch(row) {
	case 0:
		vector.x = this1[0];
		vector.y = this1[4];
		vector.z = this1[8];
		vector.w = this1[12];
		break;
	case 1:
		vector.x = this1[1];
		vector.y = this1[5];
		vector.z = this1[9];
		vector.w = this1[13];
		break;
	case 2:
		vector.x = this1[2];
		vector.y = this1[6];
		vector.z = this1[10];
		vector.w = this1[14];
		break;
	case 3:
		vector.x = this1[3];
		vector.y = this1[7];
		vector.z = this1[11];
		vector.w = this1[15];
		break;
	default:
		(lime_utils_Log().default).error("Row " + row + " out of bounds [0, ..., 3]",{ fileName : "../node_modules/lime/src/lime/math/Matrix4.hx", lineNumber : 310, className : "lime.math._Matrix4.Matrix4_Impl_", methodName : "copyRowTo"});
	}
}
Matrix4_Impl_.create2D = function(this1,a,b,c,d,tx,ty) {
	if(ty == null) {
		ty = 0;
	}
	if(tx == null) {
		tx = 0;
	}
	this1[0] = a;
	this1[1] = b;
	this1[2] = 0;
	this1[3] = 0;
	this1[4] = c;
	this1[5] = d;
	this1[6] = 0;
	this1[7] = 0;
	this1[8] = 0;
	this1[9] = 0;
	this1[10] = 1;
	this1[11] = 0;
	this1[12] = tx;
	this1[13] = ty;
	this1[14] = 0;
	this1[15] = 1;
}
Matrix4_Impl_.createOrtho = function(this1,left,right,bottom,top,zNear,zFar) {
	var sx = 1.0 / (right - left);
	var sy = 1.0 / (top - bottom);
	var sz = 1.0 / (zFar - zNear);
	this1[0] = 2 * sx;
	this1[1] = 0;
	this1[2] = 0;
	this1[3] = 0;
	this1[4] = 0;
	this1[5] = 2 * sy;
	this1[6] = 0;
	this1[7] = 0;
	this1[8] = 0;
	this1[9] = 0;
	this1[10] = -2 * sz;
	this1[11] = 0;
	this1[12] = -(left + right) * sx;
	this1[13] = -(bottom + top) * sy;
	this1[14] = -(zNear + zFar) * sz;
	this1[15] = 1;
}
Matrix4_Impl_.deltaTransformVector = function(this1,v,result) {
	if(result == null) {
		result = new (lime_math_Vector4().default)();
	}
	var x = v.x;
	var y = v.y;
	var z = v.z;
	result.x = x * this1[0] + y * this1[4] + z * this1[8] + this1[3];
	result.y = x * this1[1] + y * this1[5] + z * this1[9] + this1[7];
	result.z = x * this1[2] + y * this1[6] + z * this1[10] + this1[11];
	return result;
}
Matrix4_Impl_.fromMatrix3 = function(matrix3) {
	var mat = Matrix4_Impl_._new();
	Matrix4_Impl_.create2D(mat,matrix3.a,matrix3.b,matrix3.c,matrix3.d,matrix3.tx,matrix3.ty);
	return mat;
}
Matrix4_Impl_.identity = function(this1) {
	this1[0] = 1;
	this1[1] = 0;
	this1[2] = 0;
	this1[3] = 0;
	this1[4] = 0;
	this1[5] = 1;
	this1[6] = 0;
	this1[7] = 0;
	this1[8] = 0;
	this1[9] = 0;
	this1[10] = 1;
	this1[11] = 0;
	this1[12] = 0;
	this1[13] = 0;
	this1[14] = 0;
	this1[15] = 1;
}
Matrix4_Impl_.interpolate = function(thisMat,toMat,percent,result) {
	if(result == null) {
		result = Matrix4_Impl_._new();
	}
	var _g = 0;
	while(_g < 16) {
		var i = _g++;
		Matrix4_Impl_.set(result,i,Matrix4_Impl_.get(thisMat,i) + (Matrix4_Impl_.get(toMat,i) - Matrix4_Impl_.get(thisMat,i)) * percent);
	}
	return result;
}
Matrix4_Impl_.interpolateTo = function(this1,toMat,percent) {
	var _g = 0;
	while(_g < 16) {
		var i = _g++;
		this1[i] += (Matrix4_Impl_.get(toMat,i) - this1[i]) * percent;
	}
}
Matrix4_Impl_.invert = function(this1) {
	var d = Matrix4_Impl_.get_determinant(this1);
	var invertable = Math.abs(d) > 0.00000000001;
	if(invertable) {
		d = 1 / d;
		var m11 = this1[0];
		var m21 = this1[4];
		var m31 = this1[8];
		var m41 = this1[12];
		var m12 = this1[1];
		var m22 = this1[5];
		var m32 = this1[9];
		var m42 = this1[13];
		var m13 = this1[2];
		var m23 = this1[6];
		var m33 = this1[10];
		var m43 = this1[14];
		var m14 = this1[3];
		var m24 = this1[7];
		var m34 = this1[11];
		var m44 = this1[15];
		this1[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
		this1[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
		this1[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
		this1[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
		this1[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
		this1[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
		this1[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
		this1[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
		this1[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
		this1[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
		this1[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
		this1[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
		this1[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
		this1[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
		this1[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
		this1[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
	}
	return invertable;
}
Matrix4_Impl_.pointAt = function(this1,pos,at,up) {
	if(at == null) {
		at = new (lime_math_Vector4().default)(0,0,1);
	}
	if(up == null) {
		up = new (lime_math_Vector4().default)(0,1,0);
	}
	var dir = pos.subtract(at);
	var vup = up.clone();
	dir.normalize();
	vup.normalize();
	var dir2 = dir.clone();
	dir2.scaleBy(vup.dotProduct(dir));
	vup = vup.subtract(dir2);
	if(vup.get_length() > 0) {
		vup.normalize();
	} else if(dir.x != 0) {
		vup = new (lime_math_Vector4().default)(-dir.y,dir.x,0);
	} else {
		vup = new (lime_math_Vector4().default)(1,0,0);
	}
	var right = vup.crossProduct(dir);
	right.normalize();
	this1[0] = right.x;
	this1[4] = right.y;
	this1[8] = right.z;
	this1[12] = 0.0;
	this1[1] = vup.x;
	this1[5] = vup.y;
	this1[9] = vup.z;
	this1[13] = 0.0;
	this1[2] = dir.x;
	this1[6] = dir.y;
	this1[10] = dir.z;
	this1[14] = 0.0;
	this1[3] = pos.x;
	this1[7] = pos.y;
	this1[11] = pos.z;
	this1[15] = 1.0;
}
Matrix4_Impl_.prepend = function(this1,rhs) {
	var m111 = Matrix4_Impl_.get(rhs,0);
	var m121 = Matrix4_Impl_.get(rhs,4);
	var m131 = Matrix4_Impl_.get(rhs,8);
	var m141 = Matrix4_Impl_.get(rhs,12);
	var m112 = Matrix4_Impl_.get(rhs,1);
	var m122 = Matrix4_Impl_.get(rhs,5);
	var m132 = Matrix4_Impl_.get(rhs,9);
	var m142 = Matrix4_Impl_.get(rhs,13);
	var m113 = Matrix4_Impl_.get(rhs,2);
	var m123 = Matrix4_Impl_.get(rhs,6);
	var m133 = Matrix4_Impl_.get(rhs,10);
	var m143 = Matrix4_Impl_.get(rhs,14);
	var m114 = Matrix4_Impl_.get(rhs,3);
	var m124 = Matrix4_Impl_.get(rhs,7);
	var m134 = Matrix4_Impl_.get(rhs,11);
	var m144 = Matrix4_Impl_.get(rhs,15);
	var m211 = this1[0];
	var m221 = this1[4];
	var m231 = this1[8];
	var m241 = this1[12];
	var m212 = this1[1];
	var m222 = this1[5];
	var m232 = this1[9];
	var m242 = this1[13];
	var m213 = this1[2];
	var m223 = this1[6];
	var m233 = this1[10];
	var m243 = this1[14];
	var m214 = this1[3];
	var m224 = this1[7];
	var m234 = this1[11];
	var m244 = this1[15];
	this1[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
	this1[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
	this1[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
	this1[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
	this1[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
	this1[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
	this1[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
	this1[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
	this1[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
	this1[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
	this1[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
	this1[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
	this1[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
	this1[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
	this1[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
	this1[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
}
Matrix4_Impl_.prependRotation = function(this1,degrees,axis,pivotPoint) {
	var m = Matrix4_Impl_.__getAxisRotation(this1,axis.x,axis.y,axis.z,degrees);
	if(pivotPoint != null) {
		var p = pivotPoint;
		Matrix4_Impl_.appendTranslation(m,p.x,p.y,p.z);
	}
	Matrix4_Impl_.prepend(this1,m);
}
Matrix4_Impl_.prependScale = function(this1,xScale,yScale,zScale) {
	var elements = null;
	var array = [xScale,0.0,0.0,0.0,0.0,yScale,0.0,0.0,0.0,0.0,zScale,0.0,0.0,0.0,0.0,1.0];
	var view = null;
	var buffer = null;
	var len = null;
	var this2;
	if(elements != null) {
		this2 = new Float32Array(elements);
	} else if(array != null) {
		this2 = new Float32Array(array);
	} else if(view != null) {
		this2 = new Float32Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this2 = new Float32Array(buffer,0);
		} else {
			this2 = new Float32Array(buffer,0,len);
		}
	} else {
		this2 = null;
	}
	Matrix4_Impl_.prepend(this1,Matrix4_Impl_._new(this2));
}
Matrix4_Impl_.prependTranslation = function(this1,x,y,z) {
	var m = Matrix4_Impl_._new();
	Matrix4_Impl_.set_position(m,new (lime_math_Vector4().default)(x,y,z));
	Matrix4_Impl_.prepend(this1,m);
}
Matrix4_Impl_.transformVector = function(this1,v,result) {
	if(result == null) {
		result = new (lime_math_Vector4().default)();
	}
	var x = v.x;
	var y = v.y;
	var z = v.z;
	result.x = x * this1[0] + y * this1[4] + z * this1[8] + this1[12];
	result.y = x * this1[1] + y * this1[5] + z * this1[9] + this1[13];
	result.z = x * this1[2] + y * this1[6] + z * this1[10] + this1[14];
	result.w = x * this1[3] + y * this1[7] + z * this1[11] + this1[15];
	return result;
}
Matrix4_Impl_.transformVectors = function(this1,ain,aout) {
	var i = 0;
	var x;
	var y;
	var z;
	while(i + 3 <= ain.length) {
		x = ain[i];
		y = ain[i + 1];
		z = ain[i + 2];
		aout[i] = x * this1[0] + y * this1[4] + z * this1[8] + this1[12];
		aout[i + 1] = x * this1[1] + y * this1[5] + z * this1[9] + this1[13];
		aout[i + 2] = x * this1[2] + y * this1[6] + z * this1[10] + this1[14];
		i += 3;
	}
}
Matrix4_Impl_.transpose = function(this1) {
	var temp = this1[1];
	this1[1] = this1[4];
	this1[4] = temp;
	var temp1 = this1[2];
	this1[2] = this1[8];
	this1[8] = temp1;
	var temp2 = this1[3];
	this1[3] = this1[12];
	this1[12] = temp2;
	var temp3 = this1[6];
	this1[6] = this1[9];
	this1[9] = temp3;
	var temp4 = this1[7];
	this1[7] = this1[13];
	this1[13] = temp4;
	var temp5 = this1[11];
	this1[11] = this1[14];
	this1[14] = temp5;
}
Matrix4_Impl_.__getAxisRotation = function(this1,x,y,z,degrees) {
	var m = Matrix4_Impl_._new();
	var a1 = new (lime_math_Vector4().default)(x,y,z);
	var rad = -degrees * (Math.PI / 180);
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var t = 1.0 - c;
	Matrix4_Impl_.set(m,0,c + a1.x * a1.x * t);
	Matrix4_Impl_.set(m,5,c + a1.y * a1.y * t);
	Matrix4_Impl_.set(m,10,c + a1.z * a1.z * t);
	var tmp1 = a1.x * a1.y * t;
	var tmp2 = a1.z * s;
	Matrix4_Impl_.set(m,4,tmp1 + tmp2);
	Matrix4_Impl_.set(m,1,tmp1 - tmp2);
	tmp1 = a1.x * a1.z * t;
	tmp2 = a1.y * s;
	Matrix4_Impl_.set(m,8,tmp1 - tmp2);
	Matrix4_Impl_.set(m,2,tmp1 + tmp2);
	tmp1 = a1.y * a1.z * t;
	tmp2 = a1.x * s;
	Matrix4_Impl_.set(m,9,tmp1 + tmp2);
	Matrix4_Impl_.set(m,6,tmp1 - tmp2);
	return m;
}
Matrix4_Impl_.__swap = function(this1,a,b) {
	var temp = this1[a];
	this1[a] = this1[b];
	this1[b] = temp;
}
Matrix4_Impl_.get_determinant = function(this1) {
	return (this1[0] * this1[5] - this1[4] * this1[1]) * (this1[10] * this1[15] - this1[14] * this1[11]) - (this1[0] * this1[9] - this1[8] * this1[1]) * (this1[6] * this1[15] - this1[14] * this1[7]) + (this1[0] * this1[13] - this1[12] * this1[1]) * (this1[6] * this1[11] - this1[10] * this1[7]) + (this1[4] * this1[9] - this1[8] * this1[5]) * (this1[2] * this1[15] - this1[14] * this1[3]) - (this1[4] * this1[13] - this1[12] * this1[5]) * (this1[2] * this1[11] - this1[10] * this1[3]) + (this1[8] * this1[13] - this1[12] * this1[9]) * (this1[2] * this1[7] - this1[6] * this1[3]);
}
Matrix4_Impl_.get_position = function(this1) {
	return new (lime_math_Vector4().default)(this1[12],this1[13],this1[14]);
}
Matrix4_Impl_.set_position = function(this1,val) {
	this1[12] = val.x;
	this1[13] = val.y;
	this1[14] = val.z;
	return val;
}
Matrix4_Impl_.get = function(this1,index) {
	return this1[index];
}
Matrix4_Impl_.set = function(this1,index,value) {
	this1[index] = value;
	return value;
}
Matrix4_Impl_.__identity = [1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0]

// Export

exports.default = Matrix4_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/math/_RGBA/RGBA_Impl_.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/math/_RGBA/RGBA_Impl_.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.math._RGBA.RGBA_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var RGBA_Impl_ = function(){}

// Meta

RGBA_Impl_.__name__ = "lime.math._RGBA.RGBA_Impl_";
RGBA_Impl_.__isInterface__ = false;
RGBA_Impl_.prototype = {
	
};
RGBA_Impl_.prototype.__class__ = RGBA_Impl_.prototype.constructor = $hxClasses["lime.math._RGBA.RGBA_Impl_"] = RGBA_Impl_;

// Init

{
	var array = null;
	var view = null;
	var buffer = null;
	var len = null;
	var this1 = new Uint32Array(256);
	RGBA_Impl_.__alpha16 = this1;
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		RGBA_Impl_.__alpha16[i] = Math.ceil(i * 257.003921568627447);
	}
	var array1 = null;
	var view1 = null;
	var buffer1 = null;
	var len1 = null;
	var this2 = new Uint8Array(511);
	RGBA_Impl_.__clamp = this2;
	var _g1 = 0;
	while(_g1 < 255) {
		var i1 = _g1++;
		RGBA_Impl_.__clamp[i1] = i1;
	}
	var _g2 = 255;
	var _g3 = 511;
	while(_g2 < _g3) {
		var i2 = _g2++;
		RGBA_Impl_.__clamp[i2] = 255;
	}
};

// Statics

RGBA_Impl_._new = function(rgba) {
	if(rgba == null) {
		rgba = 0;
	}
	var this1 = rgba;
	return this1;
}
RGBA_Impl_.create = function(r,g,b,a) {
	var this1 = 0;
	var rgba = this1;
	rgba = (r & 255) << 24 | (g & 255) << 16 | (b & 255) << 8 | a & 255;
	return rgba;
}
RGBA_Impl_.multiplyAlpha = function(this1) {
	if((this1 & 255) == 0) {
		if(this1 != 0) {
			this1 = 0;
		}
	} else if((this1 & 255) != 255) {
		RGBA_Impl_.a16 = RGBA_Impl_.__alpha16[this1 & 255];
		this1 = ((this1 >>> 24 & 255) * RGBA_Impl_.a16 >> 16 & 255) << 24 | ((this1 >>> 16 & 255) * RGBA_Impl_.a16 >> 16 & 255) << 16 | ((this1 >>> 8 & 255) * RGBA_Impl_.a16 >> 16 & 255) << 8 | this1 & 255 & 255;
	}
}
RGBA_Impl_.readUInt8 = function(this1,data,offset,format,premultiplied) {
	if(premultiplied == null) {
		premultiplied = false;
	}
	if(format == null) {
		format = 0;
	}
	switch(format) {
	case 0:
		this1 = (data[offset] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset + 2] & 255) << 8 | data[offset + 3] & 255;
		break;
	case 1:
		this1 = (data[offset + 1] & 255) << 24 | (data[offset + 2] & 255) << 16 | (data[offset + 3] & 255) << 8 | data[offset] & 255;
		break;
	case 2:
		this1 = (data[offset + 2] & 255) << 24 | (data[offset + 1] & 255) << 16 | (data[offset] & 255) << 8 | data[offset + 3] & 255;
		break;
	}
	if(premultiplied) {
		if((this1 & 255) != 0 && (this1 & 255) != 255) {
			RGBA_Impl_.unmult = 255.0 / (this1 & 255);
			this1 = (RGBA_Impl_.__clamp[Math.round((this1 >>> 24 & 255) * RGBA_Impl_.unmult)] & 255) << 24 | (RGBA_Impl_.__clamp[Math.round((this1 >>> 16 & 255) * RGBA_Impl_.unmult)] & 255) << 16 | (RGBA_Impl_.__clamp[Math.round((this1 >>> 8 & 255) * RGBA_Impl_.unmult)] & 255) << 8 | this1 & 255 & 255;
		}
	}
}
RGBA_Impl_.set = function(this1,r,g,b,a) {
	this1 = (r & 255) << 24 | (g & 255) << 16 | (b & 255) << 8 | a & 255;
}
RGBA_Impl_.unmultiplyAlpha = function(this1) {
	if((this1 & 255) != 0 && (this1 & 255) != 255) {
		RGBA_Impl_.unmult = 255.0 / (this1 & 255);
		this1 = (RGBA_Impl_.__clamp[Math.round((this1 >>> 24 & 255) * RGBA_Impl_.unmult)] & 255) << 24 | (RGBA_Impl_.__clamp[Math.round((this1 >>> 16 & 255) * RGBA_Impl_.unmult)] & 255) << 16 | (RGBA_Impl_.__clamp[Math.round((this1 >>> 8 & 255) * RGBA_Impl_.unmult)] & 255) << 8 | this1 & 255 & 255;
	}
}
RGBA_Impl_.writeUInt8 = function(this1,data,offset,format,premultiplied) {
	if(premultiplied == null) {
		premultiplied = false;
	}
	if(format == null) {
		format = 0;
	}
	if(premultiplied) {
		if((this1 & 255) == 0) {
			if(this1 != 0) {
				this1 = 0;
			}
		} else if((this1 & 255) != 255) {
			RGBA_Impl_.a16 = RGBA_Impl_.__alpha16[this1 & 255];
			this1 = ((this1 >>> 24 & 255) * RGBA_Impl_.a16 >> 16 & 255) << 24 | ((this1 >>> 16 & 255) * RGBA_Impl_.a16 >> 16 & 255) << 16 | ((this1 >>> 8 & 255) * RGBA_Impl_.a16 >> 16 & 255) << 8 | this1 & 255 & 255;
		}
	}
	switch(format) {
	case 0:
		data[offset] = this1 >>> 24 & 255;
		data[offset + 1] = this1 >>> 16 & 255;
		data[offset + 2] = this1 >>> 8 & 255;
		data[offset + 3] = this1 & 255;
		break;
	case 1:
		data[offset] = this1 & 255;
		data[offset + 1] = this1 >>> 24 & 255;
		data[offset + 2] = this1 >>> 16 & 255;
		data[offset + 3] = this1 >>> 8 & 255;
		break;
	case 2:
		data[offset] = this1 >>> 8 & 255;
		data[offset + 1] = this1 >>> 16 & 255;
		data[offset + 2] = this1 >>> 24 & 255;
		data[offset + 3] = this1 & 255;
		break;
	}
}
RGBA_Impl_.__fromARGB = function(argb) {
	var this1 = 0;
	var rgba = this1;
	rgba = (argb >>> 16 & 255 & 255) << 24 | (argb >>> 8 & 255 & 255) << 16 | (argb & 255 & 255) << 8 | argb >>> 24 & 255 & 255;
	return rgba;
}
RGBA_Impl_.__fromBGRA = function(bgra) {
	var this1 = 0;
	var rgba = this1;
	rgba = (bgra >>> 8 & 255 & 255) << 24 | (bgra >>> 16 & 255 & 255) << 16 | (bgra >>> 24 & 255 & 255) << 8 | bgra & 255 & 255;
	return rgba;
}
RGBA_Impl_.get_a = function(this1) {
	return this1 & 255;
}
RGBA_Impl_.set_a = function(this1,value) {
	this1 = (this1 >>> 24 & 255 & 255) << 24 | (this1 >>> 16 & 255 & 255) << 16 | (this1 >>> 8 & 255 & 255) << 8 | value & 255;
	return value;
}
RGBA_Impl_.get_b = function(this1) {
	return this1 >>> 8 & 255;
}
RGBA_Impl_.set_b = function(this1,value) {
	this1 = (this1 >>> 24 & 255 & 255) << 24 | (this1 >>> 16 & 255 & 255) << 16 | (value & 255) << 8 | this1 & 255 & 255;
	return value;
}
RGBA_Impl_.get_g = function(this1) {
	return this1 >>> 16 & 255;
}
RGBA_Impl_.set_g = function(this1,value) {
	this1 = (this1 >>> 24 & 255 & 255) << 24 | (value & 255) << 16 | (this1 >>> 8 & 255 & 255) << 8 | this1 & 255 & 255;
	return value;
}
RGBA_Impl_.get_r = function(this1) {
	return this1 >>> 24 & 255;
}
RGBA_Impl_.set_r = function(this1,value) {
	this1 = (value & 255) << 24 | (this1 >>> 16 & 255 & 255) << 16 | (this1 >>> 8 & 255 & 255) << 8 | this1 & 255 & 255;
	return value;
}


// Export

exports.default = RGBA_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/media/AudioBuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/media/AudioBuffer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.media.AudioBuffer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime__$internal_format_Base64() {return __webpack_require__(/*! ./../../lime/_internal/format/Base64 */ "./node_modules/openfl/lib/_gen/lime/_internal/format/Base64.js");}
function lime_media_howlerjs_Howl() {return __webpack_require__(/*! howler */ "./node_modules/howler/dist/howler.js");}
function lime_app_Promise() {return __webpack_require__(/*! ./../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}

// Constructor

var AudioBuffer = function() {
}

// Meta

AudioBuffer.__name__ = "lime.media.AudioBuffer";
AudioBuffer.__isInterface__ = false;
AudioBuffer.prototype = {
	dispose: function() {
		this.__srcHowl.unload();
	},
	get_src: function() {
		return this.__srcHowl;
	},
	set_src: function(value) {
		return this.__srcHowl = value;
	}
};
AudioBuffer.prototype.__class__ = AudioBuffer.prototype.constructor = $hxClasses["lime.media.AudioBuffer"] = AudioBuffer;

// Init

{
	var p = AudioBuffer.prototype;
	Object.defineProperties(p,{ src : { get : p.get_src, set : p.set_src}});
};

// Statics

AudioBuffer.fromBase64 = function(base64String) {
	if(base64String == null) {
		return null;
	}
	if(base64String.indexOf(",") == -1) {
		base64String = "data:" + AudioBuffer.__getCodec((lime__$internal_format_Base64().default).decode(base64String)) + ";base64," + base64String;
	}
	var audioBuffer = new AudioBuffer();
	audioBuffer.set_src(new (lime_media_howlerjs_Howl().Howl)({ src : [base64String], html5 : true, preload : false}));
	return audioBuffer;
}
AudioBuffer.fromBytes = function(bytes) {
	if(bytes == null) {
		return null;
	}
	var audioBuffer = new AudioBuffer();
	audioBuffer.set_src(new (lime_media_howlerjs_Howl().Howl)({ src : ["data:" + AudioBuffer.__getCodec(bytes) + ";base64," + (lime__$internal_format_Base64().default).encode(bytes)], html5 : true, preload : false}));
	return audioBuffer;
}
AudioBuffer.fromFile = function(path) {
	if(path == null) {
		return null;
	}
	var audioBuffer = new AudioBuffer();
	audioBuffer.__srcHowl = new (lime_media_howlerjs_Howl().Howl)({ src : [path], preload : false});
	return audioBuffer;
}
AudioBuffer.fromFiles = function(paths) {
	var audioBuffer = new AudioBuffer();
	audioBuffer.__srcHowl = new (lime_media_howlerjs_Howl().Howl)({ src : paths, preload : false});
	return audioBuffer;
}
AudioBuffer.fromVorbisFile = function(vorbisFile) {
	return null;
}
AudioBuffer.loadFromFile = function(path) {
	var promise = new (lime_app_Promise().default)();
	var audioBuffer = AudioBuffer.fromFile(path);
	if(audioBuffer != null) {
		if(audioBuffer != null) {
			audioBuffer.__srcHowl.on("load",function() {
				promise.complete(audioBuffer);
			});
			audioBuffer.__srcHowl.on("loaderror",function(id,msg) {
				promise.error(msg);
			});
			audioBuffer.__srcHowl.load();
		}
	} else {
		promise.error(null);
	}
	return promise.future;
}
AudioBuffer.loadFromFiles = function(paths) {
	var promise = new (lime_app_Promise().default)();
	var audioBuffer = AudioBuffer.fromFiles(paths);
	if(audioBuffer != null) {
		audioBuffer.__srcHowl.on("load",function() {
			promise.complete(audioBuffer);
		});
		audioBuffer.__srcHowl.on("loaderror",function() {
			promise.error(null);
		});
		audioBuffer.__srcHowl.load();
	} else {
		promise.error(null);
	}
	return promise.future;
}
AudioBuffer.__getCodec = function(bytes) {
	var signature = bytes.getString(0,4);
	switch(signature) {
	case "OggS":
		return "audio/ogg";
	case "RIFF":
		if(bytes.getString(8,4) == "WAVE") {
			return "audio/wav";
		} else {
			var _g = bytes.get(2);
			var _g1 = bytes.get(1);
			switch(bytes.get(0)) {
			case 73:
				if(_g1 == 68) {
					if(_g == 51) {
						return "audio/mp3";
					}
				}
				break;
			case 255:
				switch(_g1) {
				case 243:case 250:case 251:
					return "audio/mp3";
				default:
				}
				break;
			default:
			}
		}
		break;
	case "fLaC":
		return "audio/flac";
	default:
		var _g2 = bytes.get(2);
		var _g11 = bytes.get(1);
		switch(bytes.get(0)) {
		case 73:
			if(_g11 == 68) {
				if(_g2 == 51) {
					return "audio/mp3";
				}
			}
			break;
		case 255:
			switch(_g11) {
			case 243:case 250:case 251:
				return "audio/mp3";
			default:
			}
			break;
		default:
		}
	}
	(lime_utils_Log().default).error("Unsupported sound format",{ fileName : "../node_modules/lime/src/lime/media/AudioBuffer.hx", lineNumber : 362, className : "lime.media.AudioBuffer", methodName : "__getCodec"});
	return null;
}


// Export

exports.default = AudioBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/media/AudioContext.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/media/AudioContext.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.media.AudioContext

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_CallStack() {return __webpack_require__(/*! ./../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function lime_media_HTML5AudioContext() {return __webpack_require__(/*! ./../../lime/media/HTML5AudioContext */ "./node_modules/openfl/lib/_gen/lime/media/HTML5AudioContext.js");}

// Constructor

var AudioContext = function(type) {
	if(type != "custom") {
		if(type == null || type == "web") {
			try {
				window.AudioContext = window.AudioContext || window.webkitAudioContext;
				this.web = new window.AudioContext ();
				this.type = "web";
			} catch( e ) {
				(haxe_CallStack().default).lastException = e;
				var e1 = ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e;
			}
		}
		if(this.web == null && type != "web") {
			this.html5 = new (lime_media_HTML5AudioContext().default)();
			this.type = "html5";
		}
	} else {
		this.type = "custom";
	}
}

// Meta

AudioContext.__name__ = "lime.media.AudioContext";
AudioContext.__isInterface__ = false;
AudioContext.prototype = {
	
};
AudioContext.prototype.__class__ = AudioContext.prototype.constructor = $hxClasses["lime.media.AudioContext"] = AudioContext;

// Init



// Statics




// Export

exports.default = AudioContext;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/media/AudioManager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/media/AudioManager.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.media.AudioManager

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_media_AudioContext() {return __webpack_require__(/*! ./../../lime/media/AudioContext */ "./node_modules/openfl/lib/_gen/lime/media/AudioContext.js");}

// Constructor

var AudioManager = function(){}

// Meta

AudioManager.__name__ = "lime.media.AudioManager";
AudioManager.__isInterface__ = false;
AudioManager.prototype = {
	
};
AudioManager.prototype.__class__ = AudioManager.prototype.constructor = $hxClasses["lime.media.AudioManager"] = AudioManager;

// Init



// Statics

AudioManager.init = function(context) {
	if(AudioManager.context == null) {
		if(context == null) {
			AudioManager.context = new (lime_media_AudioContext().default)();
			context = AudioManager.context;
			if(context.type == "openal") {
				var alc = context.openal;
				var device = alc.openDevice();
				var ctx = alc.createContext(device);
				alc.makeContextCurrent(ctx);
				alc.processContext(ctx);
			}
		}
		AudioManager.context = context;
	}
}
AudioManager.resume = function() {
	if(AudioManager.context != null && AudioManager.context.type == "openal") {
		var alc = AudioManager.context.openal;
		var currentContext = alc.getCurrentContext();
		if(currentContext != null) {
			var device = alc.getContextsDevice(currentContext);
			alc.resumeDevice(device);
			alc.processContext(currentContext);
		}
	}
}
AudioManager.shutdown = function() {
	if(AudioManager.context != null && AudioManager.context.type == "openal") {
		var alc = AudioManager.context.openal;
		var currentContext = alc.getCurrentContext();
		if(currentContext != null) {
			var device = alc.getContextsDevice(currentContext);
			alc.makeContextCurrent(null);
			alc.destroyContext(currentContext);
			if(device != null) {
				alc.closeDevice(device);
			}
		}
	}
	AudioManager.context = null;
}
AudioManager.suspend = function() {
	if(AudioManager.context != null && AudioManager.context.type == "openal") {
		var alc = AudioManager.context.openal;
		var currentContext = alc.getCurrentContext();
		if(currentContext != null) {
			alc.suspendContext(currentContext);
			var device = alc.getContextsDevice(currentContext);
			if(device != null) {
				alc.pauseDevice(device);
			}
		}
	}
}


// Export

exports.default = AudioManager;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/media/AudioSource.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/media/AudioSource.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.media.AudioSource

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_app__$Event_$Void_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Void_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js");}
function lime__$internal_backend_html5_HTML5AudioSource() {return __webpack_require__(/*! ./../../lime/_internal/backend/html5/HTML5AudioSource */ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5AudioSource.js");}

// Constructor

var AudioSource = function(buffer,offset,length,loops) {
	if(loops == null) {
		loops = 0;
	}
	if(offset == null) {
		offset = 0;
	}
	this.onComplete = new (lime_app__$Event_$Void_$Void().default)();
	this.buffer = buffer;
	this.offset = offset;
	this.__backend = new (lime__$internal_backend_html5_HTML5AudioSource().default)(this);
	if(length != null && length != 0) {
		this.set_length(length);
	}
	this.set_loops(loops);
	if(buffer != null) {
		this.init();
	}
}

// Meta

AudioSource.__name__ = "lime.media.AudioSource";
AudioSource.__isInterface__ = false;
AudioSource.prototype = {
	dispose: function() {
		this.__backend.dispose();
	},
	init: function() {
		this.__backend.init();
	},
	play: function() {
		this.__backend.play();
	},
	pause: function() {
		this.__backend.pause();
	},
	stop: function() {
		this.__backend.stop();
	},
	get_currentTime: function() {
		return this.__backend.getCurrentTime();
	},
	set_currentTime: function(value) {
		return this.__backend.setCurrentTime(value);
	},
	get_gain: function() {
		return this.__backend.getGain();
	},
	set_gain: function(value) {
		return this.__backend.setGain(value);
	},
	get_length: function() {
		return this.__backend.getLength();
	},
	set_length: function(value) {
		return this.__backend.setLength(value);
	},
	get_loops: function() {
		return this.__backend.getLoops();
	},
	set_loops: function(value) {
		return this.__backend.setLoops(value);
	},
	get_position: function() {
		return this.__backend.getPosition();
	},
	set_position: function(value) {
		return this.__backend.setPosition(value);
	}
};
AudioSource.prototype.__class__ = AudioSource.prototype.constructor = $hxClasses["lime.media.AudioSource"] = AudioSource;

// Init



// Statics




// Export

exports.default = AudioSource;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/media/HTML5AudioContext.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/media/HTML5AudioContext.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.media.HTML5AudioContext

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_media_AudioBuffer() {return __webpack_require__(/*! ./../../lime/media/AudioBuffer */ "./node_modules/openfl/lib/_gen/lime/media/AudioBuffer.js");}

// Constructor

var HTML5AudioContext = function() {
	this.NETWORK_NO_SOURCE = 3;
	this.NETWORK_LOADING = 2;
	this.NETWORK_IDLE = 1;
	this.NETWORK_EMPTY = 0;
	this.HAVE_NOTHING = 0;
	this.HAVE_METADATA = 1;
	this.HAVE_FUTURE_DATA = 3;
	this.HAVE_ENOUGH_DATA = 4;
	this.HAVE_CURRENT_DATA = 2;
}

// Meta

HTML5AudioContext.__name__ = "lime.media.HTML5AudioContext";
HTML5AudioContext.__isInterface__ = false;
HTML5AudioContext.prototype = {
	canPlayType: function(buffer,type) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.canPlayType(type);
		}
		return null;
	},
	createBuffer: function(urlString) {
		var buffer = new (lime_media_AudioBuffer().default)();
		buffer.__srcAudio = new Audio();
		buffer.__srcAudio.src = urlString;
		return buffer;
	},
	getAutoplay: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.autoplay;
		}
		return false;
	},
	getBuffered: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.buffered;
		}
		return null;
	},
	getCurrentSrc: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.currentSrc;
		}
		return null;
	},
	getCurrentTime: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.currentTime;
		}
		return 0;
	},
	getDefaultPlaybackRate: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.defaultPlaybackRate;
		}
		return 1;
	},
	getDuration: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.duration;
		}
		return 0;
	},
	getEnded: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.ended;
		}
		return false;
	},
	getError: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.error;
		}
		return null;
	},
	getLoop: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.loop;
		}
		return false;
	},
	getMuted: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.muted;
		}
		return false;
	},
	getNetworkState: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.networkState;
		}
		return 0;
	},
	getPaused: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.paused;
		}
		return false;
	},
	getPlaybackRate: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.playbackRate;
		}
		return 1;
	},
	getPlayed: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.played;
		}
		return null;
	},
	getPreload: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.preload;
		}
		return null;
	},
	getReadyState: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.readyState;
		}
		return 0;
	},
	getSeekable: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.seekable;
		}
		return null;
	},
	getSeeking: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.seeking;
		}
		return false;
	},
	getSrc: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.src;
		}
		return null;
	},
	getStartTime: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.playbackRate;
		}
		return 0;
	},
	getVolume: function(buffer) {
		if(buffer.__srcAudio != null) {
			return buffer.__srcAudio.volume;
		}
		return 1;
	},
	load: function(buffer) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.load();
		}
	},
	pause: function(buffer) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.pause();
		}
	},
	play: function(buffer) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.play();
		}
	},
	setAutoplay: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.autoplay = value;
		}
	},
	setCurrentTime: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.currentTime = value;
		}
	},
	setDefaultPlaybackRate: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.defaultPlaybackRate = value;
		}
	},
	setLoop: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.loop = value;
		}
	},
	setMuted: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.muted = value;
		}
	},
	setPlaybackRate: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.playbackRate = value;
		}
	},
	setPreload: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.preload = value;
		}
	},
	setSrc: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.src = value;
		}
	},
	setVolume: function(buffer,value) {
		if(buffer.__srcAudio != null) {
			buffer.__srcAudio.volume = value;
		}
	}
};
HTML5AudioContext.prototype.__class__ = HTML5AudioContext.prototype.constructor = $hxClasses["lime.media.HTML5AudioContext"] = HTML5AudioContext;

// Init



// Statics




// Export

exports.default = HTML5AudioContext;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/net/HTTPRequestHeader.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/net/HTTPRequestHeader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.net.HTTPRequestHeader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var HTTPRequestHeader = function(name,value) {
	if(value == null) {
		value = "";
	}
	this.name = name;
	this.value = value;
}

// Meta

HTTPRequestHeader.__name__ = "lime.net.HTTPRequestHeader";
HTTPRequestHeader.__isInterface__ = false;
HTTPRequestHeader.prototype = {
	
};
HTTPRequestHeader.prototype.__class__ = HTTPRequestHeader.prototype.constructor = $hxClasses["lime.net.HTTPRequestHeader"] = HTTPRequestHeader;

// Init



// Statics




// Export

exports.default = HTTPRequestHeader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest/AbstractHTTPRequest.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest/AbstractHTTPRequest.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.net._HTTPRequest.AbstractHTTPRequest

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_net__$IHTTPRequest() {return __webpack_require__(/*! ./../../../lime/net/_IHTTPRequest */ "./node_modules/openfl/lib/_gen/lime/net/_IHTTPRequest.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function lime__$internal_backend_html5_HTML5HTTPRequest() {return __webpack_require__(/*! ./../../../lime/_internal/backend/html5/HTML5HTTPRequest */ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5HTTPRequest.js");}

// Constructor

var AbstractHTTPRequest = function(uri) {
	this.uri = uri;
	this.contentType = "application/x-www-form-urlencoded";
	this.followRedirects = true;
	this.enableResponseHeaders = false;
	this.formData = new (haxe_ds_StringMap().default)();
	this.headers = [];
	this.method = "GET";
	this.timeout = 30000;
	this.withCredentials = false;
	this.__backend = new (lime__$internal_backend_html5_HTML5HTTPRequest().default)();
	this.__backend.init(this);
}

// Meta

AbstractHTTPRequest.__name__ = "lime.net._HTTPRequest.AbstractHTTPRequest";
AbstractHTTPRequest.__isInterface__ = false;
AbstractHTTPRequest.__interfaces__ = [(lime_net__$IHTTPRequest().default)];
AbstractHTTPRequest.prototype = {
	cancel: function() {
		this.__backend.cancel();
	},
	load: function(uri) {
		return null;
	}
};
AbstractHTTPRequest.prototype.__class__ = AbstractHTTPRequest.prototype.constructor = $hxClasses["lime.net._HTTPRequest.AbstractHTTPRequest"] = AbstractHTTPRequest;

// Init



// Statics




// Export

exports.default = AbstractHTTPRequest;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_Bytes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_Bytes.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.net._HTTPRequest_Bytes

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_net__$HTTPRequest_AbstractHTTPRequest() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest/AbstractHTTPRequest */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest/AbstractHTTPRequest.js");}
function lime_app_Promise() {return __webpack_require__(/*! ./../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}

// Constructor

var _HTTPRequest_Bytes = function(uri) {
	(lime_net__$HTTPRequest_AbstractHTTPRequest().default).call(this,uri);
}

// Meta

_HTTPRequest_Bytes.__name__ = "lime.net._HTTPRequest_Bytes";
_HTTPRequest_Bytes.__isInterface__ = false;
_HTTPRequest_Bytes.__super__ = (lime_net__$HTTPRequest_AbstractHTTPRequest().default);
_HTTPRequest_Bytes.prototype = $extend((lime_net__$HTTPRequest_AbstractHTTPRequest().default).prototype, {
	fromBytes: function(bytes) {
		return bytes;
	},
	load: function(uri) {
		var _gthis = this;
		if(uri != null) {
			this.uri = uri;
		}
		var promise = new (lime_app_Promise().default)();
		var future = this.__backend.loadData(this.uri);
		future.onProgress($bind(promise,promise.progress));
		future.onError($bind(promise,promise.error));
		future.onComplete(function(bytes) {
			_gthis.responseData = _gthis.fromBytes(bytes);
			promise.complete(_gthis.responseData);
		});
		return promise.future;
	}
});
_HTTPRequest_Bytes.prototype.__class__ = _HTTPRequest_Bytes.prototype.constructor = $hxClasses["lime.net._HTTPRequest_Bytes"] = _HTTPRequest_Bytes;

// Init



// Statics




// Export

exports.default = _HTTPRequest_Bytes;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_String.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_String.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.net._HTTPRequest_String

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_net__$HTTPRequest_AbstractHTTPRequest() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest/AbstractHTTPRequest */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest/AbstractHTTPRequest.js");}
function lime_app_Promise() {return __webpack_require__(/*! ./../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}

// Constructor

var _HTTPRequest_String = function(uri) {
	(lime_net__$HTTPRequest_AbstractHTTPRequest().default).call(this,uri);
}

// Meta

_HTTPRequest_String.__name__ = "lime.net._HTTPRequest_String";
_HTTPRequest_String.__isInterface__ = false;
_HTTPRequest_String.__super__ = (lime_net__$HTTPRequest_AbstractHTTPRequest().default);
_HTTPRequest_String.prototype = $extend((lime_net__$HTTPRequest_AbstractHTTPRequest().default).prototype, {
	load: function(uri) {
		var _gthis = this;
		if(uri != null) {
			this.uri = uri;
		}
		var promise = new (lime_app_Promise().default)();
		var future = this.__backend.loadText(this.uri);
		future.onProgress($bind(promise,promise.progress));
		future.onError($bind(promise,promise.error));
		future.onComplete(function(text) {
			_gthis.responseData = text;
			promise.complete(_gthis.responseData);
		});
		return promise.future;
	}
});
_HTTPRequest_String.prototype.__class__ = _HTTPRequest_String.prototype.constructor = $hxClasses["lime.net._HTTPRequest_String"] = _HTTPRequest_String;

// Init



// Statics




// Export

exports.default = _HTTPRequest_String;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_lime_text_Font.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_lime_text_Font.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.net._HTTPRequest_lime_text_Font

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_net__$HTTPRequest_$Bytes() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest_Bytes */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_Bytes.js");}
function lime_text_Font() {return __webpack_require__(/*! ./../../lime/text/Font */ "./node_modules/openfl/lib/_gen/lime/text/Font.js");}

// Constructor

var _HTTPRequest_lime_text_Font = function(uri) {
	(lime_net__$HTTPRequest_$Bytes().default).call(this,uri);
}

// Meta

_HTTPRequest_lime_text_Font.__name__ = "lime.net._HTTPRequest_lime_text_Font";
_HTTPRequest_lime_text_Font.__isInterface__ = false;
_HTTPRequest_lime_text_Font.__super__ = (lime_net__$HTTPRequest_$Bytes().default);
_HTTPRequest_lime_text_Font.prototype = $extend((lime_net__$HTTPRequest_$Bytes().default).prototype, {
	fromBytes: function(bytes) {
		return (lime_text_Font().default).fromBytes(bytes);
	}
});
_HTTPRequest_lime_text_Font.prototype.__class__ = _HTTPRequest_lime_text_Font.prototype.constructor = $hxClasses["lime.net._HTTPRequest_lime_text_Font"] = _HTTPRequest_lime_text_Font;

// Init



// Statics




// Export

exports.default = _HTTPRequest_lime_text_Font;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_lime_utils_Bytes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_lime_utils_Bytes.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.net._HTTPRequest_lime_utils_Bytes

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_net__$HTTPRequest_$Bytes() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest_Bytes */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_Bytes.js");}
function lime_utils__$Bytes_Bytes_$Impl_$() {return __webpack_require__(/*! ./../../lime/utils/_Bytes/Bytes_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js");}

// Constructor

var _HTTPRequest_lime_utils_Bytes = function(uri) {
	(lime_net__$HTTPRequest_$Bytes().default).call(this,uri);
}

// Meta

_HTTPRequest_lime_utils_Bytes.__name__ = "lime.net._HTTPRequest_lime_utils_Bytes";
_HTTPRequest_lime_utils_Bytes.__isInterface__ = false;
_HTTPRequest_lime_utils_Bytes.__super__ = (lime_net__$HTTPRequest_$Bytes().default);
_HTTPRequest_lime_utils_Bytes.prototype = $extend((lime_net__$HTTPRequest_$Bytes().default).prototype, {
	fromBytes: function(bytes) {
		return (lime_utils__$Bytes_Bytes_$Impl_$().default).fromBytes(bytes);
	}
});
_HTTPRequest_lime_utils_Bytes.prototype.__class__ = _HTTPRequest_lime_utils_Bytes.prototype.constructor = $hxClasses["lime.net._HTTPRequest_lime_utils_Bytes"] = _HTTPRequest_lime_utils_Bytes;

// Init



// Statics




// Export

exports.default = _HTTPRequest_lime_utils_Bytes;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_openfl_utils_ByteArray.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_openfl_utils_ByteArray.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.net._HTTPRequest_openfl_utils_ByteArray

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_net__$HTTPRequest_$Bytes() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest_Bytes */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_Bytes.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}

// Constructor

var _HTTPRequest_openfl_utils_ByteArray = function(uri) {
	(lime_net__$HTTPRequest_$Bytes().default).call(this,uri);
}

// Meta

_HTTPRequest_openfl_utils_ByteArray.__name__ = "lime.net._HTTPRequest_openfl_utils_ByteArray";
_HTTPRequest_openfl_utils_ByteArray.__isInterface__ = false;
_HTTPRequest_openfl_utils_ByteArray.__super__ = (lime_net__$HTTPRequest_$Bytes().default);
_HTTPRequest_openfl_utils_ByteArray.prototype = $extend((lime_net__$HTTPRequest_$Bytes().default).prototype, {
	fromBytes: function(bytes) {
		return (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(bytes);
	}
});
_HTTPRequest_openfl_utils_ByteArray.prototype.__class__ = _HTTPRequest_openfl_utils_ByteArray.prototype.constructor = $hxClasses["lime.net._HTTPRequest_openfl_utils_ByteArray"] = _HTTPRequest_openfl_utils_ByteArray;

// Init



// Statics




// Export

exports.default = _HTTPRequest_openfl_utils_ByteArray;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/net/_IHTTPRequest.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/net/_IHTTPRequest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.net._IHTTPRequest

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var _IHTTPRequest = function() {}

// Meta

_IHTTPRequest.__name__ = "lime.net._IHTTPRequest";
_IHTTPRequest.__isInterface__ = true;
_IHTTPRequest.prototype = {
	
};
_IHTTPRequest.prototype.__class__ = _IHTTPRequest.prototype.constructor = $hxClasses["lime.net._IHTTPRequest"] = _IHTTPRequest;

// Init



// Statics




// Export

exports.default = _IHTTPRequest;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/CFFI.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/CFFI.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.system.CFFI

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var CFFI = function(){}

// Meta

CFFI.__name__ = "lime.system.CFFI";
CFFI.__isInterface__ = false;
CFFI.prototype = {
	
};
CFFI.prototype.__class__ = CFFI.prototype.constructor = $hxClasses["lime.system.CFFI"] = CFFI;

// Init

{
	CFFI.available = false;
	CFFI.enabled = false;
};

// Statics

CFFI.load = function(library,method,args,lazy) {
	if(lazy == null) {
		lazy = false;
	}
	if(args == null) {
		args = 0;
	}
	if(!CFFI.enabled) {
		return (Reflect().default).makeVarArgs(function(__) {
			return { };
		});
	}
	var result = null;
	return result;
}
CFFI.__findHaxelib = function(library) {
	return "";
}
CFFI.__loaderTrace = function(message) {
}
CFFI.__sysName = function() {
	return null;
}
CFFI.__tryLoad = function(name,library,func,args) {
	return null;
}
CFFI.__moduleNames = null

// Export

exports.default = CFFI;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/Clipboard.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/Clipboard.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.system.Clipboard

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_app__$Event_$Void_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Void_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js");}
function lime_app_Application() {return __webpack_require__(/*! ./../../lime/app/Application */ "./node_modules/openfl/lib/_gen/lime/app/Application.js");}

// Constructor

var Clipboard = function(){}

// Meta

Clipboard.__name__ = "lime.system.Clipboard";
Clipboard.__isInterface__ = false;
Clipboard.prototype = {
	
};
Clipboard.prototype.__class__ = Clipboard.prototype.constructor = $hxClasses["lime.system.Clipboard"] = Clipboard;

// Init



// Statics

Clipboard.__update = function() {
	var cacheText = Clipboard._text;
	Clipboard._text = null;
	if(Clipboard._text != cacheText) {
		Clipboard.onUpdate.dispatch();
	}
}
Clipboard.get_text = function() {
	Clipboard.__update();
	return Clipboard._text;
}
Clipboard.set_text = function(value) {
	var cacheText = Clipboard._text;
	Clipboard._text = value;
	var $window = (lime_app_Application().default).current.get_window();
	if($window != null) {
		$window.__backend.setClipboard(value);
	}
	if(Clipboard._text != cacheText) {
		Clipboard.onUpdate.dispatch();
	}
	return value;
}
Clipboard.onUpdate = new (lime_app__$Event_$Void_$Void().default)()

// Export

exports.default = Clipboard;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/Display.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/Display.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.system.Display

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var Display = function() {
}

// Meta

Display.__name__ = "lime.system.Display";
Display.__isInterface__ = false;
Display.prototype = {
	
};
Display.prototype.__class__ = Display.prototype.constructor = $hxClasses["lime.system.Display"] = Display;

// Init



// Statics




// Export

exports.default = Display;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/DisplayMode.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/DisplayMode.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.system.DisplayMode

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var DisplayMode = function(width,height,refreshRate,pixelFormat) {
	this.width = width;
	this.height = height;
	this.refreshRate = refreshRate;
	this.pixelFormat = pixelFormat;
}

// Meta

DisplayMode.__name__ = "lime.system.DisplayMode";
DisplayMode.__isInterface__ = false;
DisplayMode.prototype = {
	
};
DisplayMode.prototype.__class__ = DisplayMode.prototype.constructor = $hxClasses["lime.system.DisplayMode"] = DisplayMode;

// Init



// Statics




// Export

exports.default = DisplayMode;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/Endian.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/Endian.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime.system.Endian

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var Endian = $hxEnums["lime.system.Endian"] = { __ename__ : "lime.system.Endian", __constructs__ : ["LITTLE_ENDIAN","BIG_ENDIAN"]
  ,LITTLE_ENDIAN: {_hx_index:0,__enum__:"lime.system.Endian",toString:$estr}
  ,BIG_ENDIAN: {_hx_index:1,__enum__:"lime.system.Endian",toString:$estr}
};

exports.default = Endian;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/Sensor.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/Sensor.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.system.Sensor

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function lime_app__$Event_$Float_$Float_$Float_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Float_Float_Float_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Float_Void.js");}

// Constructor

var Sensor = function(type,id) {
	this.onUpdate = new (lime_app__$Event_$Float_$Float_$Float_$Void().default)();
	this.type = type;
	this.id = id;
}

// Meta

Sensor.__name__ = "lime.system.Sensor";
Sensor.__isInterface__ = false;
Sensor.prototype = {
	
};
Sensor.prototype.__class__ = Sensor.prototype.constructor = $hxClasses["lime.system.Sensor"] = Sensor;

// Init



// Statics

Sensor.getSensors = function(type) {
	if(type == null) {
		return Sensor.sensors.slice();
	} else {
		var result = [];
		var _g = 0;
		var _g1 = Sensor.sensors;
		while(_g < _g1.length) {
			var sensor = _g1[_g];
			++_g;
			if(sensor.type == type) {
				result.push(sensor);
			}
		}
		return result;
	}
}
Sensor.registerSensor = function(type,id) {
	var sensor = new Sensor(type,id);
	Sensor.sensors.push(sensor);
	Sensor.sensorByID.set(id,sensor);
	return sensor;
}
Sensor.sensorByID = new (haxe_ds_IntMap().default)()
Sensor.sensors = []

// Export

exports.default = Sensor;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/SensorType.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/SensorType.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime.system.SensorType

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var SensorType = $hxEnums["lime.system.SensorType"] = { __ename__ : "lime.system.SensorType", __constructs__ : ["ACCELEROMETER"]
  ,ACCELEROMETER: {_hx_index:0,__enum__:"lime.system.SensorType",toString:$estr}
};

exports.default = SensorType;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/System.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/System.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.system.System

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function lime_system_Display() {return __webpack_require__(/*! ./../../lime/system/Display */ "./node_modules/openfl/lib/_gen/lime/system/Display.js");}
function lime_system_DisplayMode() {return __webpack_require__(/*! ./../../lime/system/DisplayMode */ "./node_modules/openfl/lib/_gen/lime/system/DisplayMode.js");}
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}
function lime_system_CFFI() {return __webpack_require__(/*! ./../../lime/system/CFFI */ "./node_modules/openfl/lib/_gen/lime/system/CFFI.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function lime_system_Endian() {return __webpack_require__(/*! ./../../lime/system/Endian */ "./node_modules/openfl/lib/_gen/lime/system/Endian.js");}

// Constructor

var System = function(){}

// Meta

System.__name__ = "lime.system.System";
System.__isInterface__ = false;
System.prototype = {
	
};
System.prototype.__class__ = System.prototype.constructor = $hxClasses["lime.system.System"] = System;

// Init



// Statics

System.embed = function(projectName,element,width,height,config) {
	if(System.__applicationEntryPoint == null) {
		return;
	}
	if(System.__applicationEntryPoint.exists(projectName)) {
		var htmlElement = null;
		if(typeof(element) == "string") {
			htmlElement = window.document.getElementById(element);
		} else if(element == null) {
			htmlElement = window.document.createElement("div");
		} else {
			htmlElement = element;
		}
		if(htmlElement == null) {
			window.console.log("[lime.embed] ERROR: Cannot find target element: " + (Std().default).string(element));
			return;
		}
		if(width == null) {
			width = 0;
		}
		if(height == null) {
			height = 0;
		}
		if(config == null) {
			config = { };
		}
		if((Reflect().default).hasField(config,"background") && typeof(config.background) == "string") {
			var background = (StringTools().default).replace((Std().default).string(config.background),"#","");
			if(background.indexOf("0x") > -1) {
				config.background = (Std().default).parseInt(background);
			} else {
				config.background = (Std().default).parseInt("0x" + background);
			}
		}
		config.element = htmlElement;
		config.width = width;
		config.height = height;
		(System.__applicationEntryPoint.get(projectName))(config);
	}
}
System.exit = function(code) {
}
System.getDisplay = function(id) {
	if(id == 0) {
		var display = new (lime_system_Display().default)();
		display.id = 0;
		display.name = "Generic Display";
		display.dpi = 96 * window.devicePixelRatio;
		display.currentMode = new (lime_system_DisplayMode().default)(window.screen.width,window.screen.height,60,1);
		display.supportedModes = [display.currentMode];
		display.bounds = new (lime_math_Rectangle().default)(0,0,display.currentMode.width,display.currentMode.height);
		return display;
	}
	return null;
}
System.getTimer = function() {
	return (Std().default).int(window.performance.now());
}
System.load = function(library,method,args,lazy) {
	if(lazy == null) {
		lazy = false;
	}
	if(args == null) {
		args = 0;
	}
	return (lime_system_CFFI().default).load(library,method,args,lazy);
}
System.openFile = function(path) {
	if(path != null) {
		window.open(path,"_blank");
	}
}
System.openURL = function(url,target) {
	if(target == null) {
		target = "_blank";
	}
	if(url != null) {
		window.open(url,target);
	}
}
System.__copyMissingFields = function(target,source) {
	if(source == null || target == null) {
		return;
	}
	var _g = 0;
	var _g1 = (Reflect().default).fields(source);
	while(_g < _g1.length) {
		var field = _g1[_g];
		++_g;
		if(!(Reflect().default).hasField(target,field)) {
			(Reflect().default).setField(target,field,(Reflect().default).field(source,field));
		}
	}
}
System.__getDirectory = function(type) {
	return null;
}
System.__parseBool = function(value) {
	return value == "true";
}
System.__registerEntryPoint = function(projectName,entryPoint) {
	if(System.__applicationEntryPoint == null) {
		System.__applicationEntryPoint = new (haxe_ds_StringMap().default)();
	}
	System.__applicationEntryPoint.set(projectName,entryPoint);
}
System.__runProcess = function(command,args) {
	return null;
}
System.get_allowScreenTimeout = function() {
	return true;
}
System.set_allowScreenTimeout = function(value) {
	return true;
}
System.get_applicationDirectory = function() {
	if(System.__applicationDirectory == null) {
		System.__applicationDirectory = System.__getDirectory(0);
	}
	return System.__applicationDirectory;
}
System.get_applicationStorageDirectory = function() {
	if(System.__applicationStorageDirectory == null) {
		System.__applicationStorageDirectory = System.__getDirectory(1);
	}
	return System.__applicationStorageDirectory;
}
System.get_deviceModel = function() {
	var tmp = System.__deviceModel == null;
	return System.__deviceModel;
}
System.get_deviceVendor = function() {
	var tmp = System.__deviceVendor == null;
	return System.__deviceVendor;
}
System.get_desktopDirectory = function() {
	if(System.__desktopDirectory == null) {
		System.__desktopDirectory = System.__getDirectory(2);
	}
	return System.__desktopDirectory;
}
System.get_documentsDirectory = function() {
	if(System.__documentsDirectory == null) {
		System.__documentsDirectory = System.__getDirectory(3);
	}
	return System.__documentsDirectory;
}
System.get_endianness = function() {
	if(System.__endianness == null) {
		var arrayBuffer = new ArrayBuffer(2);
		var elements = null;
		var array = null;
		var view = null;
		var len = null;
		var this1;
		if(elements != null) {
			this1 = new Uint8Array(elements);
		} else if(array != null) {
			this1 = new Uint8Array(array);
		} else if(view != null) {
			this1 = new Uint8Array(view);
		} else if(arrayBuffer != null) {
			if(len == null) {
				this1 = new Uint8Array(arrayBuffer,0);
			} else {
				this1 = new Uint8Array(arrayBuffer,0,len);
			}
		} else {
			this1 = null;
		}
		var uint8Array = this1;
		var elements1 = null;
		var array1 = null;
		var view1 = null;
		var len1 = null;
		var this2;
		if(elements1 != null) {
			this2 = new Uint16Array(elements1);
		} else if(array1 != null) {
			this2 = new Uint16Array(array1);
		} else if(view1 != null) {
			this2 = new Uint16Array(view1);
		} else if(arrayBuffer != null) {
			if(len1 == null) {
				this2 = new Uint16Array(arrayBuffer,0);
			} else {
				this2 = new Uint16Array(arrayBuffer,0,len1);
			}
		} else {
			this2 = null;
		}
		var uint16array = this2;
		uint8Array[0] = 170;
		uint8Array[1] = 187;
		if(uint16array[0] == 43707) {
			System.__endianness = (lime_system_Endian().default).BIG_ENDIAN;
		} else {
			System.__endianness = (lime_system_Endian().default).LITTLE_ENDIAN;
		}
	}
	return System.__endianness;
}
System.get_fontsDirectory = function() {
	if(System.__fontsDirectory == null) {
		System.__fontsDirectory = System.__getDirectory(4);
	}
	return System.__fontsDirectory;
}
System.get_numDisplays = function() {
	return 1;
}
System.get_platformLabel = function() {
	if(System.__platformLabel == null) {
		var name = System.get_platformName();
		var version = System.get_platformVersion();
		if(name != null && version != null) {
			System.__platformLabel = name + " " + version;
		} else if(name != null) {
			System.__platformLabel = name;
		}
	}
	return System.__platformLabel;
}
System.get_platformName = function() {
	if(System.__platformName == null) {
		System.__platformName = "HTML5";
	}
	return System.__platformName;
}
System.get_platformVersion = function() {
	var tmp = System.__platformVersion == null;
	return System.__platformVersion;
}
System.get_userDirectory = function() {
	if(System.__userDirectory == null) {
		System.__userDirectory = System.__getDirectory(5);
	}
	return System.__userDirectory;
}
System.__directories = new (haxe_ds_IntMap().default)()

// Export

exports.default = System;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/ThreadPool.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/ThreadPool.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.system.ThreadPool

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_app__$Event_$Dynamic_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Dynamic_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Dynamic_Void.js");}

// Constructor

var ThreadPool = function(minThreads,maxThreads) {
	if(maxThreads == null) {
		maxThreads = 1;
	}
	if(minThreads == null) {
		minThreads = 0;
	}
	this.onRun = new (lime_app__$Event_$Dynamic_$Void().default)();
	this.onProgress = new (lime_app__$Event_$Dynamic_$Void().default)();
	this.onError = new (lime_app__$Event_$Dynamic_$Void().default)();
	this.onComplete = new (lime_app__$Event_$Dynamic_$Void().default)();
	this.doWork = new (lime_app__$Event_$Dynamic_$Void().default)();
	this.minThreads = minThreads;
	this.maxThreads = maxThreads;
	this.currentThreads = 0;
}

// Meta

ThreadPool.__name__ = "lime.system.ThreadPool";
ThreadPool.__isInterface__ = false;
ThreadPool.prototype = {
	queue: function(state) {
		this.runWork(state);
	},
	sendComplete: function(state) {
		this.onComplete.dispatch(state);
	},
	sendError: function(state) {
		this.onError.dispatch(state);
	},
	sendProgress: function(state) {
		this.onProgress.dispatch(state);
	},
	runWork: function(state) {
		this.onRun.dispatch(state);
		this.doWork.dispatch(state);
	}
};
ThreadPool.prototype.__class__ = ThreadPool.prototype.constructor = $hxClasses["lime.system.ThreadPool"] = ThreadPool;

// Init



// Statics




// Export

exports.default = ThreadPool;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/system/_CFFIPointer/CFFIPointer_Impl_.js":
/*!************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/system/_CFFIPointer/CFFIPointer_Impl_.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.system._CFFIPointer.CFFIPointer_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var CFFIPointer_Impl_ = function(){}

// Meta

CFFIPointer_Impl_.__name__ = "lime.system._CFFIPointer.CFFIPointer_Impl_";
CFFIPointer_Impl_.__isInterface__ = false;
CFFIPointer_Impl_.prototype = {
	
};
CFFIPointer_Impl_.prototype.__class__ = CFFIPointer_Impl_.prototype.constructor = $hxClasses["lime.system._CFFIPointer.CFFIPointer_Impl_"] = CFFIPointer_Impl_;

// Init



// Statics

CFFIPointer_Impl_._new = function(handle) {
	var this1 = handle;
	return this1;
}
CFFIPointer_Impl_.get = function(this1) {
	var tmp = this1 != null;
	return 0;
}
CFFIPointer_Impl_.equals = function(a,b) {
	return CFFIPointer_Impl_.get(a) == b;
}
CFFIPointer_Impl_.equalsPointer = function(a,b) {
	return CFFIPointer_Impl_.get(a) == CFFIPointer_Impl_.get(b);
}
CFFIPointer_Impl_.greaterThan = function(a,b) {
	return CFFIPointer_Impl_.get(a) > b;
}
CFFIPointer_Impl_.greaterThanPointer = function(a,b) {
	return CFFIPointer_Impl_.get(a) > CFFIPointer_Impl_.get(b);
}
CFFIPointer_Impl_.greaterThanOrEqual = function(a,b) {
	return CFFIPointer_Impl_.get(a) >= b;
}
CFFIPointer_Impl_.greaterThanOrEqualPointer = function(a,b) {
	return CFFIPointer_Impl_.get(a) >= CFFIPointer_Impl_.get(b);
}
CFFIPointer_Impl_.lessThan = function(a,b) {
	return CFFIPointer_Impl_.get(a) < b;
}
CFFIPointer_Impl_.lessThanPointer = function(a,b) {
	return CFFIPointer_Impl_.get(a) < CFFIPointer_Impl_.get(b);
}
CFFIPointer_Impl_.lessThanOrEqual = function(a,b) {
	return CFFIPointer_Impl_.get(a) <= b;
}
CFFIPointer_Impl_.lessThanOrEqualPointer = function(a,b) {
	return CFFIPointer_Impl_.get(a) <= CFFIPointer_Impl_.get(b);
}
CFFIPointer_Impl_.notEquals = function(a,b) {
	return CFFIPointer_Impl_.get(a) != b;
}
CFFIPointer_Impl_.notEqualsPointer = function(a,b) {
	return CFFIPointer_Impl_.get(a) != CFFIPointer_Impl_.get(b);
}


// Export

exports.default = CFFIPointer_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/text/Font.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/text/Font.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.text.Font

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function lime_app_Promise() {return __webpack_require__(/*! ./../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}
function EReg() {return __webpack_require__(/*! ./../../EReg */ "./node_modules/openfl/lib/_gen/EReg.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function lime_net__$HTTPRequest_$lime_$text_$Font() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest_lime_text_Font */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_lime_text_Font.js");}
function lime_utils_Assets() {return __webpack_require__(/*! ./../../lime/utils/Assets */ "./node_modules/openfl/lib/_gen/lime/utils/Assets.js");}

// Constructor

var Font = function(name) {
	if(name != null) {
		this.name = name;
	}
	if(!this.__init) {
		if(this.ascender == undefined) {
			this.ascender = 0;
		}
		if(this.descender == undefined) {
			this.descender = 0;
		}
		if(this.height == undefined) {
			this.height = 0;
		}
		if(this.numGlyphs == undefined) {
			this.numGlyphs = 0;
		}
		if(this.underlinePosition == undefined) {
			this.underlinePosition = 0;
		}
		if(this.underlineThickness == undefined) {
			this.underlineThickness = 0;
		}
		if(this.unitsPerEM == undefined) {
			this.unitsPerEM = 0;
		}
		if(this.__fontID != null) {
			if((lime_utils_Assets().default).isLocal(this.__fontID)) {
				this.__fromBytes((lime_utils_Assets().default).getBytes(this.__fontID));
			}
		} else if(this.__fontPath != null) {
			this.__fromFile(this.__fontPath);
		}
	}
}

// Meta

Font.__name__ = "lime.text.Font";
Font.__isInterface__ = false;
Font.prototype = {
	decompose: function() {
		return null;
	},
	getGlyph: function(character) {
		return -1;
	},
	getGlyphs: function(characters) {
		if(characters == null) {
			characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^`'\"/\\&*()[]{}<>|:;_-+=?,. ";
		}
		return null;
	},
	getGlyphMetrics: function(glyph) {
		return null;
	},
	renderGlyph: function(glyph,fontSize) {
		return null;
	},
	renderGlyphs: function(glyphs,fontSize) {
		return null;
	},
	__copyFrom: function(other) {
		if(other != null) {
			this.ascender = other.ascender;
			this.descender = other.descender;
			this.height = other.height;
			this.name = other.name;
			this.numGlyphs = other.numGlyphs;
			this.src = other.src;
			this.underlinePosition = other.underlinePosition;
			this.underlineThickness = other.underlineThickness;
			this.unitsPerEM = other.unitsPerEM;
			this.__fontID = other.__fontID;
			this.__fontPath = other.__fontPath;
			this.__init = true;
		}
	},
	__fromBytes: function(bytes) {
		this.__fontPath = null;
	},
	__fromFile: function(path) {
		this.__fontPath = path;
	},
	__initializeSource: function() {
		this.__init = true;
	},
	__loadFromName: function(name) {
		var _gthis = this;
		var promise = new (lime_app_Promise().default)();
		this.name = name;
		var userAgent = window.navigator.userAgent.toLowerCase();
		var isSafari = userAgent.indexOf(" safari/") >= 0 && userAgent.indexOf(" chrome/") < 0;
		var isUIWebView = new (EReg().default)("(iPhone|iPod|iPad).*AppleWebKit(?!.*Version)","i").match(userAgent);
		if(!isSafari && !isUIWebView && (window.document.fonts && ($_=window.document.fonts,$bind($_,$_.load)))) {
			window.document.fonts.load("1em '" + name + "'").then(function(_) {
				promise.complete(_gthis);
			},function(_1) {
				(lime_utils_Log().default).warn("Could not load web font \"" + name + "\"",{ fileName : "../node_modules/lime/src/lime/text/Font.hx", lineNumber : 513, className : "lime.text.Font", methodName : "__loadFromName"});
				promise.complete(_gthis);
			});
		} else {
			var node1 = Font.__measureFontNode("'" + name + "', sans-serif");
			var node2 = Font.__measureFontNode("'" + name + "', serif");
			var width1 = node1.offsetWidth;
			var width2 = node2.offsetWidth;
			var interval = -1;
			var timeout = 3000;
			var intervalLength = 50;
			var intervalCount = 0;
			var loaded;
			var timeExpired;
			var checkFont = function() {
				intervalCount += 1;
				loaded = node1.offsetWidth != width1 || node2.offsetWidth != width2;
				timeExpired = intervalCount * intervalLength >= timeout;
				if(loaded || timeExpired) {
					window.clearInterval(interval);
					node1.parentNode.removeChild(node1);
					node2.parentNode.removeChild(node2);
					node1 = null;
					node2 = null;
					if(timeExpired) {
						(lime_utils_Log().default).warn("Could not load web font \"" + name + "\"",{ fileName : "../node_modules/lime/src/lime/text/Font.hx", lineNumber : 548, className : "lime.text.Font", methodName : "__loadFromName"});
					}
					promise.complete(_gthis);
				}
			};
			interval = window.setInterval(checkFont,intervalLength);
		}
		return promise.future;
	},
	__setSize: function(size) {
	}
};
Font.prototype.__class__ = Font.prototype.constructor = $hxClasses["lime.text.Font"] = Font;

// Init



// Statics

Font.fromBytes = function(bytes) {
	if(bytes == null) {
		return null;
	}
	var font = new Font();
	font.__fromBytes(bytes);
	return font;
}
Font.fromFile = function(path) {
	if(path == null) {
		return null;
	}
	var font = new Font();
	font.__fromFile(path);
	return font;
}
Font.loadFromBytes = function(bytes) {
	return (lime_app_Future().default).withValue(Font.fromBytes(bytes));
}
Font.loadFromFile = function(path) {
	var request = new (lime_net__$HTTPRequest_$lime_$text_$Font().default)();
	return request.load(path).then(function(font) {
		if(font != null) {
			return (lime_app_Future().default).withValue(font);
		} else {
			return (lime_app_Future().default).withError("");
		}
	});
}
Font.loadFromName = function(path) {
	var font = new Font();
	return font.__loadFromName(path);
}
Font.__measureFontNode = function(fontFamily) {
	var node = window.document.createElement("span");
	node.setAttribute("aria-hidden","true");
	var text = window.document.createTextNode("BESbswy");
	node.appendChild(text);
	var style = node.style;
	style.display = "block";
	style.position = "absolute";
	style.top = "-9999px";
	style.left = "-9999px";
	style.fontSize = "300px";
	style.width = "auto";
	style.height = "auto";
	style.lineHeight = "normal";
	style.margin = "0";
	style.padding = "0";
	style.fontVariant = "normal";
	style.whiteSpace = "nowrap";
	style.fontFamily = fontFamily;
	window.document.body.appendChild(node);
	return node;
}


// Export

exports.default = Font;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/ui/Gamepad.js":
/*!*********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/ui/Gamepad.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.ui.Gamepad

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_ui_Joystick() {return __webpack_require__(/*! ./../../lime/ui/Joystick */ "./node_modules/openfl/lib/_gen/lime/ui/Joystick.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function lime_app__$Event_$lime_$ui_$Gamepad_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_lime_ui_Gamepad_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Gamepad_Void.js");}
function lime_app__$Event_$Void_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Void_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js");}
function lime_app__$Event_$lime_$ui_$GamepadButton_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_lime_ui_GamepadButton_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_GamepadButton_Void.js");}
function lime_app__$Event_$lime_$ui_$GamepadAxis_$Float_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_lime_ui_GamepadAxis_Float_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_GamepadAxis_Float_Void.js");}

// Constructor

var Gamepad = function(id) {
	this.onDisconnect = new (lime_app__$Event_$Void_$Void().default)();
	this.onButtonUp = new (lime_app__$Event_$lime_$ui_$GamepadButton_$Void().default)();
	this.onButtonDown = new (lime_app__$Event_$lime_$ui_$GamepadButton_$Void().default)();
	this.onAxisMove = new (lime_app__$Event_$lime_$ui_$GamepadAxis_$Float_$Void().default)();
	this.id = id;
	this.connected = true;
}

// Meta

Gamepad.__name__ = "lime.ui.Gamepad";
Gamepad.__isInterface__ = false;
Gamepad.prototype = {
	get_guid: function() {
		var devices = (lime_ui_Joystick().default).__getDeviceData();
		return devices[this.id].id;
	},
	get_name: function() {
		var devices = (lime_ui_Joystick().default).__getDeviceData();
		return devices[this.id].id;
	}
};
Gamepad.prototype.__class__ = Gamepad.prototype.constructor = $hxClasses["lime.ui.Gamepad"] = Gamepad;

// Init



// Statics

Gamepad.addMappings = function(mappings) {
}
Gamepad.__connect = function(id) {
	if(!Gamepad.devices.exists(id)) {
		var gamepad = new Gamepad(id);
		Gamepad.devices.set(id,gamepad);
		Gamepad.onConnect.dispatch(gamepad);
	}
}
Gamepad.__disconnect = function(id) {
	var gamepad = Gamepad.devices.get(id);
	if(gamepad != null) {
		gamepad.connected = false;
	}
	Gamepad.devices.remove(id);
	if(gamepad != null) {
		gamepad.onDisconnect.dispatch();
	}
}
Gamepad.devices = new (haxe_ds_IntMap().default)()
Gamepad.onConnect = new (lime_app__$Event_$lime_$ui_$Gamepad_$Void().default)()

// Export

exports.default = Gamepad;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/ui/Joystick.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/ui/Joystick.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.ui.Joystick

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function lime_app__$Event_$lime_$ui_$Joystick_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_lime_ui_Joystick_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Joystick_Void.js");}
function lime_app__$Event_$Int_$Float_$Float_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Int_Float_Float_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Float_Float_Void.js");}
function lime_app__$Event_$Int_$lime_$ui_$JoystickHatPosition_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Int_lime_ui_JoystickHatPosition_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_lime_ui_JoystickHatPosition_Void.js");}
function lime_app__$Event_$Void_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Void_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js");}
function lime_app__$Event_$Int_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Int_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Void.js");}
function lime_app__$Event_$Int_$Float_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Int_Float_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Float_Void.js");}

// Constructor

var Joystick = function(id) {
	this.onTrackballMove = new (lime_app__$Event_$Int_$Float_$Float_$Void().default)();
	this.onHatMove = new (lime_app__$Event_$Int_$lime_$ui_$JoystickHatPosition_$Void().default)();
	this.onDisconnect = new (lime_app__$Event_$Void_$Void().default)();
	this.onButtonUp = new (lime_app__$Event_$Int_$Void().default)();
	this.onButtonDown = new (lime_app__$Event_$Int_$Void().default)();
	this.onAxisMove = new (lime_app__$Event_$Int_$Float_$Void().default)();
	this.id = id;
	this.connected = true;
}

// Meta

Joystick.__name__ = "lime.ui.Joystick";
Joystick.__isInterface__ = false;
Joystick.prototype = {
	get_guid: function() {
		var devices = Joystick.__getDeviceData();
		return devices[this.id].id;
	},
	get_name: function() {
		var devices = Joystick.__getDeviceData();
		return devices[this.id].id;
	},
	get_numAxes: function() {
		var devices = Joystick.__getDeviceData();
		return devices[this.id].axes.length;
	},
	get_numButtons: function() {
		var devices = Joystick.__getDeviceData();
		return devices[this.id].buttons.length;
	},
	get_numHats: function() {
		return 0;
	},
	get_numTrackballs: function() {
		return 0;
	}
};
Joystick.prototype.__class__ = Joystick.prototype.constructor = $hxClasses["lime.ui.Joystick"] = Joystick;

// Init



// Statics

Joystick.__connect = function(id) {
	if(!Joystick.devices.exists(id)) {
		var joystick = new Joystick(id);
		Joystick.devices.set(id,joystick);
		Joystick.onConnect.dispatch(joystick);
	}
}
Joystick.__disconnect = function(id) {
	var joystick = Joystick.devices.get(id);
	if(joystick != null) {
		joystick.connected = false;
	}
	Joystick.devices.remove(id);
	if(joystick != null) {
		joystick.onDisconnect.dispatch();
	}
}
Joystick.__getDeviceData = function() {
	if(navigator.getGamepads) {
		return navigator.getGamepads();
	} else if(navigator.webkitGetGamepads) {
		return navigator.webkitGetGamepads();
	} else {
		return null;
	}
}
Joystick.devices = new (haxe_ds_IntMap().default)()
Joystick.onConnect = new (lime_app__$Event_$lime_$ui_$Joystick_$Void().default)()

// Export

exports.default = Joystick;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/ui/MouseCursor.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/ui/MouseCursor.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime.ui.MouseCursor

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var MouseCursor = $hxEnums["lime.ui.MouseCursor"] = { __ename__ : "lime.ui.MouseCursor", __constructs__ : ["ARROW","CROSSHAIR","DEFAULT","MOVE","POINTER","RESIZE_NESW","RESIZE_NS","RESIZE_NWSE","RESIZE_WE","TEXT","WAIT","WAIT_ARROW","CUSTOM"]
  ,WAIT_ARROW: {_hx_index:11,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,WAIT: {_hx_index:10,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,TEXT: {_hx_index:9,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,RESIZE_WE: {_hx_index:8,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,RESIZE_NWSE: {_hx_index:7,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,RESIZE_NS: {_hx_index:6,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,RESIZE_NESW: {_hx_index:5,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,POINTER: {_hx_index:4,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,MOVE: {_hx_index:3,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,DEFAULT: {_hx_index:2,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,CUSTOM: {_hx_index:12,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,CROSSHAIR: {_hx_index:1,__enum__:"lime.ui.MouseCursor",toString:$estr}
  ,ARROW: {_hx_index:0,__enum__:"lime.ui.MouseCursor",toString:$estr}
};

exports.default = MouseCursor;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/ui/MouseWheelMode.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/ui/MouseWheelMode.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime.ui.MouseWheelMode

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var MouseWheelMode = $hxEnums["lime.ui.MouseWheelMode"] = { __ename__ : "lime.ui.MouseWheelMode", __constructs__ : ["PIXELS","LINES","PAGES","UNKNOWN"]
  ,UNKNOWN: {_hx_index:3,__enum__:"lime.ui.MouseWheelMode",toString:$estr}
  ,PIXELS: {_hx_index:0,__enum__:"lime.ui.MouseWheelMode",toString:$estr}
  ,PAGES: {_hx_index:2,__enum__:"lime.ui.MouseWheelMode",toString:$estr}
  ,LINES: {_hx_index:1,__enum__:"lime.ui.MouseWheelMode",toString:$estr}
};

exports.default = MouseWheelMode;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/ui/Touch.js":
/*!*******************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/ui/Touch.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.ui.Touch

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_app__$Event_$lime_$ui_$Touch_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_lime_ui_Touch_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_Touch_Void.js");}

// Constructor

var Touch = function(x,y,id,dx,dy,pressure,device) {
	this.x = x;
	this.y = y;
	this.id = id;
	this.dx = dx;
	this.dy = dy;
	this.pressure = pressure;
	this.device = device;
}

// Meta

Touch.__name__ = "lime.ui.Touch";
Touch.__isInterface__ = false;
Touch.prototype = {
	
};
Touch.prototype.__class__ = Touch.prototype.constructor = $hxClasses["lime.ui.Touch"] = Touch;

// Init



// Statics


Touch.onCancel = new (lime_app__$Event_$lime_$ui_$Touch_$Void().default)()
Touch.onEnd = new (lime_app__$Event_$lime_$ui_$Touch_$Void().default)()
Touch.onMove = new (lime_app__$Event_$lime_$ui_$Touch_$Void().default)()
Touch.onStart = new (lime_app__$Event_$lime_$ui_$Touch_$Void().default)()

// Export

exports.default = Touch;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/ui/Window.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/ui/Window.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.ui.Window

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_app__$Event_$String_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_String_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_String_Void.js");}
function lime_app__$Event_$String_$Int_$Int_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_String_Int_Int_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_String_Int_Int_Void.js");}
function lime_app__$Event_$Void_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Void_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js");}
function lime_app__$Event_$Int_$Int_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Int_Int_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Int_Void.js");}
function lime_app__$Event_$lime_$graphics_$RenderContext_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_lime_graphics_RenderContext_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_graphics_RenderContext_Void.js");}
function lime_app__$Event_$Float_$Float_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Float_Float_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Void.js");}
function lime_app__$Event_$Float_$Float_$lime_$ui_$MouseWheelMode_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Float_Float_lime_ui_MouseWheelMode_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_lime_ui_MouseWheelMode_Void.js");}
function lime_app__$Event_$Float_$Float_$Int_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Float_Float_Int_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_Int_Void.js");}
function lime_app__$Event_$Float_$Float_$lime_$ui_$MouseButton_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Float_Float_lime_ui_MouseButton_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Float_Float_lime_ui_MouseButton_Void.js");}
function lime_app__$Event_$lime_$ui_$KeyCode_$lime_$ui_$KeyModifier_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function lime__$internal_backend_html5_HTML5Window() {return __webpack_require__(/*! ./../../lime/_internal/backend/html5/HTML5Window */ "./node_modules/openfl/lib/_gen/lime/_internal/backend/html5/HTML5Window.js");}

// Constructor

var Window = function(application,attributes) {
	this.onTextInput = new (lime_app__$Event_$String_$Void().default)();
	this.onTextEdit = new (lime_app__$Event_$String_$Int_$Int_$Void().default)();
	this.onRestore = new (lime_app__$Event_$Void_$Void().default)();
	this.onResize = new (lime_app__$Event_$Int_$Int_$Void().default)();
	this.onRenderContextRestored = new (lime_app__$Event_$lime_$graphics_$RenderContext_$Void().default)();
	this.onRenderContextLost = new (lime_app__$Event_$Void_$Void().default)();
	this.onRender = new (lime_app__$Event_$lime_$graphics_$RenderContext_$Void().default)();
	this.onMove = new (lime_app__$Event_$Float_$Float_$Void().default)();
	this.onMouseWheel = new (lime_app__$Event_$Float_$Float_$lime_$ui_$MouseWheelMode_$Void().default)();
	this.onMouseUp = new (lime_app__$Event_$Float_$Float_$Int_$Void().default)();
	this.onMouseMoveRelative = new (lime_app__$Event_$Float_$Float_$Void().default)();
	this.onMouseMove = new (lime_app__$Event_$Float_$Float_$Void().default)();
	this.onMouseDown = new (lime_app__$Event_$Float_$Float_$lime_$ui_$MouseButton_$Void().default)();
	this.onMinimize = new (lime_app__$Event_$Void_$Void().default)();
	this.onMaximize = new (lime_app__$Event_$Void_$Void().default)();
	this.onLeave = new (lime_app__$Event_$Void_$Void().default)();
	this.onKeyUp = new (lime_app__$Event_$lime_$ui_$KeyCode_$lime_$ui_$KeyModifier_$Void().default)();
	this.onKeyDown = new (lime_app__$Event_$lime_$ui_$KeyCode_$lime_$ui_$KeyModifier_$Void().default)();
	this.onFullscreen = new (lime_app__$Event_$Void_$Void().default)();
	this.onFocusOut = new (lime_app__$Event_$Void_$Void().default)();
	this.onFocusIn = new (lime_app__$Event_$Void_$Void().default)();
	this.onExpose = new (lime_app__$Event_$Void_$Void().default)();
	this.onEnter = new (lime_app__$Event_$Void_$Void().default)();
	this.onDropFile = new (lime_app__$Event_$String_$Void().default)();
	this.onDeactivate = new (lime_app__$Event_$Void_$Void().default)();
	this.onClose = new (lime_app__$Event_$Void_$Void().default)();
	this.onActivate = new (lime_app__$Event_$Void_$Void().default)();
	this.application = application;
	this.__attributes = attributes != null ? attributes : { };
	if((Reflect().default).hasField(this.__attributes,"parameters")) {
		this.parameters = this.__attributes.parameters;
	}
	this.__width = 0;
	this.__height = 0;
	this.__fullscreen = false;
	this.__scale = 1;
	this.__x = 0;
	this.__y = 0;
	this.__title = "";
	this.id = -1;
	this.__backend = new (lime__$internal_backend_html5_HTML5Window().default)(this);
}

// Meta

Window.__name__ = "lime.ui.Window";
Window.__isInterface__ = false;
Window.prototype = {
	alert: function(message,title) {
		this.__backend.alert(message,title);
	},
	close: function() {
		this.__backend.close();
	},
	focus: function() {
		this.__backend.focus();
	},
	move: function(x,y) {
		this.__backend.move(x,y);
		this.__x = x;
		this.__y = y;
	},
	readPixels: function(rect) {
		return this.__backend.readPixels(rect);
	},
	resize: function(width,height) {
		this.__backend.resize(width,height);
		this.__width = width;
		this.__height = height;
	},
	setIcon: function(image) {
		if(image == null) {
			return;
		}
		this.__backend.setIcon(image);
	},
	toString: function() {
		return "[object Window]";
	},
	warpMouse: function(x,y) {
		this.__backend.warpMouse(x,y);
	},
	get_cursor: function() {
		return this.__backend.getCursor();
	},
	set_cursor: function(value) {
		return this.__backend.setCursor(value);
	},
	get_display: function() {
		return this.__backend.getDisplay();
	},
	get_displayMode: function() {
		return this.__backend.getDisplayMode();
	},
	set_displayMode: function(value) {
		return this.__backend.setDisplayMode(value);
	},
	get_borderless: function() {
		return this.__borderless;
	},
	set_borderless: function(value) {
		return this.__borderless = this.__backend.setBorderless(value);
	},
	get_frameRate: function() {
		return this.__backend.getFrameRate();
	},
	set_frameRate: function(value) {
		return this.__backend.setFrameRate(value);
	},
	get_fullscreen: function() {
		return this.__fullscreen;
	},
	set_fullscreen: function(value) {
		return this.__fullscreen = this.__backend.setFullscreen(value);
	},
	get_height: function() {
		return this.__height;
	},
	set_height: function(value) {
		this.resize(this.__width,value);
		return this.__height;
	},
	get_hidden: function() {
		return this.__hidden;
	},
	get_maximized: function() {
		return this.__maximized;
	},
	set_maximized: function(value) {
		this.__minimized = false;
		return this.__maximized = this.__backend.setMaximized(value);
	},
	get_minimized: function() {
		return this.__minimized;
	},
	set_minimized: function(value) {
		this.__maximized = false;
		return this.__minimized = this.__backend.setMinimized(value);
	},
	get_mouseLock: function() {
		return this.__backend.getMouseLock();
	},
	set_mouseLock: function(value) {
		this.__backend.setMouseLock(value);
		return value;
	},
	get_resizable: function() {
		return this.__resizable;
	},
	set_resizable: function(value) {
		this.__resizable = this.__backend.setResizable(value);
		return this.__resizable;
	},
	get_scale: function() {
		return this.__scale;
	},
	get_textInputEnabled: function() {
		return this.__backend.getTextInputEnabled();
	},
	set_textInputEnabled: function(value) {
		return this.__backend.setTextInputEnabled(value);
	},
	get_title: function() {
		return this.__title;
	},
	set_title: function(value) {
		return this.__title = this.__backend.setTitle(value);
	},
	get_width: function() {
		return this.__width;
	},
	set_width: function(value) {
		this.resize(value,this.__height);
		return this.__width;
	},
	get_x: function() {
		return this.__x;
	},
	set_x: function(value) {
		this.move(value,this.__y);
		return this.__x;
	},
	get_y: function() {
		return this.__y;
	},
	set_y: function(value) {
		this.move(this.__x,value);
		return this.__y;
	}
};
Window.prototype.__class__ = Window.prototype.constructor = $hxClasses["lime.ui.Window"] = Window;

// Init

{
	var p = Window.prototype;
	Object.defineProperties(p,{ borderless : { get : p.get_borderless, set : p.set_borderless}, cursor : { get : p.get_cursor, set : p.set_cursor}, display : { get : p.get_display}, displayMode : { get : p.get_displayMode, set : p.set_displayMode}, frameRate : { get : p.get_frameRate, set : p.set_frameRate}, fullscreen : { get : p.get_fullscreen, set : p.set_fullscreen}, height : { get : p.get_height, set : p.set_height}, maximized : { get : p.get_maximized, set : p.set_maximized}, minimized : { get : p.get_minimized, set : p.set_minimized}, mouseLock : { get : p.get_mouseLock, set : p.set_mouseLock}, resizable : { get : p.get_resizable, set : p.set_resizable}, scale : { get : p.get_scale}, textInputEnabled : { get : p.get_textInputEnabled, set : p.set_textInputEnabled}, title : { get : p.get_title, set : p.set_title}, width : { get : p.get_width, set : p.set_width}, x : { get : p.get_x, set : p.set_y}, y : { get : p.get_x, set : p.set_y}});
};

// Statics




// Export

exports.default = Window;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/ui/_KeyModifier/KeyModifier_Impl_.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/ui/_KeyModifier/KeyModifier_Impl_.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.ui._KeyModifier.KeyModifier_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var KeyModifier_Impl_ = function(){}

// Meta

KeyModifier_Impl_.__name__ = "lime.ui._KeyModifier.KeyModifier_Impl_";
KeyModifier_Impl_.__isInterface__ = false;
KeyModifier_Impl_.prototype = {
	
};
KeyModifier_Impl_.prototype.__class__ = KeyModifier_Impl_.prototype.constructor = $hxClasses["lime.ui._KeyModifier.KeyModifier_Impl_"] = KeyModifier_Impl_;

// Init



// Statics

KeyModifier_Impl_.get_altKey = function(this1) {
	if((this1 & 256) <= 0) {
		return (this1 & 512) > 0;
	} else {
		return true;
	}
}
KeyModifier_Impl_.set_altKey = function(this1,value) {
	if(value) {
		this1 |= 768;
	} else {
		this1 &= 268435455 - 768;
	}
	return value;
}
KeyModifier_Impl_.get_capsLock = function(this1) {
	if((this1 & 8192) <= 0) {
		return (this1 & 8192) > 0;
	} else {
		return true;
	}
}
KeyModifier_Impl_.set_capsLock = function(this1,value) {
	if(value) {
		this1 |= 8192;
	} else {
		this1 &= 268435455 - 8192;
	}
	return value;
}
KeyModifier_Impl_.get_ctrlKey = function(this1) {
	if((this1 & 64) <= 0) {
		return (this1 & 128) > 0;
	} else {
		return true;
	}
}
KeyModifier_Impl_.set_ctrlKey = function(this1,value) {
	if(value) {
		this1 |= 192;
	} else {
		this1 &= 268435455 - 192;
	}
	return value;
}
KeyModifier_Impl_.get_metaKey = function(this1) {
	if((this1 & 1024) <= 0) {
		return (this1 & 2048) > 0;
	} else {
		return true;
	}
}
KeyModifier_Impl_.set_metaKey = function(this1,value) {
	if(value) {
		this1 |= 3072;
	} else {
		this1 &= 268435455 - 3072;
	}
	return value;
}
KeyModifier_Impl_.get_numLock = function(this1) {
	if((this1 & 4096) <= 0) {
		return (this1 & 4096) > 0;
	} else {
		return true;
	}
}
KeyModifier_Impl_.set_numLock = function(this1,value) {
	if(value) {
		this1 |= 4096;
	} else {
		this1 &= 268435455 - 4096;
	}
	return value;
}
KeyModifier_Impl_.get_shiftKey = function(this1) {
	if((this1 & 1) <= 0) {
		return (this1 & 2) > 0;
	} else {
		return true;
	}
}
KeyModifier_Impl_.set_shiftKey = function(this1,value) {
	if(value) {
		this1 |= 3;
	} else {
		this1 &= 268435455 - 3;
	}
	return value;
}
KeyModifier_Impl_.NONE = 0
KeyModifier_Impl_.LEFT_SHIFT = 1
KeyModifier_Impl_.RIGHT_SHIFT = 2
KeyModifier_Impl_.LEFT_CTRL = 64
KeyModifier_Impl_.RIGHT_CTRL = 128
KeyModifier_Impl_.LEFT_ALT = 256
KeyModifier_Impl_.RIGHT_ALT = 512
KeyModifier_Impl_.LEFT_META = 1024
KeyModifier_Impl_.RIGHT_META = 2048
KeyModifier_Impl_.NUM_LOCK = 4096
KeyModifier_Impl_.CAPS_LOCK = 8192
KeyModifier_Impl_.MODE = 16384
KeyModifier_Impl_.CTRL = 192
KeyModifier_Impl_.SHIFT = 3
KeyModifier_Impl_.ALT = 768
KeyModifier_Impl_.META = 3072

// Export

exports.default = KeyModifier_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/AssetBundle.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/AssetBundle.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.AssetBundle

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_io_BytesInput() {return __webpack_require__(/*! ./../../haxe/io/BytesInput */ "./node_modules/openfl/lib/_gen/haxe/io/BytesInput.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function lime_utils__$Bytes_Bytes_$Impl_$() {return __webpack_require__(/*! ./../../lime/utils/_Bytes/Bytes_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js");}
function haxe_zip_Reader() {return __webpack_require__(/*! ./../../haxe/zip/Reader */ "./node_modules/openfl/lib/_gen/haxe/zip/Reader.js");}
function lime_utils_CompressionAlgorithm() {return __webpack_require__(/*! ./../../lime/utils/CompressionAlgorithm */ "./node_modules/openfl/lib/_gen/lime/utils/CompressionAlgorithm.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}

// Constructor

var AssetBundle = function() {
	this.data = new (haxe_ds_StringMap().default)();
	this.paths = [];
}

// Meta

AssetBundle.__name__ = "lime.utils.AssetBundle";
AssetBundle.__isInterface__ = false;
AssetBundle.prototype = {
	
};
AssetBundle.prototype.__class__ = AssetBundle.prototype.constructor = $hxClasses["lime.utils.AssetBundle"] = AssetBundle;

// Init



// Statics

AssetBundle.fromBytes = function(bytes) {
	var input = new (haxe_io_BytesInput().default)(bytes);
	return AssetBundle.__extractBundle(input);
}
AssetBundle.fromFile = function(path) {
	return null;
}
AssetBundle.loadFromBytes = function(bytes) {
	return (lime_app_Future().default).withValue(AssetBundle.fromBytes(bytes));
}
AssetBundle.loadFromFile = function(path) {
	return (lime_utils__$Bytes_Bytes_$Impl_$().default).loadFromFile(path).then(AssetBundle.loadFromBytes);
}
AssetBundle.__extractBundle = function(input) {
	var entries = (haxe_zip_Reader().default).readZip(input);
	var bundle = new AssetBundle();
	var entry = entries.iterator();
	while(entry.hasNext()) {
		var entry1 = entry.next();
		if(entry1.compressed) {
			var bytes = entry1.data;
			bundle.data.set(entry1.fileName,(lime_utils__$Bytes_Bytes_$Impl_$().default).decompress(bytes,(lime_utils_CompressionAlgorithm().default).DEFLATE));
		} else {
			bundle.data.set(entry1.fileName,entry1.data);
		}
		bundle.paths.push(entry1.fileName);
	}
	return bundle;
}


// Export

exports.default = AssetBundle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/AssetCache.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/AssetCache.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.AssetCache

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_graphics_Image() {return __webpack_require__(/*! ./../../lime/graphics/Image */ "./node_modules/openfl/lib/_gen/lime/graphics/Image.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_media_AudioBuffer() {return __webpack_require__(/*! ./../../lime/media/AudioBuffer */ "./node_modules/openfl/lib/_gen/lime/media/AudioBuffer.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}

// Constructor

var AssetCache = function() {
	this.enabled = true;
	this.audio = new (haxe_ds_StringMap().default)();
	this.font = new (haxe_ds_StringMap().default)();
	this.image = new (haxe_ds_StringMap().default)();
	this.version = 0;
}

// Meta

AssetCache.__name__ = "lime.utils.AssetCache";
AssetCache.__isInterface__ = false;
AssetCache.prototype = {
	exists: function(id,type) {
		if(type == "IMAGE" || type == null) {
			if(this.image.exists(id)) {
				return true;
			}
		}
		if(type == "FONT" || type == null) {
			if(this.font.exists(id)) {
				return true;
			}
		}
		if(type == "SOUND" || type == "MUSIC" || type == null) {
			if(this.audio.exists(id)) {
				return true;
			}
		}
		return false;
	},
	set: function(id,type,asset) {
		switch(type) {
		case "FONT":
			this.font.set(id,asset);
			break;
		case "IMAGE":
			if(!((asset) instanceof (lime_graphics_Image().default))) {
				throw new (js__$Boot_HaxeError().default)("Cannot cache non-Image asset: " + (Std().default).string(asset) + " as Image");
			}
			this.image.set(id,asset);
			break;
		case "MUSIC":case "SOUND":
			if(!((asset) instanceof (lime_media_AudioBuffer().default))) {
				throw new (js__$Boot_HaxeError().default)("Cannot cache non-AudioBuffer asset: " + (Std().default).string(asset) + " as AudioBuffer");
			}
			this.audio.set(id,asset);
			break;
		default:
			throw new (js__$Boot_HaxeError().default)(type + " assets are not cachable");
		}
	},
	clear: function(prefix) {
		if(prefix == null) {
			this.audio = new (haxe_ds_StringMap().default)();
			this.font = new (haxe_ds_StringMap().default)();
			this.image = new (haxe_ds_StringMap().default)();
		} else {
			var keys = this.audio.keys();
			var key = keys;
			while(key.hasNext()) {
				var key1 = key.next();
				if((StringTools().default).startsWith(key1,prefix)) {
					this.audio.remove(key1);
				}
			}
			var keys1 = this.font.keys();
			var key2 = keys1;
			while(key2.hasNext()) {
				var key3 = key2.next();
				if((StringTools().default).startsWith(key3,prefix)) {
					this.font.remove(key3);
				}
			}
			var keys2 = this.image.keys();
			var key4 = keys2;
			while(key4.hasNext()) {
				var key5 = key4.next();
				if((StringTools().default).startsWith(key5,prefix)) {
					this.image.remove(key5);
				}
			}
		}
	}
};
AssetCache.prototype.__class__ = AssetCache.prototype.constructor = $hxClasses["lime.utils.AssetCache"] = AssetCache;

// Init



// Statics




// Export

exports.default = AssetCache;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/AssetLibrary.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/AssetLibrary.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.AssetLibrary

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function js_Boot() {return __webpack_require__(/*! ./../../js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function lime_media_AudioBuffer() {return __webpack_require__(/*! ./../../lime/media/AudioBuffer */ "./node_modules/openfl/lib/_gen/lime/media/AudioBuffer.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function lime_utils__$Bytes_Bytes_$Impl_$() {return __webpack_require__(/*! ./../../lime/utils/_Bytes/Bytes_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js");}
function lime_text_Font() {return __webpack_require__(/*! ./../../lime/text/Font */ "./node_modules/openfl/lib/_gen/lime/text/Font.js");}
function lime_graphics_Image() {return __webpack_require__(/*! ./../../lime/graphics/Image */ "./node_modules/openfl/lib/_gen/lime/graphics/Image.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function lime_app_Promise() {return __webpack_require__(/*! ./../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function lime_net__$HTTPRequest_$String() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest_String */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_String.js");}
function lime_utils_Assets() {return __webpack_require__(/*! ./../../lime/utils/Assets */ "./node_modules/openfl/lib/_gen/lime/utils/Assets.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function lime_utils_AssetManifest() {return __webpack_require__(/*! ./../../lime/utils/AssetManifest */ "./node_modules/openfl/lib/_gen/lime/utils/AssetManifest.js");}
function lime_app__$Event_$Void_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Void_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js");}

// Constructor

var AssetLibrary = function() {
	this.types = new (haxe_ds_StringMap().default)();
	this.sizes = new (haxe_ds_StringMap().default)();
	this.preload = new (haxe_ds_StringMap().default)();
	this.paths = new (haxe_ds_StringMap().default)();
	this.pathGroups = new (haxe_ds_StringMap().default)();
	this.classTypes = new (haxe_ds_StringMap().default)();
	this.cachedText = new (haxe_ds_StringMap().default)();
	this.cachedImages = new (haxe_ds_StringMap().default)();
	this.cachedFonts = new (haxe_ds_StringMap().default)();
	this.cachedBytes = new (haxe_ds_StringMap().default)();
	this.cachedAudioBuffers = new (haxe_ds_StringMap().default)();
	this.onChange = new (lime_app__$Event_$Void_$Void().default)();
	this.bytesLoaded = 0;
	this.bytesTotal = 0;
}

// Meta

AssetLibrary.__name__ = "lime.utils.AssetLibrary";
AssetLibrary.__isInterface__ = false;
AssetLibrary.prototype = {
	exists: function(id,type) {
		var requestedType = type != null ? (js_Boot().default).__cast(type , String) : null;
		var assetType = this.types.get(id);
		if(assetType != null) {
			if(assetType == requestedType || (requestedType == "SOUND" || requestedType == "MUSIC") && (assetType == "MUSIC" || assetType == "SOUND")) {
				return true;
			}
			if(requestedType == "BINARY" || requestedType == null || assetType == "BINARY" && requestedType == "TEXT") {
				return true;
			}
		}
		return false;
	},
	getAsset: function(id,type) {
		switch(type) {
		case "BINARY":
			return this.getBytes(id);
		case "FONT":
			return this.getFont(id);
		case "IMAGE":
			return this.getImage(id);
		case "MUSIC":case "SOUND":
			return this.getAudioBuffer(id);
		case "TEMPLATE":
			throw new (js__$Boot_HaxeError().default)("Not sure how to get template: " + id);
		case "TEXT":
			return this.getText(id);
		default:
			throw new (js__$Boot_HaxeError().default)("Unknown asset type: " + type);
		}
	},
	getAudioBuffer: function(id) {
		if(this.cachedAudioBuffers.exists(id)) {
			return this.cachedAudioBuffers.get(id);
		} else if(this.classTypes.exists(id)) {
			return (lime_media_AudioBuffer().default).fromBytes((js_Boot().default).__cast((Type().default).createInstance(this.classTypes.get(id),[]) , (haxe_io_Bytes().default)));
		} else {
			return (lime_media_AudioBuffer().default).fromFile(this.paths.get(id));
		}
	},
	getBytes: function(id) {
		if(this.cachedBytes.exists(id)) {
			return this.cachedBytes.get(id);
		} else if(this.cachedText.exists(id)) {
			var bytes = (lime_utils__$Bytes_Bytes_$Impl_$().default).ofString(this.cachedText.get(id));
			this.cachedBytes.set(id,bytes);
			return bytes;
		} else if(this.classTypes.exists(id)) {
			return (js_Boot().default).__cast((Type().default).createInstance(this.classTypes.get(id),[]) , (haxe_io_Bytes().default));
		} else {
			return (lime_utils__$Bytes_Bytes_$Impl_$().default).fromFile(this.paths.get(id));
		}
	},
	getFont: function(id) {
		if(this.cachedFonts.exists(id)) {
			return this.cachedFonts.get(id);
		} else if(this.classTypes.exists(id)) {
			return (js_Boot().default).__cast((Type().default).createInstance(this.classTypes.get(id),[]) , (lime_text_Font().default));
		} else {
			return (lime_text_Font().default).fromFile(this.paths.get(id));
		}
	},
	getImage: function(id) {
		if(this.cachedImages.exists(id)) {
			return this.cachedImages.get(id);
		} else if(this.classTypes.exists(id)) {
			return (js_Boot().default).__cast((Type().default).createInstance(this.classTypes.get(id),[]) , (lime_graphics_Image().default));
		} else {
			return (lime_graphics_Image().default).fromFile(this.paths.get(id));
		}
	},
	getPath: function(id) {
		if(this.paths.exists(id)) {
			return this.paths.get(id);
		} else if(this.pathGroups.exists(id)) {
			return this.pathGroups.get(id)[0];
		} else {
			return null;
		}
	},
	getText: function(id) {
		if(this.cachedText.exists(id)) {
			return this.cachedText.get(id);
		} else {
			var bytes = this.getBytes(id);
			if(bytes == null) {
				return null;
			} else {
				return bytes.getString(0,bytes.get_length());
			}
		}
	},
	isLocal: function(id,type) {
		if(this.classTypes.exists(id)) {
			return true;
		}
		var requestedType = type != null ? (js_Boot().default).__cast(type , String) : null;
		if(requestedType == null) {
			if(!this.cachedBytes.exists(id)) {
				return this.cachedText.exists(id);
			} else {
				return true;
			}
		} else {
			switch(requestedType) {
			case "FONT":
				return this.cachedFonts.exists(id);
			case "IMAGE":
				return this.cachedImages.exists(id);
			case "MUSIC":case "SOUND":
				return this.cachedAudioBuffers.exists(id);
			default:
				if(!this.cachedBytes.exists(id)) {
					return this.cachedText.exists(id);
				} else {
					return true;
				}
			}
		}
	},
	list: function(type) {
		var requestedType = type != null ? (js_Boot().default).__cast(type , String) : null;
		var items = [];
		var id = this.types.keys();
		while(id.hasNext()) {
			var id1 = id.next();
			if(requestedType == null || this.exists(id1,type)) {
				items.push(id1);
			}
		}
		return items;
	},
	loadAsset: function(id,type) {
		switch(type) {
		case "BINARY":
			return this.loadBytes(id);
		case "FONT":
			return this.loadFont(id);
		case "IMAGE":
			return this.loadImage(id);
		case "MUSIC":case "SOUND":
			return this.loadAudioBuffer(id);
		case "TEMPLATE":
			throw new (js__$Boot_HaxeError().default)("Not sure how to load template: " + id);
		case "TEXT":
			return this.loadText(id);
		default:
			throw new (js__$Boot_HaxeError().default)("Unknown asset type: " + type);
		}
	},
	load: function() {
		if(this.loaded) {
			return (lime_app_Future().default).withValue(this);
		}
		if(this.promise == null) {
			this.promise = new (lime_app_Promise().default)();
			this.bytesLoadedCache = new (haxe_ds_StringMap().default)();
			this.assetsLoaded = 0;
			this.assetsTotal = 1;
			var id = this.preload.keys();
			while(id.hasNext()) {
				var id1 = id.next();
				if(!this.preload.get(id1)) {
					continue;
				}
				(lime_utils_Log().default).verbose("Preloading asset: " + id1 + " [" + this.types.get(id1) + "]",{ fileName : "../node_modules/lime/src/lime/utils/AssetLibrary.hx", lineNumber : 405, className : "lime.utils.AssetLibrary", methodName : "load"});
				var _g = this.types.get(id1);
				if(_g != null) {
					switch(_g) {
					case "BINARY":
						this.assetsTotal++;
						var future = this.loadBytes(id1);
						future.onProgress((function(id2,f) {
							return function(bytesLoaded,bytesTotal) {
								f[0](id2[0],bytesLoaded,bytesTotal);
							};
						})([id1],[$bind(this,this.load_onProgress)]));
						future.onError((function(id3,f1) {
							return function(message) {
								f1[0](id3[0],message);
							};
						})([id1],[$bind(this,this.load_onError)]));
						future.onComplete((function(id4,f2) {
							return function(bytes) {
								f2[0](id4[0],bytes);
							};
						})([id1],[$bind(this,this.loadBytes_onComplete)]));
						break;
					case "FONT":
						this.assetsTotal++;
						var future1 = this.loadFont(id1);
						future1.onProgress((function(id5,f3) {
							return function(bytesLoaded1,bytesTotal1) {
								f3[0](id5[0],bytesLoaded1,bytesTotal1);
							};
						})([id1],[$bind(this,this.load_onProgress)]));
						future1.onError((function(id6,f4) {
							return function(message1) {
								f4[0](id6[0],message1);
							};
						})([id1],[$bind(this,this.load_onError)]));
						future1.onComplete((function(id7,f5) {
							return function(font) {
								f5[0](id7[0],font);
							};
						})([id1],[$bind(this,this.loadFont_onComplete)]));
						break;
					case "IMAGE":
						this.assetsTotal++;
						var future2 = this.loadImage(id1);
						future2.onProgress((function(id8,f6) {
							return function(bytesLoaded2,bytesTotal2) {
								f6[0](id8[0],bytesLoaded2,bytesTotal2);
							};
						})([id1],[$bind(this,this.load_onProgress)]));
						future2.onError((function(id9,f7) {
							return function(message2) {
								f7[0](id9[0],message2);
							};
						})([id1],[$bind(this,this.load_onError)]));
						future2.onComplete((function(id10,f8) {
							return function(image) {
								f8[0](id10[0],image);
							};
						})([id1],[$bind(this,this.loadImage_onComplete)]));
						break;
					case "MUSIC":case "SOUND":
						this.assetsTotal++;
						var future3 = this.loadAudioBuffer(id1);
						future3.onProgress((function(id11,f9) {
							return function(bytesLoaded3,bytesTotal3) {
								f9[0](id11[0],bytesLoaded3,bytesTotal3);
							};
						})([id1],[$bind(this,this.load_onProgress)]));
						future3.onError((function(id12,f10) {
							return function(message3) {
								f10[0](id12[0],message3);
							};
						})([id1],[$bind(this,this.loadAudioBuffer_onError)]));
						future3.onComplete((function(id13,f11) {
							return function(audioBuffer) {
								f11[0](id13[0],audioBuffer);
							};
						})([id1],[$bind(this,this.loadAudioBuffer_onComplete)]));
						break;
					case "TEXT":
						this.assetsTotal++;
						var future4 = this.loadText(id1);
						future4.onProgress((function(id14,f12) {
							return function(bytesLoaded4,bytesTotal4) {
								f12[0](id14[0],bytesLoaded4,bytesTotal4);
							};
						})([id1],[$bind(this,this.load_onProgress)]));
						future4.onError((function(id15,f13) {
							return function(message4) {
								f13[0](id15[0],message4);
							};
						})([id1],[$bind(this,this.load_onError)]));
						future4.onComplete((function(id16,f14) {
							return function(text) {
								f14[0](id16[0],text);
							};
						})([id1],[$bind(this,this.loadText_onComplete)]));
						break;
					default:
					}
				}
			}
			this.__assetLoaded(null);
		}
		return this.promise.future;
	},
	loadAudioBuffer: function(id) {
		if(this.cachedAudioBuffers.exists(id)) {
			return (lime_app_Future().default).withValue(this.cachedAudioBuffers.get(id));
		} else if(this.classTypes.exists(id)) {
			return (lime_app_Future().default).withValue((Type().default).createInstance(this.classTypes.get(id),[]));
		} else if(this.pathGroups.exists(id)) {
			return (lime_media_AudioBuffer().default).loadFromFiles(this.pathGroups.get(id));
		} else {
			return (lime_media_AudioBuffer().default).loadFromFile(this.paths.get(id));
		}
	},
	loadBytes: function(id) {
		if(this.cachedBytes.exists(id)) {
			return (lime_app_Future().default).withValue(this.cachedBytes.get(id));
		} else if(this.classTypes.exists(id)) {
			return (lime_app_Future().default).withValue((Type().default).createInstance(this.classTypes.get(id),[]));
		} else {
			return (lime_utils__$Bytes_Bytes_$Impl_$().default).loadFromFile(this.paths.get(id));
		}
	},
	loadFont: function(id) {
		if(this.cachedFonts.exists(id)) {
			return (lime_app_Future().default).withValue(this.cachedFonts.get(id));
		} else if(this.classTypes.exists(id)) {
			var font = (Type().default).createInstance(this.classTypes.get(id),[]);
			return font.__loadFromName(font.name);
		} else {
			return (lime_text_Font().default).loadFromName(this.paths.get(id));
		}
	},
	loadImage: function(id) {
		var _gthis = this;
		if(this.cachedImages.exists(id)) {
			return (lime_app_Future().default).withValue(this.cachedImages.get(id));
		} else if(this.classTypes.exists(id)) {
			return (lime_app_Future().default).withValue((Type().default).createInstance(this.classTypes.get(id),[]));
		} else if(this.cachedBytes.exists(id)) {
			return (lime_graphics_Image().default).loadFromBytes(this.cachedBytes.get(id)).then(function(image) {
				_gthis.cachedBytes.remove(id);
				_gthis.cachedImages.set(id,image);
				return (lime_app_Future().default).withValue(image);
			});
		} else {
			return (lime_graphics_Image().default).loadFromFile(this.paths.get(id));
		}
	},
	loadText: function(id) {
		if(this.cachedText.exists(id)) {
			return (lime_app_Future().default).withValue(this.cachedText.get(id));
		} else if(this.cachedBytes.exists(id) || this.classTypes.exists(id)) {
			var bytes = this.getBytes(id);
			if(bytes == null) {
				return (lime_app_Future().default).withValue(null);
			} else {
				var text = bytes.getString(0,bytes.get_length());
				this.cachedText.set(id,text);
				return (lime_app_Future().default).withValue(text);
			}
		} else {
			var request = new (lime_net__$HTTPRequest_$String().default)();
			return request.load(this.paths.get(id));
		}
	},
	unload: function() {
	},
	__assetLoaded: function(id) {
		this.assetsLoaded++;
		if(id != null) {
			(lime_utils_Log().default).verbose("Loaded asset: " + id + " [" + this.types.get(id) + "] (" + (this.assetsLoaded - 1) + "/" + (this.assetsTotal - 1) + ")",{ fileName : "../node_modules/lime/src/lime/utils/AssetLibrary.hx", lineNumber : 619, className : "lime.utils.AssetLibrary", methodName : "__assetLoaded"});
		}
		if(id != null) {
			var size = this.sizes.exists(id) ? this.sizes.get(id) : 0;
			if(!this.bytesLoadedCache.exists(id)) {
				this.bytesLoaded += size;
			} else {
				var cache = this.bytesLoadedCache.get(id);
				if(cache < size) {
					this.bytesLoaded += size - cache;
				}
			}
			this.bytesLoadedCache.set(id,size);
		}
		if(this.assetsLoaded < this.assetsTotal) {
			this.promise.progress(this.bytesLoaded,this.bytesTotal);
		} else {
			this.loaded = true;
			this.promise.progress(this.bytesTotal,this.bytesTotal);
			this.promise.complete(this);
		}
	},
	__cacheBreak: function(path) {
		return (lime_utils_Assets().default).__cacheBreak(path);
	},
	__fromBundle: function(bundle,manifest) {
		if(manifest != null) {
			var id;
			var data;
			var type;
			var _g = 0;
			var _g1 = manifest.assets;
			while(_g < _g1.length) {
				var asset = _g1[_g];
				++_g;
				id = (Reflect().default).hasField(asset,"id") ? asset.id : asset.path;
				data = bundle.data.get(asset.path);
				if((Reflect().default).hasField(asset,"type")) {
					type = asset.type;
					switch(type) {
					case "FONT":
						this.cachedFonts.set(id,(lime_text_Font().default).fromBytes(data));
						break;
					case "IMAGE":
						this.cachedImages.set(id,(lime_graphics_Image().default).fromBytes(data));
						break;
					case "MUSIC":case "SOUND":
						this.cachedAudioBuffers.set(id,(lime_media_AudioBuffer().default).fromBytes(data));
						break;
					case "TEXT":
						this.cachedText.set(id,data != null ? (Std().default).string(data) : null);
						break;
					default:
						this.cachedBytes.set(id,data);
					}
					this.types.set(id,asset.type);
				} else {
					this.cachedBytes.set(id,data);
					this.types.set(id,"BINARY");
				}
			}
		} else {
			var _g2 = 0;
			var _g11 = bundle.paths;
			while(_g2 < _g11.length) {
				var path = _g11[_g2];
				++_g2;
				this.cachedBytes.set(path,bundle.data.get(path));
				this.types.set(path,"BINARY");
			}
		}
	},
	__fromManifest: function(manifest) {
		var hasSize = manifest.version >= 2;
		var size;
		var id;
		var pathGroup;
		var classRef;
		var basePath = manifest.rootPath;
		if(basePath == null) {
			basePath = "";
		}
		if(basePath != "") {
			basePath += "/";
		}
		var _g = 0;
		var _g1 = manifest.assets;
		while(_g < _g1.length) {
			var asset = _g1[_g];
			++_g;
			size = hasSize && (Reflect().default).hasField(asset,"size") ? asset.size : 100;
			id = (Reflect().default).hasField(asset,"id") ? asset.id : asset.path;
			if((Reflect().default).hasField(asset,"path")) {
				this.paths.set(id,this.__cacheBreak(this.__resolvePath(basePath + (Std().default).string((Reflect().default).field(asset,"path")))));
			}
			if((Reflect().default).hasField(asset,"pathGroup")) {
				pathGroup = (Reflect().default).field(asset,"pathGroup");
				var _g2 = 0;
				var _g11 = pathGroup.length;
				while(_g2 < _g11) {
					var i = _g2++;
					pathGroup[i] = this.__cacheBreak(this.__resolvePath(basePath + pathGroup[i]));
				}
				this.pathGroups.set(id,pathGroup);
			}
			this.sizes.set(id,size);
			this.types.set(id,asset.type);
			if((Reflect().default).hasField(asset,"preload")) {
				this.preload.set(id,(Reflect().default).field(asset,"preload"));
			}
			if((Reflect().default).hasField(asset,"className")) {
				classRef = (Type().default).resolveClass((Reflect().default).field(asset,"className"));
				this.classTypes.set(id,classRef);
			}
		}
		this.bytesTotal = 0;
		var _g21 = 0;
		var _g3 = manifest.assets;
		while(_g21 < _g3.length) {
			var asset1 = _g3[_g21];
			++_g21;
			id = (Reflect().default).hasField(asset1,"id") ? asset1.id : asset1.path;
			if(this.preload.exists(id) && this.preload.get(id) && this.sizes.exists(id)) {
				this.bytesTotal += this.sizes.get(id);
			}
		}
	},
	__resolvePath: function(path) {
		path = (StringTools().default).replace(path,"\\","/");
		var colonIdx = path.indexOf(":");
		if((StringTools().default).startsWith(path,"http") && colonIdx > 0) {
			var lastSlashIdx = colonIdx + 3;
			var httpSection = (HxOverrides().default).substr(path,0,lastSlashIdx);
			path = httpSection + (StringTools().default).replace((HxOverrides().default).substr(path,lastSlashIdx,null),"//","/");
		} else {
			path = (StringTools().default).replace(path,"//","/");
		}
		if(path.indexOf("./") > -1) {
			var split = path.split("/");
			var newPath = [];
			var _g = 0;
			var _g1 = split.length;
			while(_g < _g1) {
				var i = _g++;
				if(split[i] == "..") {
					if(i == 0 || newPath[i - 1] == "..") {
						newPath.push("..");
					} else {
						newPath.pop();
					}
				} else if(split[i] == ".") {
					if(i == 0) {
						newPath.push(".");
					}
				} else {
					newPath.push(split[i]);
				}
			}
			path = newPath.join("/");
		}
		return path;
	},
	loadAudioBuffer_onComplete: function(id,audioBuffer) {
		this.cachedAudioBuffers.set(id,audioBuffer);
		if(this.pathGroups.exists(id)) {
			var pathGroup = this.pathGroups.get(id);
			var otherID = this.pathGroups.keys();
			while(otherID.hasNext()) {
				var otherID1 = otherID.next();
				if(otherID1 == id) {
					continue;
				}
				var _g = 0;
				while(_g < pathGroup.length) {
					var path = pathGroup[_g];
					++_g;
					if(this.pathGroups.get(otherID1).indexOf(path) > -1) {
						this.cachedAudioBuffers.set(otherID1,audioBuffer);
						break;
					}
				}
			}
		}
		this.__assetLoaded(id);
	},
	loadAudioBuffer_onError: function(id,message) {
		if(message != null && message != "") {
			(lime_utils_Log().default).warn("Could not load \"" + id + "\": " + (Std().default).string(message),{ fileName : "../node_modules/lime/src/lime/utils/AssetLibrary.hx", lineNumber : 865, className : "lime.utils.AssetLibrary", methodName : "loadAudioBuffer_onError"});
		} else {
			(lime_utils_Log().default).warn("Could not load \"" + id + "\"",{ fileName : "../node_modules/lime/src/lime/utils/AssetLibrary.hx", lineNumber : 869, className : "lime.utils.AssetLibrary", methodName : "loadAudioBuffer_onError"});
		}
		this.loadAudioBuffer_onComplete(id,new (lime_media_AudioBuffer().default)());
	},
	loadBytes_onComplete: function(id,bytes) {
		this.cachedBytes.set(id,bytes);
		this.__assetLoaded(id);
	},
	loadFont_onComplete: function(id,font) {
		this.cachedFonts.set(id,font);
		this.__assetLoaded(id);
	},
	loadImage_onComplete: function(id,image) {
		this.cachedImages.set(id,image);
		this.__assetLoaded(id);
	},
	loadText_onComplete: function(id,text) {
		this.cachedText.set(id,text);
		this.__assetLoaded(id);
	},
	load_onError: function(id,message) {
		if(message != null && message != "") {
			this.promise.error("Error loading asset \"" + id + "\": " + (Std().default).string(message));
		} else {
			this.promise.error("Error loading asset \"" + id + "\"");
		}
	},
	load_onProgress: function(id,bytesLoaded,bytesTotal) {
		if(bytesLoaded > 0) {
			var size = this.sizes.get(id);
			var percent;
			if(bytesTotal > 0) {
				percent = bytesLoaded / bytesTotal;
				if(percent > 1) {
					percent = 1;
				}
				bytesLoaded = Math.floor(percent * size);
			} else if(bytesLoaded > size) {
				bytesLoaded = size;
			}
			if(this.bytesLoadedCache.exists(id)) {
				var cache = this.bytesLoadedCache.get(id);
				if(bytesLoaded != cache) {
					this.bytesLoaded += bytesLoaded - cache;
				}
			} else {
				this.bytesLoaded += bytesLoaded;
			}
			this.bytesLoadedCache.set(id,bytesLoaded);
			this.promise.progress(this.bytesLoaded,this.bytesTotal);
		}
	}
};
AssetLibrary.prototype.__class__ = AssetLibrary.prototype.constructor = $hxClasses["lime.utils.AssetLibrary"] = AssetLibrary;

// Init



// Statics

AssetLibrary.fromBytes = function(bytes,rootPath) {
	return AssetLibrary.fromManifest((lime_utils_AssetManifest().default).fromBytes(bytes,rootPath));
}
AssetLibrary.fromFile = function(path,rootPath) {
	return AssetLibrary.fromManifest((lime_utils_AssetManifest().default).fromFile(path,rootPath));
}
AssetLibrary.fromBundle = function(bundle) {
	if(bundle.data.exists("library.json")) {
		var manifest = (lime_utils_AssetManifest().default).fromBytes(bundle.data.get("library.json"));
		if(manifest != null) {
			var library = null;
			if(manifest.libraryType == null) {
				library = new AssetLibrary();
			} else {
				var libraryClass = (Type().default).resolveClass(manifest.libraryType);
				if(libraryClass != null) {
					library = (Type().default).createInstance(libraryClass,manifest.libraryArgs);
				} else {
					(lime_utils_Log().default).warn("Could not find library type: " + manifest.libraryType,{ fileName : "../node_modules/lime/src/lime/utils/AssetLibrary.hx", lineNumber : 122, className : "lime.utils.AssetLibrary", methodName : "fromBundle"});
					return null;
				}
			}
			library.__fromBundle(bundle,manifest);
			return library;
		}
	} else {
		var library1 = new AssetLibrary();
		library1.__fromBundle(bundle);
		return library1;
	}
	return null;
}
AssetLibrary.fromManifest = function(manifest) {
	if(manifest == null) {
		return null;
	}
	var library = null;
	if(manifest.libraryType == null) {
		library = new AssetLibrary();
	} else {
		var libraryClass = (Type().default).resolveClass(manifest.libraryType);
		if(libraryClass != null) {
			library = (Type().default).createInstance(libraryClass,manifest.libraryArgs);
		} else {
			(lime_utils_Log().default).warn("Could not find library type: " + manifest.libraryType,{ fileName : "../node_modules/lime/src/lime/utils/AssetLibrary.hx", lineNumber : 160, className : "lime.utils.AssetLibrary", methodName : "fromManifest"});
			return null;
		}
	}
	library.__fromManifest(manifest);
	return library;
}
AssetLibrary.loadFromBytes = function(bytes,rootPath) {
	return (lime_utils_AssetManifest().default).loadFromBytes(bytes,rootPath).then(function(manifest) {
		return AssetLibrary.loadFromManifest(manifest);
	});
}
AssetLibrary.loadFromFile = function(path,rootPath) {
	return (lime_utils_AssetManifest().default).loadFromFile(path,rootPath).then(function(manifest) {
		return AssetLibrary.loadFromManifest(manifest);
	});
}
AssetLibrary.loadFromManifest = function(manifest) {
	var library = AssetLibrary.fromManifest(manifest);
	if(library != null) {
		return library.load();
	} else {
		return (lime_app_Future().default).withError("Could not load asset manifest");
	}
}


// Export

exports.default = AssetLibrary;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/AssetManifest.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/AssetManifest.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.AssetManifest

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_Serializer() {return __webpack_require__(/*! ./../../haxe/Serializer */ "./node_modules/openfl/lib/_gen/haxe/Serializer.js");}
function lime_utils__$Bytes_Bytes_$Impl_$() {return __webpack_require__(/*! ./../../lime/utils/_Bytes/Bytes_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function haxe_Unserializer() {return __webpack_require__(/*! ./../../haxe/Unserializer */ "./node_modules/openfl/lib/_gen/haxe/Unserializer.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function haxe_io_Path() {return __webpack_require__(/*! ./../../haxe/io/Path */ "./node_modules/openfl/lib/_gen/haxe/io/Path.js");}

// Constructor

var AssetManifest = function() {
	this.assets = [];
	this.libraryArgs = [];
	this.version = 2;
}

// Meta

AssetManifest.__name__ = "lime.utils.AssetManifest";
AssetManifest.__isInterface__ = false;
AssetManifest.prototype = {
	serialize: function() {
		var manifestData = { };
		manifestData.version = this.version;
		manifestData.libraryType = this.libraryType;
		manifestData.libraryArgs = this.libraryArgs;
		manifestData.name = this.name;
		manifestData.assets = (haxe_Serializer().default).run(this.assets);
		manifestData.rootPath = this.rootPath;
		return JSON.stringify(manifestData);
	}
};
AssetManifest.prototype.__class__ = AssetManifest.prototype.constructor = $hxClasses["lime.utils.AssetManifest"] = AssetManifest;

// Init



// Statics

AssetManifest.fromBytes = function(bytes,rootPath) {
	if(bytes != null) {
		return AssetManifest.parse(bytes.getString(0,bytes.get_length()),rootPath);
	} else {
		return null;
	}
}
AssetManifest.fromFile = function(path,rootPath) {
	path = AssetManifest.__resolvePath(path);
	rootPath = AssetManifest.__resolveRootPath(rootPath,path);
	if(path == null) {
		return null;
	}
	return AssetManifest.fromBytes((lime_utils__$Bytes_Bytes_$Impl_$().default).fromFile(path),rootPath);
}
AssetManifest.loadFromBytes = function(bytes,rootPath) {
	return (lime_app_Future().default).withValue(AssetManifest.fromBytes(bytes,rootPath));
}
AssetManifest.loadFromFile = function(path,rootPath) {
	path = AssetManifest.__resolvePath(path);
	rootPath = AssetManifest.__resolveRootPath(rootPath,path);
	if(path == null) {
		return null;
	}
	return (lime_utils__$Bytes_Bytes_$Impl_$().default).loadFromFile(path).then(function(bytes) {
		return (lime_app_Future().default).withValue(AssetManifest.fromBytes(bytes,rootPath));
	});
}
AssetManifest.parse = function(data,rootPath) {
	if(data == null || data == "") {
		return null;
	}
	var manifestData = JSON.parse(data);
	var manifest = new AssetManifest();
	if((Reflect().default).hasField(manifestData,"name")) {
		manifest.name = manifestData.name;
	}
	if((Reflect().default).hasField(manifestData,"libraryType")) {
		manifest.libraryType = manifestData.libraryType;
	}
	if((Reflect().default).hasField(manifestData,"libraryArgs")) {
		manifest.libraryArgs = manifestData.libraryArgs;
	}
	if((Reflect().default).hasField(manifestData,"assets")) {
		var assets = manifestData.assets;
		if((Reflect().default).hasField(manifestData,"version") && manifestData.version <= 2) {
			manifest.assets = (haxe_Unserializer().default).run(assets);
		} else {
			manifest.assets = assets;
		}
	}
	if((Reflect().default).hasField(manifestData,"rootPath")) {
		manifest.rootPath = manifestData.rootPath;
	}
	if(rootPath != null && rootPath != "") {
		if(manifest.rootPath == null || manifest.rootPath == "") {
			manifest.rootPath = rootPath;
		} else {
			manifest.rootPath = rootPath + "/" + manifest.rootPath;
		}
	}
	return manifest;
}
AssetManifest.__resolvePath = function(path) {
	if(path == null) {
		return null;
	}
	var queryIndex = path.indexOf("?");
	var basePath;
	if(queryIndex > -1) {
		basePath = (HxOverrides().default).substr(path,0,queryIndex);
	} else {
		basePath = path;
	}
	basePath = (StringTools().default).replace(basePath,"\\","/");
	while((StringTools().default).endsWith(basePath,"/")) basePath = (HxOverrides().default).substr(basePath,0,basePath.length - 1);
	if((StringTools().default).endsWith(basePath,".bundle")) {
		if(queryIndex > -1) {
			return basePath + "/library.json" + (HxOverrides().default).substr(path,queryIndex,null);
		} else {
			return basePath + "/library.json";
		}
	} else {
		return path;
	}
}
AssetManifest.__resolveRootPath = function(rootPath,path) {
	if(rootPath != null) {
		return rootPath;
	}
	var queryIndex = path.indexOf("?");
	if(queryIndex > -1) {
		rootPath = (HxOverrides().default).substr(path,0,queryIndex);
	} else {
		rootPath = path;
	}
	rootPath = (StringTools().default).replace(rootPath,"\\","/");
	while((StringTools().default).endsWith(rootPath,"/")) {
		if(rootPath == "/") {
			return rootPath;
		}
		rootPath = (HxOverrides().default).substr(rootPath,0,rootPath.length - 1);
	}
	if((StringTools().default).endsWith(rootPath,".bundle")) {
		return rootPath;
	} else {
		return (haxe_io_Path().default).directory(rootPath);
	}
}


// Export

exports.default = AssetManifest;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/Assets.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/Assets.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.Assets

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function lime_utils_AssetCache() {return __webpack_require__(/*! ./../../lime/utils/AssetCache */ "./node_modules/openfl/lib/_gen/lime/utils/AssetCache.js");}
function lime_app__$Event_$Void_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Void_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function lime_utils__$Assets_LibrarySymbol() {return __webpack_require__(/*! ./../../lime/utils/_Assets/LibrarySymbol */ "./node_modules/openfl/lib/_gen/lime/utils/_Assets/LibrarySymbol.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function lime_app_Promise() {return __webpack_require__(/*! ./../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}
function lime_utils_AssetBundle() {return __webpack_require__(/*! ./../../lime/utils/AssetBundle */ "./node_modules/openfl/lib/_gen/lime/utils/AssetBundle.js");}
function lime_utils_AssetLibrary() {return __webpack_require__(/*! ./../../lime/utils/AssetLibrary */ "./node_modules/openfl/lib/_gen/lime/utils/AssetLibrary.js");}
function haxe_io_Path() {return __webpack_require__(/*! ./../../haxe/io/Path */ "./node_modules/openfl/lib/_gen/haxe/io/Path.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function lime_utils_AssetManifest() {return __webpack_require__(/*! ./../../lime/utils/AssetManifest */ "./node_modules/openfl/lib/_gen/lime/utils/AssetManifest.js");}
function lime_app_Application() {return __webpack_require__(/*! ./../../lime/app/Application */ "./node_modules/openfl/lib/_gen/lime/app/Application.js");}

// Constructor

var Assets = function(){}

// Meta

Assets.__name__ = "lime.utils.Assets";
Assets.__isInterface__ = false;
Assets.prototype = {
	
};
Assets.prototype.__class__ = Assets.prototype.constructor = $hxClasses["lime.utils.Assets"] = Assets;

// Init



// Statics

Assets.exists = function(id,type) {
	if(type == null) {
		type = "BINARY";
	}
	var symbol = new (lime_utils__$Assets_LibrarySymbol().default)(id);
	if(symbol.library != null) {
		return symbol.exists(type);
	}
	return false;
}
Assets.getAsset = function(id,type,useCache) {
	if(useCache && Assets.cache.enabled) {
		switch(type) {
		case "BINARY":case "TEXT":
			useCache = false;
			break;
		case "FONT":
			var font = Assets.cache.font.get(id);
			if(font != null) {
				return font;
			}
			break;
		case "IMAGE":
			var image = Assets.cache.image.get(id);
			if(Assets.isValidImage(image)) {
				return image;
			}
			break;
		case "MUSIC":case "SOUND":
			var audio = Assets.cache.audio.get(id);
			if(Assets.isValidAudio(audio)) {
				return audio;
			}
			break;
		case "TEMPLATE":
			throw new (js__$Boot_HaxeError().default)("Not sure how to get template: " + id);
		default:
			return null;
		}
	}
	var symbol = new (lime_utils__$Assets_LibrarySymbol().default)(id);
	if(symbol.library != null) {
		if(symbol.exists(type)) {
			if(symbol.isLocal(type)) {
				var asset = symbol.library.getAsset(symbol.symbolName,type);
				if(useCache && Assets.cache.enabled) {
					Assets.cache.set(id,type,asset);
				}
				return asset;
			} else {
				(lime_utils_Log().default).error(type + " asset \"" + id + "\" exists, but only asynchronously",{ fileName : "../node_modules/lime/src/lime/utils/Assets.hx", lineNumber : 133, className : "lime.utils.Assets", methodName : "getAsset"});
			}
		} else {
			(lime_utils_Log().default).error("There is no " + type + " asset with an ID of \"" + id + "\"",{ fileName : "../node_modules/lime/src/lime/utils/Assets.hx", lineNumber : 138, className : "lime.utils.Assets", methodName : "getAsset"});
		}
	} else {
		(lime_utils_Log().default).error(Assets.__libraryNotFound(symbol.libraryName),{ fileName : "../node_modules/lime/src/lime/utils/Assets.hx", lineNumber : 143, className : "lime.utils.Assets", methodName : "getAsset"});
	}
	return null;
}
Assets.getAudioBuffer = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return Assets.getAsset(id,"SOUND",useCache);
}
Assets.getBytes = function(id) {
	return Assets.getAsset(id,"BINARY",false);
}
Assets.getFont = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return Assets.getAsset(id,"FONT",useCache);
}
Assets.getImage = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return Assets.getAsset(id,"IMAGE",useCache);
}
Assets.getLibrary = function(name) {
	if(name == null || name == "") {
		name = "default";
	}
	return Assets.libraries.get(name);
}
Assets.getPath = function(id) {
	var symbol = new (lime_utils__$Assets_LibrarySymbol().default)(id);
	if(symbol.library != null) {
		if(symbol.exists()) {
			return symbol.library.getPath(symbol.symbolName);
		} else {
			(lime_utils_Log().default).error("There is no asset with an ID of \"" + id + "\"",{ fileName : "../node_modules/lime/src/lime/utils/Assets.hx", lineNumber : 224, className : "lime.utils.Assets", methodName : "getPath"});
		}
	} else {
		(lime_utils_Log().default).error(Assets.__libraryNotFound(symbol.libraryName),{ fileName : "../node_modules/lime/src/lime/utils/Assets.hx", lineNumber : 229, className : "lime.utils.Assets", methodName : "getPath"});
	}
	return null;
}
Assets.getText = function(id) {
	return Assets.getAsset(id,"TEXT",false);
}
Assets.hasLibrary = function(name) {
	if(name == null || name == "") {
		name = "default";
	}
	return Assets.libraries.exists(name);
}
Assets.isLocal = function(id,type,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache && Assets.cache.enabled) {
		if(Assets.cache.exists(id,type)) {
			return true;
		}
	}
	var symbol = new (lime_utils__$Assets_LibrarySymbol().default)(id);
	if(symbol.library != null) {
		return symbol.isLocal(type);
	} else {
		return false;
	}
}
Assets.isValidAudio = function(buffer) {
	return buffer != null;
}
Assets.isValidImage = function(image) {
	if(image != null) {
		return image.buffer != null;
	} else {
		return false;
	}
}
Assets.list = function(type) {
	var items = [];
	var library = Assets.libraries.iterator();
	while(library.hasNext()) {
		var library1 = library.next();
		var libraryItems = library1.list(type);
		if(libraryItems != null) {
			items = items.concat(libraryItems);
		}
	}
	return items;
}
Assets.loadAsset = function(id,type,useCache) {
	if(useCache && Assets.cache.enabled) {
		switch(type) {
		case "BINARY":case "TEXT":
			useCache = false;
			break;
		case "FONT":
			var font = Assets.cache.font.get(id);
			if(font != null) {
				return (lime_app_Future().default).withValue(font);
			}
			break;
		case "IMAGE":
			var image = Assets.cache.image.get(id);
			if(Assets.isValidImage(image)) {
				return (lime_app_Future().default).withValue(image);
			}
			break;
		case "MUSIC":case "SOUND":
			var audio = Assets.cache.audio.get(id);
			if(Assets.isValidAudio(audio)) {
				return (lime_app_Future().default).withValue(audio);
			}
			break;
		case "TEMPLATE":
			throw new (js__$Boot_HaxeError().default)("Not sure how to get template: " + id);
		default:
			return null;
		}
	}
	var symbol = new (lime_utils__$Assets_LibrarySymbol().default)(id);
	if(symbol.library != null) {
		if(symbol.exists(type)) {
			var future = symbol.library.loadAsset(symbol.symbolName,type);
			if(useCache && Assets.cache.enabled) {
				future.onComplete(function(asset) {
					Assets.cache.set(id,type,asset);
				});
			}
			return future;
		} else {
			return (lime_app_Future().default).withError("There is no " + type + " asset with an ID of \"" + id + "\"");
		}
	} else {
		return (lime_app_Future().default).withError(Assets.__libraryNotFound(symbol.libraryName));
	}
}
Assets.loadAudioBuffer = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return Assets.loadAsset(id,"SOUND",useCache);
}
Assets.loadBytes = function(id) {
	return Assets.loadAsset(id,"BINARY",false);
}
Assets.loadFont = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return Assets.loadAsset(id,"FONT",useCache);
}
Assets.loadImage = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return Assets.loadAsset(id,"IMAGE",useCache);
}
Assets.loadLibrary = function(id) {
	var promise = new (lime_app_Promise().default)();
	var library = Assets.getLibrary(id);
	if(library != null) {
		return library.load();
	}
	var path = id;
	var rootPath = null;
	if(Assets.bundlePaths.exists(id)) {
		(lime_utils_AssetBundle().default).loadFromFile(Assets.bundlePaths.get(id)).onComplete(function(bundle) {
			if(bundle == null) {
				promise.error("Cannot load bundle for library \"" + id + "\"");
				return;
			}
			var library1 = (lime_utils_AssetLibrary().default).fromBundle(bundle);
			if(library1 == null) {
				promise.error("Cannot open library \"" + id + "\"");
			} else {
				Assets.libraries.set(id,library1);
				library1.onChange.add(($_=Assets.onChange,$bind($_,$_.dispatch)));
				var tmp = library1.load();
				promise.completeWith(tmp);
			}
		}).onError(function(_) {
			promise.error("There is no asset library with an ID of \"" + id + "\"");
		});
	} else {
		if(Assets.libraryPaths.exists(id)) {
			path = Assets.libraryPaths.get(id);
			rootPath = (haxe_io_Path().default).directory(path);
		} else {
			if((StringTools().default).endsWith(path,".bundle")) {
				rootPath = path;
				path += "/library.json";
			} else {
				rootPath = (haxe_io_Path().default).directory(path);
			}
			path = Assets.__cacheBreak(path);
		}
		(lime_utils_AssetManifest().default).loadFromFile(path,rootPath).onComplete(function(manifest) {
			if(manifest == null) {
				promise.error("Cannot parse asset manifest for library \"" + id + "\"");
				return;
			}
			var library2 = (lime_utils_AssetLibrary().default).fromManifest(manifest);
			if(library2 == null) {
				promise.error("Cannot open library \"" + id + "\"");
			} else {
				Assets.libraries.set(id,library2);
				library2.onChange.add(($_=Assets.onChange,$bind($_,$_.dispatch)));
				var tmp1 = library2.load();
				promise.completeWith(tmp1);
			}
		}).onError(function(_1) {
			promise.error("There is no asset library with an ID of \"" + id + "\"");
		});
	}
	return promise.future;
}
Assets.loadText = function(id) {
	return Assets.loadAsset(id,"TEXT",false);
}
Assets.registerLibrary = function(name,library) {
	if(Assets.libraries.exists(name)) {
		if(Assets.libraries.get(name) == library) {
			return;
		} else {
			Assets.unloadLibrary(name);
		}
	}
	if(library != null) {
		library.onChange.add(Assets.library_onChange);
	}
	Assets.libraries.set(name,library);
}
Assets.unloadLibrary = function(name) {
	if(name == null || name == "") {
		name = "default";
	}
	var library = Assets.libraries.get(name);
	if(library != null) {
		Assets.cache.clear(name + ":");
		library.onChange.remove(Assets.library_onChange);
		library.unload();
	}
	Assets.libraries.remove(name);
}
Assets.__cacheBreak = function(path) {
	return path;
}
Assets.__libraryNotFound = function(name) {
	if(name == null || name == "") {
		name = "default";
	}
	if((lime_app_Application().default).current != null && (lime_app_Application().default).current.get_preloader() != null && !(lime_app_Application().default).current.get_preloader().complete) {
		return "There is no asset library named \"" + name + "\", or it is not yet preloaded";
	} else {
		return "There is no asset library named \"" + name + "\"";
	}
}
Assets.library_onChange = function() {
	Assets.cache.clear();
	Assets.onChange.dispatch();
}
Assets.cache = new (lime_utils_AssetCache().default)()
Assets.onChange = new (lime_app__$Event_$Void_$Void().default)()
Assets.bundlePaths = new (haxe_ds_StringMap().default)()
Assets.libraries = new (haxe_ds_StringMap().default)()
Assets.libraryPaths = new (haxe_ds_StringMap().default)()

// Export

exports.default = Assets;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/BytePointerData.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/BytePointerData.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.BytePointerData

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var BytePointerData = function(bytes,offset) {
	this.bytes = bytes;
	this.offset = offset;
}

// Meta

BytePointerData.__name__ = "lime.utils.BytePointerData";
BytePointerData.__isInterface__ = false;
BytePointerData.prototype = {
	
};
BytePointerData.prototype.__class__ = BytePointerData.prototype.constructor = $hxClasses["lime.utils.BytePointerData"] = BytePointerData;

// Init



// Statics




// Export

exports.default = BytePointerData;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/CompressionAlgorithm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/CompressionAlgorithm.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: lime.utils.CompressionAlgorithm

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var CompressionAlgorithm = $hxEnums["lime.utils.CompressionAlgorithm"] = { __ename__ : "lime.utils.CompressionAlgorithm", __constructs__ : ["DEFLATE","GZIP","LZMA","ZLIB"]
  ,ZLIB: {_hx_index:3,__enum__:"lime.utils.CompressionAlgorithm",toString:$estr}
  ,LZMA: {_hx_index:2,__enum__:"lime.utils.CompressionAlgorithm",toString:$estr}
  ,GZIP: {_hx_index:1,__enum__:"lime.utils.CompressionAlgorithm",toString:$estr}
  ,DEFLATE: {_hx_index:0,__enum__:"lime.utils.CompressionAlgorithm",toString:$estr}
};

exports.default = CompressionAlgorithm;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/Log.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/Log.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.Log

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}

// Constructor

var Log = function(){}

// Meta

Log.__name__ = "lime.utils.Log";
Log.__isInterface__ = false;
Log.prototype = {
	
};
Log.prototype.__class__ = Log.prototype.constructor = $hxClasses["lime.utils.Log"] = Log;

// Init

{
	Log.level = 3;
	if(typeof console == "undefined") {
		console = {}
	}
	if(console.log == null) {
		console.log = function() {
		};
	}
};

// Statics

Log.debug = function(message,info) {
	if(Log.level >= 4) {
		console.debug("[" + info.className + "] " + (Std().default).string(message));
	}
}
Log.error = function(message,info) {
	if(Log.level >= 1) {
		var message1 = "[" + info.className + "] ERROR: " + (Std().default).string(message);
		if(Log.throwErrors) {
			throw new (js__$Boot_HaxeError().default)(message1);
		} else {
			console.error(message1);
		}
	}
}
Log.info = function(message,info) {
	if(Log.level >= 3) {
		console.info("[" + info.className + "] " + (Std().default).string(message));
	}
}
Log.print = function(message) {
	console.log(message);
}
Log.println = function(message) {
	console.log(message);
}
Log.verbose = function(message,info) {
	if(Log.level >= 5) {
		Log.println("[" + info.className + "] " + (Std().default).string(message));
	}
}
Log.warn = function(message,info) {
	if(Log.level >= 2) {
		console.warn("[" + info.className + "] WARNING: " + (Std().default).string(message));
	}
}
Log.throwErrors = true

// Export

exports.default = Log;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.ObjectPool

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_ObjectMap() {return __webpack_require__(/*! ./../../haxe/ds/ObjectMap */ "./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js");}
function haxe_ds_List() {return __webpack_require__(/*! ./../../haxe/ds/List */ "./node_modules/openfl/lib/_gen/haxe/ds/List.js");}

// Constructor

var ObjectPool = function(create,clean,size) {
	this.__pool = new (haxe_ds_ObjectMap().default)();
	this.activeObjects = 0;
	this.inactiveObjects = 0;
	this.__inactiveObject0 = null;
	this.__inactiveObject1 = null;
	this.__inactiveObjectList = new (haxe_ds_List().default)();
	if(create != null) {
		this.create = create;
	}
	if(clean != null) {
		this.clean = clean;
	}
	if(size != null) {
		this.set_size(size);
	}
}

// Meta

ObjectPool.__name__ = "lime.utils.ObjectPool";
ObjectPool.__isInterface__ = false;
ObjectPool.prototype = {
	add: function(object) {
		if(!this.__pool.exists(object)) {
			this.__pool.set(object,false);
			this.clean(object);
			this.__addInactive(object);
		}
	},
	clean: function(object) {
	},
	clear: function() {
		this.__pool = new (haxe_ds_ObjectMap().default)();
		this.activeObjects = 0;
		this.inactiveObjects = 0;
		this.__inactiveObject0 = null;
		this.__inactiveObject1 = null;
		this.__inactiveObjectList.clear();
	},
	create: function() {
		return null;
	},
	get: function() {
		var object = null;
		if(this.inactiveObjects > 0) {
			object = this.__getInactive();
		} else if(this.__size == null || this.activeObjects < this.__size) {
			object = this.create();
			if(object != null) {
				this.__pool.set(object,true);
				this.activeObjects++;
			}
		}
		return object;
	},
	release: function(object) {
		this.activeObjects--;
		if(this.__size == null || this.activeObjects + this.inactiveObjects < this.__size) {
			this.clean(object);
			this.__addInactive(object);
		} else {
			this.__pool.remove(object);
		}
	},
	remove: function(object) {
		if(this.__pool.exists(object)) {
			this.__pool.remove(object);
			if(this.__inactiveObject0 == object) {
				this.__inactiveObject0 = null;
				this.inactiveObjects--;
			} else if(this.__inactiveObject1 == object) {
				this.__inactiveObject1 = null;
				this.inactiveObjects--;
			} else if(this.__inactiveObjectList.remove(object)) {
				this.inactiveObjects--;
			} else {
				this.activeObjects--;
			}
		}
	},
	__addInactive: function(object) {
		if(this.__inactiveObject0 == null) {
			this.__inactiveObject0 = object;
		} else if(this.__inactiveObject1 == null) {
			this.__inactiveObject1 = object;
		} else {
			this.__inactiveObjectList.add(object);
		}
		this.inactiveObjects++;
	},
	__getInactive: function() {
		var object = null;
		if(this.__inactiveObject0 != null) {
			object = this.__inactiveObject0;
			this.__inactiveObject0 = null;
		} else if(this.__inactiveObject1 != null) {
			object = this.__inactiveObject1;
			this.__inactiveObject1 = null;
		} else {
			object = this.__inactiveObjectList.pop();
			if(this.__inactiveObjectList.length > 0) {
				this.__inactiveObject0 = this.__inactiveObjectList.pop();
			}
			if(this.__inactiveObjectList.length > 0) {
				this.__inactiveObject1 = this.__inactiveObjectList.pop();
			}
		}
		this.inactiveObjects--;
		this.activeObjects++;
		return object;
	},
	__removeInactive: function(count) {
		if(count <= 0 || this.inactiveObjects == 0) {
			return;
		}
		if(this.__inactiveObject0 != null) {
			this.__pool.remove(this.__inactiveObject0);
			this.__inactiveObject0 = null;
			this.inactiveObjects--;
			--count;
		}
		if(count == 0 || this.inactiveObjects == 0) {
			return;
		}
		if(this.__inactiveObject1 != null) {
			this.__pool.remove(this.__inactiveObject1);
			this.__inactiveObject1 = null;
			this.inactiveObjects--;
			--count;
		}
		if(count == 0 || this.inactiveObjects == 0) {
			return;
		}
		var object = this.__inactiveObjectList.iterator();
		while(object.hasNext()) {
			var object1 = object.next();
			this.__pool.remove(object1);
			this.__inactiveObjectList.remove(object1);
			this.inactiveObjects--;
			--count;
			if(count == 0 || this.inactiveObjects == 0) {
				return;
			}
		}
	},
	get_size: function() {
		return this.__size;
	},
	set_size: function(value) {
		if(value == null) {
			this.__size = null;
		} else {
			var current = this.inactiveObjects + this.activeObjects;
			this.__size = value;
			if(current > value) {
				this.__removeInactive(current - value);
			} else if(value > current) {
				var object;
				var _g = 0;
				var _g1 = value - current;
				while(_g < _g1) {
					var i = _g++;
					object = this.create();
					if(object != null) {
						this.__pool.set(object,false);
						this.__inactiveObjectList.add(object);
						this.inactiveObjects++;
					} else {
						break;
					}
				}
			}
		}
		return value;
	}
};
ObjectPool.prototype.__class__ = ObjectPool.prototype.constructor = $hxClasses["lime.utils.ObjectPool"] = ObjectPool;

// Init



// Statics




// Export

exports.default = ObjectPool;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/Preloader.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/Preloader.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils.Preloader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function lime_utils_Assets() {return __webpack_require__(/*! ./../../lime/utils/Assets */ "./node_modules/openfl/lib/_gen/lime/utils/Assets.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function haxe_ds_ObjectMap() {return __webpack_require__(/*! ./../../haxe/ds/ObjectMap */ "./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js");}
function lime_app__$Event_$Int_$Int_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Int_Int_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Int_Int_Void.js");}
function lime_app__$Event_$Void_$Void() {return __webpack_require__(/*! ./../../lime/app/_Event_Void_Void */ "./node_modules/openfl/lib/_gen/lime/app/_Event_Void_Void.js");}

// Constructor

var Preloader = function() {
	this.bytesTotalCache = new (haxe_ds_StringMap().default)();
	this.bytesLoadedCache2 = new (haxe_ds_StringMap().default)();
	this.bytesLoadedCache = new (haxe_ds_ObjectMap().default)();
	this.onProgress = new (lime_app__$Event_$Int_$Int_$Void().default)();
	this.onComplete = new (lime_app__$Event_$Void_$Void().default)();
	this.bytesLoaded = 0;
	this.bytesTotal = 0;
	this.libraries = [];
	this.libraryNames = [];
	this.onProgress.add($bind(this,this.update));
}

// Meta

Preloader.__name__ = "lime.utils.Preloader";
Preloader.__isInterface__ = false;
Preloader.prototype = {
	addLibrary: function(library) {
		this.libraries.push(library);
	},
	addLibraryName: function(name) {
		if(this.libraryNames.indexOf(name) == -1) {
			this.libraryNames.push(name);
		}
	},
	load: function() {
		var _gthis = this;
		var _g = 0;
		var _g1 = this.libraries;
		while(_g < _g1.length) {
			var library = _g1[_g];
			++_g;
			this.bytesTotal += library.bytesTotal;
		}
		this.loadedLibraries = -1;
		this.preloadStarted = false;
		var _g2 = 0;
		var _g3 = this.libraries;
		while(_g2 < _g3.length) {
			var library1 = [_g3[_g2]];
			++_g2;
			(lime_utils_Log().default).verbose("Preloading asset library",{ fileName : "../node_modules/lime/src/lime/utils/Preloader.hx", lineNumber : 132, className : "lime.utils.Preloader", methodName : "load"});
			library1[0].load().onProgress((function(library2) {
				return function(loaded,total) {
					if(!_gthis.bytesLoadedCache.exists(library2[0])) {
						_gthis.bytesLoaded += loaded;
					} else {
						_gthis.bytesLoaded += loaded - _gthis.bytesLoadedCache.get(library2[0]);
					}
					_gthis.bytesLoadedCache.set(library2[0],loaded);
					if(!_gthis.simulateProgress) {
						_gthis.onProgress.dispatch(_gthis.bytesLoaded,_gthis.bytesTotal);
					}
				};
			})(library1)).onComplete((function(library3) {
				return function(_) {
					if(!_gthis.bytesLoadedCache.exists(library3[0])) {
						_gthis.bytesLoaded += library3[0].bytesTotal;
					} else {
						_gthis.bytesLoaded += library3[0].bytesTotal - _gthis.bytesLoadedCache.get(library3[0]);
					}
					_gthis.loadedAssetLibrary();
				};
			})(library1)).onError((function() {
				return function(e) {
					(lime_utils_Log().default).error(e,{ fileName : "../node_modules/lime/src/lime/utils/Preloader.hx", lineNumber : 168, className : "lime.utils.Preloader", methodName : "load"});
				};
			})());
		}
		var _g4 = 0;
		var _g5 = this.libraryNames;
		while(_g4 < _g5.length) {
			var name = _g5[_g4];
			++_g4;
			this.bytesTotal += 200;
		}
		this.loadedLibraries++;
		this.preloadStarted = true;
		this.updateProgress();
	},
	loadedAssetLibrary: function(name) {
		this.loadedLibraries++;
		var current = this.loadedLibraries;
		if(!this.preloadStarted) {
			++current;
		}
		var totalLibraries = this.libraries.length + this.libraryNames.length;
		if(name != null) {
			(lime_utils_Log().default).verbose("Loaded asset library: " + name + " [" + current + "/" + totalLibraries + "]",{ fileName : "../node_modules/lime/src/lime/utils/Preloader.hx", lineNumber : 195, className : "lime.utils.Preloader", methodName : "loadedAssetLibrary"});
		} else {
			(lime_utils_Log().default).verbose("Loaded asset library [" + current + "/" + totalLibraries + "]",{ fileName : "../node_modules/lime/src/lime/utils/Preloader.hx", lineNumber : 199, className : "lime.utils.Preloader", methodName : "loadedAssetLibrary"});
		}
		this.updateProgress();
	},
	start: function() {
		if(this.complete || this.simulateProgress || !this.preloadComplete) {
			return;
		}
		this.complete = true;
		this.onComplete.dispatch();
	},
	update: function(loaded,total) {
	},
	updateProgress: function() {
		var _gthis = this;
		if(!this.simulateProgress) {
			this.onProgress.dispatch(this.bytesLoaded,this.bytesTotal);
		}
		if(this.loadedLibraries == this.libraries.length && !this.initLibraryNames) {
			this.initLibraryNames = true;
			var _g = 0;
			var _g1 = this.libraryNames;
			while(_g < _g1.length) {
				var name = [_g1[_g]];
				++_g;
				(lime_utils_Log().default).verbose("Preloading asset library: " + name[0],{ fileName : "../node_modules/lime/src/lime/utils/Preloader.hx", lineNumber : 236, className : "lime.utils.Preloader", methodName : "updateProgress"});
				(lime_utils_Assets().default).loadLibrary(name[0]).onProgress((function(name1) {
					return function(loaded,total) {
						if(total > 0) {
							if(!_gthis.bytesTotalCache.exists(name1[0])) {
								_gthis.bytesTotalCache.set(name1[0],total);
								_gthis.bytesTotal += total - 200;
							}
							if(loaded > total) {
								loaded = total;
							}
							if(!_gthis.bytesLoadedCache2.exists(name1[0])) {
								_gthis.bytesLoaded += loaded;
							} else {
								_gthis.bytesLoaded += loaded - _gthis.bytesLoadedCache2.get(name1[0]);
							}
							_gthis.bytesLoadedCache2.set(name1[0],loaded);
							if(!_gthis.simulateProgress) {
								_gthis.onProgress.dispatch(_gthis.bytesLoaded,_gthis.bytesTotal);
							}
						}
					};
				})(name)).onComplete((function(name2) {
					return function(library) {
						var total1 = 200;
						if(_gthis.bytesTotalCache.exists(name2[0])) {
							total1 = _gthis.bytesTotalCache.get(name2[0]);
						}
						if(!_gthis.bytesLoadedCache2.exists(name2[0])) {
							_gthis.bytesLoaded += total1;
						} else {
							_gthis.bytesLoaded += total1 - _gthis.bytesLoadedCache2.get(name2[0]);
						}
						_gthis.loadedAssetLibrary(name2[0]);
					};
				})(name)).onError((function() {
					return function(e) {
						(lime_utils_Log().default).error(e,{ fileName : "../node_modules/lime/src/lime/utils/Preloader.hx", lineNumber : 290, className : "lime.utils.Preloader", methodName : "updateProgress"});
					};
				})());
			}
		}
		if(!this.simulateProgress && this.loadedLibraries == this.libraries.length + this.libraryNames.length) {
			if(!this.preloadComplete) {
				this.preloadComplete = true;
				(lime_utils_Log().default).verbose("Preload complete",{ fileName : "../node_modules/lime/src/lime/utils/Preloader.hx", lineNumber : 301, className : "lime.utils.Preloader", methodName : "updateProgress"});
			}
			this.start();
		}
	}
};
Preloader.prototype.__class__ = Preloader.prototype.constructor = $hxClasses["lime.utils.Preloader"] = Preloader;

// Init



// Statics




// Export

exports.default = Preloader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/_Assets/LibrarySymbol.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/_Assets/LibrarySymbol.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils._Assets.LibrarySymbol

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_utils_Assets() {return __webpack_require__(/*! ./../../../lime/utils/Assets */ "./node_modules/openfl/lib/_gen/lime/utils/Assets.js");}

// Constructor

var LibrarySymbol = function(id) {
	var colonIndex = id.indexOf(":");
	this.libraryName = id.substring(0,colonIndex);
	this.symbolName = id.substring(colonIndex + 1);
	this.library = (lime_utils_Assets().default).getLibrary(this.libraryName);
}

// Meta

LibrarySymbol.__name__ = "lime.utils._Assets.LibrarySymbol";
LibrarySymbol.__isInterface__ = false;
LibrarySymbol.prototype = {
	isLocal: function(type) {
		return this.library.isLocal(this.symbolName,type);
	},
	exists: function(type) {
		return this.library.exists(this.symbolName,type);
	}
};
LibrarySymbol.prototype.__class__ = LibrarySymbol.prototype.constructor = $hxClasses["lime.utils._Assets.LibrarySymbol"] = LibrarySymbol;

// Init



// Statics




// Export

exports.default = LibrarySymbol;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/_BytePointer/BytePointer_Impl_.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/_BytePointer/BytePointer_Impl_.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils._BytePointer.BytePointer_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_utils_BytePointerData() {return __webpack_require__(/*! ./../../../lime/utils/BytePointerData */ "./node_modules/openfl/lib/_gen/lime/utils/BytePointerData.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function lime_utils__$Bytes_Bytes_$Impl_$() {return __webpack_require__(/*! ./../../../lime/utils/_Bytes/Bytes_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js");}
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var BytePointer_Impl_ = function(){}

// Meta

BytePointer_Impl_.__name__ = "lime.utils._BytePointer.BytePointer_Impl_";
BytePointer_Impl_.__isInterface__ = false;
BytePointer_Impl_.prototype = {
	
};
BytePointer_Impl_.prototype.__class__ = BytePointer_Impl_.prototype.constructor = $hxClasses["lime.utils._BytePointer.BytePointer_Impl_"] = BytePointer_Impl_;

// Init



// Statics

BytePointer_Impl_._new = function(bytes,offset) {
	if(offset == null) {
		offset = 0;
	}
	var this1 = new (lime_utils_BytePointerData().default)(bytes,offset);
	return this1;
}
BytePointer_Impl_.set = function(this1,bytes,bufferView,buffer,offset) {
	if(buffer != null) {
		bytes = (haxe_io_Bytes().default).ofData(buffer);
	}
	if(bytes != null || bufferView == null) {
		this1.bytes = bytes;
		this1.offset = offset != null ? offset : 0;
	} else {
		this1.bytes = (haxe_io_Bytes().default).ofData(bufferView.buffer);
		this1.offset = offset != null ? bufferView.byteOffset + offset : bufferView.byteOffset;
	}
}
BytePointer_Impl_.__arrayGet = function(this1,index) {
	if(this1.bytes != null) {
		return this1.bytes.get(index + this1.offset);
	} else {
		return 0;
	}
}
BytePointer_Impl_.__arraySet = function(this1,index,value) {
	if(this1.bytes == null) {
		this1.bytes.set(index + this1.offset,value);
	}
	return value;
}
BytePointer_Impl_.fromArrayBufferView = function(arrayBufferView) {
	if(arrayBufferView == null) {
		return null;
	}
	return new (lime_utils_BytePointerData().default)((haxe_io_Bytes().default).ofData(arrayBufferView.buffer),arrayBufferView.byteOffset);
}
BytePointer_Impl_.fromArrayBuffer = function(buffer) {
	if(buffer == null) {
		return null;
	}
	return new (lime_utils_BytePointerData().default)((haxe_io_Bytes().default).ofData(buffer),0);
}
BytePointer_Impl_.fromBytes = function(bytes) {
	return new (lime_utils_BytePointerData().default)(bytes,0);
}
BytePointer_Impl_.fromBytesData = function(bytesData) {
	if(bytesData == null) {
		return new (lime_utils_BytePointerData().default)(null,0);
	} else {
		return new (lime_utils_BytePointerData().default)((haxe_io_Bytes().default).ofData(bytesData),0);
	}
}
BytePointer_Impl_.fromFile = function(path) {
	return new (lime_utils_BytePointerData().default)((lime_utils__$Bytes_Bytes_$Impl_$().default).fromFile(path),0);
}
BytePointer_Impl_.fromLimeBytes = function(bytes) {
	return new (lime_utils_BytePointerData().default)(bytes,0);
}
BytePointer_Impl_.toUInt8Array = function(bytePointer) {
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 8);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Uint8Array(elements);
	} else if(array != null) {
		this1 = new Uint8Array(array);
	} else if(view != null) {
		this1 = new Uint8Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Uint8Array(buffer,byteoffset);
		} else {
			this1 = new Uint8Array(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}
BytePointer_Impl_.toUInt8ClampedArray = function(bytePointer) {
	if(bytePointer == null || bytePointer.bytes == null) {
		return null;
	}
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 8);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Uint8ClampedArray(elements);
	} else if(array != null) {
		this1 = new Uint8ClampedArray(array);
	} else if(view != null) {
		this1 = new Uint8ClampedArray(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Uint8ClampedArray(buffer,byteoffset);
		} else {
			this1 = new Uint8ClampedArray(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}
BytePointer_Impl_.toInt8Array = function(bytePointer) {
	if(bytePointer == null || bytePointer.bytes == null) {
		return null;
	}
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 8);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Int8Array(elements);
	} else if(array != null) {
		this1 = new Int8Array(array);
	} else if(view != null) {
		this1 = new Int8Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Int8Array(buffer,byteoffset);
		} else {
			this1 = new Int8Array(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}
BytePointer_Impl_.toUInt16Array = function(bytePointer) {
	if(bytePointer == null || bytePointer.bytes == null) {
		return null;
	}
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 16);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Uint16Array(elements);
	} else if(array != null) {
		this1 = new Uint16Array(array);
	} else if(view != null) {
		this1 = new Uint16Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Uint16Array(buffer,byteoffset);
		} else {
			this1 = new Uint16Array(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}
BytePointer_Impl_.toInt16Array = function(bytePointer) {
	if(bytePointer == null || bytePointer.bytes == null) {
		return null;
	}
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 16);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Int16Array(elements);
	} else if(array != null) {
		this1 = new Int16Array(array);
	} else if(view != null) {
		this1 = new Int16Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Int16Array(buffer,byteoffset);
		} else {
			this1 = new Int16Array(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}
BytePointer_Impl_.toUInt32Array = function(bytePointer) {
	if(bytePointer == null || bytePointer.bytes == null) {
		return null;
	}
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 32);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Uint32Array(elements);
	} else if(array != null) {
		this1 = new Uint32Array(array);
	} else if(view != null) {
		this1 = new Uint32Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Uint32Array(buffer,byteoffset);
		} else {
			this1 = new Uint32Array(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}
BytePointer_Impl_.toInt32Array = function(bytePointer) {
	if(bytePointer == null || bytePointer.bytes == null) {
		return null;
	}
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 32);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Int32Array(elements);
	} else if(array != null) {
		this1 = new Int32Array(array);
	} else if(view != null) {
		this1 = new Int32Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Int32Array(buffer,byteoffset);
		} else {
			this1 = new Int32Array(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}
BytePointer_Impl_.toFloat32Array = function(bytePointer) {
	if(bytePointer == null || bytePointer.bytes == null) {
		return null;
	}
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 32);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Float32Array(elements);
	} else if(array != null) {
		this1 = new Float32Array(array);
	} else if(view != null) {
		this1 = new Float32Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Float32Array(buffer,byteoffset);
		} else {
			this1 = new Float32Array(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}
BytePointer_Impl_.toFloat64Array = function(bytePointer) {
	if(bytePointer == null || bytePointer.bytes == null) {
		return null;
	}
	var elements = null;
	var array = null;
	var view = null;
	var buffer = bytePointer.bytes.getData();
	var byteoffset = (Std().default).int(bytePointer.offset / 64);
	var len = null;
	if(byteoffset == null) {
		byteoffset = 0;
	}
	var this1;
	if(elements != null) {
		this1 = new Float64Array(elements);
	} else if(array != null) {
		this1 = new Float64Array(array);
	} else if(view != null) {
		this1 = new Float64Array(view);
	} else if(buffer != null) {
		if(len == null) {
			this1 = new Float64Array(buffer,byteoffset);
		} else {
			this1 = new Float64Array(buffer,byteoffset,len);
		}
	} else {
		this1 = null;
	}
	return this1;
}


// Export

exports.default = BytePointer_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils._Bytes.Bytes_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function lime__$internal_format_Deflate() {return __webpack_require__(/*! ./../../../lime/_internal/format/Deflate */ "./node_modules/openfl/lib/_gen/lime/_internal/format/Deflate.js");}
function lime__$internal_format_GZip() {return __webpack_require__(/*! ./../../../lime/_internal/format/GZip */ "./node_modules/openfl/lib/_gen/lime/_internal/format/GZip.js");}
function lime__$internal_format_LZMA() {return __webpack_require__(/*! ./../../../lime/_internal/format/LZMA */ "./node_modules/openfl/lib/_gen/lime/_internal/format/LZMA.js");}
function lime__$internal_format_Zlib() {return __webpack_require__(/*! ./../../../lime/_internal/format/Zlib */ "./node_modules/openfl/lib/_gen/lime/_internal/format/Zlib.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function lime_net__$HTTPRequest_$lime_$utils_$Bytes() {return __webpack_require__(/*! ./../../../lime/net/_HTTPRequest_lime_utils_Bytes */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_lime_utils_Bytes.js");}

// Constructor

var Bytes_Impl_ = function(){}

// Meta

Bytes_Impl_.__name__ = "lime.utils._Bytes.Bytes_Impl_";
Bytes_Impl_.__isInterface__ = false;
Bytes_Impl_.prototype = {
	
};
Bytes_Impl_.prototype.__class__ = Bytes_Impl_.prototype.constructor = $hxClasses["lime.utils._Bytes.Bytes_Impl_"] = Bytes_Impl_;

// Init



// Statics

Bytes_Impl_._new = function(length,bytesData) {
	var this1 = new (haxe_io_Bytes().default)(bytesData);
	return this1;
}
Bytes_Impl_.alloc = function(length) {
	return (haxe_io_Bytes().default).alloc(length);
}
Bytes_Impl_.compress = function(this1,algorithm) {
	switch(algorithm._hx_index) {
	case 0:
		return (lime__$internal_format_Deflate().default).compress(this1);
	case 1:
		return (lime__$internal_format_GZip().default).compress(this1);
	case 2:
		return (lime__$internal_format_LZMA().default).compress(this1);
	case 3:
		return (lime__$internal_format_Zlib().default).compress(this1);
	}
}
Bytes_Impl_.decompress = function(this1,algorithm) {
	switch(algorithm._hx_index) {
	case 0:
		return (lime__$internal_format_Deflate().default).decompress(this1);
	case 1:
		return (lime__$internal_format_GZip().default).decompress(this1);
	case 2:
		return (lime__$internal_format_LZMA().default).decompress(this1);
	case 3:
		return (lime__$internal_format_Zlib().default).decompress(this1);
	}
}
Bytes_Impl_.fastGet = function(b,pos) {
	return (haxe_io_Bytes().default).fastGet(b,pos);
}
Bytes_Impl_.fromBytes = function(bytes) {
	if(bytes == null) {
		return null;
	}
	return Bytes_Impl_._new(bytes.get_length(),bytes.getData());
}
Bytes_Impl_.fromFile = function(path) {
	return null;
}
Bytes_Impl_.loadFromBytes = function(bytes) {
	return (lime_app_Future().default).withValue(Bytes_Impl_.fromBytes(bytes));
}
Bytes_Impl_.loadFromFile = function(path) {
	var request = new (lime_net__$HTTPRequest_$lime_$utils_$Bytes().default)();
	return request.load(path);
}
Bytes_Impl_.ofData = function(b) {
	var bytes = (haxe_io_Bytes().default).ofData(b);
	return Bytes_Impl_._new(bytes.get_length(),bytes.getData());
}
Bytes_Impl_.ofString = function(s) {
	var bytes = (haxe_io_Bytes().default).ofString(s);
	return Bytes_Impl_._new(bytes.get_length(),bytes.getData());
}


// Export

exports.default = Bytes_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/lime/utils/_DataPointer/DataPointer_Impl_.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/lime/utils/_DataPointer/DataPointer_Impl_.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: lime.utils._DataPointer.DataPointer_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_system__$CFFIPointer_CFFIPointer_$Impl_$() {return __webpack_require__(/*! ./../../../lime/system/_CFFIPointer/CFFIPointer_Impl_ */ "./node_modules/openfl/lib/_gen/lime/system/_CFFIPointer/CFFIPointer_Impl_.js");}
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var DataPointer_Impl_ = function(){}

// Meta

DataPointer_Impl_.__name__ = "lime.utils._DataPointer.DataPointer_Impl_";
DataPointer_Impl_.__isInterface__ = false;
DataPointer_Impl_.prototype = {
	
};
DataPointer_Impl_.prototype.__class__ = DataPointer_Impl_.prototype.constructor = $hxClasses["lime.utils._DataPointer.DataPointer_Impl_"] = DataPointer_Impl_;

// Init



// Statics

DataPointer_Impl_._new = function(data) {
	var this1 = data;
	return this1;
}
DataPointer_Impl_.fromFloat = function(value) {
	return value;
}
DataPointer_Impl_.fromBytesPointer = function(pointer) {
	return DataPointer_Impl_.fromFloat(0);
}
DataPointer_Impl_.fromArrayBufferView = function(arrayBufferView) {
	return DataPointer_Impl_.fromFloat(0);
}
DataPointer_Impl_.fromArrayBuffer = function(buffer) {
	return DataPointer_Impl_.fromFloat(0);
}
DataPointer_Impl_.fromBytes = function(bytes) {
	return DataPointer_Impl_.fromFloat(0);
}
DataPointer_Impl_.fromBytesData = function(bytesData) {
	return DataPointer_Impl_.fromFloat(0);
}
DataPointer_Impl_.fromLimeBytes = function(bytes) {
	return DataPointer_Impl_.fromBytes(bytes);
}
DataPointer_Impl_.fromCFFIPointer = function(pointer) {
	return DataPointer_Impl_.fromFloat(0);
}
DataPointer_Impl_.fromFile = function(path) {
	return DataPointer_Impl_.fromFloat(0);
}
DataPointer_Impl_.__withOffset = function(data,offset) {
	return DataPointer_Impl_.fromFloat(0);
}
DataPointer_Impl_.equals = function(a,b) {
	return a == b;
}
DataPointer_Impl_.equalsPointer = function(a,b) {
	return a == b;
}
DataPointer_Impl_.greaterThan = function(a,b) {
	return a > b;
}
DataPointer_Impl_.greaterThanPointer = function(a,b) {
	return (lime_system__$CFFIPointer_CFFIPointer_$Impl_$().default).get(a) > (lime_system__$CFFIPointer_CFFIPointer_$Impl_$().default).get(b);
}
DataPointer_Impl_.greaterThanOrEqual = function(a,b) {
	return a >= b;
}
DataPointer_Impl_.greaterThanOrEqualPointer = function(a,b) {
	return (lime_system__$CFFIPointer_CFFIPointer_$Impl_$().default).get(a) >= (lime_system__$CFFIPointer_CFFIPointer_$Impl_$().default).get(b);
}
DataPointer_Impl_.lessThan = function(a,b) {
	return a < b;
}
DataPointer_Impl_.lessThanPointer = function(a,b) {
	return (lime_system__$CFFIPointer_CFFIPointer_$Impl_$().default).get(a) < (lime_system__$CFFIPointer_CFFIPointer_$Impl_$().default).get(b);
}
DataPointer_Impl_.lessThanOrEqual = function(a,b) {
	return a <= b;
}
DataPointer_Impl_.lessThanOrEqualPointer = function(a,b) {
	return (lime_system__$CFFIPointer_CFFIPointer_$Impl_$().default).get(a) <= (lime_system__$CFFIPointer_CFFIPointer_$Impl_$().default).get(b);
}
DataPointer_Impl_.notEquals = function(a,b) {
	return a != b;
}
DataPointer_Impl_.notEqualsPointer = function(a,b) {
	return a != b;
}
DataPointer_Impl_.plus = function(a,b) {
	return DataPointer_Impl_.__withOffset(a,b);
}
DataPointer_Impl_.plusPointer = function(a,b) {
	return DataPointer_Impl_.__withOffset(a,(Std().default).int(b));
}
DataPointer_Impl_.minus = function(a,b) {
	return DataPointer_Impl_.__withOffset(a,-b);
}
DataPointer_Impl_.minusPointer = function(a,b) {
	return DataPointer_Impl_.__withOffset(a,-(Std().default).int(b));
}


// Export

exports.default = DataPointer_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/Lib.js":
/*!****************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/Lib.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.Lib

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function Std() {return __webpack_require__(/*! ./../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl_display_MovieClip() {return __webpack_require__(/*! ./../openfl/display/MovieClip */ "./node_modules/openfl/lib/_gen/openfl/display/MovieClip.js");}
function Type() {return __webpack_require__(/*! ./../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function lime_system_System() {return __webpack_require__(/*! ./../lime/system/System */ "./node_modules/openfl/lib/_gen/lime/system/System.js");}
function ValueType() {return __webpack_require__(/*! ./../ValueType */ "./node_modules/openfl/lib/_gen/ValueType.js");}
function Reflect() {return __webpack_require__(/*! ./../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function StringTools() {return __webpack_require__(/*! ./../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function openfl_net_URLLoader() {return __webpack_require__(/*! ./../openfl/net/URLLoader */ "./node_modules/openfl/lib/_gen/openfl/net/URLLoader.js");}
function haxe_Timer() {return __webpack_require__(/*! ./../haxe/Timer */ "./node_modules/openfl/lib/_gen/haxe/Timer.js");}
function haxe_Log() {return __webpack_require__(/*! ./../haxe/Log */ "./node_modules/openfl/lib/_gen/haxe/Log.js");}
function openfl__$internal_Lib() {return __webpack_require__(/*! ./../openfl/_internal/Lib */ "./node_modules/openfl/lib/_gen/openfl/_internal/Lib.js");}

// Constructor

var Lib = function(){}

// Meta

Lib.__name__ = "openfl.Lib";
Lib.__isInterface__ = false;
Lib.prototype = {
	
};
Lib.prototype.__class__ = Lib.prototype.constructor = $hxClasses["openfl.Lib"] = Lib;

// Init

Object.defineProperties(Lib,{ application : { get : function() {
	return Lib.get_application();
}}, current : { get : function() {
	return Lib.get_current();
}}});

// Statics

Lib.as = function(v,c) {
	if((Std().default).is(v,c)) {
		return v;
	} else {
		return null;
	}
}
Lib.attach = function(name) {
	return new (openfl_display_MovieClip().default)();
}
Lib.clearInterval = function(id) {
	if(Lib.__timers.exists(id)) {
		var timer = Lib.__timers.get(id);
		timer.stop();
		Lib.__timers.remove(id);
	}
}
Lib.clearTimeout = function(id) {
	if(Lib.__timers.exists(id)) {
		var timer = Lib.__timers.get(id);
		timer.stop();
		Lib.__timers.remove(id);
	}
}
Lib.getDefinitionByName = function(name) {
	if(name == null) {
		return null;
	}
	return (Type().default).resolveClass(name);
}
Lib.getQualifiedClassName = function(value) {
	if(value == null) {
		return null;
	}
	var ref = (Std().default).is(value,$hxClasses["Class"]) ? value : (Type().default).getClass(value);
	if(ref == null) {
		if(typeof(value) == "boolean" || value == $hxClasses["Bool"]) {
			return "Bool";
		} else if(typeof(value) == "number" && ((value | 0) === value) || value == $hxClasses["Int"]) {
			return "Int";
		} else if(typeof(value) == "number" || value == $hxClasses["Float"]) {
			return "Float";
		} else {
			return null;
		}
	}
	return (Type().default).getClassName(ref);
}
Lib.getQualifiedSuperclassName = function(value) {
	if(value == null) {
		return null;
	}
	var ref = (Std().default).is(value,$hxClasses["Class"]) ? value : (Type().default).getClass(value);
	if(ref == null) {
		return null;
	}
	var parentRef = (Type().default).getSuperClass(ref);
	if(parentRef == null) {
		return null;
	}
	return (Type().default).getClassName(parentRef);
}
Lib.getTimer = function() {
	return (lime_system_System().default).getTimer();
}
Lib.getURL = function(request,target) {
	Lib.navigateToURL(request,target);
}
Lib.navigateToURL = function(request,$window) {
	if($window == null) {
		$window = "_blank";
	}
	var uri = request.url;
	if((Type().default).typeof(request.data) == (ValueType().default).TObject) {
		var query = "";
		var fields = (Reflect().default).fields(request.data);
		var _g = 0;
		while(_g < fields.length) {
			var field = fields[_g];
			++_g;
			if(query.length > 0) {
				query += "&";
			}
			query += (StringTools().default).urlEncode(field) + "=" + (StringTools().default).urlEncode((Std().default).string((Reflect().default).field(request.data,field)));
		}
		if(uri.indexOf("?") > -1) {
			uri += "&" + query;
		} else {
			uri += "?" + query;
		}
	}
	(lime_system_System().default).openURL(uri,$window);
}
Lib.notImplemented = function(posInfo) {
	var api = posInfo.className + "." + posInfo.methodName;
	if(!Lib.__sentWarnings.exists(api)) {
		Lib.__sentWarnings.set(api,true);
		(lime_utils_Log().default).warn(posInfo.methodName + " is not implemented",posInfo);
	}
}
Lib.preventDefaultTouchMove = function() {
	window.document.addEventListener("touchmove",function(evt) {
		evt.preventDefault();
	},false);
}
Lib.sendToURL = function(request) {
	var urlLoader = new (openfl_net_URLLoader().default)();
	urlLoader.load(request);
}
Lib.setInterval = function(closure,delay,args) {
	var id = ++Lib.__lastTimerID;
	var timer = new (haxe_Timer().default)(delay);
	Lib.__timers.set(id,timer);
	timer.run = function() {
		(Reflect().default).callMethod(closure,closure,args == null ? [] : args);
	};
	return id;
}
Lib.setTimeout = function(closure,delay,args) {
	var id = ++Lib.__lastTimerID;
	var this1 = Lib.__timers;
	var v = (haxe_Timer().default).delay(function() {
		(Reflect().default).callMethod(closure,closure,args == null ? [] : args);
	},delay);
	this1.set(id,v);
	return id;
}
Lib.trace = function(arg) {
	(haxe_Log().default).trace(arg,{ fileName : "../src/openfl/Lib.hx", lineNumber : 573, className : "openfl.Lib", methodName : "trace"});
}
Lib.get_application = function() {
	return (openfl__$internal_Lib().default).application;
}
Lib.get_current = function() {
	if((openfl__$internal_Lib().default).current == null) {
		(openfl__$internal_Lib().default).current = new (openfl_display_MovieClip().default)();
	}
	return (openfl__$internal_Lib().default).current;
}
Lib.__lastTimerID = 0
Lib.__sentWarnings = new (haxe_ds_StringMap().default)()
Lib.__timers = new (haxe_ds_IntMap().default)()

// Export

exports.default = Lib;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/VectorData.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/VectorData.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.VectorData

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$Vector_VectorIterator() {return __webpack_require__(/*! ./../openfl/_Vector/VectorIterator */ "./node_modules/openfl/lib/_gen/openfl/_Vector/VectorIterator.js");}

// Constructor

var VectorData = function(length,fixed,array) {
	this.construct(this,length,fixed);
}

// Meta

VectorData.__name__ = "openfl.VectorData";
VectorData.__isInterface__ = false;
VectorData.prototype = {
	construct: function(instance,length,fixed) {
		if(length != null) {
			instance.length = length;
		}
		instance.fixed = fixed == true;
		return instance;
	},
	concat: function(a) {
		return VectorData.ofArray(Array.prototype.concat.call (this, a));
	},
	copy: function() {
		return VectorData.ofArray(this);
	},
	filter: function(callback) {
		return VectorData.ofArray(Array.prototype.filter.call (this, callback));
	},
	get: function(index) {
		return this[index];
	},
	indexOf: function(x,from) {
		if(from == null) {
			from = 0;
		}
		return -1;
	},
	insertAt: function(index,element) {
		if(!this.fixed || index < this.length) {
			Array.prototype.splice.call (this, index, 0, element);
		}
	},
	iterator: function() {
		return new (openfl__$Vector_VectorIterator().default)(this);
	},
	join: function(sep) {
		if(sep == null) {
			sep = ",";
		}
		return null;
	},
	lastIndexOf: function(x,from) {
		if(from == null) {
			return Array.prototype.lastIndexOf.call (this, x);
		} else {
			return Array.prototype.lastIndexOf.call (this, x, from);
		}
	},
	pop: function() {
		if(!this.fixed) {
			return Array.prototype.pop.call (this);
		} else {
			return null;
		}
	},
	push: function(x) {
		if(!this.fixed) {
			return Array.prototype.push.call (this, x);
		} else {
			return this.length;
		}
	},
	removeAt: function(index) {
		if(!this.fixed || index < this.length) {
			return Array.prototype.splice.call (this, index, 1)[0];
		}
		return null;
	},
	reverse: function() {
		return this;
	},
	set: function(index,value) {
		if(!this.fixed || index < this.length) {
			return this[index] = value;
		} else {
			return value;
		}
	},
	shift: function() {
		if(!this.fixed) {
			return Array.prototype.shift.call (this);
		} else {
			return null;
		}
	},
	slice: function(startIndex,endIndex) {
		if(startIndex == null) {
			startIndex = 0;
		}
		if(endIndex == null) {
			endIndex = 16777215;
		}
		return VectorData.ofArray(Array.prototype.slice.call (this, startIndex, endIndex));
	},
	sort: function(f) {
	},
	splice: function(pos,len) {
		return VectorData.ofArray(Array.prototype.splice.call (this, pos, len));
	},
	toString: function() {
		return null;
	},
	unshift: function(x) {
		if(!this.fixed) {
			Array.prototype.unshift.call (this, x);
		}
	},
	get_length: function() {
		return this.length;
	},
	set_length: function(value) {
		if(!this.fixed) {
			this.length = value;
		}
		return value;
	}
};
VectorData.prototype.__class__ = VectorData.prototype.constructor = $hxClasses["openfl.VectorData"] = VectorData;

// Init

var prefix = (typeof openfl_VectorData !== 'undefined');
		var ref = (prefix ? openfl_VectorData : VectorData);
		var p = ref.prototype;
		var construct = p.construct;
		var _VectorDataDescriptor = {
			constructor: { value: null },
			concat: { value: p.concat },
			copy: { value: p.copy },
			filter: { value: p.filter },
			get: { value: p.get },
			insertAt: { value: p.insertAt },
			iterator: { value: p.iterator },
			lastIndexOf: { value: p.lastIndexOf },
			pop: { value: p.pop },
			push: { value: p.push },
			removeAt: { value: p.removeAt },
			set: { value: p.set },
			shift: { value: p.shift },
			slice: { value: p.slice },
			splice: { value: p.splice },
			unshift: { value: p.unshift },
			get_length: { value: p.get_length },
			set_length: { value: p.set_length },
		}
		var _VectorData = function (length, fixed, array) {
			if (array == null) array = [];
			return Object.defineProperties (construct (array, length, fixed), _VectorDataDescriptor);
		}
		_VectorDataDescriptor.constructor.value = _VectorData;
		_VectorData.__name__ = ref.__name__;
		_VectorData.ofArray = ref.ofArray;
		$hxClasses['openfl.VectorData'] = _VectorData;
		_VectorData.prototype = Array.prototype
		if (prefix) openfl_VectorData = _VectorData; else VectorData = _VectorData;
		;

// Statics

VectorData.ofArray = function(a) {
	if(a == null) {
		return null;
	}
	var data = new VectorData();
	var _g = 0;
	var _g1 = a.length;
	while(_g < _g1) {
		var i = _g++;
		data[i] = a[i];
	}
	return data;
}
VectorData.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = VectorData;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_Vector/VectorIterator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_Vector/VectorIterator.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._Vector.VectorIterator

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var VectorIterator = function(vector) {
	this.vector = vector;
	this.index = -1;
}

// Meta

VectorIterator.__name__ = "openfl._Vector.VectorIterator";
VectorIterator.__isInterface__ = false;
VectorIterator.prototype = {
	hasNext: function() {
		return this.index < this.vector.get_length() - 1;
	},
	next: function() {
		this.index++;
		return this.vector[this.index];
	}
};
VectorIterator.prototype.__class__ = VectorIterator.prototype.constructor = $hxClasses["openfl._Vector.VectorIterator"] = VectorIterator;

// Init



// Statics


VectorIterator.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = VectorIterator;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._Vector.Vector_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_VectorData() {return __webpack_require__(/*! ./../../openfl/VectorData */ "./node_modules/openfl/lib/_gen/openfl/VectorData.js");}
function openfl__$Vector_VectorIterator() {return __webpack_require__(/*! ./../../openfl/_Vector/VectorIterator */ "./node_modules/openfl/lib/_gen/openfl/_Vector/VectorIterator.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Vector_Impl_ = function(){}

// Meta

Vector_Impl_.__name__ = "openfl._Vector.Vector_Impl_";
Vector_Impl_.__isInterface__ = false;
Vector_Impl_.prototype = {
	
};
Vector_Impl_.prototype.__class__ = Vector_Impl_.prototype.constructor = $hxClasses["openfl._Vector.Vector_Impl_"] = Vector_Impl_;

// Init



// Statics

Vector_Impl_._new = function(length,fixed,array) {
	var this1;
	if(array != null) {
		this1 = (openfl_VectorData().default).ofArray(array);
	} else {
		this1 = new (openfl_VectorData().default)(length,fixed);
	}
	return this1;
}
Vector_Impl_.concat = function(this1,a) {
	return (openfl_VectorData().default).ofArray(Array.prototype.concat.call(this1,a));
}
Vector_Impl_.copy = function(this1) {
	return (openfl_VectorData().default).ofArray(this1);
}
Vector_Impl_.filter = function(this1,callback) {
	return (openfl_VectorData().default).ofArray(Array.prototype.filter.call(this1,callback));
}
Vector_Impl_.get = function(this1,index) {
	return this1[index];
}
Vector_Impl_.indexOf = function(this1,x,from) {
	if(from == null) {
		from = 0;
	}
	return Array.prototype.indexOf.call(this1,x,from);
}
Vector_Impl_.insertAt = function(this1,index,element) {
	if(!this1.fixed || index < this1.get_length()) {
		Array.prototype.splice.call(this1,index,0,element);
	}
}
Vector_Impl_.iterator = function(this1) {
	return new (openfl__$Vector_VectorIterator().default)(this1);
}
Vector_Impl_.join = function(this1,sep) {
	if(sep == null) {
		sep = ",";
	}
	return Array.prototype.join.call(this1,sep);
}
Vector_Impl_.lastIndexOf = function(this1,x,from) {
	if(from == null) {
		return Array.prototype.lastIndexOf.call(this1,x);
	} else {
		return Array.prototype.lastIndexOf.call(this1,x,from);
	}
}
Vector_Impl_.pop = function(this1) {
	if(!this1.fixed) {
		return Array.prototype.pop.call(this1);
	} else {
		return null;
	}
}
Vector_Impl_.push = function(this1,x) {
	if(!this1.fixed) {
		return Array.prototype.push.call(this1,x);
	} else {
		return this.length;
	}
}
Vector_Impl_.removeAt = function(this1,index) {
	if(!this1.fixed || index < this1.get_length()) {
		return Array.prototype.splice.call(this1,index,1)[0];
	}
	return null;
}
Vector_Impl_.reverse = function(this1) {
	return Array.prototype.reverse.call(this1);
}
Vector_Impl_.set = function(this1,index,value) {
	if(!this1.fixed || index < this1.get_length()) {
		return this1[index] = value;
	} else {
		return value;
	}
}
Vector_Impl_.shift = function(this1) {
	if(!this1.fixed) {
		return Array.prototype.shift.call(this1);
	} else {
		return null;
	}
}
Vector_Impl_.slice = function(this1,startIndex,endIndex) {
	if(endIndex == null) {
		endIndex = 16777215;
	}
	if(startIndex == null) {
		startIndex = 0;
	}
	return (openfl_VectorData().default).ofArray(Array.prototype.slice.call(this1,startIndex,endIndex));
}
Vector_Impl_.sort = function(this1,f) {
	Array.prototype.sort.call(this1,f);
}
Vector_Impl_.splice = function(this1,pos,len) {
	return (openfl_VectorData().default).ofArray(Array.prototype.splice.call(this1,pos,len));
}
Vector_Impl_.toString = function(this1) {
	if(this1 != null) {
		return (Std().default).string(this1);
	} else {
		return null;
	}
}
Vector_Impl_.unshift = function(this1,x) {
	if(!this1.fixed) {
		Array.prototype.unshift.call(this1,x);
	}
}
Vector_Impl_.ofArray = function(a) {
	return (openfl_VectorData().default).ofArray(a);
}
Vector_Impl_.convert = function(v) {
	return v;
}
Vector_Impl_.get_fixed = function(this1) {
	return this1.fixed;
}
Vector_Impl_.set_fixed = function(this1,value) {
	return this1.fixed = value;
}
Vector_Impl_.get_length = function(this1) {
	return this1.get_length();
}
Vector_Impl_.set_length = function(this1,value) {
	return this1.set_length(value);
}


// Export

exports.default = Vector_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/Lib.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/Lib.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.Lib

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}

// Constructor

var Lib = function(){}

// Meta

Lib.__name__ = "openfl._internal.Lib";
Lib.__isInterface__ = false;
Lib.prototype = {
	
};
Lib.prototype.__class__ = Lib.prototype.constructor = $hxClasses["openfl._internal.Lib"] = Lib;

// Init



// Statics

Lib.notImplemented = function(posInfo) {
	var api = posInfo.className + "." + posInfo.methodName;
	if(!Lib.__sentWarnings.exists(api)) {
		Lib.__sentWarnings.set(api,true);
		(lime_utils_Log().default).warn(posInfo.methodName + " is not implemented",posInfo);
	}
}
Lib.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, statics : { notImplemented : { SuppressWarnings : ["checkstyle:NullableParameter"]}}}
Lib.__sentWarnings = new (haxe_ds_StringMap().default)()

// Export

exports.default = Lib;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/AGALConverter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/AGALConverter.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.formats.agal.AGALConverter

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_formats_agal__$AGALConverter_ProgramType() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/_AGALConverter/ProgramType */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/ProgramType.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_IllegalOperationError() {return __webpack_require__(/*! ./../../../../openfl/errors/IllegalOperationError */ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js");}
function haxe__$Int64__$_$_$Int64() {return __webpack_require__(/*! ./../../../../haxe/_Int64/___Int64 */ "./node_modules/openfl/lib/_gen/haxe/_Int64/___Int64.js");}
function openfl__$internal_formats_agal_RegisterMap() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/RegisterMap */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/RegisterMap.js");}
function StringBuf() {return __webpack_require__(/*! ./../../../../StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function openfl__$internal_formats_agal__$AGALConverter_DestRegister() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/_AGALConverter/DestRegister */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/DestRegister.js");}
function openfl__$internal_formats_agal__$AGALConverter_SourceRegister() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/_AGALConverter/SourceRegister */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/SourceRegister.js");}
function openfl__$internal_formats_agal__$AGALConverter_RegisterUsage() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/_AGALConverter/RegisterUsage */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/RegisterUsage.js");}
function openfl__$internal_formats_agal__$AGALConverter_SamplerRegister() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/_AGALConverter/SamplerRegister */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/SamplerRegister.js");}
function lime_graphics_opengl_GL() {return __webpack_require__(/*! ./../../../../lime/graphics/opengl/GL */ "./node_modules/openfl/lib/_gen/lime/graphics/opengl/GL.js");}

// Constructor

var AGALConverter = function(){}

// Meta

AGALConverter.__name__ = "openfl._internal.formats.agal.AGALConverter";
AGALConverter.__isInterface__ = false;
AGALConverter.prototype = {
	
};
AGALConverter.prototype.__class__ = AGALConverter.prototype.constructor = $hxClasses["openfl._internal.formats.agal.AGALConverter"] = AGALConverter;

// Init



// Statics

AGALConverter.prefixFromType = function(regType,programType) {
	switch(regType) {
	case 0:
		return "va";
	case 1:
		if(programType == (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).VERTEX) {
			return "vc";
		} else {
			return "fc";
		}
		break;
	case 2:
		if(programType == (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).VERTEX) {
			return "vt";
		} else {
			return "ft";
		}
		break;
	case 3:
		return "output_";
	case 4:
		return "v";
	case 5:
		return "sampler";
	default:
		throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Invalid data!"));
	}
}
AGALConverter.readUInt64 = function(byteArray) {
	var low = byteArray.readInt();
	var high = byteArray.readInt();
	var this1 = new (haxe__$Int64__$_$_$Int64().default)(high,low);
	return this1;
}
AGALConverter.convertToGLSL = function(agal,samplerState) {
	agal.position = 0;
	agal.set_endian("littleEndian");
	var magic = agal.readByte() & 255;
	if(magic == 176) {
		return agal.readUTF();
	}
	if(magic != 160) {
		throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Magic value must be 0xA0, may not be AGAL"));
	}
	var version = agal.readInt();
	if(version != 1) {
		throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Version must be 1"));
	}
	var shaderTypeID = agal.readByte() & 255;
	if(shaderTypeID != 161) {
		throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Shader type ID must be 0xA1"));
	}
	var programType = (agal.readByte() & 255) == 0 ? (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).VERTEX : (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).FRAGMENT;
	var map = new (openfl__$internal_formats_agal_RegisterMap().default)();
	var sb = new (StringBuf().default)();
	while(true) {
		var a = agal.position;
		if(!(_$UInt_UInt_$Impl_$().default).gt((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(agal),a)) {
			break;
		}
		var opcode = agal.readInt();
		var dest = agal.readUnsignedInt();
		var source1 = AGALConverter.readUInt64(agal);
		var source2 = AGALConverter.readUInt64(agal);
		var dr = (openfl__$internal_formats_agal__$AGALConverter_DestRegister().default).parse(dest,programType);
		var sr1 = (openfl__$internal_formats_agal__$AGALConverter_SourceRegister().default).parse(source1,programType,dr.mask);
		var sr2 = (openfl__$internal_formats_agal__$AGALConverter_SourceRegister().default).parse(source2,programType,dr.mask);
		sb.add("\t");
		switch(opcode) {
		case 0:
			sb.add(dr.toGLSL() + " = " + sr1.toGLSL() + "; // mov");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 1:
			sb.add(dr.toGLSL() + " = " + sr1.toGLSL() + " + " + sr2.toGLSL() + "; // add");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 2:
			sb.add(dr.toGLSL() + " = " + sr1.toGLSL() + " - " + sr2.toGLSL() + "; // sub");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 3:
			sb.add(dr.toGLSL() + " = " + sr1.toGLSL() + " * " + sr2.toGLSL() + "; // mul");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 4:
			sb.add(dr.toGLSL() + " = " + sr1.toGLSL() + " / " + sr2.toGLSL() + "; // div");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 5:
			var sr = sr1.toGLSL();
			if(sr.indexOf(".") > -1) {
				sb.add(dr.toGLSL() + " = 1.0 / " + sr1.toGLSL() + "; // rcp");
			} else {
				sb.add(dr.toGLSL() + " = vec4(1) / " + sr1.toGLSL() + "; // rcp");
			}
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 6:
			sb.add(dr.toGLSL() + " = min(" + sr1.toGLSL() + ", " + sr2.toGLSL() + "); // min");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 7:
			sb.add(dr.toGLSL() + " = max(" + sr1.toGLSL() + ", " + sr2.toGLSL() + "); // max");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 8:
			sb.add(dr.toGLSL() + " = fract(" + sr1.toGLSL() + "); // frc");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 9:
			sb.add(dr.toGLSL() + " = sqrt(" + sr1.toGLSL() + "); // sqrt");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 10:
			sb.add(dr.toGLSL() + " = inversesqrt(" + sr1.toGLSL() + "); // rsq");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 11:
			sb.add(dr.toGLSL() + " = pow(" + sr1.toGLSL() + ", " + sr2.toGLSL() + "); // pow");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 12:
			sb.add(dr.toGLSL() + " = log2(" + sr1.toGLSL() + "); // log");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 13:
			sb.add(dr.toGLSL() + " = exp2(" + sr1.toGLSL() + "); // exp");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 14:
			sb.add(dr.toGLSL() + " = normalize(" + sr1.toGLSL() + "); // normalize");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 15:
			sb.add(dr.toGLSL() + " = sin(" + sr1.toGLSL() + "); // sin");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 16:
			sb.add(dr.toGLSL() + " = cos(" + sr1.toGLSL() + "); // cos");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 17:
			sr1.sourceMask = sr2.sourceMask = 7;
			sb.add(dr.toGLSL() + " = cross(vec3(" + sr1.toGLSL() + "), vec3(" + sr2.toGLSL() + ")); // crs");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 18:
			sr1.sourceMask = sr2.sourceMask = 7;
			sb.add(dr.toGLSL() + " = vec4(dot(vec3(" + sr1.toGLSL() + "), vec3(" + sr2.toGLSL() + ")))" + dr.getWriteMask() + "; // dp3");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 19:
			sr1.sourceMask = sr2.sourceMask = 15;
			sb.add(dr.toGLSL() + " = vec4(dot(vec4(" + sr1.toGLSL() + "), vec4(" + sr2.toGLSL() + ")))" + dr.getWriteMask() + "; // dp4");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 20:
			sb.add(dr.toGLSL() + " = abs(" + sr1.toGLSL() + "); // abs");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 21:
			sb.add(dr.toGLSL() + " = -" + sr1.toGLSL() + "; // neg");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 22:
			sb.add(dr.toGLSL() + " = clamp(" + sr1.toGLSL() + ", 0.0, 1.0); // saturate");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 23:
			var existingUsage = map.getRegisterUsage(sr2);
			if(existingUsage != (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4 && existingUsage != (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY) {
				sb.add(dr.toGLSL() + " = " + sr1.toGLSL() + " * mat3(" + sr2.toGLSL(false) + "); // m33");
				map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).MATRIX_4_4);
			} else {
				sr1.sourceMask = sr2.sourceMask = 7;
				sb.add(dr.toGLSL() + " = vec3(" + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,0) + "), " + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,1) + ")," + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,2) + ")); // m33");
				map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,0);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,1);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,2);
			}
			break;
		case 24:
			var existingUsage1 = map.getRegisterUsage(sr2);
			if(existingUsage1 != (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4 && existingUsage1 != (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY) {
				sb.add(dr.toGLSL() + " = " + sr1.toGLSL() + " * " + sr2.toGLSL(false) + "; // m44");
				map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).MATRIX_4_4);
			} else {
				sr1.sourceMask = sr2.sourceMask = 15;
				sb.add(dr.toGLSL() + " = vec4(" + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,0) + "), " + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,1) + "), " + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,2) + "), " + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,3) + ")); // m44");
				map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,0);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,1);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,2);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,3);
			}
			break;
		case 25:
			dr.mask &= 7;
			var existingUsage2 = map.getRegisterUsage(sr2);
			if(existingUsage2 != (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4 && existingUsage2 != (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY) {
				sb.add(dr.toGLSL() + " = " + sr1.toGLSL() + " * " + sr2.toGLSL(false) + "; // m34");
				map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).MATRIX_4_4);
			} else {
				sr1.sourceMask = sr2.sourceMask = 15;
				sb.add(dr.toGLSL() + " = vec3(" + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,0) + "), " + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,1) + ")," + "dot(" + sr1.toGLSL(true) + "," + sr2.toGLSL(true,2) + ")); // m34");
				map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,0);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,1);
				map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4,2);
			}
			break;
		case 39:
			sr1.sourceMask = 15;
			sb.add("if (any(lessThan(" + sr1.toGLSL() + ", vec4(0)))) discard;");
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 40:
			var sampler = (openfl__$internal_formats_agal__$AGALConverter_SamplerRegister().default).parse(source2,programType);
			switch(sampler.d) {
			case 0:
				if(sampler.t == 2) {
					sr1.sourceMask = 3;
					map.addSaR(sampler,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).SAMPLER_2D_ALPHA);
					sb.add("if (" + sampler.toGLSL() + "_alphaEnabled) {\n");
					sb.add("\t\t" + dr.toGLSL() + " = vec4(texture2D(" + sampler.toGLSL() + ", " + sr1.toGLSL() + ").xyz, texture2D(" + sampler.toGLSL() + "_alpha, " + sr1.toGLSL() + ").x); // tex + alpha\n");
					sb.add("\t} else {\n");
					sb.add("\t\t" + dr.toGLSL() + " = texture2D(" + sampler.toGLSL() + ", " + sr1.toGLSL() + "); // tex\n");
					sb.add("\t}");
				} else {
					sr1.sourceMask = 3;
					map.addSaR(sampler,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).SAMPLER_2D);
					sb.add(dr.toGLSL() + " = texture2D(" + sampler.toGLSL() + ", " + sr1.toGLSL() + "); // tex");
				}
				break;
			case 1:
				if(sampler.t == 2) {
					sr1.sourceMask = 7;
					map.addSaR(sampler,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).SAMPLER_CUBE_ALPHA);
					sb.add("if (" + sampler.toGLSL() + "_alphaEnabled) {\n");
					sb.add("\t\t" + dr.toGLSL() + " = vec4(textureCube(" + sampler.toGLSL() + ", " + sr1.toGLSL() + ").xyz, textureCube(" + sampler.toGLSL() + "_alpha, " + sr1.toGLSL() + ").x); // tex + alpha\n");
					sb.add("\t} else {\n");
					sb.add("\t\t" + dr.toGLSL() + " = textureCube(" + sampler.toGLSL() + ", " + sr1.toGLSL() + "); // tex");
					sb.add("\t}");
				} else {
					sr1.sourceMask = 7;
					sb.add(dr.toGLSL() + " = textureCube(" + sampler.toGLSL() + ", " + sr1.toGLSL() + "); // tex");
					map.addSaR(sampler,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).SAMPLER_CUBE);
				}
				break;
			}
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			if(samplerState != null) {
				samplerState[sampler.n] = sampler.toSamplerState();
			}
			break;
		case 41:
			sr1.sourceMask = sr2.sourceMask = 15;
			sb.add(dr.toGLSL() + " = vec4(greaterThanEqual(" + sr1.toGLSL() + ", " + sr2.toGLSL() + "))" + dr.getWriteMask() + "; // ste");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 42:
			sr1.sourceMask = sr2.sourceMask = 15;
			sb.add(dr.toGLSL() + " = vec4(lessThan(" + sr1.toGLSL() + ", " + sr2.toGLSL() + "))" + dr.getWriteMask() + "; // slt");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 44:
			sr1.sourceMask = sr2.sourceMask = 15;
			sb.add(dr.toGLSL() + " = vec4(equal(" + sr1.toGLSL() + ", " + sr2.toGLSL() + "))" + dr.getWriteMask() + "; // seq");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		case 45:
			sr1.sourceMask = sr2.sourceMask = 15;
			sb.add(dr.toGLSL() + " = vec4(notEqual(" + sr1.toGLSL() + ", " + sr2.toGLSL() + "))" + dr.getWriteMask() + "; // sne");
			map.addDR(dr,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr1,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			map.addSR(sr2,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			break;
		default:
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Opcode " + opcode));
		}
		sb.add("\n");
	}
	if(AGALConverter.limitedProfile == null) {
		var version1 = (lime_graphics_opengl_GL().default).getParameter(7938);
		AGALConverter.limitedProfile = version1.indexOf("OpenGL ES") > -1 || version1.indexOf("WebGL") > -1;
	}
	var glsl = new (StringBuf().default)();
	glsl.add("// AGAL " + (programType == (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).VERTEX ? "vertex" : "fragment") + " shader\n");
	if(AGALConverter.limitedProfile) {
		glsl.add("#version 100\n");
		glsl.add("precision highp float;\n");
	} else {
		glsl.add("#version 120\n");
	}
	glsl.add(map.toGLSL(false));
	if(programType == (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).VERTEX) {
		glsl.add("uniform vec4 vcPositionScale;\n");
	}
	glsl.add("void main() {\n");
	glsl.add(map.toGLSL(true));
	glsl.add(sb.toString());
	if(programType == (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).VERTEX) {
		glsl.add("\tgl_Position *= vcPositionScale;\n");
	}
	glsl.add("}\n");
	return glsl.toString();
}
AGALConverter.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}
AGALConverter.limitedProfile = true

// Export

exports.default = AGALConverter;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/RegisterMap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/RegisterMap.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.formats.agal.RegisterMap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_IllegalOperationError() {return __webpack_require__(/*! ./../../../../openfl/errors/IllegalOperationError */ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js");}
function openfl__$internal_formats_agal__$AGALConverter_RegisterMapEntry() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/_AGALConverter/RegisterMapEntry */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/RegisterMapEntry.js");}
function openfl__$internal_formats_agal_AGALConverter() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/AGALConverter */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/AGALConverter.js");}
function openfl__$internal_formats_agal__$AGALConverter_RegisterUsage() {return __webpack_require__(/*! ./../../../../openfl/_internal/formats/agal/_AGALConverter/RegisterUsage */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/RegisterUsage.js");}
function js_Boot() {return __webpack_require__(/*! ./../../../../js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}
function StringBuf() {return __webpack_require__(/*! ./../../../../StringBuf */ "./node_modules/openfl/lib/_gen/StringBuf.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}

// Constructor

var RegisterMap = function() {
	this.mEntries = [];
}

// Meta

RegisterMap.__name__ = "openfl._internal.formats.agal.RegisterMap";
RegisterMap.__isInterface__ = false;
RegisterMap.prototype = {
	add: function(type,name,number,usage) {
		var _g = 0;
		var _g1 = this.mEntries;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			if(entry.type == type && entry.name == name && entry.number == number) {
				if(entry.usage != usage) {
					throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Cannot use register in multiple ways yet (mat4/vec4)"));
				}
				return;
			}
		}
		var entry1 = new (openfl__$internal_formats_agal__$AGALConverter_RegisterMapEntry().default)();
		entry1.type = type;
		entry1.name = name;
		entry1.number = number;
		entry1.usage = usage;
		this.mEntries.push(entry1);
	},
	addDR: function(dr,usage) {
		this.add(dr.type,dr.toGLSL(false),dr.n,usage);
	},
	addSaR: function(sr,usage) {
		this.add(sr.type,sr.toGLSL(),sr.n,usage);
	},
	addSR: function(sr,usage,offset) {
		if(offset == null) {
			offset = 0;
		}
		if(sr.d != 0) {
			this.add(sr.itype,(openfl__$internal_formats_agal_AGALConverter().default).prefixFromType(sr.itype,sr.programType) + sr.n,sr.n,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4);
			this.add(sr.type,(openfl__$internal_formats_agal_AGALConverter().default).prefixFromType(sr.type,sr.programType) + sr.o,sr.o,(openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY);
			return;
		}
		this.add(sr.type,sr.toGLSL(false,offset),sr.n + offset,usage);
	},
	getRegisterUsage: function(sr) {
		if(sr.d != 0) {
			return (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY;
		}
		return this.getUsage(sr.type,sr.toGLSL(false),sr.n);
	},
	getUsage: function(type,name,number) {
		var _g = 0;
		var _g1 = this.mEntries;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			if(entry.type == type && entry.name == name && entry.number == number) {
				return entry.usage;
			}
		}
		return (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).UNUSED;
	},
	toGLSL: function(tempRegistersOnly) {
		this.mEntries.sort(function(a,b) {
			return a.number - b.number;
		});
		var entry;
		this.mEntries.sort(function(a1,b1) {
			return (js_Boot().default).__cast(a1.type , $hxClasses["Int"]) - (js_Boot().default).__cast(b1.type , $hxClasses["Int"]);
		});
		var sb = new (StringBuf().default)();
		var _g = 0;
		var _g1 = this.mEntries.length;
		while(_g < _g1) {
			var i = _g++;
			entry = this.mEntries[i];
			if(tempRegistersOnly && entry.type != 2 || !tempRegistersOnly && entry.type == 2) {
				continue;
			}
			if(entry.type == 3) {
				continue;
			}
			switch(entry.type) {
			case 0:
				sb.add("attribute ");
				break;
			case 1:
				sb.add("uniform ");
				break;
			case 2:
				sb.add("\t");
				break;
			case 3:
				break;
			case 4:
				sb.add("varying ");
				break;
			case 5:
				sb.add("uniform ");
				break;
			default:
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
			}
			switch(entry.usage._hx_index) {
			case 0:
				(lime_utils_Log().default).info("Missing switch patten: RegisterUsage.UNUSED",{ fileName : "../src/openfl/_internal/formats/agal/AGALConverter.hx", lineNumber : 746, className : "openfl._internal.formats.agal.RegisterMap", methodName : "toGLSL"});
				break;
			case 1:
				sb.add("vec4 ");
				break;
			case 2:
				sb.add("mat4 ");
				break;
			case 3:
				sb.add("sampler2D ");
				break;
			case 4:
				break;
			case 5:
				sb.add("samplerCube ");
				break;
			case 6:
				break;
			case 7:
				sb.add("vec4 ");
				break;
			}
			if(entry.usage == (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).SAMPLER_2D_ALPHA) {
				sb.add("sampler2D ");
				sb.add(entry.name);
				sb.add(";\n");
				sb.add("uniform ");
				sb.add("sampler2D ");
				sb.add(entry.name + "_alpha");
				sb.add(";\n");
				sb.add("uniform ");
				sb.add("bool ");
				sb.add(entry.name + "_alphaEnabled");
				sb.add(";\n");
			} else if(entry.usage == (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).SAMPLER_CUBE_ALPHA) {
				sb.add("samplerCube ");
				sb.add(entry.name);
				sb.add(";\n");
				sb.add("uniform ");
				sb.add("samplerCube ");
				sb.add(entry.name + "_alpha");
				sb.add(";\n");
				sb.add("uniform ");
				sb.add("bool ");
				sb.add(entry.name + "_alphaEnabled");
				sb.add(";\n");
			} else if(entry.usage == (openfl__$internal_formats_agal__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY) {
				sb.add(entry.name + "[128]");
				sb.add(";\n");
			} else {
				sb.add(entry.name);
				sb.add(";\n");
			}
		}
		return sb.toString();
	}
};
RegisterMap.prototype.__class__ = RegisterMap.prototype.constructor = $hxClasses["openfl._internal.formats.agal.RegisterMap"] = RegisterMap;

// Init



// Statics


RegisterMap.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = RegisterMap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/DestRegister.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/DestRegister.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.formats.agal._AGALConverter.DestRegister

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_formats_agal__$AGALConverter_ProgramType() {return __webpack_require__(/*! ./../../../../../openfl/_internal/formats/agal/_AGALConverter/ProgramType */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/ProgramType.js");}
function openfl__$internal_formats_agal_AGALConverter() {return __webpack_require__(/*! ./../../../../../openfl/_internal/formats/agal/AGALConverter */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/AGALConverter.js");}

// Constructor

var DestRegister = function() {
}

// Meta

DestRegister.__name__ = "openfl._internal.formats.agal._AGALConverter.DestRegister";
DestRegister.__isInterface__ = false;
DestRegister.prototype = {
	getWriteMask: function() {
		var str = ".";
		if((this.mask & 1) != 0) {
			str += "x";
		}
		if((this.mask & 2) != 0) {
			str += "y";
		}
		if((this.mask & 4) != 0) {
			str += "z";
		}
		if((this.mask & 8) != 0) {
			str += "w";
		}
		return str;
	},
	toGLSL: function(useMask) {
		if(useMask == null) {
			useMask = true;
		}
		var str;
		if(this.type == 3) {
			str = this.programType == (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).VERTEX ? "gl_Position" : "gl_FragColor";
		} else {
			str = (openfl__$internal_formats_agal_AGALConverter().default).prefixFromType(this.type,this.programType) + this.n;
		}
		if(useMask && this.mask != 15) {
			str += this.getWriteMask();
		}
		return str;
	}
};
DestRegister.prototype.__class__ = DestRegister.prototype.constructor = $hxClasses["openfl._internal.formats.agal._AGALConverter.DestRegister"] = DestRegister;

// Init



// Statics

DestRegister.parse = function(v,programType) {
	var dr = new DestRegister();
	dr.programType = programType;
	dr.type = v >>> 24 & 15;
	dr.mask = v >>> 16 & 15;
	dr.n = v & 65535;
	return dr;
}
DestRegister.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = DestRegister;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/ProgramType.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/ProgramType.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: openfl._internal.formats.agal._AGALConverter.ProgramType

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../../../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var ProgramType = $hxEnums["openfl._internal.formats.agal._AGALConverter.ProgramType"] = { __ename__ : "openfl._internal.formats.agal._AGALConverter.ProgramType", __constructs__ : ["VERTEX","FRAGMENT"]
  ,VERTEX: {_hx_index:0,__enum__:"openfl._internal.formats.agal._AGALConverter.ProgramType",toString:$estr}
  ,FRAGMENT: {_hx_index:1,__enum__:"openfl._internal.formats.agal._AGALConverter.ProgramType",toString:$estr}
};

exports.default = ProgramType;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/RegisterMapEntry.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/RegisterMapEntry.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.formats.agal._AGALConverter.RegisterMapEntry

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var RegisterMapEntry = function() {
}

// Meta

RegisterMapEntry.__name__ = "openfl._internal.formats.agal._AGALConverter.RegisterMapEntry";
RegisterMapEntry.__isInterface__ = false;
RegisterMapEntry.prototype = {
	
};
RegisterMapEntry.prototype.__class__ = RegisterMapEntry.prototype.constructor = $hxClasses["openfl._internal.formats.agal._AGALConverter.RegisterMapEntry"] = RegisterMapEntry;

// Init



// Statics




// Export

exports.default = RegisterMapEntry;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/RegisterUsage.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/RegisterUsage.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: openfl._internal.formats.agal._AGALConverter.RegisterUsage

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../../../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var RegisterUsage = $hxEnums["openfl._internal.formats.agal._AGALConverter.RegisterUsage"] = { __ename__ : "openfl._internal.formats.agal._AGALConverter.RegisterUsage", __constructs__ : ["UNUSED","VECTOR_4","MATRIX_4_4","SAMPLER_2D","SAMPLER_2D_ALPHA","SAMPLER_CUBE","SAMPLER_CUBE_ALPHA","VECTOR_4_ARRAY"]
  ,VECTOR_4_ARRAY: {_hx_index:7,__enum__:"openfl._internal.formats.agal._AGALConverter.RegisterUsage",toString:$estr}
  ,VECTOR_4: {_hx_index:1,__enum__:"openfl._internal.formats.agal._AGALConverter.RegisterUsage",toString:$estr}
  ,UNUSED: {_hx_index:0,__enum__:"openfl._internal.formats.agal._AGALConverter.RegisterUsage",toString:$estr}
  ,SAMPLER_CUBE_ALPHA: {_hx_index:6,__enum__:"openfl._internal.formats.agal._AGALConverter.RegisterUsage",toString:$estr}
  ,SAMPLER_CUBE: {_hx_index:5,__enum__:"openfl._internal.formats.agal._AGALConverter.RegisterUsage",toString:$estr}
  ,SAMPLER_2D_ALPHA: {_hx_index:4,__enum__:"openfl._internal.formats.agal._AGALConverter.RegisterUsage",toString:$estr}
  ,SAMPLER_2D: {_hx_index:3,__enum__:"openfl._internal.formats.agal._AGALConverter.RegisterUsage",toString:$estr}
  ,MATRIX_4_4: {_hx_index:2,__enum__:"openfl._internal.formats.agal._AGALConverter.RegisterUsage",toString:$estr}
};

exports.default = RegisterUsage;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/SamplerRegister.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/SamplerRegister.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.formats.agal._AGALConverter.SamplerRegister

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_formats_agal_AGALConverter() {return __webpack_require__(/*! ./../../../../../openfl/_internal/formats/agal/AGALConverter */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/AGALConverter.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../../../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_IllegalOperationError() {return __webpack_require__(/*! ./../../../../../openfl/errors/IllegalOperationError */ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js");}
function openfl__$internal_renderer_SamplerState() {return __webpack_require__(/*! ./../../../../../openfl/_internal/renderer/SamplerState */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/SamplerState.js");}
function haxe__$Int64__$_$_$Int64() {return __webpack_require__(/*! ./../../../../../haxe/_Int64/___Int64 */ "./node_modules/openfl/lib/_gen/haxe/_Int64/___Int64.js");}

// Constructor

var SamplerRegister = function() {
}

// Meta

SamplerRegister.__name__ = "openfl._internal.formats.agal._AGALConverter.SamplerRegister";
SamplerRegister.__isInterface__ = false;
SamplerRegister.prototype = {
	toGLSL: function() {
		var str = (openfl__$internal_formats_agal_AGALConverter().default).prefixFromType(this.type,this.programType) + this.n;
		return str;
	},
	toSamplerState: function() {
		var wrap;
		var filter;
		var mipfilter;
		switch(this.f) {
		case 0:
			filter = "nearest";
			break;
		case 1:
			filter = "linear";
			break;
		default:
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
		}
		switch(this.m) {
		case 0:
			mipfilter = "mipnone";
			break;
		case 1:
			mipfilter = "mipnearest";
			break;
		case 2:
			mipfilter = "miplinear";
			break;
		default:
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
		}
		switch(this.w) {
		case 0:
			wrap = "clamp";
			break;
		case 1:
			wrap = "repeat";
			break;
		default:
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
		}
		var ignoreSampler = (this.s & 4) == 4;
		var centroid = (this.s & 1) == 1;
		var textureAlpha = this.t == 2;
		var lodBias = (this.b << 24 >> 24) / 8.0;
		return new (openfl__$internal_renderer_SamplerState().default)(wrap,filter,mipfilter,lodBias,ignoreSampler,centroid,textureAlpha);
	}
};
SamplerRegister.prototype.__class__ = SamplerRegister.prototype.constructor = $hxClasses["openfl._internal.formats.agal._AGALConverter.SamplerRegister"] = SamplerRegister;

// Init



// Statics

SamplerRegister.parse = function(v,programType) {
	var sr = new SamplerRegister();
	sr.programType = programType;
	var b = 60;
	b &= 63;
	var a;
	if(b == 0) {
		var this1 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a = this1;
	} else if(b < 32) {
		var this2 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b,v.high << 32 - b | v.low >>> b);
		a = this2;
	} else {
		var this3 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b - 32);
		a = this3;
	}
	var this4 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b1 = this4;
	var this5 = new (haxe__$Int64__$_$_$Int64().default)(a.high & b1.high,a.low & b1.low);
	sr.f = this5.low;
	var b2 = 56;
	b2 &= 63;
	var a1;
	if(b2 == 0) {
		var this6 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a1 = this6;
	} else if(b2 < 32) {
		var this7 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b2,v.high << 32 - b2 | v.low >>> b2);
		a1 = this7;
	} else {
		var this8 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b2 - 32);
		a1 = this8;
	}
	var this9 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b3 = this9;
	var this10 = new (haxe__$Int64__$_$_$Int64().default)(a1.high & b3.high,a1.low & b3.low);
	sr.m = this10.low;
	var b4 = 52;
	b4 &= 63;
	var a2;
	if(b4 == 0) {
		var this11 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a2 = this11;
	} else if(b4 < 32) {
		var this12 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b4,v.high << 32 - b4 | v.low >>> b4);
		a2 = this12;
	} else {
		var this13 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b4 - 32);
		a2 = this13;
	}
	var this14 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b5 = this14;
	var this15 = new (haxe__$Int64__$_$_$Int64().default)(a2.high & b5.high,a2.low & b5.low);
	sr.w = this15.low;
	var b6 = 48;
	b6 &= 63;
	var a3;
	if(b6 == 0) {
		var this16 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a3 = this16;
	} else if(b6 < 32) {
		var this17 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b6,v.high << 32 - b6 | v.low >>> b6);
		a3 = this17;
	} else {
		var this18 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b6 - 32);
		a3 = this18;
	}
	var this19 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b7 = this19;
	var this20 = new (haxe__$Int64__$_$_$Int64().default)(a3.high & b7.high,a3.low & b7.low);
	sr.s = this20.low;
	var b8 = 44;
	b8 &= 63;
	var a4;
	if(b8 == 0) {
		var this21 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a4 = this21;
	} else if(b8 < 32) {
		var this22 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b8,v.high << 32 - b8 | v.low >>> b8);
		a4 = this22;
	} else {
		var this23 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b8 - 32);
		a4 = this23;
	}
	var this24 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b9 = this24;
	var this25 = new (haxe__$Int64__$_$_$Int64().default)(a4.high & b9.high,a4.low & b9.low);
	sr.d = this25.low;
	var b10 = 40;
	b10 &= 63;
	var a5;
	if(b10 == 0) {
		var this26 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a5 = this26;
	} else if(b10 < 32) {
		var this27 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b10,v.high << 32 - b10 | v.low >>> b10);
		a5 = this27;
	} else {
		var this28 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b10 - 32);
		a5 = this28;
	}
	var this29 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b11 = this29;
	var this30 = new (haxe__$Int64__$_$_$Int64().default)(a5.high & b11.high,a5.low & b11.low);
	sr.t = this30.low;
	var b12 = 32;
	b12 &= 63;
	var a6;
	if(b12 == 0) {
		var this31 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a6 = this31;
	} else if(b12 < 32) {
		var this32 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b12,v.high << 32 - b12 | v.low >>> b12);
		a6 = this32;
	} else {
		var this33 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b12 - 32);
		a6 = this33;
	}
	var this34 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b13 = this34;
	var this35 = new (haxe__$Int64__$_$_$Int64().default)(a6.high & b13.high,a6.low & b13.low);
	sr.type = this35.low;
	var b14 = 16;
	b14 &= 63;
	var a7;
	if(b14 == 0) {
		var this36 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a7 = this36;
	} else if(b14 < 32) {
		var this37 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b14,v.high << 32 - b14 | v.low >>> b14);
		a7 = this37;
	} else {
		var this38 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b14 - 32);
		a7 = this38;
	}
	var this39 = new (haxe__$Int64__$_$_$Int64().default)(0,255);
	var b15 = this39;
	var this40 = new (haxe__$Int64__$_$_$Int64().default)(a7.high & b15.high,a7.low & b15.low);
	sr.b = this40.low;
	var this41 = new (haxe__$Int64__$_$_$Int64().default)(0,65535);
	var b16 = this41;
	var this42 = new (haxe__$Int64__$_$_$Int64().default)(v.high & b16.high,v.low & b16.low);
	sr.n = this42.low;
	return sr;
}
SamplerRegister.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = SamplerRegister;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/SourceRegister.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/SourceRegister.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.formats.agal._AGALConverter.SourceRegister

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_formats_agal__$AGALConverter_ProgramType() {return __webpack_require__(/*! ./../../../../../openfl/_internal/formats/agal/_AGALConverter/ProgramType */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/_AGALConverter/ProgramType.js");}
function openfl__$internal_formats_agal_AGALConverter() {return __webpack_require__(/*! ./../../../../../openfl/_internal/formats/agal/AGALConverter */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/AGALConverter.js");}
function haxe__$Int64__$_$_$Int64() {return __webpack_require__(/*! ./../../../../../haxe/_Int64/___Int64 */ "./node_modules/openfl/lib/_gen/haxe/_Int64/___Int64.js");}

// Constructor

var SourceRegister = function() {
}

// Meta

SourceRegister.__name__ = "openfl._internal.formats.agal._AGALConverter.SourceRegister";
SourceRegister.__isInterface__ = false;
SourceRegister.prototype = {
	toGLSL: function(emitSwizzle,offset) {
		if(offset == null) {
			offset = 0;
		}
		if(emitSwizzle == null) {
			emitSwizzle = true;
		}
		if(this.type == 3) {
			if(this.programType == (openfl__$internal_formats_agal__$AGALConverter_ProgramType().default).VERTEX) {
				return "gl_Position";
			} else {
				return "gl_FragColor";
			}
		}
		var fullxyzw = this.s == 228 && this.sourceMask == 15;
		var swizzle = "";
		if(this.type != 5 && !fullxyzw) {
			if((this.sourceMask & 1) != 0) {
				switch(this.s & 3) {
				case 0:
					swizzle += "x";
					break;
				case 1:
					swizzle += "y";
					break;
				case 2:
					swizzle += "z";
					break;
				case 3:
					swizzle += "w";
					break;
				}
			}
			if((this.sourceMask & 2) != 0) {
				switch(this.s >> 2 & 3) {
				case 0:
					swizzle += "x";
					break;
				case 1:
					swizzle += "y";
					break;
				case 2:
					swizzle += "z";
					break;
				case 3:
					swizzle += "w";
					break;
				}
			}
			if((this.sourceMask & 4) != 0) {
				switch(this.s >> 4 & 3) {
				case 0:
					swizzle += "x";
					break;
				case 1:
					swizzle += "y";
					break;
				case 2:
					swizzle += "z";
					break;
				case 3:
					swizzle += "w";
					break;
				}
			}
			if((this.sourceMask & 8) != 0) {
				switch(this.s >> 6 & 3) {
				case 0:
					swizzle += "x";
					break;
				case 1:
					swizzle += "y";
					break;
				case 2:
					swizzle += "z";
					break;
				case 3:
					swizzle += "w";
					break;
				}
			}
		}
		var str = (openfl__$internal_formats_agal_AGALConverter().default).prefixFromType(this.type,this.programType);
		if(this.d == 0) {
			str += this.n + offset;
		} else {
			str += this.o;
			var indexComponent = "";
			switch(this.q) {
			case 0:
				indexComponent = "x";
				break;
			case 1:
				indexComponent = "y";
				break;
			case 2:
				indexComponent = "z";
				break;
			case 3:
				indexComponent = "w";
				break;
			}
			var indexRegister = (openfl__$internal_formats_agal_AGALConverter().default).prefixFromType(this.itype,this.programType) + this.n + "." + indexComponent;
			str += "[ int(" + indexRegister + ") +" + offset + "]";
		}
		if(emitSwizzle && swizzle != "") {
			str += "." + swizzle;
		}
		return str;
	}
};
SourceRegister.prototype.__class__ = SourceRegister.prototype.constructor = $hxClasses["openfl._internal.formats.agal._AGALConverter.SourceRegister"] = SourceRegister;

// Init



// Statics

SourceRegister.parse = function(v,programType,sourceMask) {
	var sr = new SourceRegister();
	sr.programType = programType;
	var b = 63;
	b &= 63;
	var a;
	if(b == 0) {
		var this1 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a = this1;
	} else if(b < 32) {
		var this2 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b,v.high << 32 - b | v.low >>> b);
		a = this2;
	} else {
		var this3 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b - 32);
		a = this3;
	}
	var this4 = new (haxe__$Int64__$_$_$Int64().default)(0,1);
	var b1 = this4;
	var this5 = new (haxe__$Int64__$_$_$Int64().default)(a.high & b1.high,a.low & b1.low);
	sr.d = this5.low;
	var b2 = 48;
	b2 &= 63;
	var a1;
	if(b2 == 0) {
		var this6 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a1 = this6;
	} else if(b2 < 32) {
		var this7 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b2,v.high << 32 - b2 | v.low >>> b2);
		a1 = this7;
	} else {
		var this8 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b2 - 32);
		a1 = this8;
	}
	var this9 = new (haxe__$Int64__$_$_$Int64().default)(0,3);
	var b3 = this9;
	var this10 = new (haxe__$Int64__$_$_$Int64().default)(a1.high & b3.high,a1.low & b3.low);
	sr.q = this10.low;
	var b4 = 40;
	b4 &= 63;
	var a2;
	if(b4 == 0) {
		var this11 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a2 = this11;
	} else if(b4 < 32) {
		var this12 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b4,v.high << 32 - b4 | v.low >>> b4);
		a2 = this12;
	} else {
		var this13 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b4 - 32);
		a2 = this13;
	}
	var this14 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b5 = this14;
	var this15 = new (haxe__$Int64__$_$_$Int64().default)(a2.high & b5.high,a2.low & b5.low);
	sr.itype = this15.low;
	var b6 = 32;
	b6 &= 63;
	var a3;
	if(b6 == 0) {
		var this16 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a3 = this16;
	} else if(b6 < 32) {
		var this17 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b6,v.high << 32 - b6 | v.low >>> b6);
		a3 = this17;
	} else {
		var this18 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b6 - 32);
		a3 = this18;
	}
	var this19 = new (haxe__$Int64__$_$_$Int64().default)(0,15);
	var b7 = this19;
	var this20 = new (haxe__$Int64__$_$_$Int64().default)(a3.high & b7.high,a3.low & b7.low);
	sr.type = this20.low;
	var b8 = 24;
	b8 &= 63;
	var a4;
	if(b8 == 0) {
		var this21 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a4 = this21;
	} else if(b8 < 32) {
		var this22 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b8,v.high << 32 - b8 | v.low >>> b8);
		a4 = this22;
	} else {
		var this23 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b8 - 32);
		a4 = this23;
	}
	var this24 = new (haxe__$Int64__$_$_$Int64().default)(0,255);
	var b9 = this24;
	var this25 = new (haxe__$Int64__$_$_$Int64().default)(a4.high & b9.high,a4.low & b9.low);
	sr.s = this25.low;
	var b10 = 16;
	b10 &= 63;
	var a5;
	if(b10 == 0) {
		var this26 = new (haxe__$Int64__$_$_$Int64().default)(v.high,v.low);
		a5 = this26;
	} else if(b10 < 32) {
		var this27 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> b10,v.high << 32 - b10 | v.low >>> b10);
		a5 = this27;
	} else {
		var this28 = new (haxe__$Int64__$_$_$Int64().default)(v.high >> 31,v.high >> b10 - 32);
		a5 = this28;
	}
	var this29 = new (haxe__$Int64__$_$_$Int64().default)(0,255);
	var b11 = this29;
	var this30 = new (haxe__$Int64__$_$_$Int64().default)(a5.high & b11.high,a5.low & b11.low);
	sr.o = this30.low;
	var this31 = new (haxe__$Int64__$_$_$Int64().default)(0,65535);
	var b12 = this31;
	var this32 = new (haxe__$Int64__$_$_$Int64().default)(v.high & b12.high,v.low & b12.low);
	sr.n = this32.low;
	sr.sourceMask = sourceMask;
	return sr;
}
SourceRegister.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = SourceRegister;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/atf/ATFReader.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/formats/atf/ATFReader.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.formats.atf.ATFReader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_IllegalOperationError() {return __webpack_require__(/*! ./../../../../openfl/errors/IllegalOperationError */ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function js_Boot() {return __webpack_require__(/*! ./../../../../js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}

// Constructor

var ATFReader = function(data,byteArrayOffset) {
	this.version = 0;
	data.position = byteArrayOffset;
	var signature = data.readUTFBytes(3);
	data.position = byteArrayOffset;
	if(signature != "ATF") {
		throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("ATF signature not found"));
	}
	var length = 0;
	if(data.get(byteArrayOffset + 6) == 255) {
		this.version = data.get(byteArrayOffset + 7);
		data.position = byteArrayOffset + 8;
		length = this.__readUInt32(data);
	} else {
		this.version = 0;
		data.position = byteArrayOffset + 3;
		length = this.__readUInt24(data);
	}
	if((_$UInt_UInt_$Impl_$().default).gt((js_Boot().default).__cast(byteArrayOffset + length , $hxClasses["Int"]),(openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(data))) {
		throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("ATF length exceeds byte array length"));
	}
	this.data = data;
}

// Meta

ATFReader.__name__ = "openfl._internal.formats.atf.ATFReader";
ATFReader.__isInterface__ = false;
ATFReader.prototype = {
	readHeader: function(__width,__height,cubeMap) {
		var tdata = this.data.readUnsignedByte();
		var type = tdata >>> 7;
		if(!cubeMap && type != 0) {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("ATF Cube map not expected"));
		}
		if(cubeMap && type != 1) {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("ATF Cube map expected"));
		}
		this.cubeMap = cubeMap;
		this.atfFormat = tdata & 127;
		if(this.atfFormat != 3 && this.atfFormat != 5) {
			(lime_utils_Log().default).warn("Only ATF block compressed textures without JPEG-XR+LZMA are supported",{ fileName : "../src/openfl/_internal/formats/atf/ATFReader.hx", lineNumber : 96, className : "openfl._internal.formats.atf.ATFReader", methodName : "readHeader"});
		}
		this.width = 1 << this.data.readUnsignedByte();
		this.height = 1 << this.data.readUnsignedByte();
		if(this.width != __width || this.height != __height) {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("ATF width and height dont match"));
		}
		this.mipCount = this.data.readUnsignedByte();
		return this.atfFormat == 5;
	},
	readTextures: function(uploadCallback) {
		var gpuFormats = this.version < 3 ? 3 : 4;
		var sideCount = this.cubeMap ? 6 : 1;
		var _g = 0;
		var _g1 = sideCount;
		while(_g < _g1) {
			var side = _g++;
			var _g2 = 0;
			var _g11 = this.mipCount;
			while(_g2 < _g11) {
				var level = _g2++;
				var _g3 = 0;
				var _g12 = gpuFormats;
				while(_g3 < _g12) {
					var gpuFormat = _g3++;
					var blockLength = this.version == 0 ? this.__readUInt24(this.data) : this.__readUInt32(this.data);
					if((_$UInt_UInt_$Impl_$().default).gt(this.data.position + blockLength,(openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(this.data))) {
						throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Block length exceeds ATF file length"));
					}
					if((_$UInt_UInt_$Impl_$().default).gt(blockLength,0)) {
						var bytes = (haxe_io_Bytes().default).alloc(blockLength);
						var this1 = this.data;
						var bytes1 = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(bytes);
						var offset = 0;
						var length = blockLength;
						if(length == null) {
							length = 0;
						}
						if(offset == null) {
							offset = 0;
						}
						this1.readBytes(bytes1,offset,length);
						uploadCallback(side,level,gpuFormat,this.width >> level,this.height >> level,blockLength,bytes);
					}
				}
			}
		}
	},
	__readUInt24: function(data) {
		var value = data.readUnsignedByte() << 16;
		value = value | data.readUnsignedByte() << 8;
		value = value | data.readUnsignedByte();
		return value;
	},
	__readUInt32: function(data) {
		var value = data.readUnsignedByte() << 24;
		value = value | data.readUnsignedByte() << 16;
		value = value | data.readUnsignedByte() << 8;
		value = value | data.readUnsignedByte();
		return value;
	}
};
ATFReader.prototype.__class__ = ATFReader.prototype.constructor = $hxClasses["openfl._internal.formats.atf.ATFReader"] = ATFReader;

// Init



// Statics


ATFReader.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = ATFReader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandBuffer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandBuffer.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.DrawCommandBuffer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_DrawCommandReader() {return __webpack_require__(/*! ./../../../openfl/_internal/renderer/DrawCommandReader */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandReader.js");}
function openfl__$internal_renderer_DrawCommandType() {return __webpack_require__(/*! ./../../../openfl/_internal/renderer/DrawCommandType */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandType.js");}

// Constructor

var DrawCommandBuffer = function() {
	if(DrawCommandBuffer.empty == null) {
		this.types = [];
		this.b = [];
		this.i = [];
		this.f = [];
		this.o = [];
		this.ff = [];
		this.ii = [];
		this.copyOnWrite = true;
	} else {
		this.clear();
	}
}

// Meta

DrawCommandBuffer.__name__ = "openfl._internal.renderer.DrawCommandBuffer";
DrawCommandBuffer.__isInterface__ = false;
DrawCommandBuffer.prototype = {
	append: function(other) {
		if(this.get_length() == 0) {
			this.types = other.types;
			this.b = other.b;
			this.i = other.i;
			this.f = other.f;
			this.o = other.o;
			this.ff = other.ff;
			this.ii = other.ii;
			this.copyOnWrite = other.copyOnWrite = true;
			return other;
		}
		var data = new (openfl__$internal_renderer_DrawCommandReader().default)(other);
		var _g = 0;
		var _g1 = other.types;
		while(_g < _g1.length) {
			var type = _g1[_g];
			++_g;
			switch(type._hx_index) {
			case 0:
				var c = data.readBeginBitmapFill();
				this.beginBitmapFill(c.obj(0),c.obj(1),c.bool(0),c.bool(1));
				break;
			case 1:
				var c1 = data.readBeginFill();
				this.beginFill(c1.int(0),c1.float(0));
				break;
			case 2:
				var c2 = data.readBeginGradientFill();
				this.beginGradientFill(c2.obj(0),c2.iArr(0),c2.fArr(0),c2.iArr(1),c2.obj(1),c2.obj(2),c2.obj(3),c2.float(0));
				break;
			case 3:
				var c3 = data.readBeginShaderFill();
				this.beginShaderFill(c3.obj(0));
				break;
			case 4:
				var c4 = data.readCubicCurveTo();
				this.cubicCurveTo(c4.float(0),c4.float(1),c4.float(2),c4.float(3),c4.float(4),c4.float(5));
				break;
			case 5:
				var c5 = data.readCurveTo();
				this.curveTo(c5.float(0),c5.float(1),c5.float(2),c5.float(3));
				break;
			case 6:
				var c6 = data.readDrawCircle();
				this.drawCircle(c6.float(0),c6.float(1),c6.float(2));
				break;
			case 7:
				var c7 = data.readDrawEllipse();
				this.drawEllipse(c7.float(0),c7.float(1),c7.float(2),c7.float(3));
				break;
			case 8:
				var c8 = data.readDrawQuads();
				this.drawQuads(c8.obj(0),c8.obj(1),c8.obj(2));
				break;
			case 9:
				var c9 = data.readDrawRect();
				this.drawRect(c9.float(0),c9.float(1),c9.float(2),c9.float(3));
				break;
			case 10:
				var c10 = data.readDrawRoundRect();
				this.drawRoundRect(c10.float(0),c10.float(1),c10.float(2),c10.float(3),c10.float(4),c10.obj(0));
				break;
			case 12:
				var c11 = data.readDrawTriangles();
				this.drawTriangles(c11.obj(0),c11.obj(1),c11.obj(2),c11.obj(3));
				break;
			case 13:
				var c12 = data.readEndFill();
				this.endFill();
				break;
			case 14:
				var c13 = data.readLineBitmapStyle();
				this.lineBitmapStyle(c13.obj(0),c13.obj(1),c13.bool(0),c13.bool(1));
				break;
			case 15:
				var c14 = data.readLineGradientStyle();
				this.lineGradientStyle(c14.obj(0),c14.iArr(0),c14.fArr(0),c14.iArr(1),c14.obj(1),c14.obj(2),c14.obj(3),c14.float(0));
				break;
			case 16:
				var c15 = data.readLineStyle();
				this.lineStyle(c15.obj(0),c15.int(0),c15.float(0),c15.bool(0),c15.obj(1),c15.obj(2),c15.obj(3),c15.float(1));
				break;
			case 17:
				var c16 = data.readLineTo();
				this.lineTo(c16.float(0),c16.float(1));
				break;
			case 18:
				var c17 = data.readMoveTo();
				this.moveTo(c17.float(0),c17.float(1));
				break;
			case 20:
				var c18 = data.readOverrideMatrix();
				this.overrideMatrix(c18.obj(0));
				break;
			case 21:
				var c19 = data.readWindingEvenOdd();
				this.windingEvenOdd();
				break;
			case 22:
				var c20 = data.readWindingNonZero();
				this.windingNonZero();
				break;
			default:
			}
		}
		data.destroy();
		return other;
	},
	beginBitmapFill: function(bitmap,matrix,repeat,smooth) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).BEGIN_BITMAP_FILL);
		this.o.push(bitmap);
		this.o.push(matrix);
		this.b.push(repeat);
		this.b.push(smooth);
	},
	beginFill: function(color,alpha) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).BEGIN_FILL);
		this.i.push(color);
		this.f.push(alpha);
	},
	beginGradientFill: function(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).BEGIN_GRADIENT_FILL);
		this.o.push(type);
		this.ii.push(colors);
		this.ff.push(alphas);
		this.ii.push(ratios);
		this.o.push(matrix);
		this.o.push(spreadMethod);
		this.o.push(interpolationMethod);
		this.f.push(focalPointRatio);
	},
	beginShaderFill: function(shaderBuffer) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).BEGIN_SHADER_FILL);
		this.o.push(shaderBuffer);
	},
	clear: function() {
		this.types = DrawCommandBuffer.empty.types;
		this.b = DrawCommandBuffer.empty.b;
		this.i = DrawCommandBuffer.empty.i;
		this.f = DrawCommandBuffer.empty.f;
		this.o = DrawCommandBuffer.empty.o;
		this.ff = DrawCommandBuffer.empty.ff;
		this.ii = DrawCommandBuffer.empty.ii;
		this.copyOnWrite = true;
	},
	copy: function() {
		var copy = new DrawCommandBuffer();
		copy.append(this);
		return copy;
	},
	cubicCurveTo: function(controlX1,controlY1,controlX2,controlY2,anchorX,anchorY) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).CUBIC_CURVE_TO);
		this.f.push(controlX1);
		this.f.push(controlY1);
		this.f.push(controlX2);
		this.f.push(controlY2);
		this.f.push(anchorX);
		this.f.push(anchorY);
	},
	curveTo: function(controlX,controlY,anchorX,anchorY) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).CURVE_TO);
		this.f.push(controlX);
		this.f.push(controlY);
		this.f.push(anchorX);
		this.f.push(anchorY);
	},
	destroy: function() {
		this.clear();
		this.types = null;
		this.b = null;
		this.i = null;
		this.f = null;
		this.o = null;
		this.ff = null;
		this.ii = null;
	},
	drawCircle: function(x,y,radius) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).DRAW_CIRCLE);
		this.f.push(x);
		this.f.push(y);
		this.f.push(radius);
	},
	drawEllipse: function(x,y,width,height) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).DRAW_ELLIPSE);
		this.f.push(x);
		this.f.push(y);
		this.f.push(width);
		this.f.push(height);
	},
	drawQuads: function(rects,indices,transforms) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).DRAW_QUADS);
		this.o.push(rects);
		this.o.push(indices);
		this.o.push(transforms);
	},
	drawRect: function(x,y,width,height) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).DRAW_RECT);
		this.f.push(x);
		this.f.push(y);
		this.f.push(width);
		this.f.push(height);
	},
	drawRoundRect: function(x,y,width,height,ellipseWidth,ellipseHeight) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).DRAW_ROUND_RECT);
		this.f.push(x);
		this.f.push(y);
		this.f.push(width);
		this.f.push(height);
		this.f.push(ellipseWidth);
		this.o.push(ellipseHeight);
	},
	drawTriangles: function(vertices,indices,uvtData,culling) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).DRAW_TRIANGLES);
		this.o.push(vertices);
		this.o.push(indices);
		this.o.push(uvtData);
		this.o.push(culling);
	},
	endFill: function() {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).END_FILL);
	},
	lineBitmapStyle: function(bitmap,matrix,repeat,smooth) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).LINE_BITMAP_STYLE);
		this.o.push(bitmap);
		this.o.push(matrix);
		this.b.push(repeat);
		this.b.push(smooth);
	},
	lineGradientStyle: function(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).LINE_GRADIENT_STYLE);
		this.o.push(type);
		this.ii.push(colors);
		this.ff.push(alphas);
		this.ii.push(ratios);
		this.o.push(matrix);
		this.o.push(spreadMethod);
		this.o.push(interpolationMethod);
		this.f.push(focalPointRatio);
	},
	lineStyle: function(thickness,color,alpha,pixelHinting,scaleMode,caps,joints,miterLimit) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).LINE_STYLE);
		this.o.push(thickness);
		this.i.push(color);
		this.f.push(alpha);
		this.b.push(pixelHinting);
		this.o.push(scaleMode);
		this.o.push(caps);
		this.o.push(joints);
		this.f.push(miterLimit);
	},
	lineTo: function(x,y) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).LINE_TO);
		this.f.push(x);
		this.f.push(y);
	},
	moveTo: function(x,y) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).MOVE_TO);
		this.f.push(x);
		this.f.push(y);
	},
	prepareWrite: function() {
		if(this.copyOnWrite) {
			this.types = this.types.slice();
			this.b = this.b.slice();
			this.i = this.i.slice();
			this.f = this.f.slice();
			this.o = this.o.slice();
			this.ff = this.ff.slice();
			this.ii = this.ii.slice();
			this.copyOnWrite = false;
		}
	},
	overrideBlendMode: function(blendMode) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).OVERRIDE_BLEND_MODE);
		this.o.push(blendMode);
	},
	overrideMatrix: function(matrix) {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).OVERRIDE_MATRIX);
		this.o.push(matrix);
	},
	windingEvenOdd: function() {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).WINDING_EVEN_ODD);
	},
	windingNonZero: function() {
		this.prepareWrite();
		this.types.push((openfl__$internal_renderer_DrawCommandType().default).WINDING_NON_ZERO);
	},
	get_length: function() {
		return this.types.length;
	}
};
DrawCommandBuffer.prototype.__class__ = DrawCommandBuffer.prototype.constructor = $hxClasses["openfl._internal.renderer.DrawCommandBuffer"] = DrawCommandBuffer;

// Init



// Statics


DrawCommandBuffer.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, fields : { o : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
DrawCommandBuffer.empty = new DrawCommandBuffer()

// Export

exports.default = DrawCommandBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandReader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandReader.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.DrawCommandReader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_DrawCommandType() {return __webpack_require__(/*! ./../../../openfl/_internal/renderer/DrawCommandType */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandType.js");}

// Constructor

var DrawCommandReader = function(buffer) {
	this.buffer = buffer;
	this.bPos = this.iPos = this.fPos = this.oPos = this.ffPos = this.iiPos = this.tsPos = 0;
	this.prev = (openfl__$internal_renderer_DrawCommandType().default).UNKNOWN;
}

// Meta

DrawCommandReader.__name__ = "openfl._internal.renderer.DrawCommandReader";
DrawCommandReader.__isInterface__ = false;
DrawCommandReader.prototype = {
	advance: function() {
		switch(this.prev._hx_index) {
		case 0:
			this.oPos += 2;
			this.bPos += 2;
			break;
		case 1:
			this.iPos += 1;
			this.fPos += 1;
			break;
		case 2:
			this.oPos += 4;
			this.iiPos += 2;
			this.ffPos += 1;
			this.fPos += 1;
			break;
		case 3:
			this.oPos += 1;
			break;
		case 4:
			this.fPos += 6;
			break;
		case 5:
			this.fPos += 4;
			break;
		case 6:
			this.fPos += 3;
			break;
		case 7:
			this.fPos += 4;
			break;
		case 8:
			this.oPos += 3;
			break;
		case 9:
			this.fPos += 4;
			break;
		case 10:
			this.fPos += 5;
			this.oPos += 1;
			break;
		case 12:
			this.oPos += 4;
			break;
		case 13:
			break;
		case 14:
			this.oPos += 2;
			this.bPos += 2;
			break;
		case 15:
			this.oPos += 4;
			this.iiPos += 2;
			this.ffPos += 1;
			this.fPos += 1;
			break;
		case 16:
			this.oPos += 4;
			this.iPos += 1;
			this.fPos += 2;
			this.bPos += 1;
			break;
		case 17:
			this.fPos += 2;
			break;
		case 18:
			this.fPos += 2;
			break;
		case 19:
			this.oPos += 1;
			break;
		case 20:
			this.oPos += 1;
			break;
		case 21:case 22:
			break;
		default:
		}
	},
	bool: function(index) {
		return this.buffer.b[this.bPos + index];
	},
	destroy: function() {
		this.buffer = null;
		this.reset();
	},
	fArr: function(index) {
		return this.buffer.ff[this.ffPos + index];
	},
	float: function(index) {
		return this.buffer.f[this.fPos + index];
	},
	iArr: function(index) {
		return this.buffer.ii[this.iiPos + index];
	},
	int: function(index) {
		return this.buffer.i[this.iPos + index];
	},
	obj: function(index) {
		return this.buffer.o[this.oPos + index];
	},
	readBeginBitmapFill: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).BEGIN_BITMAP_FILL;
		var this1 = this;
		return this1;
	},
	readBeginFill: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).BEGIN_FILL;
		var this1 = this;
		return this1;
	},
	readBeginGradientFill: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).BEGIN_GRADIENT_FILL;
		var this1 = this;
		return this1;
	},
	readBeginShaderFill: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).BEGIN_SHADER_FILL;
		var this1 = this;
		return this1;
	},
	readCubicCurveTo: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).CUBIC_CURVE_TO;
		var this1 = this;
		return this1;
	},
	readCurveTo: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).CURVE_TO;
		var this1 = this;
		return this1;
	},
	readDrawCircle: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).DRAW_CIRCLE;
		var this1 = this;
		return this1;
	},
	readDrawEllipse: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).DRAW_ELLIPSE;
		var this1 = this;
		return this1;
	},
	readDrawQuads: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).DRAW_QUADS;
		var this1 = this;
		return this1;
	},
	readDrawRect: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).DRAW_RECT;
		var this1 = this;
		return this1;
	},
	readDrawRoundRect: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).DRAW_ROUND_RECT;
		var this1 = this;
		return this1;
	},
	readDrawTriangles: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).DRAW_TRIANGLES;
		var this1 = this;
		return this1;
	},
	readEndFill: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).END_FILL;
		var this1 = this;
		return this1;
	},
	readLineBitmapStyle: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).LINE_BITMAP_STYLE;
		var this1 = this;
		return this1;
	},
	readLineGradientStyle: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).LINE_GRADIENT_STYLE;
		var this1 = this;
		return this1;
	},
	readLineStyle: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).LINE_STYLE;
		var this1 = this;
		return this1;
	},
	readLineTo: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).LINE_TO;
		var this1 = this;
		return this1;
	},
	readMoveTo: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).MOVE_TO;
		var this1 = this;
		return this1;
	},
	readOverrideBlendMode: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).OVERRIDE_BLEND_MODE;
		var this1 = this;
		return this1;
	},
	readOverrideMatrix: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).OVERRIDE_MATRIX;
		var this1 = this;
		return this1;
	},
	readWindingEvenOdd: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).WINDING_EVEN_ODD;
		var this1 = this;
		return this1;
	},
	readWindingNonZero: function() {
		this.advance();
		this.prev = (openfl__$internal_renderer_DrawCommandType().default).WINDING_NON_ZERO;
		var this1 = this;
		return this1;
	},
	reset: function() {
		this.bPos = this.iPos = this.fPos = this.oPos = this.ffPos = this.iiPos = this.tsPos = 0;
	},
	skip: function(type) {
		this.advance();
		this.prev = type;
	}
};
DrawCommandReader.prototype.__class__ = DrawCommandReader.prototype.constructor = $hxClasses["openfl._internal.renderer.DrawCommandReader"] = DrawCommandReader;

// Init



// Statics


DrawCommandReader.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, fields : { obj : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = DrawCommandReader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandType.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandType.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: openfl._internal.renderer.DrawCommandType

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var DrawCommandType = $hxEnums["openfl._internal.renderer.DrawCommandType"] = { __ename__ : "openfl._internal.renderer.DrawCommandType", __constructs__ : ["BEGIN_BITMAP_FILL","BEGIN_FILL","BEGIN_GRADIENT_FILL","BEGIN_SHADER_FILL","CUBIC_CURVE_TO","CURVE_TO","DRAW_CIRCLE","DRAW_ELLIPSE","DRAW_QUADS","DRAW_RECT","DRAW_ROUND_RECT","DRAW_TILES","DRAW_TRIANGLES","END_FILL","LINE_BITMAP_STYLE","LINE_GRADIENT_STYLE","LINE_STYLE","LINE_TO","MOVE_TO","OVERRIDE_BLEND_MODE","OVERRIDE_MATRIX","WINDING_EVEN_ODD","WINDING_NON_ZERO","UNKNOWN"]
  ,WINDING_NON_ZERO: {_hx_index:22,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,WINDING_EVEN_ODD: {_hx_index:21,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,UNKNOWN: {_hx_index:23,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,OVERRIDE_MATRIX: {_hx_index:20,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,OVERRIDE_BLEND_MODE: {_hx_index:19,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,MOVE_TO: {_hx_index:18,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,LINE_TO: {_hx_index:17,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,LINE_STYLE: {_hx_index:16,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,LINE_GRADIENT_STYLE: {_hx_index:15,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,LINE_BITMAP_STYLE: {_hx_index:14,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,END_FILL: {_hx_index:13,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,DRAW_TRIANGLES: {_hx_index:12,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,DRAW_TILES: {_hx_index:11,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,DRAW_ROUND_RECT: {_hx_index:10,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,DRAW_RECT: {_hx_index:9,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,DRAW_QUADS: {_hx_index:8,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,DRAW_ELLIPSE: {_hx_index:7,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,DRAW_CIRCLE: {_hx_index:6,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,CURVE_TO: {_hx_index:5,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,CUBIC_CURVE_TO: {_hx_index:4,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,BEGIN_SHADER_FILL: {_hx_index:3,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,BEGIN_GRADIENT_FILL: {_hx_index:2,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,BEGIN_FILL: {_hx_index:1,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
  ,BEGIN_BITMAP_FILL: {_hx_index:0,__enum__:"openfl._internal.renderer.DrawCommandType",toString:$estr}
};

exports.default = DrawCommandType;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/SamplerState.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/SamplerState.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.SamplerState

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var SamplerState = function(wrap,filter,mipfilter,lodBias,ignoreSampler,centroid,textureAlpha) {
	if(textureAlpha == null) {
		textureAlpha = false;
	}
	if(centroid == null) {
		centroid = false;
	}
	if(ignoreSampler == null) {
		ignoreSampler = false;
	}
	if(lodBias == null) {
		lodBias = 0.0;
	}
	if(mipfilter == null) {
		mipfilter = "mipnone";
	}
	if(filter == null) {
		filter = "nearest";
	}
	if(wrap == null) {
		wrap = "clamp";
	}
	this.wrap = wrap;
	this.filter = filter;
	this.mipfilter = mipfilter;
	this.lodBias = lodBias;
	this.ignoreSampler = ignoreSampler;
	this.centroid = centroid;
	this.textureAlpha = textureAlpha;
}

// Meta

SamplerState.__name__ = "openfl._internal.renderer.SamplerState";
SamplerState.__isInterface__ = false;
SamplerState.prototype = {
	clone: function() {
		var copy = new SamplerState(this.wrap,this.filter,this.mipfilter,this.lodBias,this.ignoreSampler,this.centroid,this.textureAlpha);
		copy.mipmapGenerated = this.mipmapGenerated;
		return copy;
	},
	copyFrom: function(other) {
		if(other == null || other.ignoreSampler) {
			return;
		}
		this.wrap = other.wrap;
		this.filter = other.filter;
		this.mipfilter = other.mipfilter;
		this.lodBias = other.lodBias;
		this.centroid = other.centroid;
		this.textureAlpha = other.textureAlpha;
	},
	equals: function(other) {
		if(other == null) {
			return false;
		}
		if(this.wrap == other.wrap && this.filter == other.filter && this.mipfilter == other.mipfilter && this.lodBias == other.lodBias) {
			return this.textureAlpha == other.textureAlpha;
		} else {
			return false;
		}
	}
};
SamplerState.prototype.__class__ = SamplerState.prototype.constructor = $hxClasses["openfl._internal.renderer.SamplerState"] = SamplerState;

// Init



// Statics


SamplerState.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = SamplerState;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/ShaderBuffer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/ShaderBuffer.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.ShaderBuffer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var ShaderBuffer = function() {
	this.inputRefs = [];
	this.inputFilter = [];
	this.inputMipFilter = [];
	this.inputs = [];
	this.inputWrap = [];
	this.overrideIntNames = [];
	this.overrideIntValues = [];
	this.overrideFloatNames = [];
	this.overrideFloatValues = [];
	this.overrideBoolNames = [];
	this.overrideBoolValues = [];
	this.paramLengths = [];
	this.paramPositions = [];
	this.paramRefs_Bool = [];
	this.paramRefs_Float = [];
	this.paramRefs_Int = [];
	this.paramTypes = [];
}

// Meta

ShaderBuffer.__name__ = "openfl._internal.renderer.ShaderBuffer";
ShaderBuffer.__isInterface__ = false;
ShaderBuffer.prototype = {
	addBoolOverride: function(name,values) {
		this.overrideBoolNames[this.overrideBoolCount] = name;
		this.overrideBoolValues[this.overrideBoolCount] = values;
		this.overrideBoolCount++;
	},
	addFloatOverride: function(name,values) {
		this.overrideFloatNames[this.overrideFloatCount] = name;
		this.overrideFloatValues[this.overrideFloatCount] = values;
		this.overrideFloatCount++;
	},
	addIntOverride: function(name,values) {
		this.overrideIntNames[this.overrideIntCount] = name;
		this.overrideIntValues[this.overrideIntCount] = values;
		this.overrideIntCount++;
	},
	clearOverride: function() {
		this.overrideIntCount = 0;
		this.overrideFloatCount = 0;
		this.overrideBoolCount = 0;
	},
	update: function(shader) {
		this.inputCount = 0;
		this.overrideIntCount = 0;
		this.overrideFloatCount = 0;
		this.overrideBoolCount = 0;
		this.paramBoolCount = 0;
		this.paramCount = 0;
		this.paramDataLength = 0;
		this.paramFloatCount = 0;
		this.paramIntCount = 0;
		this.shader = null;
		if(shader == null) {
			return;
		}
		shader.__init();
		this.inputCount = shader.__inputBitmapData.length;
		var input;
		var _g = 0;
		var _g1 = this.inputCount;
		while(_g < _g1) {
			var i = _g++;
			input = shader.__inputBitmapData[i];
			this.inputs[i] = input.input;
			this.inputFilter[i] = input.filter;
			this.inputMipFilter[i] = input.mipFilter;
			this.inputRefs[i] = input;
			this.inputWrap[i] = input.wrap;
		}
		var boolCount = shader.__paramBool.length;
		var floatCount = shader.__paramFloat.length;
		var intCount = shader.__paramInt.length;
		this.paramCount = boolCount + floatCount + intCount;
		this.paramBoolCount = boolCount;
		this.paramFloatCount = floatCount;
		this.paramIntCount = intCount;
		var length = 0;
		var p = 0;
		var param;
		var _g2 = 0;
		var _g3 = boolCount;
		while(_g2 < _g3) {
			var i1 = _g2++;
			param = shader.__paramBool[i1];
			this.paramPositions[p] = this.paramDataLength;
			length = param.value != null ? param.value.length : 0;
			this.paramLengths[p] = length;
			this.paramDataLength += length;
			this.paramTypes[p] = 0;
			this.paramRefs_Bool[i1] = param;
			++p;
		}
		var param1;
		var _g4 = 0;
		var _g5 = floatCount;
		while(_g4 < _g5) {
			var i2 = _g4++;
			param1 = shader.__paramFloat[i2];
			this.paramPositions[p] = this.paramDataLength;
			length = param1.value != null ? param1.value.length : 0;
			this.paramLengths[p] = length;
			this.paramDataLength += length;
			this.paramTypes[p] = 1;
			this.paramRefs_Float[i2] = param1;
			++p;
		}
		var param2;
		var _g6 = 0;
		var _g7 = intCount;
		while(_g6 < _g7) {
			var i3 = _g6++;
			param2 = shader.__paramInt[i3];
			this.paramPositions[p] = this.paramDataLength;
			length = param2.value != null ? param2.value.length : 0;
			this.paramLengths[p] = length;
			this.paramDataLength += length;
			this.paramTypes[p] = 2;
			this.paramRefs_Int[i3] = param2;
			++p;
		}
		if(this.paramDataLength > 0) {
			if(this.paramData == null) {
				var elements = this.paramDataLength;
				var array = null;
				var view = null;
				var buffer = null;
				var len = null;
				var this1;
				if(elements != null) {
					this1 = new Float32Array(elements);
				} else if(array != null) {
					this1 = new Float32Array(array);
				} else if(view != null) {
					this1 = new Float32Array(view);
				} else if(buffer != null) {
					if(len == null) {
						this1 = new Float32Array(buffer,0);
					} else {
						this1 = new Float32Array(buffer,0,len);
					}
				} else {
					this1 = null;
				}
				this.paramData = this1;
			} else if(this.paramDataLength > this.paramData.length) {
				var elements1 = this.paramDataLength;
				var array1 = null;
				var view1 = null;
				var buffer1 = null;
				var len1 = null;
				var this2;
				if(elements1 != null) {
					this2 = new Float32Array(elements1);
				} else if(array1 != null) {
					this2 = new Float32Array(array1);
				} else if(view1 != null) {
					this2 = new Float32Array(view1);
				} else if(buffer1 != null) {
					if(len1 == null) {
						this2 = new Float32Array(buffer1,0);
					} else {
						this2 = new Float32Array(buffer1,0,len1);
					}
				} else {
					this2 = null;
				}
				var data = this2;
				data.set(this.paramData);
				this.paramData = data;
			}
		}
		var boolIndex = 0;
		var floatIndex = 0;
		var intIndex = 0;
		var paramPosition = 0;
		var boolParam;
		var floatParam;
		var intParam;
		var length1;
		var _g8 = 0;
		var _g9 = this.paramCount;
		while(_g8 < _g9) {
			var i4 = _g8++;
			length1 = this.paramLengths[i4];
			if(i4 < boolCount) {
				boolParam = this.paramRefs_Bool[boolIndex];
				++boolIndex;
				var _g81 = 0;
				var _g91 = length1;
				while(_g81 < _g91) {
					var j = _g81++;
					this.paramData[paramPosition] = boolParam.value[j] ? 1 : 0;
					++paramPosition;
				}
			} else if(i4 < boolCount + floatCount) {
				floatParam = this.paramRefs_Float[floatIndex];
				++floatIndex;
				var _g82 = 0;
				var _g92 = length1;
				while(_g82 < _g92) {
					var j1 = _g82++;
					this.paramData[paramPosition] = floatParam.value[j1];
					++paramPosition;
				}
			} else {
				intParam = this.paramRefs_Int[intIndex];
				++intIndex;
				var _g83 = 0;
				var _g93 = length1;
				while(_g83 < _g93) {
					var j2 = _g83++;
					this.paramData[paramPosition] = intParam.value[j2];
					++paramPosition;
				}
			}
		}
		this.shader = shader;
	}
};
ShaderBuffer.prototype.__class__ = ShaderBuffer.prototype.constructor = $hxClasses["openfl._internal.renderer.ShaderBuffer"] = ShaderBuffer;

// Init



// Statics


ShaderBuffer.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, fields : { overrideIntValues : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = ShaderBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasBitmap.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasBitmap.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.canvas.CanvasBitmap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}

// Constructor

var CanvasBitmap = function(){}

// Meta

CanvasBitmap.__name__ = "openfl._internal.renderer.canvas.CanvasBitmap";
CanvasBitmap.__isInterface__ = false;
CanvasBitmap.prototype = {
	
};
CanvasBitmap.prototype.__class__ = CanvasBitmap.prototype.constructor = $hxClasses["openfl._internal.renderer.canvas.CanvasBitmap"] = CanvasBitmap;

// Init



// Statics

CanvasBitmap.render = function(bitmap,renderer) {
	if(!bitmap.__renderable) {
		return;
	}
	var alpha = renderer.__getAlpha(bitmap.__worldAlpha);
	if(alpha > 0 && bitmap.__bitmapData != null && bitmap.__bitmapData.__isValid && bitmap.__bitmapData.readable) {
		var context = renderer.context;
		renderer.__setBlendMode(bitmap.__worldBlendMode);
		renderer.__pushMaskObject(bitmap,false);
		(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(bitmap.__bitmapData.image);
		context.globalAlpha = alpha;
		var scrollRect = bitmap.__scrollRect;
		renderer.setTransform(bitmap.__renderTransform,context);
		if(!renderer.__allowSmoothing || !bitmap.smoothing) {
			context.imageSmoothingEnabled = false;
		}
		if(scrollRect == null) {
			context.drawImage(bitmap.__bitmapData.image.get_src(),0,0,bitmap.__bitmapData.image.width,bitmap.__bitmapData.image.height);
		} else {
			context.drawImage(bitmap.__bitmapData.image.get_src(),scrollRect.x,scrollRect.y,scrollRect.width,scrollRect.height);
		}
		if(!renderer.__allowSmoothing || !bitmap.smoothing) {
			context.imageSmoothingEnabled = true;
		}
		renderer.__popMaskObject(bitmap,false);
	}
}
CanvasBitmap.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = CanvasBitmap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasDisplayObject.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasDisplayObject.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.canvas.CanvasDisplayObject

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_canvas_CanvasShape() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/canvas/CanvasShape */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasShape.js");}

// Constructor

var CanvasDisplayObject = function(){}

// Meta

CanvasDisplayObject.__name__ = "openfl._internal.renderer.canvas.CanvasDisplayObject";
CanvasDisplayObject.__isInterface__ = false;
CanvasDisplayObject.prototype = {
	
};
CanvasDisplayObject.prototype.__class__ = CanvasDisplayObject.prototype.constructor = $hxClasses["openfl._internal.renderer.canvas.CanvasDisplayObject"] = CanvasDisplayObject;

// Init



// Statics

CanvasDisplayObject.render = function(displayObject,renderer) {
	if(displayObject.opaqueBackground == null && displayObject.__graphics == null) {
		return;
	}
	if(!displayObject.__renderable) {
		return;
	}
	var alpha = renderer.__getAlpha(displayObject.__worldAlpha);
	if(alpha <= 0) {
		return;
	}
	if(displayObject.opaqueBackground != null && !displayObject.__isCacheBitmapRender && displayObject.get_width() > 0 && displayObject.get_height() > 0) {
		renderer.__setBlendMode(displayObject.__worldBlendMode);
		renderer.__pushMaskObject(displayObject);
		var context = renderer.context;
		renderer.setTransform(displayObject.__renderTransform,context);
		var color = displayObject.opaqueBackground;
		context.fillStyle = "rgb(" + (color >>> 16 & 255) + "," + (color >>> 8 & 255) + "," + (color & 255) + ")";
		context.fillRect(0,0,displayObject.get_width(),displayObject.get_height());
		renderer.__popMaskObject(displayObject);
	}
	if(displayObject.__graphics != null) {
		(openfl__$internal_renderer_canvas_CanvasShape().default).render(displayObject,renderer);
	}
}
CanvasDisplayObject.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = CanvasDisplayObject;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasGraphics.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasGraphics.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.canvas.CanvasGraphics

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_DrawCommandBuffer() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/DrawCommandBuffer */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandBuffer.js");}
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function openfl__$internal_renderer_DrawCommandReader() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/DrawCommandReader */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandReader.js");}
function openfl__$internal_renderer_DrawCommandType() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/DrawCommandType */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandType.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function StringTools() {return __webpack_require__(/*! ./../../../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function Std() {return __webpack_require__(/*! ./../../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl_display_BitmapData() {return __webpack_require__(/*! ./../../../../openfl/display/BitmapData */ "./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js");}

// Constructor

var CanvasGraphics = function(){}

// Meta

CanvasGraphics.__name__ = "openfl._internal.renderer.canvas.CanvasGraphics";
CanvasGraphics.__isInterface__ = false;
CanvasGraphics.prototype = {
	
};
CanvasGraphics.prototype.__class__ = CanvasGraphics.prototype.constructor = $hxClasses["openfl._internal.renderer.canvas.CanvasGraphics"] = CanvasGraphics;

// Init

{
	CanvasGraphics.hitTestCanvas = typeof(window) != "undefined" ? window.document.createElement("canvas") : null;
	CanvasGraphics.hitTestContext = typeof(window) != "undefined" ? CanvasGraphics.hitTestCanvas.getContext("2d") : null;
};

// Statics

CanvasGraphics.closePath = function(strokeBefore) {
	if(strokeBefore == null) {
		strokeBefore = false;
	}
	if(CanvasGraphics.context.strokeStyle == null) {
		return;
	}
	if(!strokeBefore) {
		CanvasGraphics.context.closePath();
	}
	CanvasGraphics.context.stroke();
	if(strokeBefore) {
		CanvasGraphics.context.closePath();
	}
	CanvasGraphics.context.beginPath();
}
CanvasGraphics.createBitmapFill = function(bitmap,bitmapRepeat,smooth) {
	(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(bitmap.image);
	CanvasGraphics.setSmoothing(smooth);
	return CanvasGraphics.context.createPattern(bitmap.image.get_src(),bitmapRepeat ? "repeat" : "no-repeat");
}
CanvasGraphics.createGradientPattern = function(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio) {
	var gradientFill = null;
	var point = null;
	var point2 = null;
	var releaseMatrix = false;
	if(matrix == null) {
		matrix = (openfl_geom_Matrix().default).__pool.get();
		releaseMatrix = true;
	}
	switch(type) {
	case "linear":
		point = (openfl_geom_Point().default).__pool.get();
		point.setTo(-819.2,0);
		matrix.__transformPoint(point);
		point2 = (openfl_geom_Point().default).__pool.get();
		point2.setTo(819.2,0);
		matrix.__transformPoint(point2);
		gradientFill = CanvasGraphics.context.createLinearGradient(point.x,point.y,point2.x,point2.y);
		break;
	case "radial":
		point = (openfl_geom_Point().default).__pool.get();
		point.setTo(1638.4,0);
		matrix.__transformPoint(point);
		gradientFill = CanvasGraphics.context.createRadialGradient(matrix.tx,matrix.ty,0,matrix.tx,matrix.ty,Math.abs((point.x - matrix.tx) / 2));
		break;
	}
	var rgb;
	var alpha;
	var r;
	var g;
	var b;
	var ratio;
	var _g = 0;
	var _g1 = colors.length;
	while(_g < _g1) {
		var i = _g++;
		rgb = colors[i];
		alpha = alphas[i];
		r = (rgb & 16711680) >>> 16;
		g = (rgb & 65280) >>> 8;
		b = rgb & 255;
		ratio = ratios[i] / 255;
		if(ratio < 0) {
			ratio = 0;
		}
		if(ratio > 1) {
			ratio = 1;
		}
		gradientFill.addColorStop(ratio,"rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")");
	}
	if(point != null) {
		(openfl_geom_Point().default).__pool.release(point);
	}
	if(point2 != null) {
		(openfl_geom_Point().default).__pool.release(point2);
	}
	if(releaseMatrix) {
		(openfl_geom_Matrix().default).__pool.release(matrix);
	}
	return gradientFill;
}
CanvasGraphics.createTempPatternCanvas = function(bitmap,repeat,width,height) {
	var canvas = window.document.createElement("canvas");
	var context = canvas.getContext("2d");
	canvas.width = width;
	canvas.height = height;
	var tmp = bitmap.image.get_src();
	context.fillStyle = context.createPattern(tmp,repeat ? "repeat" : "no-repeat");
	context.beginPath();
	context.moveTo(0,0);
	context.lineTo(0,height);
	context.lineTo(width,height);
	context.lineTo(width,0);
	context.lineTo(0,0);
	context.closePath();
	if(!CanvasGraphics.hitTesting) {
		context.fill(CanvasGraphics.windingRule);
	}
	return canvas;
}
CanvasGraphics.drawRoundRect = function(x,y,width,height,ellipseWidth,ellipseHeight) {
	if(ellipseHeight == null) {
		ellipseHeight = ellipseWidth;
	}
	ellipseWidth *= 0.5;
	ellipseHeight *= 0.5;
	if(ellipseWidth > width / 2) {
		ellipseWidth = width / 2;
	}
	if(ellipseHeight > height / 2) {
		ellipseHeight = height / 2;
	}
	var xe = x + width;
	var ye = y + height;
	var cx1 = -ellipseWidth + ellipseWidth * 0.70710678118654752440084436210485;
	var cx2 = -ellipseWidth + ellipseWidth * 0.4142135623730950488016887242097;
	var cy1 = -ellipseHeight + ellipseHeight * 0.70710678118654752440084436210485;
	var cy2 = -ellipseHeight + ellipseHeight * 0.4142135623730950488016887242097;
	CanvasGraphics.context.moveTo(xe,ye - ellipseHeight);
	CanvasGraphics.context.quadraticCurveTo(xe,ye + cy2,xe + cx1,ye + cy1);
	CanvasGraphics.context.quadraticCurveTo(xe + cx2,ye,xe - ellipseWidth,ye);
	CanvasGraphics.context.lineTo(x + ellipseWidth,ye);
	CanvasGraphics.context.quadraticCurveTo(x - cx2,ye,x - cx1,ye + cy1);
	CanvasGraphics.context.quadraticCurveTo(x,ye + cy2,x,ye - ellipseHeight);
	CanvasGraphics.context.lineTo(x,y + ellipseHeight);
	CanvasGraphics.context.quadraticCurveTo(x,y - cy2,x - cx1,y - cy1);
	CanvasGraphics.context.quadraticCurveTo(x - cx2,y,x + ellipseWidth,y);
	CanvasGraphics.context.lineTo(xe - ellipseWidth,y);
	CanvasGraphics.context.quadraticCurveTo(xe + cx2,y,xe + cx1,y - cy1);
	CanvasGraphics.context.quadraticCurveTo(xe,y - cy2,xe,y + ellipseHeight);
	CanvasGraphics.context.lineTo(xe,ye - ellipseHeight);
}
CanvasGraphics.endFill = function() {
	CanvasGraphics.context.beginPath();
	CanvasGraphics.playCommands(CanvasGraphics.fillCommands,false);
	CanvasGraphics.fillCommands.clear();
}
CanvasGraphics.endStroke = function() {
	CanvasGraphics.context.beginPath();
	CanvasGraphics.playCommands(CanvasGraphics.strokeCommands,true);
	CanvasGraphics.context.closePath();
	CanvasGraphics.strokeCommands.clear();
}
CanvasGraphics.hitTest = function(graphics,x,y) {
	CanvasGraphics.bounds = graphics.__bounds;
	CanvasGraphics.graphics = graphics;
	if(graphics.__commands.get_length() == 0 || CanvasGraphics.bounds == null || CanvasGraphics.bounds.width <= 0 || CanvasGraphics.bounds.height <= 0) {
		return false;
	} else {
		CanvasGraphics.hitTesting = true;
		var transform = graphics.__renderTransform;
		var px = transform.__transformX(x,y);
		var py = transform.__transformY(x,y);
		x = px;
		y = py;
		x -= transform.__transformX(CanvasGraphics.bounds.x,CanvasGraphics.bounds.y);
		y -= transform.__transformY(CanvasGraphics.bounds.x,CanvasGraphics.bounds.y);
		var cacheCanvas = graphics.__canvas;
		var cacheContext = graphics.__context;
		graphics.__canvas = CanvasGraphics.hitTestCanvas;
		graphics.__context = CanvasGraphics.hitTestContext;
		CanvasGraphics.context = graphics.__context;
		CanvasGraphics.context.setTransform(transform.a,transform.b,transform.c,transform.d,transform.tx,transform.ty);
		CanvasGraphics.fillCommands.clear();
		CanvasGraphics.strokeCommands.clear();
		CanvasGraphics.hasFill = false;
		CanvasGraphics.hasStroke = false;
		CanvasGraphics.bitmapFill = null;
		CanvasGraphics.bitmapRepeat = false;
		CanvasGraphics.windingRule = "evenodd";
		var data = new (openfl__$internal_renderer_DrawCommandReader().default)(graphics.__commands);
		var _g = 0;
		var _g1 = graphics.__commands.types;
		while(_g < _g1.length) {
			var type = _g1[_g];
			++_g;
			switch(type._hx_index) {
			case 0:case 1:case 2:case 3:
				CanvasGraphics.endFill();
				if(CanvasGraphics.hasFill && CanvasGraphics.context.isPointInPath(x,y,CanvasGraphics.windingRule)) {
					data.destroy();
					graphics.__canvas = cacheCanvas;
					graphics.__context = cacheContext;
					return true;
				}
				CanvasGraphics.endStroke();
				if(CanvasGraphics.hasStroke && CanvasGraphics.context.isPointInStroke(x,y)) {
					data.destroy();
					graphics.__canvas = cacheCanvas;
					graphics.__context = cacheContext;
					return true;
				}
				if(type == (openfl__$internal_renderer_DrawCommandType().default).BEGIN_BITMAP_FILL) {
					var c = data.readBeginBitmapFill();
					CanvasGraphics.fillCommands.beginBitmapFill(c.obj(0),c.obj(1),c.bool(0),c.bool(1));
					CanvasGraphics.strokeCommands.beginBitmapFill(c.obj(0),c.obj(1),c.bool(0),c.bool(1));
				} else if(type == (openfl__$internal_renderer_DrawCommandType().default).BEGIN_GRADIENT_FILL) {
					var c1 = data.readBeginGradientFill();
					CanvasGraphics.fillCommands.beginGradientFill(c1.obj(0),c1.iArr(0),c1.fArr(0),c1.iArr(1),c1.obj(1),c1.obj(2),c1.obj(3),c1.float(0));
					CanvasGraphics.strokeCommands.beginGradientFill(c1.obj(0),c1.iArr(0),c1.fArr(0),c1.iArr(1),c1.obj(1),c1.obj(2),c1.obj(3),c1.float(0));
				} else if(type == (openfl__$internal_renderer_DrawCommandType().default).BEGIN_SHADER_FILL) {
					var c2 = data.readBeginShaderFill();
					CanvasGraphics.fillCommands.beginShaderFill(c2.obj(0));
					CanvasGraphics.strokeCommands.beginShaderFill(c2.obj(0));
				} else {
					var c3 = data.readBeginFill();
					CanvasGraphics.fillCommands.beginFill(c3.int(0),1);
					CanvasGraphics.strokeCommands.beginFill(c3.int(0),1);
				}
				break;
			case 4:
				var c4 = data.readCubicCurveTo();
				CanvasGraphics.fillCommands.cubicCurveTo(c4.float(0),c4.float(1),c4.float(2),c4.float(3),c4.float(4),c4.float(5));
				CanvasGraphics.strokeCommands.cubicCurveTo(c4.float(0),c4.float(1),c4.float(2),c4.float(3),c4.float(4),c4.float(5));
				break;
			case 5:
				var c5 = data.readCurveTo();
				CanvasGraphics.fillCommands.curveTo(c5.float(0),c5.float(1),c5.float(2),c5.float(3));
				CanvasGraphics.strokeCommands.curveTo(c5.float(0),c5.float(1),c5.float(2),c5.float(3));
				break;
			case 6:
				var c6 = data.readDrawCircle();
				CanvasGraphics.fillCommands.drawCircle(c6.float(0),c6.float(1),c6.float(2));
				CanvasGraphics.strokeCommands.drawCircle(c6.float(0),c6.float(1),c6.float(2));
				break;
			case 7:
				var c7 = data.readDrawEllipse();
				CanvasGraphics.fillCommands.drawEllipse(c7.float(0),c7.float(1),c7.float(2),c7.float(3));
				CanvasGraphics.strokeCommands.drawEllipse(c7.float(0),c7.float(1),c7.float(2),c7.float(3));
				break;
			case 9:
				var c8 = data.readDrawRect();
				CanvasGraphics.fillCommands.drawRect(c8.float(0),c8.float(1),c8.float(2),c8.float(3));
				CanvasGraphics.strokeCommands.drawRect(c8.float(0),c8.float(1),c8.float(2),c8.float(3));
				break;
			case 10:
				var c9 = data.readDrawRoundRect();
				CanvasGraphics.fillCommands.drawRoundRect(c9.float(0),c9.float(1),c9.float(2),c9.float(3),c9.float(4),c9.obj(0));
				CanvasGraphics.strokeCommands.drawRoundRect(c9.float(0),c9.float(1),c9.float(2),c9.float(3),c9.float(4),c9.obj(0));
				break;
			case 13:
				data.readEndFill();
				CanvasGraphics.endFill();
				if(CanvasGraphics.hasFill && CanvasGraphics.context.isPointInPath(x,y,CanvasGraphics.windingRule)) {
					data.destroy();
					graphics.__canvas = cacheCanvas;
					graphics.__context = cacheContext;
					return true;
				}
				CanvasGraphics.endStroke();
				if(CanvasGraphics.hasStroke && CanvasGraphics.context.isPointInStroke(x,y)) {
					data.destroy();
					graphics.__canvas = cacheCanvas;
					graphics.__context = cacheContext;
					return true;
				}
				CanvasGraphics.hasFill = false;
				CanvasGraphics.bitmapFill = null;
				break;
			case 14:
				var c10 = data.readLineBitmapStyle();
				CanvasGraphics.strokeCommands.lineBitmapStyle(c10.obj(0),c10.obj(1),c10.bool(0),c10.bool(1));
				break;
			case 15:
				var c11 = data.readLineGradientStyle();
				CanvasGraphics.strokeCommands.lineGradientStyle(c11.obj(0),c11.iArr(0),c11.fArr(0),c11.iArr(1),c11.obj(1),c11.obj(2),c11.obj(3),c11.float(0));
				break;
			case 16:
				var c12 = data.readLineStyle();
				CanvasGraphics.strokeCommands.lineStyle(c12.obj(0),c12.int(0),1,c12.bool(0),c12.obj(1),c12.obj(2),c12.obj(3),c12.float(1));
				break;
			case 17:
				var c13 = data.readLineTo();
				CanvasGraphics.fillCommands.lineTo(c13.float(0),c13.float(1));
				CanvasGraphics.strokeCommands.lineTo(c13.float(0),c13.float(1));
				break;
			case 18:
				var c14 = data.readMoveTo();
				CanvasGraphics.fillCommands.moveTo(c14.float(0),c14.float(1));
				CanvasGraphics.strokeCommands.moveTo(c14.float(0),c14.float(1));
				break;
			case 21:
				CanvasGraphics.windingRule = "evenodd";
				break;
			case 22:
				CanvasGraphics.windingRule = "nonzero";
				break;
			default:
				data.skip(type);
			}
		}
		var hitTest = false;
		if(CanvasGraphics.fillCommands.get_length() > 0) {
			CanvasGraphics.endFill();
		}
		if(CanvasGraphics.hasFill && CanvasGraphics.context.isPointInPath(x,y,CanvasGraphics.windingRule)) {
			hitTest = true;
		}
		if(CanvasGraphics.strokeCommands.get_length() > 0) {
			CanvasGraphics.endStroke();
		}
		if(CanvasGraphics.hasStroke && CanvasGraphics.context.isPointInStroke(x,y)) {
			hitTest = true;
		}
		data.destroy();
		graphics.__canvas = cacheCanvas;
		graphics.__context = cacheContext;
		return hitTest;
	}
}
CanvasGraphics.isCCW = function(x1,y1,x2,y2,x3,y3) {
	return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1) < 0;
}
CanvasGraphics.normalizeUVT = function(uvt,skipT) {
	if(skipT == null) {
		skipT = false;
	}
	var max = -Infinity;
	var tmp = -Infinity;
	var len = uvt.get_length();
	var _g = 1;
	var _g1 = len + 1;
	while(_g < _g1) {
		var t = _g++;
		if(skipT && t % 3 == 0) {
			continue;
		}
		tmp = uvt[t - 1];
		if(max < tmp) {
			max = tmp;
		}
	}
	if(!skipT) {
		return { max : max, uvt : uvt};
	}
	var result = (openfl__$Vector_Vector_$Impl_$().default)._new();
	var _g2 = 1;
	var _g3 = len + 1;
	while(_g2 < _g3) {
		var t1 = _g2++;
		if(skipT && t1 % 3 == 0) {
			continue;
		}
		(openfl__$Vector_Vector_$Impl_$().default).push(result,uvt[t1 - 1]);
	}
	return { max : max, uvt : result};
}
CanvasGraphics.playCommands = function(commands,stroke) {
	if(stroke == null) {
		stroke = false;
	}
	CanvasGraphics.bounds = CanvasGraphics.graphics.__bounds;
	var offsetX = CanvasGraphics.bounds.x;
	var offsetY = CanvasGraphics.bounds.y;
	var positionX = 0.0;
	var positionY = 0.0;
	var closeGap = false;
	var startX = 0.0;
	var startY = 0.0;
	var setStart = false;
	CanvasGraphics.windingRule = "evenodd";
	CanvasGraphics.setSmoothing(true);
	var hasPath = false;
	var data = new (openfl__$internal_renderer_DrawCommandReader().default)(commands);
	var x;
	var y;
	var width;
	var height;
	var kappa = .5522848;
	var ox;
	var oy;
	var xe;
	var ye;
	var xm;
	var ym;
	var r;
	var g;
	var b;
	var optimizationUsed;
	var canOptimizeMatrix;
	var st;
	var sr;
	var sb;
	var sl;
	var stl = null;
	var sbr = null;
	var _g = 0;
	var _g1 = commands.types;
	_hx_loop1: while(_g < _g1.length) {
		var type = _g1[_g];
		++_g;
		switch(type._hx_index) {
		case 0:
			var c = data.readBeginBitmapFill();
			CanvasGraphics.bitmapFill = c.obj(0);
			var tmp = c.obj(0);
			var tmp1 = c.bool(0);
			var tmp2 = c.bool(1);
			CanvasGraphics.context.fillStyle = CanvasGraphics.createBitmapFill(tmp,tmp1,tmp2);
			CanvasGraphics.hasFill = true;
			if(c.obj(1) != null) {
				CanvasGraphics.pendingMatrix = c.obj(1);
				CanvasGraphics.inversePendingMatrix = c.obj(1).clone();
				CanvasGraphics.inversePendingMatrix.invert();
			} else {
				CanvasGraphics.pendingMatrix = null;
				CanvasGraphics.inversePendingMatrix = null;
			}
			break;
		case 1:
			var c1 = data.readBeginFill();
			if(c1.float(0) < 0.005) {
				CanvasGraphics.hasFill = false;
			} else {
				if(c1.float(0) == 1) {
					var tmp3 = (StringTools().default).hex(c1.int(0) & 16777215,6);
					CanvasGraphics.context.fillStyle = "#" + tmp3;
				} else {
					r = (c1.int(0) & 16711680) >>> 16;
					g = (c1.int(0) & 65280) >>> 8;
					b = c1.int(0) & 255;
					var tmp4 = "rgba(" + r + ", " + g + ", " + b + ", " + c1.float(0);
					CanvasGraphics.context.fillStyle = tmp4 + ")";
				}
				CanvasGraphics.bitmapFill = null;
				CanvasGraphics.setSmoothing(true);
				CanvasGraphics.hasFill = true;
			}
			break;
		case 2:
			var c2 = data.readBeginGradientFill();
			var tmp5 = c2.obj(0);
			var tmp6 = c2.iArr(0);
			var tmp7 = c2.fArr(0);
			var tmp8 = c2.iArr(1);
			var tmp9 = c2.obj(1);
			var tmp10 = c2.obj(2);
			var tmp11 = c2.obj(3);
			CanvasGraphics.context.fillStyle = CanvasGraphics.createGradientPattern(tmp5,tmp6,tmp7,tmp8,tmp9,tmp10,tmp11,c2.float(0));
			CanvasGraphics.bitmapFill = null;
			CanvasGraphics.setSmoothing(true);
			CanvasGraphics.hasFill = true;
			break;
		case 3:
			var c3 = data.readBeginShaderFill();
			var shaderBuffer = c3.obj(0);
			if(shaderBuffer.inputCount > 0) {
				CanvasGraphics.bitmapFill = shaderBuffer.inputs[0];
				CanvasGraphics.context.fillStyle = CanvasGraphics.createBitmapFill(CanvasGraphics.bitmapFill,shaderBuffer.inputWrap[0] != "clamp",shaderBuffer.inputFilter[0] != "nearest");
				CanvasGraphics.hasFill = true;
				CanvasGraphics.pendingMatrix = null;
				CanvasGraphics.inversePendingMatrix = null;
			}
			break;
		case 4:
			var c4 = data.readCubicCurveTo();
			hasPath = true;
			CanvasGraphics.context.bezierCurveTo(c4.float(0) - offsetX,c4.float(1) - offsetY,c4.float(2) - offsetX,c4.float(3) - offsetY,c4.float(4) - offsetX,c4.float(5) - offsetY);
			break;
		case 5:
			var c5 = data.readCurveTo();
			hasPath = true;
			CanvasGraphics.context.quadraticCurveTo(c5.float(0) - offsetX,c5.float(1) - offsetY,c5.float(2) - offsetX,c5.float(3) - offsetY);
			break;
		case 6:
			var c6 = data.readDrawCircle();
			hasPath = true;
			CanvasGraphics.context.moveTo(c6.float(0) - offsetX + c6.float(2),c6.float(1) - offsetY);
			CanvasGraphics.context.arc(c6.float(0) - offsetX,c6.float(1) - offsetY,c6.float(2),0,Math.PI * 2,true);
			break;
		case 7:
			var c7 = data.readDrawEllipse();
			hasPath = true;
			x = c7.float(0);
			y = c7.float(1);
			width = c7.float(2);
			height = c7.float(3);
			x -= offsetX;
			y -= offsetY;
			ox = width / 2 * kappa;
			oy = height / 2 * kappa;
			xe = x + width;
			ye = y + height;
			xm = x + width / 2;
			ym = y + height / 2;
			CanvasGraphics.context.moveTo(x,ym);
			CanvasGraphics.context.bezierCurveTo(x,ym - oy,xm - ox,y,xm,y);
			CanvasGraphics.context.bezierCurveTo(xm + ox,y,xe,ym - oy,xe,ym);
			CanvasGraphics.context.bezierCurveTo(xe,ym + oy,xm + ox,ye,xm,ye);
			CanvasGraphics.context.bezierCurveTo(xm - ox,ye,x,ym + oy,x,ym);
			break;
		case 8:
			var c8 = data.readDrawQuads();
			var rects = c8.obj(0);
			var indices = c8.obj(1);
			var transforms = c8.obj(2);
			var hasIndices = indices != null;
			var transformABCD = false;
			var transformXY = false;
			var length = hasIndices ? indices.get_length() : Math.floor(rects.get_length() / 4);
			if(length == 0) {
				return;
			}
			if(transforms != null) {
				if(transforms.get_length() >= length * 6) {
					transformABCD = true;
					transformXY = true;
				} else if(transforms.get_length() >= length * 4) {
					transformABCD = true;
				} else if(transforms.get_length() >= length * 2) {
					transformXY = true;
				}
			}
			var tileRect = (openfl_geom_Rectangle().default).__pool.get();
			var tileTransform = (openfl_geom_Matrix().default).__pool.get();
			var transform = CanvasGraphics.graphics.__renderTransform;
			var alpha = CanvasGraphics.worldAlpha;
			var ri;
			var ti;
			CanvasGraphics.context.save();
			var _g2 = 0;
			var _g11 = length;
			while(_g2 < _g11) {
				var i = _g2++;
				ri = hasIndices ? indices[i] * 4 : i * 4;
				if(ri < 0) {
					continue;
				}
				tileRect.setTo(rects[ri],rects[ri + 1],rects[ri + 2],rects[ri + 3]);
				if(tileRect.width <= 0 || tileRect.height <= 0) {
					continue;
				}
				if(transformABCD && transformXY) {
					ti = i * 6;
					tileTransform.setTo(transforms[ti],transforms[ti + 1],transforms[ti + 2],transforms[ti + 3],transforms[ti + 4],transforms[ti + 5]);
				} else if(transformABCD) {
					ti = i * 4;
					tileTransform.setTo(transforms[ti],transforms[ti + 1],transforms[ti + 2],transforms[ti + 3],tileRect.x,tileRect.y);
				} else if(transformXY) {
					ti = i * 2;
					tileTransform.tx = transforms[ti];
					tileTransform.ty = transforms[ti + 1];
				} else {
					tileTransform.tx = tileRect.x;
					tileTransform.ty = tileRect.y;
				}
				tileTransform.tx += positionX - offsetX;
				tileTransform.ty += positionY - offsetY;
				tileTransform.concat(transform);
				CanvasGraphics.context.setTransform(tileTransform.a,tileTransform.b,tileTransform.c,tileTransform.d,tileTransform.tx,tileTransform.ty);
				if(CanvasGraphics.bitmapFill != null) {
					CanvasGraphics.context.drawImage(CanvasGraphics.bitmapFill.image.get_src(),tileRect.x,tileRect.y,tileRect.width,tileRect.height,0,0,tileRect.width,tileRect.height);
				} else {
					CanvasGraphics.context.fillRect(0,0,tileRect.width,tileRect.height);
				}
			}
			(openfl_geom_Rectangle().default).__pool.release(tileRect);
			(openfl_geom_Matrix().default).__pool.release(tileTransform);
			CanvasGraphics.context.restore();
			break;
		case 9:
			var c9 = data.readDrawRect();
			optimizationUsed = false;
			if(CanvasGraphics.bitmapFill != null && !CanvasGraphics.hitTesting) {
				st = 0;
				sr = 0;
				sb = 0;
				sl = 0;
				canOptimizeMatrix = true;
				if(CanvasGraphics.pendingMatrix != null) {
					if(CanvasGraphics.pendingMatrix.b != 0 || CanvasGraphics.pendingMatrix.c != 0) {
						canOptimizeMatrix = false;
					} else {
						if(stl == null) {
							stl = (openfl_geom_Point().default).__pool.get();
						}
						if(sbr == null) {
							sbr = (openfl_geom_Point().default).__pool.get();
						}
						stl.setTo(c9.float(0),c9.float(1));
						CanvasGraphics.inversePendingMatrix.__transformPoint(stl);
						sbr.setTo(c9.float(0) + c9.float(2),c9.float(1) + c9.float(3));
						CanvasGraphics.inversePendingMatrix.__transformPoint(sbr);
						st = stl.y;
						sl = stl.x;
						sb = sbr.y;
						sr = sbr.x;
					}
				} else {
					st = c9.float(1);
					sl = c9.float(0);
					sb = c9.float(1) + c9.float(3);
					sr = c9.float(0) + c9.float(2);
				}
				if(canOptimizeMatrix && st >= 0 && sl >= 0 && sr <= CanvasGraphics.bitmapFill.width && sb <= CanvasGraphics.bitmapFill.height) {
					optimizationUsed = true;
					if(!CanvasGraphics.hitTesting) {
						CanvasGraphics.context.drawImage(CanvasGraphics.bitmapFill.image.get_src(),sl,st,sr - sl,sb - st,c9.float(0) - offsetX,c9.float(1) - offsetY,c9.float(2),c9.float(3));
					}
				}
			}
			if(!optimizationUsed) {
				hasPath = true;
				CanvasGraphics.context.rect(c9.float(0) - offsetX,c9.float(1) - offsetY,c9.float(2),c9.float(3));
			}
			break;
		case 10:
			var c10 = data.readDrawRoundRect();
			hasPath = true;
			CanvasGraphics.drawRoundRect(c10.float(0) - offsetX,c10.float(1) - offsetY,c10.float(2),c10.float(3),c10.float(4),c10.obj(0));
			break;
		case 12:
			var c11 = data.readDrawTriangles();
			var v = c11.obj(0);
			var ind = c11.obj(1);
			var uvt = c11.obj(2);
			var pattern = null;
			var colorFill = CanvasGraphics.bitmapFill == null;
			if(colorFill && uvt != null) {
				break _hx_loop1;
			}
			if(!colorFill) {
				if(uvt == null) {
					uvt = (openfl__$Vector_Vector_$Impl_$().default)._new();
					var _g3 = 0;
					var _g12 = (Std().default).int(v.get_length() / 2);
					while(_g3 < _g12) {
						var i1 = _g3++;
						(openfl__$Vector_Vector_$Impl_$().default).push(uvt,v[i1 * 2] - offsetX / CanvasGraphics.bitmapFill.width);
						(openfl__$Vector_Vector_$Impl_$().default).push(uvt,v[i1 * 2 + 1] - offsetY / CanvasGraphics.bitmapFill.height);
					}
				}
				var skipT = uvt.get_length() != v.get_length();
				var normalizedUVT = CanvasGraphics.normalizeUVT(uvt,skipT);
				var maxUVT = normalizedUVT.max;
				uvt = normalizedUVT.uvt;
				if(maxUVT > 1) {
					pattern = CanvasGraphics.createTempPatternCanvas(CanvasGraphics.bitmapFill,CanvasGraphics.bitmapRepeat,(Std().default).int(CanvasGraphics.bounds.width),(Std().default).int(CanvasGraphics.bounds.height));
				} else {
					pattern = CanvasGraphics.createTempPatternCanvas(CanvasGraphics.bitmapFill,CanvasGraphics.bitmapRepeat,CanvasGraphics.bitmapFill.width,CanvasGraphics.bitmapFill.height);
				}
			}
			var i2 = 0;
			var l = ind.get_length();
			var a_;
			var b_;
			var c_;
			var iax;
			var iay;
			var ibx;
			var iby;
			var icx;
			var icy;
			var x1;
			var y1;
			var x2;
			var y2;
			var x3;
			var y3;
			var uvx1;
			var uvy1;
			var uvx2;
			var uvy2;
			var uvx3;
			var uvy3;
			var denom;
			var t1;
			var t2;
			var t3;
			var t4;
			var dx;
			var dy;
			while(i2 < l) {
				a_ = i2;
				b_ = i2 + 1;
				c_ = i2 + 2;
				iax = ind[a_] * 2;
				iay = ind[a_] * 2 + 1;
				ibx = ind[b_] * 2;
				iby = ind[b_] * 2 + 1;
				icx = ind[c_] * 2;
				icy = ind[c_] * 2 + 1;
				x1 = v[iax] - offsetX;
				y1 = v[iay] - offsetY;
				x2 = v[ibx] - offsetX;
				y2 = v[iby] - offsetY;
				x3 = v[icx] - offsetX;
				y3 = v[icy] - offsetY;
				switch(c11.obj(3)) {
				case "negative":
					if(CanvasGraphics.isCCW(x1,y1,x2,y2,x3,y3)) {
						i2 += 3;
						continue;
					}
					break;
				case "positive":
					if(!CanvasGraphics.isCCW(x1,y1,x2,y2,x3,y3)) {
						i2 += 3;
						continue;
					}
					break;
				default:
				}
				if(colorFill) {
					CanvasGraphics.context.beginPath();
					CanvasGraphics.context.moveTo(x1,y1);
					CanvasGraphics.context.lineTo(x2,y2);
					CanvasGraphics.context.lineTo(x3,y3);
					CanvasGraphics.context.closePath();
					if(!CanvasGraphics.hitTesting) {
						CanvasGraphics.context.fill(CanvasGraphics.windingRule);
					}
					i2 += 3;
					continue;
				}
				uvx1 = uvt[iax] * pattern.width;
				uvx2 = uvt[ibx] * pattern.width;
				uvx3 = uvt[icx] * pattern.width;
				uvy1 = uvt[iay] * pattern.height;
				uvy2 = uvt[iby] * pattern.height;
				uvy3 = uvt[icy] * pattern.height;
				denom = uvx1 * (uvy3 - uvy2) - uvx2 * uvy3 + uvx3 * uvy2 + (uvx2 - uvx3) * uvy1;
				if(denom == 0) {
					i2 += 3;
					CanvasGraphics.context.restore();
					continue;
				}
				CanvasGraphics.context.save();
				CanvasGraphics.context.beginPath();
				CanvasGraphics.context.moveTo(x1,y1);
				CanvasGraphics.context.lineTo(x2,y2);
				CanvasGraphics.context.lineTo(x3,y3);
				CanvasGraphics.context.closePath();
				CanvasGraphics.context.clip();
				t1 = -(uvy1 * (x3 - x2) - uvy2 * x3 + uvy3 * x2 + (uvy2 - uvy3) * x1) / denom;
				t2 = (uvy2 * y3 + uvy1 * (y2 - y3) - uvy3 * y2 + (uvy3 - uvy2) * y1) / denom;
				t3 = (uvx1 * (x3 - x2) - uvx2 * x3 + uvx3 * x2 + (uvx2 - uvx3) * x1) / denom;
				t4 = -(uvx2 * y3 + uvx1 * (y2 - y3) - uvx3 * y2 + (uvx3 - uvx2) * y1) / denom;
				dx = (uvx1 * (uvy3 * x2 - uvy2 * x3) + uvy1 * (uvx2 * x3 - uvx3 * x2) + (uvx3 * uvy2 - uvx2 * uvy3) * x1) / denom;
				dy = (uvx1 * (uvy3 * y2 - uvy2 * y3) + uvy1 * (uvx2 * y3 - uvx3 * y2) + (uvx3 * uvy2 - uvx2 * uvy3) * y1) / denom;
				CanvasGraphics.context.transform(t1,t2,t3,t4,dx,dy);
				CanvasGraphics.context.drawImage(pattern,0,0,pattern.width,pattern.height);
				CanvasGraphics.context.restore();
				i2 += 3;
			}
			break;
		case 14:
			var c12 = data.readLineBitmapStyle();
			if(stroke && CanvasGraphics.hasStroke) {
				CanvasGraphics.closePath();
			}
			CanvasGraphics.context.moveTo(positionX - offsetX,positionY - offsetY);
			var tmp12 = c12.obj(0);
			var tmp13 = c12.bool(0);
			CanvasGraphics.context.strokeStyle = CanvasGraphics.createBitmapFill(tmp12,tmp13,c12.bool(1));
			CanvasGraphics.hasStroke = true;
			break;
		case 15:
			var c13 = data.readLineGradientStyle();
			if(stroke && CanvasGraphics.hasStroke) {
				CanvasGraphics.closePath();
			}
			CanvasGraphics.context.moveTo(positionX - offsetX,positionY - offsetY);
			var tmp14 = c13.obj(0);
			var tmp15 = c13.iArr(0);
			var tmp16 = c13.fArr(0);
			var tmp17 = c13.iArr(1);
			var tmp18 = c13.obj(1);
			var tmp19 = c13.obj(2);
			var tmp20 = c13.obj(3);
			CanvasGraphics.context.strokeStyle = CanvasGraphics.createGradientPattern(tmp14,tmp15,tmp16,tmp17,tmp18,tmp19,tmp20,c13.float(0));
			CanvasGraphics.setSmoothing(true);
			CanvasGraphics.hasStroke = true;
			break;
		case 16:
			var c14 = data.readLineStyle();
			if(stroke && CanvasGraphics.hasStroke) {
				CanvasGraphics.closePath(true);
			}
			CanvasGraphics.context.moveTo(positionX - offsetX,positionY - offsetY);
			if(c14.obj(0) == null) {
				CanvasGraphics.hasStroke = false;
			} else {
				var tmp21 = c14.obj(0) > 0 ? c14.obj(0) : 1;
				CanvasGraphics.context.lineWidth = tmp21;
				var tmp22 = c14.obj(3) == null ? "round" : (Std().default).string(c14.obj(3)).toLowerCase();
				CanvasGraphics.context.lineJoin = tmp22;
				var tmp23 = c14.obj(2) == null ? "round" : c14.obj(2) == "none" ? "butt" : (Std().default).string(c14.obj(2)).toLowerCase();
				CanvasGraphics.context.lineCap = tmp23;
				CanvasGraphics.context.miterLimit = c14.float(1);
				if(c14.float(0) == 1) {
					var tmp24 = (StringTools().default).hex(c14.int(0) & 16777215,6);
					CanvasGraphics.context.strokeStyle = "#" + tmp24;
				} else {
					r = (c14.int(0) & 16711680) >>> 16;
					g = (c14.int(0) & 65280) >>> 8;
					b = c14.int(0) & 255;
					var tmp25 = "rgba(" + r + ", " + g + ", " + b + ", " + c14.float(0);
					CanvasGraphics.context.strokeStyle = tmp25 + ")";
				}
				CanvasGraphics.setSmoothing(true);
				CanvasGraphics.hasStroke = true;
			}
			break;
		case 17:
			var c15 = data.readLineTo();
			hasPath = true;
			CanvasGraphics.context.lineTo(c15.float(0) - offsetX,c15.float(1) - offsetY);
			positionX = c15.float(0);
			positionY = c15.float(1);
			if(positionX == startX && positionY == startY) {
				closeGap = true;
			}
			break;
		case 18:
			var c16 = data.readMoveTo();
			CanvasGraphics.context.moveTo(c16.float(0) - offsetX,c16.float(1) - offsetY);
			positionX = c16.float(0);
			positionY = c16.float(1);
			if(setStart) {
				closeGap = true;
			}
			startX = c16.float(0);
			startY = c16.float(1);
			setStart = true;
			break;
		case 21:
			CanvasGraphics.windingRule = "evenodd";
			break;
		case 22:
			CanvasGraphics.windingRule = "nonzero";
			break;
		default:
			data.skip(type);
		}
	}
	if(stl != null) {
		(openfl_geom_Point().default).__pool.release(stl);
	}
	if(sbr != null) {
		(openfl_geom_Point().default).__pool.release(sbr);
	}
	data.destroy();
	if(hasPath) {
		if(stroke && CanvasGraphics.hasStroke) {
			if(CanvasGraphics.hasFill && closeGap) {
				CanvasGraphics.context.lineTo(startX - offsetX,startY - offsetY);
				CanvasGraphics.closePath(false);
			} else if(closeGap && positionX == startX && positionY == startY) {
				CanvasGraphics.closePath(false);
			}
			if(!CanvasGraphics.hitTesting) {
				CanvasGraphics.context.stroke();
			}
		}
		if(!stroke) {
			if(CanvasGraphics.hasFill || CanvasGraphics.bitmapFill != null) {
				CanvasGraphics.context.translate(-CanvasGraphics.bounds.x,-CanvasGraphics.bounds.y);
				if(CanvasGraphics.pendingMatrix != null) {
					CanvasGraphics.context.transform(CanvasGraphics.pendingMatrix.a,CanvasGraphics.pendingMatrix.b,CanvasGraphics.pendingMatrix.c,CanvasGraphics.pendingMatrix.d,CanvasGraphics.pendingMatrix.tx,CanvasGraphics.pendingMatrix.ty);
					if(!CanvasGraphics.hitTesting) {
						CanvasGraphics.context.fill(CanvasGraphics.windingRule);
					}
					CanvasGraphics.context.transform(CanvasGraphics.inversePendingMatrix.a,CanvasGraphics.inversePendingMatrix.b,CanvasGraphics.inversePendingMatrix.c,CanvasGraphics.inversePendingMatrix.d,CanvasGraphics.inversePendingMatrix.tx,CanvasGraphics.inversePendingMatrix.ty);
				} else if(!CanvasGraphics.hitTesting) {
					CanvasGraphics.context.fill(CanvasGraphics.windingRule);
				}
				CanvasGraphics.context.translate(CanvasGraphics.bounds.x,CanvasGraphics.bounds.y);
				CanvasGraphics.context.closePath();
			}
		}
	}
}
CanvasGraphics.render = function(graphics,renderer) {
	graphics.__update(renderer.__worldTransform);
	if(graphics.__softwareDirty) {
		CanvasGraphics.hitTesting = false;
		CanvasGraphics.graphics = graphics;
		CanvasGraphics.allowSmoothing = renderer.__allowSmoothing;
		CanvasGraphics.worldAlpha = renderer.__getAlpha(graphics.__owner.__worldAlpha);
		CanvasGraphics.bounds = graphics.__bounds;
		var width = graphics.__width;
		var height = graphics.__height;
		if(!graphics.__visible || graphics.__commands.get_length() == 0 || CanvasGraphics.bounds == null || width < 1 || height < 1) {
			graphics.__canvas = null;
			graphics.__context = null;
			graphics.__bitmap = null;
		} else {
			if(graphics.__canvas == null) {
				graphics.__canvas = window.document.createElement("canvas");
				graphics.__context = graphics.__canvas.getContext("2d");
			}
			CanvasGraphics.context = graphics.__context;
			var transform = graphics.__renderTransform;
			var canvas = graphics.__canvas;
			var scale = renderer.pixelRatio;
			var scaledWidth = (Std().default).int(width * scale);
			var scaledHeight = (Std().default).int(height * scale);
			renderer.__setBlendModeContext(CanvasGraphics.context,"normal");
			if(renderer.__isDOM) {
				if(canvas.width == scaledWidth && canvas.height == scaledHeight) {
					CanvasGraphics.context.clearRect(0,0,scaledWidth,scaledHeight);
				} else {
					canvas.width = scaledWidth;
					canvas.height = scaledHeight;
					canvas.style.width = width + "px";
					canvas.style.height = height + "px";
				}
				var transform1 = graphics.__renderTransform;
				CanvasGraphics.context.setTransform(transform1.a * scale,transform1.b * scale,transform1.c * scale,transform1.d * scale,transform1.tx * scale,transform1.ty * scale);
			} else {
				if(canvas.width == scaledWidth && canvas.height == scaledHeight) {
					CanvasGraphics.context.closePath();
					CanvasGraphics.context.setTransform(1,0,0,1,0,0);
					CanvasGraphics.context.clearRect(0,0,scaledWidth,scaledHeight);
				} else {
					canvas.width = width;
					canvas.height = height;
				}
				CanvasGraphics.context.setTransform(transform.a,transform.b,transform.c,transform.d,transform.tx,transform.ty);
			}
			CanvasGraphics.fillCommands.clear();
			CanvasGraphics.strokeCommands.clear();
			CanvasGraphics.hasFill = false;
			CanvasGraphics.hasStroke = false;
			CanvasGraphics.bitmapFill = null;
			CanvasGraphics.bitmapRepeat = false;
			var hasLineStyle = false;
			var initStrokeX = 0.0;
			var initStrokeY = 0.0;
			CanvasGraphics.windingRule = "evenodd";
			var data = new (openfl__$internal_renderer_DrawCommandReader().default)(graphics.__commands);
			var _g = 0;
			var _g1 = graphics.__commands.types;
			while(_g < _g1.length) {
				var type = _g1[_g];
				++_g;
				switch(type._hx_index) {
				case 0:case 1:case 2:case 3:
					CanvasGraphics.endFill();
					CanvasGraphics.endStroke();
					if(type == (openfl__$internal_renderer_DrawCommandType().default).BEGIN_BITMAP_FILL) {
						var c = data.readBeginBitmapFill();
						CanvasGraphics.fillCommands.beginBitmapFill(c.obj(0),c.obj(1),c.bool(0),c.bool(1));
						CanvasGraphics.strokeCommands.beginBitmapFill(c.obj(0),c.obj(1),c.bool(0),c.bool(1));
					} else if(type == (openfl__$internal_renderer_DrawCommandType().default).BEGIN_GRADIENT_FILL) {
						var c1 = data.readBeginGradientFill();
						CanvasGraphics.fillCommands.beginGradientFill(c1.obj(0),c1.iArr(0),c1.fArr(0),c1.iArr(1),c1.obj(1),c1.obj(2),c1.obj(3),c1.float(0));
						CanvasGraphics.strokeCommands.beginGradientFill(c1.obj(0),c1.iArr(0),c1.fArr(0),c1.iArr(1),c1.obj(1),c1.obj(2),c1.obj(3),c1.float(0));
					} else if(type == (openfl__$internal_renderer_DrawCommandType().default).BEGIN_SHADER_FILL) {
						var c2 = data.readBeginShaderFill();
						CanvasGraphics.fillCommands.beginShaderFill(c2.obj(0));
						CanvasGraphics.strokeCommands.beginShaderFill(c2.obj(0));
					} else {
						var c3 = data.readBeginFill();
						CanvasGraphics.fillCommands.beginFill(c3.int(0),c3.float(0));
						CanvasGraphics.strokeCommands.beginFill(c3.int(0),c3.float(0));
					}
					break;
				case 4:
					var c4 = data.readCubicCurveTo();
					CanvasGraphics.fillCommands.cubicCurveTo(c4.float(0),c4.float(1),c4.float(2),c4.float(3),c4.float(4),c4.float(5));
					if(hasLineStyle) {
						CanvasGraphics.strokeCommands.cubicCurveTo(c4.float(0),c4.float(1),c4.float(2),c4.float(3),c4.float(4),c4.float(5));
					} else {
						initStrokeX = c4.float(4);
						initStrokeY = c4.float(5);
					}
					break;
				case 5:
					var c5 = data.readCurveTo();
					CanvasGraphics.fillCommands.curveTo(c5.float(0),c5.float(1),c5.float(2),c5.float(3));
					if(hasLineStyle) {
						CanvasGraphics.strokeCommands.curveTo(c5.float(0),c5.float(1),c5.float(2),c5.float(3));
					} else {
						initStrokeX = c5.float(2);
						initStrokeY = c5.float(3);
					}
					break;
				case 6:
					var c6 = data.readDrawCircle();
					CanvasGraphics.fillCommands.drawCircle(c6.float(0),c6.float(1),c6.float(2));
					if(hasLineStyle) {
						CanvasGraphics.strokeCommands.drawCircle(c6.float(0),c6.float(1),c6.float(2));
					}
					break;
				case 7:
					var c7 = data.readDrawEllipse();
					CanvasGraphics.fillCommands.drawEllipse(c7.float(0),c7.float(1),c7.float(2),c7.float(3));
					if(hasLineStyle) {
						CanvasGraphics.strokeCommands.drawEllipse(c7.float(0),c7.float(1),c7.float(2),c7.float(3));
					}
					break;
				case 8:
					var c8 = data.readDrawQuads();
					CanvasGraphics.fillCommands.drawQuads(c8.obj(0),c8.obj(1),c8.obj(2));
					break;
				case 9:
					var c9 = data.readDrawRect();
					CanvasGraphics.fillCommands.drawRect(c9.float(0),c9.float(1),c9.float(2),c9.float(3));
					if(hasLineStyle) {
						CanvasGraphics.strokeCommands.drawRect(c9.float(0),c9.float(1),c9.float(2),c9.float(3));
					}
					break;
				case 10:
					var c10 = data.readDrawRoundRect();
					CanvasGraphics.fillCommands.drawRoundRect(c10.float(0),c10.float(1),c10.float(2),c10.float(3),c10.float(4),c10.obj(0));
					if(hasLineStyle) {
						CanvasGraphics.strokeCommands.drawRoundRect(c10.float(0),c10.float(1),c10.float(2),c10.float(3),c10.float(4),c10.obj(0));
					}
					break;
				case 12:
					var c11 = data.readDrawTriangles();
					CanvasGraphics.fillCommands.drawTriangles(c11.obj(0),c11.obj(1),c11.obj(2),c11.obj(3));
					break;
				case 13:
					data.readEndFill();
					CanvasGraphics.endFill();
					CanvasGraphics.endStroke();
					CanvasGraphics.hasFill = false;
					hasLineStyle = false;
					CanvasGraphics.bitmapFill = null;
					initStrokeX = 0;
					initStrokeY = 0;
					break;
				case 14:
					var c12 = data.readLineBitmapStyle();
					if(!hasLineStyle && (initStrokeX != 0 || initStrokeY != 0)) {
						CanvasGraphics.strokeCommands.moveTo(initStrokeX,initStrokeY);
						initStrokeX = 0;
						initStrokeY = 0;
					}
					hasLineStyle = true;
					CanvasGraphics.strokeCommands.lineBitmapStyle(c12.obj(0),c12.obj(1),c12.bool(0),c12.bool(1));
					break;
				case 15:
					var c13 = data.readLineGradientStyle();
					if(!hasLineStyle && (initStrokeX != 0 || initStrokeY != 0)) {
						CanvasGraphics.strokeCommands.moveTo(initStrokeX,initStrokeY);
						initStrokeX = 0;
						initStrokeY = 0;
					}
					hasLineStyle = true;
					CanvasGraphics.strokeCommands.lineGradientStyle(c13.obj(0),c13.iArr(0),c13.fArr(0),c13.iArr(1),c13.obj(1),c13.obj(2),c13.obj(3),c13.float(0));
					break;
				case 16:
					var c14 = data.readLineStyle();
					if(!hasLineStyle && c14.obj(0) != null) {
						if(initStrokeX != 0 || initStrokeY != 0) {
							CanvasGraphics.strokeCommands.moveTo(initStrokeX,initStrokeY);
							initStrokeX = 0;
							initStrokeY = 0;
						}
					}
					hasLineStyle = c14.obj(0) != null;
					CanvasGraphics.strokeCommands.lineStyle(c14.obj(0),c14.int(0),c14.float(0),c14.bool(0),c14.obj(1),c14.obj(2),c14.obj(3),c14.float(1));
					break;
				case 17:
					var c15 = data.readLineTo();
					CanvasGraphics.fillCommands.lineTo(c15.float(0),c15.float(1));
					if(hasLineStyle) {
						CanvasGraphics.strokeCommands.lineTo(c15.float(0),c15.float(1));
					} else {
						initStrokeX = c15.float(0);
						initStrokeY = c15.float(1);
					}
					break;
				case 18:
					var c16 = data.readMoveTo();
					CanvasGraphics.fillCommands.moveTo(c16.float(0),c16.float(1));
					if(hasLineStyle) {
						CanvasGraphics.strokeCommands.moveTo(c16.float(0),c16.float(1));
					} else {
						initStrokeX = c16.float(0);
						initStrokeY = c16.float(1);
					}
					break;
				case 19:
					var c17 = data.readOverrideBlendMode();
					renderer.__setBlendModeContext(CanvasGraphics.context,c17.obj(0));
					break;
				case 21:
					data.readWindingEvenOdd();
					CanvasGraphics.fillCommands.windingEvenOdd();
					CanvasGraphics.windingRule = "evenodd";
					break;
				case 22:
					data.readWindingNonZero();
					CanvasGraphics.fillCommands.windingNonZero();
					CanvasGraphics.windingRule = "nonzero";
					break;
				default:
					data.skip(type);
				}
			}
			if(CanvasGraphics.fillCommands.get_length() > 0) {
				CanvasGraphics.endFill();
			}
			if(CanvasGraphics.strokeCommands.get_length() > 0) {
				CanvasGraphics.endStroke();
			}
			data.destroy();
			graphics.__bitmap = (openfl_display_BitmapData().default).fromCanvas(graphics.__canvas);
		}
		graphics.__softwareDirty = false;
		graphics.set___dirty(false);
	}
}
CanvasGraphics.renderMask = function(graphics,renderer) {
	if(graphics.__commands.get_length() != 0) {
		CanvasGraphics.context = renderer.context;
		var positionX = 0.0;
		var positionY = 0.0;
		var offsetX = 0;
		var offsetY = 0;
		var data = new (openfl__$internal_renderer_DrawCommandReader().default)(graphics.__commands);
		var x;
		var y;
		var width;
		var height;
		var kappa = .5522848;
		var ox;
		var oy;
		var xe;
		var ye;
		var xm;
		var ym;
		var _g = 0;
		var _g1 = graphics.__commands.types;
		while(_g < _g1.length) {
			var type = _g1[_g];
			++_g;
			switch(type._hx_index) {
			case 4:
				var c = data.readCubicCurveTo();
				CanvasGraphics.context.bezierCurveTo(c.float(0) - offsetX,c.float(1) - offsetY,c.float(2) - offsetX,c.float(3) - offsetY,c.float(4) - offsetX,c.float(5) - offsetY);
				positionX = c.float(4);
				positionY = c.float(5);
				break;
			case 5:
				var c1 = data.readCurveTo();
				CanvasGraphics.context.quadraticCurveTo(c1.float(0) - offsetX,c1.float(1) - offsetY,c1.float(2) - offsetX,c1.float(3) - offsetY);
				positionX = c1.float(2);
				positionY = c1.float(3);
				break;
			case 6:
				var c2 = data.readDrawCircle();
				CanvasGraphics.context.arc(c2.float(0) - offsetX,c2.float(1) - offsetY,c2.float(2),0,Math.PI * 2,true);
				break;
			case 7:
				var c3 = data.readDrawEllipse();
				x = c3.float(0);
				y = c3.float(1);
				width = c3.float(2);
				height = c3.float(3);
				x -= offsetX;
				y -= offsetY;
				ox = width / 2 * kappa;
				oy = height / 2 * kappa;
				xe = x + width;
				ye = y + height;
				xm = x + width / 2;
				ym = y + height / 2;
				CanvasGraphics.context.moveTo(x,ym);
				CanvasGraphics.context.bezierCurveTo(x,ym - oy,xm - ox,y,xm,y);
				CanvasGraphics.context.bezierCurveTo(xm + ox,y,xe,ym - oy,xe,ym);
				CanvasGraphics.context.bezierCurveTo(xe,ym + oy,xm + ox,ye,xm,ye);
				CanvasGraphics.context.bezierCurveTo(xm - ox,ye,x,ym + oy,x,ym);
				break;
			case 9:
				var c4 = data.readDrawRect();
				CanvasGraphics.context.beginPath();
				CanvasGraphics.context.rect(c4.float(0) - offsetX,c4.float(1) - offsetY,c4.float(2),c4.float(3));
				CanvasGraphics.context.closePath();
				break;
			case 10:
				var c5 = data.readDrawRoundRect();
				CanvasGraphics.drawRoundRect(c5.float(0) - offsetX,c5.float(1) - offsetY,c5.float(2),c5.float(3),c5.float(4),c5.obj(0));
				break;
			case 17:
				var c6 = data.readLineTo();
				CanvasGraphics.context.lineTo(c6.float(0) - offsetX,c6.float(1) - offsetY);
				positionX = c6.float(0);
				positionY = c6.float(1);
				break;
			case 18:
				var c7 = data.readMoveTo();
				CanvasGraphics.context.moveTo(c7.float(0) - offsetX,c7.float(1) - offsetY);
				positionX = c7.float(0);
				positionY = c7.float(1);
				break;
			default:
				data.skip(type);
			}
		}
		data.destroy();
	}
}
CanvasGraphics.setSmoothing = function(smooth) {
	if(!CanvasGraphics.allowSmoothing) {
		smooth = false;
	}
	if(CanvasGraphics.context.imageSmoothingEnabled != smooth) {
		CanvasGraphics.context.imageSmoothingEnabled = smooth;
	}
}
CanvasGraphics.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, statics : { windingRule : { SuppressWarnings : ["checkstyle:Dynamic"]}, createBitmapFill : { SuppressWarnings : ["checkstyle:Dynamic"]}, createGradientPattern : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
CanvasGraphics.SIN45 = 0.70710678118654752440084436210485
CanvasGraphics.TAN22 = 0.4142135623730950488016887242097
CanvasGraphics.fillCommands = new (openfl__$internal_renderer_DrawCommandBuffer().default)()
CanvasGraphics.strokeCommands = new (openfl__$internal_renderer_DrawCommandBuffer().default)()

// Export

exports.default = CanvasGraphics;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasShape.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasShape.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.canvas.CanvasShape

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_canvas_CanvasGraphics() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/canvas/CanvasGraphics */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasGraphics.js");}

// Constructor

var CanvasShape = function(){}

// Meta

CanvasShape.__name__ = "openfl._internal.renderer.canvas.CanvasShape";
CanvasShape.__isInterface__ = false;
CanvasShape.prototype = {
	
};
CanvasShape.prototype.__class__ = CanvasShape.prototype.constructor = $hxClasses["openfl._internal.renderer.canvas.CanvasShape"] = CanvasShape;

// Init



// Statics

CanvasShape.render = function(shape,renderer) {
	if(!shape.__renderable) {
		return;
	}
	var alpha = renderer.__getAlpha(shape.__worldAlpha);
	if(alpha <= 0) {
		return;
	}
	var graphics = shape.__graphics;
	if(graphics != null) {
		(openfl__$internal_renderer_canvas_CanvasGraphics().default).render(graphics,renderer);
		var width = graphics.__width;
		var height = graphics.__height;
		var canvas = graphics.__canvas;
		if(canvas != null && graphics.__visible && width >= 1 && height >= 1) {
			var transform = graphics.__worldTransform;
			var context = renderer.context;
			var scrollRect = shape.__scrollRect;
			var scale9Grid = shape.__worldScale9Grid;
			if(scrollRect == null || scrollRect.width > 0 && scrollRect.height > 0) {
				renderer.__setBlendMode(shape.__worldBlendMode);
				renderer.__pushMaskObject(shape);
				context.globalAlpha = alpha;
				if(scale9Grid != null && transform.b == 0 && transform.c == 0) {
					context.setTransform(1,0,0,1,transform.tx,transform.ty);
					var bounds = graphics.__bounds;
					var scaleX = graphics.__renderTransform.a;
					var scaleY = graphics.__renderTransform.d;
					var renderScaleX = transform.a;
					var renderScaleY = transform.d;
					var left = Math.max(1,Math.round(scale9Grid.x * scaleX));
					var top = Math.round(scale9Grid.y * scaleY);
					var right = Math.max(1,Math.round((bounds.get_right() - scale9Grid.get_right()) * scaleX));
					var bottom = Math.round((bounds.get_bottom() - scale9Grid.get_bottom()) * scaleY);
					var centerWidth = Math.round(scale9Grid.width * scaleX);
					var centerHeight = Math.round(scale9Grid.height * scaleY);
					var renderLeft = Math.round(scale9Grid.x * renderScaleX);
					var renderTop = Math.round(scale9Grid.y * renderScaleY);
					var renderRight = Math.round((bounds.get_right() - scale9Grid.get_right()) * renderScaleX);
					var renderBottom = Math.round((bounds.get_bottom() - scale9Grid.get_bottom()) * renderScaleY);
					var renderCenterWidth = Math.round(width * renderScaleX) - renderLeft - renderRight;
					var renderCenterHeight = Math.round(height * renderScaleY) - renderTop - renderBottom;
					renderer.applySmoothing(context,false);
					if(centerWidth != 0 && centerHeight != 0) {
						context.drawImage(canvas,0,0,left,top,0,0,renderLeft,renderTop);
						context.drawImage(canvas,left,0,centerWidth,top,renderLeft,0,renderCenterWidth,renderTop);
						context.drawImage(canvas,left + centerWidth,0,right,top,renderLeft + renderCenterWidth,0,renderRight,renderTop);
						context.drawImage(canvas,0,top,left,centerHeight,0,renderTop,renderLeft,renderCenterHeight);
						context.drawImage(canvas,left,top,centerWidth,centerHeight,renderLeft,renderTop,renderCenterWidth,renderCenterHeight);
						context.drawImage(canvas,left + centerWidth,top,right,centerHeight,renderLeft + renderCenterWidth,renderTop,renderRight,renderCenterHeight);
						context.drawImage(canvas,0,top + centerHeight,left,bottom,0,renderTop + renderCenterHeight,renderLeft,renderBottom);
						context.drawImage(canvas,left,top + centerHeight,centerWidth,bottom,renderLeft,renderTop + renderCenterHeight,renderCenterWidth,renderBottom);
						context.drawImage(canvas,left + centerWidth,top + centerHeight,right,bottom,renderLeft + renderCenterWidth,renderTop + renderCenterHeight,renderRight,renderBottom);
					} else if(centerWidth == 0 && centerHeight != 0) {
						var renderWidth = renderLeft + renderCenterWidth + renderRight;
						context.drawImage(canvas,0,0,width,top,0,0,renderWidth,renderTop);
						context.drawImage(canvas,0,top,width,centerHeight,0,renderTop,renderWidth,renderCenterHeight);
						context.drawImage(canvas,0,top + centerHeight,width,bottom,0,renderTop + renderCenterHeight,renderWidth,renderBottom);
					} else if(centerHeight == 0 && centerWidth != 0) {
						var renderHeight = renderTop + renderCenterHeight + renderBottom;
						context.drawImage(canvas,0,0,left,height,0,0,renderLeft,renderHeight);
						context.drawImage(canvas,left,0,centerWidth,height,renderLeft,0,renderCenterWidth,renderHeight);
						context.drawImage(canvas,left + centerWidth,0,right,height,renderLeft + renderCenterWidth,0,renderRight,renderHeight);
					}
				} else {
					renderer.setTransform(transform,context);
					if(renderer.__isDOM) {
						var reverseScale = 1 / renderer.pixelRatio;
						context.scale(reverseScale,reverseScale);
					}
					context.drawImage(canvas,0,0,width,height);
				}
				renderer.__popMaskObject(shape);
			}
		}
	}
}
CanvasShape.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = CanvasShape;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DBitmap.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DBitmap.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.context3D.Context3DBitmap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_context3D_Context3DMaskShader() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/context3D/Context3DMaskShader */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DMaskShader.js");}

// Constructor

var Context3DBitmap = function(){}

// Meta

Context3DBitmap.__name__ = "openfl._internal.renderer.context3D.Context3DBitmap";
Context3DBitmap.__isInterface__ = false;
Context3DBitmap.prototype = {
	
};
Context3DBitmap.prototype.__class__ = Context3DBitmap.prototype.constructor = $hxClasses["openfl._internal.renderer.context3D.Context3DBitmap"] = Context3DBitmap;

// Init



// Statics

Context3DBitmap.render = function(bitmap,renderer) {
	if(!bitmap.__renderable || bitmap.__worldAlpha <= 0) {
		return;
	}
	if(bitmap.__bitmapData != null && bitmap.__bitmapData.__isValid) {
		var context = renderer.__context3D;
		renderer.__setBlendMode(bitmap.__worldBlendMode);
		renderer.__pushMaskObject(bitmap);
		var shader = renderer.__initDisplayShader(bitmap.__worldShader);
		renderer.setShader(shader);
		renderer.applyBitmapData(bitmap.__bitmapData,renderer.__allowSmoothing && (bitmap.smoothing || renderer.__upscaled));
		renderer.applyMatrix(renderer.__getMatrix(bitmap.__renderTransform,bitmap.pixelSnapping));
		renderer.applyAlpha(bitmap.__worldAlpha);
		renderer.applyColorTransform(bitmap.__worldColorTransform);
		renderer.updateShader();
		var vertexBuffer = bitmap.__bitmapData.getVertexBuffer(context);
		if(shader.__position != null) {
			context.setVertexBufferAt(shader.__position.index,vertexBuffer,0,"float3");
		}
		if(shader.__textureCoord != null) {
			context.setVertexBufferAt(shader.__textureCoord.index,vertexBuffer,3,"float2");
		}
		var indexBuffer = bitmap.__bitmapData.getIndexBuffer(context);
		context.drawTriangles(indexBuffer);
		renderer.__clearShader();
		renderer.__popMaskObject(bitmap);
	}
}
Context3DBitmap.renderMask = function(bitmap,renderer) {
	if(bitmap.__bitmapData != null && bitmap.__bitmapData.__isValid) {
		var context = renderer.__context3D;
		var shader = renderer.__maskShader;
		renderer.setShader(shader);
		renderer.applyBitmapData((openfl__$internal_renderer_context3D_Context3DMaskShader().default).opaqueBitmapData,true);
		renderer.applyMatrix(renderer.__getMatrix(bitmap.__renderTransform,bitmap.pixelSnapping));
		renderer.updateShader();
		var vertexBuffer = bitmap.__bitmapData.getVertexBuffer(context);
		if(shader.__position != null) {
			context.setVertexBufferAt(shader.__position.index,vertexBuffer,0,"float3");
		}
		if(shader.__textureCoord != null) {
			context.setVertexBufferAt(shader.__textureCoord.index,vertexBuffer,3,"float2");
		}
		var indexBuffer = bitmap.__bitmapData.getIndexBuffer(context);
		context.drawTriangles(indexBuffer);
		renderer.__clearShader();
	}
}
Context3DBitmap.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Context3DBitmap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DBuffer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DBuffer.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.context3D.Context3DBuffer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Context3DBuffer = function(context3D,elementType,elementCount,dataPerVertex) {
	this.context3D = context3D;
	this.elementType = elementType;
	this.dataPerVertex = dataPerVertex;
	this.indexCount = 0;
	this.vertexCount = 0;
	this.resize(elementCount);
}

// Meta

Context3DBuffer.__name__ = "openfl._internal.renderer.context3D.Context3DBuffer";
Context3DBuffer.__isInterface__ = false;
Context3DBuffer.prototype = {
	drawElements: function(start,length) {
		if(length == null) {
			length = -1;
		}
		if(this.indexCount == 0 || this.vertexCount == 0) {
			return;
		}
		if(this.elementType._hx_index == 0) {
			if(length == -1) {
				length = this.elementCount * 2;
			}
			if(start < 10922 && length - start < 10922) {
				this.context3D.drawTriangles(this.indexBuffers[0],start,length * 2);
			} else {
				var end = start + length;
				while(start < end) {
					var arrayBufferIndex = Math.floor(start / 10922);
					length = (Std().default).int(Math.min(end - start,10922));
					if(length <= 0) {
						break;
					}
					this.context3D.drawTriangles(this.indexBuffers[arrayBufferIndex],(start - arrayBufferIndex * 10922) * 3,length * 2);
					start += length;
				}
			}
		}
	},
	flushVertexBufferData: function() {
		if(this.vertexBufferData.length > this.vertexCount) {
			this.vertexCount = this.vertexBufferData.length;
			this.vertexBuffer = this.context3D.createVertexBuffer(this.vertexCount,this.dataPerVertex,"dynamicDraw");
		}
		this.vertexBuffer.uploadFromTypedArray(this.vertexBufferData);
	},
	resize: function(elementCount,dataPerVertex) {
		if(dataPerVertex == null) {
			dataPerVertex = -1;
		}
		this.elementCount = elementCount;
		if(dataPerVertex == -1) {
			dataPerVertex = this.dataPerVertex;
		}
		if(dataPerVertex != this.dataPerVertex) {
			this.vertexBuffer = null;
			this.vertexCount = 0;
			this.dataPerVertex = dataPerVertex;
		}
		var numVertices = 0;
		switch(this.elementType._hx_index) {
		case 0:
			numVertices = elementCount * 4;
			break;
		case 1:
			numVertices = elementCount * 3;
			break;
		case 2:
			numVertices = elementCount * 3;
			break;
		}
		var vertexLength = numVertices * dataPerVertex;
		if(this.vertexBufferData == null) {
			var array = null;
			var view = null;
			var buffer = null;
			var len = null;
			var this1;
			if(vertexLength != null) {
				this1 = new Float32Array(vertexLength);
			} else if(array != null) {
				this1 = new Float32Array(array);
			} else if(view != null) {
				this1 = new Float32Array(view);
			} else if(buffer != null) {
				if(len == null) {
					this1 = new Float32Array(buffer,0);
				} else {
					this1 = new Float32Array(buffer,0,len);
				}
			} else {
				this1 = null;
			}
			this.vertexBufferData = this1;
		} else if(vertexLength > this.vertexBufferData.length) {
			var cacheBufferData = this.vertexBufferData;
			var array1 = null;
			var view1 = null;
			var buffer1 = null;
			var len1 = null;
			var this2;
			if(vertexLength != null) {
				this2 = new Float32Array(vertexLength);
			} else if(array1 != null) {
				this2 = new Float32Array(array1);
			} else if(view1 != null) {
				this2 = new Float32Array(view1);
			} else if(buffer1 != null) {
				if(len1 == null) {
					this2 = new Float32Array(buffer1,0);
				} else {
					this2 = new Float32Array(buffer1,0,len1);
				}
			} else {
				this2 = null;
			}
			this.vertexBufferData = this2;
			this.vertexBufferData.set(cacheBufferData);
		}
	}
};
Context3DBuffer.prototype.__class__ = Context3DBuffer.prototype.constructor = $hxClasses["openfl._internal.renderer.context3D.Context3DBuffer"] = Context3DBuffer;

// Init



// Statics


Context3DBuffer.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}
Context3DBuffer.MAX_INDEX_BUFFER_LENGTH = 65535
Context3DBuffer.MAX_QUADS_PER_INDEX_BUFFER = 10922
Context3DBuffer.MAX_QUAD_INDEX_BUFFER_LENGTH = 65532

// Export

exports.default = Context3DBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DDisplayObject.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DDisplayObject.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.context3D.Context3DDisplayObject

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function openfl__$internal_renderer_context3D_Context3DShape() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/context3D/Context3DShape */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DShape.js");}

// Constructor

var Context3DDisplayObject = function(){}

// Meta

Context3DDisplayObject.__name__ = "openfl._internal.renderer.context3D.Context3DDisplayObject";
Context3DDisplayObject.__isInterface__ = false;
Context3DDisplayObject.prototype = {
	
};
Context3DDisplayObject.prototype.__class__ = Context3DDisplayObject.prototype.constructor = $hxClasses["openfl._internal.renderer.context3D.Context3DDisplayObject"] = Context3DDisplayObject;

// Init



// Statics

Context3DDisplayObject.render = function(displayObject,renderer) {
	if(displayObject.opaqueBackground == null && displayObject.__graphics == null) {
		return;
	}
	if(!displayObject.__renderable || displayObject.__worldAlpha <= 0) {
		return;
	}
	if(displayObject.opaqueBackground != null && !displayObject.__isCacheBitmapRender && displayObject.get_width() > 0 && displayObject.get_height() > 0) {
		renderer.__setBlendMode(displayObject.__worldBlendMode);
		renderer.__pushMaskObject(displayObject);
		var context = renderer.__context3D;
		var rect = (openfl_geom_Rectangle().default).__pool.get();
		rect.setTo(0,0,displayObject.get_width(),displayObject.get_height());
		renderer.__pushMaskRect(rect,displayObject.__renderTransform);
		var color = displayObject.opaqueBackground;
		context.clear((color >>> 16 & 255) / 255,(color >>> 8 & 255) / 255,(color & 255) / 255,1,0,0,1);
		renderer.__popMaskRect();
		renderer.__popMaskObject(displayObject);
		(openfl_geom_Rectangle().default).__pool.release(rect);
	}
	if(displayObject.__graphics != null) {
		(openfl__$internal_renderer_context3D_Context3DShape().default).render(displayObject,renderer);
	}
}
Context3DDisplayObject.renderMask = function(displayObject,renderer) {
	if(displayObject.opaqueBackground == null && displayObject.__graphics == null) {
		return;
	}
	var tmp = displayObject.opaqueBackground != null && !displayObject.__isCacheBitmapRender && displayObject.get_width() > 0 && displayObject.get_height() > 0;
	if(displayObject.__graphics != null) {
		(openfl__$internal_renderer_context3D_Context3DShape().default).renderMask(displayObject,renderer);
	}
}
Context3DDisplayObject.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Context3DDisplayObject;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DElementType.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DElementType.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: openfl._internal.renderer.context3D.Context3DElementType

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var Context3DElementType = $hxEnums["openfl._internal.renderer.context3D.Context3DElementType"] = { __ename__ : "openfl._internal.renderer.context3D.Context3DElementType", __constructs__ : ["QUADS","TRIANGLES","TRIANGLE_INDICES"]
  ,TRIANGLE_INDICES: {_hx_index:2,__enum__:"openfl._internal.renderer.context3D.Context3DElementType",toString:$estr}
  ,TRIANGLES: {_hx_index:1,__enum__:"openfl._internal.renderer.context3D.Context3DElementType",toString:$estr}
  ,QUADS: {_hx_index:0,__enum__:"openfl._internal.renderer.context3D.Context3DElementType",toString:$estr}
};

exports.default = Context3DElementType;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DGraphics.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DGraphics.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.context3D.Context3DGraphics

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_display_BitmapData() {return __webpack_require__(/*! ./../../../../openfl/display/BitmapData */ "./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js");}
function openfl_geom_ColorTransform() {return __webpack_require__(/*! ./../../../../openfl/geom/ColorTransform */ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js");}
function openfl__$internal_renderer_DrawCommandReader() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/DrawCommandReader */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandReader.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function openfl__$internal_renderer_context3D_Context3DBuffer() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/context3D/Context3DBuffer */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DBuffer.js");}
function openfl__$internal_renderer_context3D_Context3DElementType() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/context3D/Context3DElementType */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DElementType.js");}
function openfl__$internal_renderer_canvas_CanvasGraphics() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/canvas/CanvasGraphics */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasGraphics.js");}
function Std() {return __webpack_require__(/*! ./../../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Context3DGraphics = function(){}

// Meta

Context3DGraphics.__name__ = "openfl._internal.renderer.context3D.Context3DGraphics";
Context3DGraphics.__isInterface__ = false;
Context3DGraphics.prototype = {
	
};
Context3DGraphics.prototype.__class__ = Context3DGraphics.prototype.constructor = $hxClasses["openfl._internal.renderer.context3D.Context3DGraphics"] = Context3DGraphics;

// Init



// Statics

Context3DGraphics.buildBuffer = function(graphics,renderer) {
	var quadBufferPosition = 0;
	var triangleIndexBufferPosition = 0;
	var vertexBufferPosition = 0;
	var vertexBufferPositionUVT = 0;
	var data = new (openfl__$internal_renderer_DrawCommandReader().default)(graphics.__commands);
	var context = renderer.__context3D;
	var tileRect = (openfl_geom_Rectangle().default).__pool.get();
	var tileTransform = (openfl_geom_Matrix().default).__pool.get();
	var bitmap = null;
	var _g = 0;
	var _g1 = graphics.__commands.types;
	while(_g < _g1.length) {
		var type = _g1[_g];
		++_g;
		switch(type._hx_index) {
		case 0:
			var c = data.readBeginBitmapFill();
			bitmap = c.obj(0);
			break;
		case 1:
			bitmap = null;
			data.skip(type);
			break;
		case 3:
			var c1 = data.readBeginShaderFill();
			var shaderBuffer = c1.obj(0);
			bitmap = null;
			if(shaderBuffer != null) {
				var _g2 = 0;
				var _g11 = shaderBuffer.inputCount;
				while(_g2 < _g11) {
					var i = _g2++;
					if(shaderBuffer.inputRefs[i].name == "bitmap") {
						bitmap = shaderBuffer.inputs[i];
						break;
					}
				}
			}
			break;
		case 8:
			if(bitmap != null) {
				var c2 = data.readDrawQuads();
				var rects = c2.obj(0);
				var indices = c2.obj(1);
				var transforms = c2.obj(2);
				var hasIndices = indices != null;
				var transformABCD = false;
				var transformXY = false;
				var length = hasIndices ? indices.get_length() : Math.floor(rects.get_length() / 4);
				if(length == 0) {
					return;
				}
				if(transforms != null) {
					if(transforms.get_length() >= length * 6) {
						transformABCD = true;
						transformXY = true;
					} else if(transforms.get_length() >= length * 4) {
						transformABCD = true;
					} else if(transforms.get_length() >= length * 2) {
						transformXY = true;
					}
				}
				var dataPerVertex = 4;
				var stride = dataPerVertex * 4;
				if(graphics.__quadBuffer == null) {
					graphics.__quadBuffer = new (openfl__$internal_renderer_context3D_Context3DBuffer().default)(context,(openfl__$internal_renderer_context3D_Context3DElementType().default).QUADS,length,dataPerVertex);
				} else {
					graphics.__quadBuffer.resize(quadBufferPosition + length,dataPerVertex);
				}
				var vertexOffset;
				var alpha = 1.0;
				var tileData;
				var id;
				var tileWidth;
				var tileHeight;
				var uvX;
				var uvY;
				var uvWidth;
				var uvHeight;
				var x;
				var y;
				var x2;
				var y2;
				var x3;
				var y3;
				var x4;
				var y4;
				var ri;
				var ti;
				var vertexBufferData = graphics.__quadBuffer.vertexBufferData;
				var bitmapWidth = bitmap.width;
				var bitmapHeight = bitmap.height;
				var sourceRect = bitmap.rect;
				var _g3 = 0;
				var _g12 = length;
				while(_g3 < _g12) {
					var i1 = _g3++;
					vertexOffset = (quadBufferPosition + i1) * stride;
					ri = hasIndices ? indices[i1] * 4 : i1 * 4;
					if(ri < 0) {
						continue;
					}
					tileRect.setTo(rects[ri],rects[ri + 1],rects[ri + 2],rects[ri + 3]);
					tileWidth = tileRect.width;
					tileHeight = tileRect.height;
					if(tileWidth <= 0 || tileHeight <= 0) {
						continue;
					}
					if(transformABCD && transformXY) {
						ti = i1 * 6;
						tileTransform.setTo(transforms[ti],transforms[ti + 1],transforms[ti + 2],transforms[ti + 3],transforms[ti + 4],transforms[ti + 5]);
					} else if(transformABCD) {
						ti = i1 * 4;
						tileTransform.setTo(transforms[ti],transforms[ti + 1],transforms[ti + 2],transforms[ti + 3],tileRect.x,tileRect.y);
					} else if(transformXY) {
						ti = i1 * 2;
						tileTransform.tx = transforms[ti];
						tileTransform.ty = transforms[ti + 1];
					} else {
						tileTransform.tx = tileRect.x;
						tileTransform.ty = tileRect.y;
					}
					uvX = tileRect.x / bitmapWidth;
					uvY = tileRect.y / bitmapHeight;
					uvWidth = tileRect.get_right() / bitmapWidth;
					uvHeight = tileRect.get_bottom() / bitmapHeight;
					x = tileTransform.__transformX(0,0);
					y = tileTransform.__transformY(0,0);
					x2 = tileTransform.__transformX(tileWidth,0);
					y2 = tileTransform.__transformY(tileWidth,0);
					x3 = tileTransform.__transformX(0,tileHeight);
					y3 = tileTransform.__transformY(0,tileHeight);
					x4 = tileTransform.__transformX(tileWidth,tileHeight);
					y4 = tileTransform.__transformY(tileWidth,tileHeight);
					vertexBufferData[vertexOffset] = x;
					vertexBufferData[vertexOffset + 1] = y;
					vertexBufferData[vertexOffset + 2] = uvX;
					vertexBufferData[vertexOffset + 3] = uvY;
					vertexBufferData[vertexOffset + dataPerVertex] = x2;
					vertexBufferData[vertexOffset + dataPerVertex + 1] = y2;
					vertexBufferData[vertexOffset + dataPerVertex + 2] = uvWidth;
					vertexBufferData[vertexOffset + dataPerVertex + 3] = uvY;
					vertexBufferData[vertexOffset + dataPerVertex * 2] = x3;
					vertexBufferData[vertexOffset + dataPerVertex * 2 + 1] = y3;
					vertexBufferData[vertexOffset + dataPerVertex * 2 + 2] = uvX;
					vertexBufferData[vertexOffset + dataPerVertex * 2 + 3] = uvHeight;
					vertexBufferData[vertexOffset + dataPerVertex * 3] = x4;
					vertexBufferData[vertexOffset + dataPerVertex * 3 + 1] = y4;
					vertexBufferData[vertexOffset + dataPerVertex * 3 + 2] = uvWidth;
					vertexBufferData[vertexOffset + dataPerVertex * 3 + 3] = uvHeight;
				}
				quadBufferPosition += length;
			}
			break;
		case 12:
			var c3 = data.readDrawTriangles();
			var vertices = c3.obj(0);
			var indices1 = c3.obj(1);
			var uvtData = c3.obj(2);
			var culling = c3.obj(3);
			var hasIndices1 = indices1 != null;
			var numVertices = Math.floor(vertices.get_length() / 2);
			var length1 = hasIndices1 ? indices1.get_length() : numVertices;
			var hasUVData = uvtData != null;
			var hasUVTData = hasUVData && uvtData.get_length() >= numVertices * 3;
			var vertLength = hasUVTData ? 4 : 2;
			var uvStride = hasUVTData ? 3 : 2;
			var dataPerVertex1 = vertLength + 2;
			var vertexOffset1 = hasUVTData ? vertexBufferPositionUVT : vertexBufferPosition;
			Context3DGraphics.resizeVertexBuffer(graphics,hasUVTData,vertexOffset1 + length1 * dataPerVertex1);
			var vertexBufferData1 = hasUVTData ? graphics.__vertexBufferDataUVT : graphics.__vertexBufferData;
			var offset;
			var vertOffset;
			var uvOffset;
			var t;
			var _g4 = 0;
			var _g13 = length1;
			while(_g4 < _g13) {
				var i2 = _g4++;
				offset = vertexOffset1 + i2 * dataPerVertex1;
				vertOffset = hasIndices1 ? indices1[i2] * 2 : i2 * 2;
				uvOffset = hasIndices1 ? indices1[i2] * uvStride : i2 * uvStride;
				if(hasUVTData) {
					t = uvtData[uvOffset + 2];
					vertexBufferData1[offset] = vertices[vertOffset] / t;
					vertexBufferData1[offset + 1] = vertices[vertOffset + 1] / t;
					vertexBufferData1[offset + 2] = 0;
					vertexBufferData1[offset + 3] = 1 / t;
				} else {
					vertexBufferData1[offset] = vertices[vertOffset];
					vertexBufferData1[offset + 1] = vertices[vertOffset + 1];
				}
				vertexBufferData1[offset + vertLength] = hasUVData ? uvtData[uvOffset] : 0;
				vertexBufferData1[offset + vertLength + 1] = hasUVData ? uvtData[uvOffset + 1] : 0;
			}
			if(hasUVTData) {
				vertexBufferPositionUVT += length1 * dataPerVertex1;
			} else {
				vertexBufferPosition += length1 * dataPerVertex1;
			}
			break;
		case 13:
			bitmap = null;
			break;
		default:
			data.skip(type);
		}
	}
	if(quadBufferPosition > 0) {
		graphics.__quadBuffer.flushVertexBufferData();
	}
	if(triangleIndexBufferPosition > 0) {
		var buffer = graphics.__triangleIndexBuffer;
		if(buffer == null || triangleIndexBufferPosition > graphics.__triangleIndexBufferCount) {
			buffer = context.createIndexBuffer(triangleIndexBufferPosition,"dynamicDraw");
			graphics.__triangleIndexBuffer = buffer;
			graphics.__triangleIndexBufferCount = triangleIndexBufferPosition;
		}
		buffer.uploadFromTypedArray(graphics.__triangleIndexBufferData);
	}
	if(vertexBufferPosition > 0) {
		var buffer1 = graphics.__vertexBuffer;
		if(buffer1 == null || vertexBufferPosition > graphics.__vertexBufferCount) {
			buffer1 = context.createVertexBuffer(vertexBufferPosition,4,"dynamicDraw");
			graphics.__vertexBuffer = buffer1;
			graphics.__vertexBufferCount = vertexBufferPosition;
		}
		buffer1.uploadFromTypedArray(graphics.__vertexBufferData);
	}
	if(vertexBufferPositionUVT > 0) {
		var buffer2 = graphics.__vertexBufferUVT;
		if(buffer2 == null || vertexBufferPositionUVT > graphics.__vertexBufferCountUVT) {
			buffer2 = context.createVertexBuffer(vertexBufferPositionUVT,6,"dynamicDraw");
			graphics.__vertexBufferUVT = buffer2;
			graphics.__vertexBufferCountUVT = vertexBufferPositionUVT;
		}
		buffer2.uploadFromTypedArray(graphics.__vertexBufferDataUVT);
	}
	(openfl_geom_Rectangle().default).__pool.release(tileRect);
	(openfl_geom_Matrix().default).__pool.release(tileTransform);
}
Context3DGraphics.isCompatible = function(graphics) {
	if(graphics.__owner.__worldScale9Grid != null) {
		return false;
	}
	var data = new (openfl__$internal_renderer_DrawCommandReader().default)(graphics.__commands);
	var hasColorFill = false;
	var hasBitmapFill = false;
	var hasShaderFill = false;
	var _g = 0;
	var _g1 = graphics.__commands.types;
	while(_g < _g1.length) {
		var type = _g1[_g];
		++_g;
		switch(type._hx_index) {
		case 0:
			hasBitmapFill = true;
			hasColorFill = false;
			hasShaderFill = false;
			data.skip(type);
			break;
		case 1:
			hasBitmapFill = false;
			hasColorFill = true;
			hasShaderFill = false;
			data.skip(type);
			break;
		case 3:
			hasBitmapFill = false;
			hasColorFill = false;
			hasShaderFill = true;
			data.skip(type);
			break;
		case 8:
			if(hasBitmapFill || hasShaderFill) {
				data.skip(type);
			} else {
				data.destroy();
				return false;
			}
			break;
		case 9:
			if(hasColorFill) {
				data.skip(type);
			} else {
				data.destroy();
				return false;
			}
			break;
		case 12:
			if(hasBitmapFill || hasShaderFill) {
				data.skip(type);
			} else {
				data.destroy();
				return false;
			}
			break;
		case 13:
			hasBitmapFill = false;
			hasColorFill = false;
			hasShaderFill = false;
			data.skip(type);
			break;
		case 18:
			data.skip(type);
			break;
		case 19:
			data.skip(type);
			break;
		default:
			data.destroy();
			return false;
		}
	}
	data.destroy();
	return true;
}
Context3DGraphics.render = function(graphics,renderer) {
	if(!graphics.__visible || graphics.__commands.get_length() == 0) {
		return;
	}
	if(graphics.__bitmap != null && !graphics.__dirty || !Context3DGraphics.isCompatible(graphics)) {
		var cacheTransform = renderer.__softwareRenderer.__worldTransform;
		renderer.__softwareRenderer.__worldTransform = renderer.__worldTransform;
		(openfl__$internal_renderer_canvas_CanvasGraphics().default).render(graphics,renderer.__softwareRenderer);
		renderer.__softwareRenderer.__worldTransform = cacheTransform;
	} else {
		graphics.__bitmap = null;
		graphics.__update(renderer.__worldTransform);
		var bounds = graphics.__bounds;
		var width = graphics.__width;
		var height = graphics.__height;
		if(bounds != null && width >= 1 && height >= 1) {
			if(graphics.__hardwareDirty || graphics.__quadBuffer == null && graphics.__vertexBuffer == null && graphics.__vertexBufferUVT == null) {
				Context3DGraphics.buildBuffer(graphics,renderer);
			}
			var data = new (openfl__$internal_renderer_DrawCommandReader().default)(graphics.__commands);
			var context = renderer.__context3D;
			var gl = context.gl;
			var matrix = (openfl_geom_Matrix().default).__pool.get();
			var shaderBuffer = null;
			var bitmap = null;
			var repeat = false;
			var smooth = false;
			var fill = null;
			var positionX = 0.0;
			var positionY = 0.0;
			var quadBufferPosition = 0;
			var shaderBufferOffset = 0;
			var triangleIndexBufferPosition = 0;
			var vertexBufferPosition = 0;
			var vertexBufferPositionUVT = 0;
			var _g = 0;
			var _g1 = graphics.__commands.types;
			while(_g < _g1.length) {
				var type = _g1[_g];
				++_g;
				switch(type._hx_index) {
				case 0:
					var c = data.readBeginBitmapFill();
					bitmap = c.obj(0);
					repeat = c.bool(0);
					smooth = c.bool(1);
					shaderBuffer = null;
					fill = null;
					break;
				case 1:
					var c1 = data.readBeginFill();
					var color = (Std().default).int(c1.int(0));
					var alpha = (Std().default).int(c1.float(0) * 255);
					fill = color & 16777215 | alpha << 24;
					shaderBuffer = null;
					bitmap = null;
					break;
				case 3:
					var c2 = data.readBeginShaderFill();
					shaderBuffer = c2.obj(0);
					shaderBufferOffset = 0;
					if(shaderBuffer == null || shaderBuffer.shader == null || shaderBuffer.shader.__bitmap == null) {
						bitmap = null;
					} else {
						bitmap = shaderBuffer.shader.__bitmap.input;
					}
					fill = null;
					break;
				case 8:
					if(bitmap != null) {
						var c3 = data.readDrawQuads();
						var rects = c3.obj(0);
						var indices = c3.obj(1);
						var transforms = c3.obj(2);
						var hasIndices = indices != null;
						var length = hasIndices ? indices.get_length() : Math.floor(rects.get_length() / 4);
						var uMatrix = renderer.__getMatrix(graphics.__owner.__renderTransform,"auto");
						var shader;
						if(shaderBuffer != null && !Context3DGraphics.maskRender) {
							shader = renderer.__initShaderBuffer(shaderBuffer);
							renderer.__setShaderBuffer(shaderBuffer);
							renderer.applyMatrix(uMatrix);
							renderer.applyBitmapData(bitmap,false,repeat);
							renderer.applyAlpha(graphics.__owner.__worldAlpha);
							renderer.applyColorTransform(graphics.__owner.__worldColorTransform);
						} else {
							shader = Context3DGraphics.maskRender ? renderer.__maskShader : renderer.__initGraphicsShader(null);
							renderer.setShader(shader);
							renderer.applyMatrix(uMatrix);
							renderer.applyBitmapData(bitmap,smooth,repeat);
							renderer.applyAlpha(graphics.__owner.__worldAlpha);
							renderer.applyColorTransform(graphics.__owner.__worldColorTransform);
							renderer.updateShader();
						}
						var end = quadBufferPosition + length;
						while(quadBufferPosition < end) {
							length = (Std().default).int(Math.min(end - quadBufferPosition,context.__quadIndexBufferElements));
							if(length <= 0) {
								break;
							}
							if(shaderBuffer != null && !Context3DGraphics.maskRender) {
								renderer.__updateShaderBuffer(shaderBufferOffset);
							}
							if(shader.__position != null) {
								context.setVertexBufferAt(shader.__position.index,graphics.__quadBuffer.vertexBuffer,quadBufferPosition * 16,"float2");
							}
							if(shader.__textureCoord != null) {
								context.setVertexBufferAt(shader.__textureCoord.index,graphics.__quadBuffer.vertexBuffer,quadBufferPosition * 16 + 2,"float2");
							}
							context.drawTriangles(context.__quadIndexBuffer,0,length * 2);
							shaderBufferOffset += length * 4;
							quadBufferPosition += length;
						}
						renderer.__clearShader();
					}
					break;
				case 9:
					if(fill != null) {
						var c4 = data.readDrawRect();
						var x = c4.float(0);
						var y = c4.float(1);
						var width1 = c4.float(2);
						var height1 = c4.float(3);
						var color1 = fill;
						Context3DGraphics.tempColorTransform.redOffset = color1 >>> 16 & 255;
						Context3DGraphics.tempColorTransform.greenOffset = color1 >>> 8 & 255;
						Context3DGraphics.tempColorTransform.blueOffset = color1 & 255;
						Context3DGraphics.tempColorTransform.__combine(graphics.__owner.__worldColorTransform);
						matrix.identity();
						matrix.scale(width1,height1);
						matrix.tx = x;
						matrix.ty = y;
						matrix.concat(graphics.__owner.__renderTransform);
						var shader1 = Context3DGraphics.maskRender ? renderer.__maskShader : renderer.__initGraphicsShader(null);
						renderer.setShader(shader1);
						renderer.applyMatrix(renderer.__getMatrix(matrix,"auto"));
						renderer.applyBitmapData(Context3DGraphics.blankBitmapData,true,repeat);
						renderer.applyAlpha((color1 >>> 24 & 255) / 255 * graphics.__owner.__worldAlpha);
						renderer.applyColorTransform(Context3DGraphics.tempColorTransform);
						renderer.updateShader();
						var vertexBuffer = Context3DGraphics.blankBitmapData.getVertexBuffer(context);
						if(shader1.__position != null) {
							context.setVertexBufferAt(shader1.__position.index,vertexBuffer,0,"float3");
						}
						if(shader1.__textureCoord != null) {
							context.setVertexBufferAt(shader1.__textureCoord.index,vertexBuffer,3,"float2");
						}
						var indexBuffer = Context3DGraphics.blankBitmapData.getIndexBuffer(context);
						context.drawTriangles(indexBuffer);
						shaderBufferOffset += 4;
						renderer.__clearShader();
					}
					break;
				case 12:
					var c5 = data.readDrawTriangles();
					var vertices = c5.obj(0);
					var indices1 = c5.obj(1);
					var uvtData = c5.obj(2);
					var culling = c5.obj(3);
					var hasIndices1 = indices1 != null;
					var numVertices = Math.floor(vertices.get_length() / 2);
					var length1 = hasIndices1 ? indices1.get_length() : numVertices;
					var hasUVData = uvtData != null;
					var hasUVTData = hasUVData && uvtData.get_length() >= numVertices * 3;
					var vertLength = hasUVTData ? 4 : 2;
					var uvStride = hasUVTData ? 3 : 2;
					var dataPerVertex = vertLength + 2;
					var vertexBuffer1 = hasUVTData ? graphics.__vertexBufferUVT : graphics.__vertexBuffer;
					var bufferPosition = hasUVTData ? vertexBufferPositionUVT : vertexBufferPosition;
					var uMatrix1 = renderer.__getMatrix(graphics.__owner.__renderTransform,"auto");
					var shader2;
					if(shaderBuffer != null && !Context3DGraphics.maskRender) {
						shader2 = renderer.__initShaderBuffer(shaderBuffer);
						renderer.__setShaderBuffer(shaderBuffer);
						renderer.applyMatrix(uMatrix1);
						renderer.applyBitmapData(bitmap,false,repeat);
						renderer.applyAlpha(1);
						renderer.applyColorTransform(null);
						renderer.__updateShaderBuffer(shaderBufferOffset);
					} else {
						shader2 = Context3DGraphics.maskRender ? renderer.__maskShader : renderer.__initGraphicsShader(null);
						renderer.setShader(shader2);
						renderer.applyMatrix(uMatrix1);
						renderer.applyBitmapData(bitmap,smooth,repeat);
						renderer.applyAlpha(graphics.__owner.__worldAlpha);
						renderer.applyColorTransform(graphics.__owner.__worldColorTransform);
						renderer.updateShader();
					}
					if(shader2.__position != null) {
						context.setVertexBufferAt(shader2.__position.index,vertexBuffer1,bufferPosition,hasUVTData ? "float4" : "float2");
					}
					if(shader2.__textureCoord != null) {
						context.setVertexBufferAt(shader2.__textureCoord.index,vertexBuffer1,bufferPosition + vertLength,"float2");
					}
					switch(culling) {
					case "negative":
						context.setCulling("back");
						break;
					case "none":
						context.setCulling("none");
						break;
					case "positive":
						context.setCulling("front");
						break;
					default:
					}
					context.__drawTriangles(0,length1);
					shaderBufferOffset += length1;
					if(hasUVTData) {
						vertexBufferPositionUVT += dataPerVertex * length1;
					} else {
						vertexBufferPosition += dataPerVertex * length1;
					}
					switch(culling) {
					case "none":case "positive":
						context.setCulling("back");
						break;
					default:
					}
					renderer.__clearShader();
					break;
				case 13:
					bitmap = null;
					fill = null;
					shaderBuffer = null;
					data.skip(type);
					break;
				case 18:
					var c6 = data.readMoveTo();
					positionX = c6.float(0);
					positionY = c6.float(1);
					break;
				case 19:
					var c7 = data.readOverrideBlendMode();
					renderer.__setBlendMode(c7.obj(0));
					break;
				default:
					data.skip(type);
				}
			}
			(openfl_geom_Matrix().default).__pool.release(matrix);
		}
		graphics.__hardwareDirty = false;
		graphics.set___dirty(false);
	}
}
Context3DGraphics.renderMask = function(graphics,renderer) {
	Context3DGraphics.maskRender = true;
	Context3DGraphics.render(graphics,renderer);
	Context3DGraphics.maskRender = false;
}
Context3DGraphics.resizeIndexBuffer = function(graphics,isQuad,length) {
	if(isQuad) {
		return;
	}
	var buffer = isQuad ? null : graphics.__triangleIndexBufferData;
	var position = 0;
	var newBuffer = null;
	if(buffer == null) {
		var array = null;
		var view = null;
		var buffer1 = null;
		var len = null;
		var this1;
		if(length != null) {
			this1 = new Uint16Array(length);
		} else if(array != null) {
			this1 = new Uint16Array(array);
		} else if(view != null) {
			this1 = new Uint16Array(view);
		} else if(buffer1 != null) {
			if(len == null) {
				this1 = new Uint16Array(buffer1,0);
			} else {
				this1 = new Uint16Array(buffer1,0,len);
			}
		} else {
			this1 = null;
		}
		newBuffer = this1;
	} else if(length > buffer.length) {
		var array1 = null;
		var view1 = null;
		var buffer2 = null;
		var len1 = null;
		var this2;
		if(length != null) {
			this2 = new Uint16Array(length);
		} else if(array1 != null) {
			this2 = new Uint16Array(array1);
		} else if(view1 != null) {
			this2 = new Uint16Array(view1);
		} else if(buffer2 != null) {
			if(len1 == null) {
				this2 = new Uint16Array(buffer2,0);
			} else {
				this2 = new Uint16Array(buffer2,0,len1);
			}
		} else {
			this2 = null;
		}
		newBuffer = this2;
		newBuffer.set(buffer);
		position = buffer.length;
	}
	if(newBuffer != null) {
		if(!isQuad) {
			graphics.__triangleIndexBufferData = newBuffer;
		}
	}
}
Context3DGraphics.resizeVertexBuffer = function(graphics,hasUVTData,length) {
	var buffer = hasUVTData ? graphics.__vertexBufferDataUVT : graphics.__vertexBufferData;
	var newBuffer = null;
	if(buffer == null) {
		var array = null;
		var view = null;
		var buffer1 = null;
		var len = null;
		var this1;
		if(length != null) {
			this1 = new Float32Array(length);
		} else if(array != null) {
			this1 = new Float32Array(array);
		} else if(view != null) {
			this1 = new Float32Array(view);
		} else if(buffer1 != null) {
			if(len == null) {
				this1 = new Float32Array(buffer1,0);
			} else {
				this1 = new Float32Array(buffer1,0,len);
			}
		} else {
			this1 = null;
		}
		newBuffer = this1;
	} else if(length > buffer.length) {
		var array1 = null;
		var view1 = null;
		var buffer2 = null;
		var len1 = null;
		var this2;
		if(length != null) {
			this2 = new Float32Array(length);
		} else if(array1 != null) {
			this2 = new Float32Array(array1);
		} else if(view1 != null) {
			this2 = new Float32Array(view1);
		} else if(buffer2 != null) {
			if(len1 == null) {
				this2 = new Float32Array(buffer2,0);
			} else {
				this2 = new Float32Array(buffer2,0,len1);
			}
		} else {
			this2 = null;
		}
		newBuffer = this2;
		newBuffer.set(buffer);
	}
	if(newBuffer != null) {
		if(hasUVTData) {
			graphics.__vertexBufferDataUVT = newBuffer;
		} else {
			graphics.__vertexBufferData = newBuffer;
		}
	}
}
Context3DGraphics.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}
Context3DGraphics.blankBitmapData = new (openfl_display_BitmapData().default)(1,1,false,0)
Context3DGraphics.tempColorTransform = new (openfl_geom_ColorTransform().default)(1,1,1,1,0,0,0,0)

// Export

exports.default = Context3DGraphics;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DMaskShader.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DMaskShader.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.context3D.Context3DMaskShader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_Shader() {return __webpack_require__(/*! ./../../../../openfl/display/Shader */ "./node_modules/openfl/lib/_gen/openfl/display/Shader.js");}
function openfl_display_BitmapData() {return __webpack_require__(/*! ./../../../../openfl/display/BitmapData */ "./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js");}

// Constructor

var Context3DMaskShader = function() {
	if(this.__glFragmentSource == null) {
		this.__glFragmentSource = "varying vec2 openfl_TextureCoordv;\n\t\t\n\t\tuniform sampler2D openfl_Texture;\n\t\t\n\t\tvoid main(void) {\n\t\t\t\n\t\t\tvec4 color = texture2D (openfl_Texture, openfl_TextureCoordv);\n\t\t\t\n\t\t\tif (color.a == 0.0) {\n\t\t\t\t\n\t\t\t\tdiscard;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tgl_FragColor = color;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}";
	}
	if(this.__glVertexSource == null) {
		this.__glVertexSource = "attribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\t\tvarying vec2 openfl_TextureCoordv;\n\t\t\n\t\tuniform mat4 openfl_Matrix;\n\t\t\n\t\tvoid main(void) {\n\t\t\t\n\t\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\t\t\t\n\t\t\tgl_Position = openfl_Matrix * openfl_Position;\n\t\t\t\n\t\t}";
	}
	(openfl_display_Shader().default).call(this);
	this.__isGenerated = true;
	this.__initGL();
}

// Meta

Context3DMaskShader.__name__ = "openfl._internal.renderer.context3D.Context3DMaskShader";
Context3DMaskShader.__isInterface__ = false;
Context3DMaskShader.__super__ = (openfl_display_Shader().default);
Context3DMaskShader.prototype = $extend((openfl_display_Shader().default).prototype, {
	
});
Context3DMaskShader.prototype.__class__ = Context3DMaskShader.prototype.constructor = $hxClasses["openfl._internal.renderer.context3D.Context3DMaskShader"] = Context3DMaskShader;

// Init



// Statics


Context3DMaskShader.opaqueBitmapData = new (openfl_display_BitmapData().default)(1,1,false,0)

// Export

exports.default = Context3DMaskShader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DShape.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DShape.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.context3D.Context3DShape

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_context3D_Context3DGraphics() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/context3D/Context3DGraphics */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DGraphics.js");}

// Constructor

var Context3DShape = function(){}

// Meta

Context3DShape.__name__ = "openfl._internal.renderer.context3D.Context3DShape";
Context3DShape.__isInterface__ = false;
Context3DShape.prototype = {
	
};
Context3DShape.prototype.__class__ = Context3DShape.prototype.constructor = $hxClasses["openfl._internal.renderer.context3D.Context3DShape"] = Context3DShape;

// Init



// Statics

Context3DShape.render = function(shape,renderer) {
	if(!shape.__renderable || shape.__worldAlpha <= 0) {
		return;
	}
	var graphics = shape.__graphics;
	if(graphics != null) {
		renderer.__setBlendMode(shape.__worldBlendMode);
		renderer.__pushMaskObject(shape);
		(openfl__$internal_renderer_context3D_Context3DGraphics().default).render(graphics,renderer);
		if(graphics.__bitmap != null && graphics.__visible) {
			var context = renderer.__context3D;
			var scale9Grid = shape.__worldScale9Grid;
			var shader = renderer.__initDisplayShader(shape.__worldShader);
			renderer.setShader(shader);
			renderer.applyBitmapData(graphics.__bitmap,true);
			renderer.applyMatrix(renderer.__getMatrix(graphics.__worldTransform,"auto"));
			renderer.applyAlpha(shape.__worldAlpha);
			renderer.applyColorTransform(shape.__worldColorTransform);
			renderer.updateShader();
			var vertexBuffer = graphics.__bitmap.getVertexBuffer(context);
			if(shader.__position != null) {
				context.setVertexBufferAt(shader.__position.index,vertexBuffer,0,"float3");
			}
			if(shader.__textureCoord != null) {
				context.setVertexBufferAt(shader.__textureCoord.index,vertexBuffer,3,"float2");
			}
			var indexBuffer = graphics.__bitmap.getIndexBuffer(context);
			context.drawTriangles(indexBuffer);
			renderer.__clearShader();
		}
		renderer.__popMaskObject(shape);
	}
}
Context3DShape.renderMask = function(shape,renderer) {
	var graphics = shape.__graphics;
	if(graphics != null) {
		(openfl__$internal_renderer_context3D_Context3DGraphics().default).renderMask(graphics,renderer);
		if(graphics.__bitmap != null) {
			var context = renderer.__context3D;
			var shader = renderer.__maskShader;
			renderer.setShader(shader);
			renderer.applyBitmapData(graphics.__bitmap,true);
			renderer.applyMatrix(renderer.__getMatrix(graphics.__worldTransform,"auto"));
			renderer.updateShader();
			var vertexBuffer = graphics.__bitmap.getVertexBuffer(context);
			if(shader.__position != null) {
				context.setVertexBufferAt(shader.__position.index,vertexBuffer,0,"float3");
			}
			if(shader.__textureCoord != null) {
				context.setVertexBufferAt(shader.__textureCoord.index,vertexBuffer,3,"float2");
			}
			var indexBuffer = graphics.__bitmap.getIndexBuffer(context);
			context.drawTriangles(indexBuffer);
			renderer.__clearShader();
		}
	}
}
Context3DShape.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Context3DShape;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DState.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DState.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.context3D.Context3DState

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}

// Constructor

var Context3DState = function() {
	this.backBufferEnableDepthAndStencil = false;
	this.blendDestinationAlphaFactor = "zero";
	this.blendSourceAlphaFactor = "one";
	this.blendDestinationRGBFactor = "zero";
	this.blendSourceRGBFactor = "one";
	this.colorMaskRed = true;
	this.colorMaskGreen = true;
	this.colorMaskBlue = true;
	this.colorMaskAlpha = true;
	this.culling = "none";
	this.depthCompareMode = "less";
	this.depthMask = true;
	this.samplerStates = [];
	this.scissorRectangle = new (openfl_geom_Rectangle().default)();
	this.stencilCompareMode = "always";
	this.stencilDepthFail = "keep";
	this.stencilFail = "keep";
	this.stencilPass = "keep";
	this.stencilReadMask = 255;
	this.stencilReferenceValue = 0;
	this.stencilTriangleFace = "frontAndBack";
	this.stencilWriteMask = 255;
	this.textures = [];
	this.__frontFaceGLCCW = true;
	this.__glBlendEquation = 32774;
}

// Meta

Context3DState.__name__ = "openfl._internal.renderer.context3D.Context3DState";
Context3DState.__isInterface__ = false;
Context3DState.prototype = {
	
};
Context3DState.prototype.__class__ = Context3DState.prototype.constructor = $hxClasses["openfl._internal.renderer.context3D.Context3DState"] = Context3DState;

// Init



// Statics


Context3DState.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Context3DState;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMBitmap.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMBitmap.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.dom.DOMBitmap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}

// Constructor

var DOMBitmap = function(){}

// Meta

DOMBitmap.__name__ = "openfl._internal.renderer.dom.DOMBitmap";
DOMBitmap.__isInterface__ = false;
DOMBitmap.prototype = {
	
};
DOMBitmap.prototype.__class__ = DOMBitmap.prototype.constructor = $hxClasses["openfl._internal.renderer.dom.DOMBitmap"] = DOMBitmap;

// Init



// Statics

DOMBitmap.clear = function(bitmap,renderer) {
	if(bitmap.__image != null) {
		renderer.element.removeChild(bitmap.__image);
		bitmap.__image = null;
		bitmap.__style = null;
	}
	if(bitmap.__canvas != null) {
		renderer.element.removeChild(bitmap.__canvas);
		bitmap.__canvas = null;
		bitmap.__style = null;
	}
}
DOMBitmap.render = function(bitmap,renderer) {
	if(bitmap.stage != null && bitmap.__worldVisible && bitmap.__renderable && bitmap.__bitmapData != null && bitmap.__bitmapData.__isValid && bitmap.__bitmapData.readable) {
		renderer.__pushMaskObject(bitmap);
		if(bitmap.__bitmapData.image.buffer.__srcImage != null) {
			DOMBitmap.renderImage(bitmap,renderer);
		} else {
			DOMBitmap.renderCanvas(bitmap,renderer);
		}
		renderer.__popMaskObject(bitmap);
	} else {
		DOMBitmap.clear(bitmap,renderer);
	}
}
DOMBitmap.renderCanvas = function(bitmap,renderer) {
	if(bitmap.__image != null) {
		renderer.element.removeChild(bitmap.__image);
		bitmap.__image = null;
	}
	if(bitmap.__canvas == null) {
		bitmap.__canvas = window.document.createElement("canvas");
		bitmap.__context = bitmap.__canvas.getContext("2d");
		bitmap.__imageVersion = -1;
		if(!renderer.__allowSmoothing || !bitmap.smoothing) {
			bitmap.__context.imageSmoothingEnabled = false;
		}
		renderer.__initializeElement(bitmap,bitmap.__canvas);
	}
	if(bitmap.__imageVersion != bitmap.__bitmapData.image.version) {
		(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(bitmap.__bitmapData.image);
		bitmap.__canvas.width = bitmap.__bitmapData.width + 1;
		bitmap.__canvas.width = bitmap.__bitmapData.width;
		bitmap.__canvas.height = bitmap.__bitmapData.height;
		bitmap.__context.drawImage(bitmap.__bitmapData.image.buffer.__srcCanvas,0,0);
		bitmap.__imageVersion = bitmap.__bitmapData.image.version;
	}
	renderer.__updateClip(bitmap);
	renderer.__applyStyle(bitmap,true,true,true);
}
DOMBitmap.renderImage = function(bitmap,renderer) {
	if(bitmap.__canvas != null) {
		renderer.element.removeChild(bitmap.__canvas);
		bitmap.__canvas = null;
	}
	if(bitmap.__image == null) {
		bitmap.__image = window.document.createElement("img");
		bitmap.__image.crossOrigin = "Anonymous";
		bitmap.__image.src = bitmap.__bitmapData.image.buffer.__srcImage.src;
		renderer.__initializeElement(bitmap,bitmap.__image);
	}
	renderer.__updateClip(bitmap);
	renderer.__applyStyle(bitmap,true,true,true);
}
DOMBitmap.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = DOMBitmap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMDisplayObject.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMDisplayObject.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.dom.DOMDisplayObject

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_dom_DOMBitmap() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/dom/DOMBitmap */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMBitmap.js");}
function openfl__$internal_renderer_dom_DOMShape() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/dom/DOMShape */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMShape.js");}

// Constructor

var DOMDisplayObject = function(){}

// Meta

DOMDisplayObject.__name__ = "openfl._internal.renderer.dom.DOMDisplayObject";
DOMDisplayObject.__isInterface__ = false;
DOMDisplayObject.prototype = {
	
};
DOMDisplayObject.prototype.__class__ = DOMDisplayObject.prototype.constructor = $hxClasses["openfl._internal.renderer.dom.DOMDisplayObject"] = DOMDisplayObject;

// Init



// Statics

DOMDisplayObject.clear = function(displayObject,renderer) {
	if(displayObject.__cacheBitmap != null) {
		(openfl__$internal_renderer_dom_DOMBitmap().default).clear(displayObject.__cacheBitmap,renderer);
	}
	(openfl__$internal_renderer_dom_DOMShape().default).clear(displayObject,renderer);
}
DOMDisplayObject.render = function(displayObject,renderer) {
	var tmp = displayObject.opaqueBackground != null && !displayObject.__isCacheBitmapRender && displayObject.get_width() > 0 && displayObject.get_height() > 0;
	(openfl__$internal_renderer_dom_DOMShape().default).render(displayObject,renderer);
}
DOMDisplayObject.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = DOMDisplayObject;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMShape.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMShape.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.renderer.dom.DOMShape

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$internal_renderer_canvas_CanvasGraphics() {return __webpack_require__(/*! ./../../../../openfl/_internal/renderer/canvas/CanvasGraphics */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasGraphics.js");}

// Constructor

var DOMShape = function(){}

// Meta

DOMShape.__name__ = "openfl._internal.renderer.dom.DOMShape";
DOMShape.__isInterface__ = false;
DOMShape.prototype = {
	
};
DOMShape.prototype.__class__ = DOMShape.prototype.constructor = $hxClasses["openfl._internal.renderer.dom.DOMShape"] = DOMShape;

// Init



// Statics

DOMShape.clear = function(shape,renderer) {
	if(shape.__canvas != null) {
		renderer.element.removeChild(shape.__canvas);
		shape.__canvas = null;
		shape.__style = null;
	}
}
DOMShape.render = function(shape,renderer) {
	var graphics = shape.__graphics;
	if(shape.stage != null && shape.__worldVisible && shape.__renderable && graphics != null) {
		(openfl__$internal_renderer_canvas_CanvasGraphics().default).render(graphics,renderer.__canvasRenderer);
		if(graphics.__softwareDirty || shape.__worldAlphaChanged || shape.__canvas != graphics.__canvas) {
			if(graphics.__canvas != null) {
				if(shape.__canvas != graphics.__canvas) {
					if(shape.__canvas != null) {
						renderer.element.removeChild(shape.__canvas);
					}
					shape.__canvas = graphics.__canvas;
					shape.__context = graphics.__context;
					renderer.__initializeElement(shape,shape.__canvas);
				}
			} else {
				DOMShape.clear(shape,renderer);
			}
		}
		if(shape.__canvas != null) {
			renderer.__pushMaskObject(shape);
			var cacheTransform = shape.__renderTransform;
			shape.__renderTransform = graphics.__worldTransform;
			if(graphics.__transformDirty) {
				graphics.__transformDirty = false;
				shape.__renderTransformChanged = true;
			}
			renderer.__updateClip(shape);
			renderer.__applyStyle(shape,true,true,true);
			shape.__renderTransform = cacheTransform;
			renderer.__popMaskObject(shape);
		}
	} else {
		DOMShape.clear(shape,renderer);
	}
}
DOMShape.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = DOMShape;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/symbols/timeline/FrameObjectType.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/symbols/timeline/FrameObjectType.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Enum: openfl._internal.symbols.timeline.FrameObjectType

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

// Imports

var $estr = __webpack_require__(/*! ./../../../../estr_stub */ "./node_modules/openfl/lib/_gen/estr_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Definition

var FrameObjectType = $hxEnums["openfl._internal.symbols.timeline.FrameObjectType"] = { __ename__ : "openfl._internal.symbols.timeline.FrameObjectType", __constructs__ : ["CREATE","UPDATE","DESTROY"]
  ,UPDATE: {_hx_index:1,__enum__:"openfl._internal.symbols.timeline.FrameObjectType",toString:$estr}
  ,DESTROY: {_hx_index:2,__enum__:"openfl._internal.symbols.timeline.FrameObjectType",toString:$estr}
  ,CREATE: {_hx_index:0,__enum__:"openfl._internal.symbols.timeline.FrameObjectType",toString:$estr}
};

exports.default = FrameObjectType;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/utils/AbstractNoise.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/utils/AbstractNoise.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.utils.AbstractNoise

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var AbstractNoise = function(seed,octaves,channels,grayScale,falloff,stitch,stitch_threshold) {
	if(stitch_threshold == null) {
		stitch_threshold = 0.05;
	}
	if(stitch == null) {
		stitch = false;
	}
	this.stitch = stitch;
	this.stitch_threshold = stitch_threshold;
	this.octaves = octaves;
	this.channels = channels;
	this.grayscale = grayScale;
	this.calculateOctaves(falloff);
}

// Meta

AbstractNoise.__name__ = "openfl._internal.utils.AbstractNoise";
AbstractNoise.__isInterface__ = false;
AbstractNoise.prototype = {
	fill: function(bitmap,_scale_x,_scale_y,_scale_z) {
	},
	stitching: function(bitmap,color,px,py,stitch_w,stitch_h,width,height) {
		var r = color >> 16 & 255;
		var g = color >> 8 & 255;
		var b = color & 255;
		if(width - stitch_w < px) {
			var dest = bitmap.getPixel32(width - px,py);
			var dest_r = dest >> 16 & 255;
			var dest_g = dest >> 8 & 255;
			var dest_b = dest & 255;
			var u = (width - px) / stitch_w;
			var uu = u * u;
			r = this.mixI(dest_r,r,u);
			g = this.mixI(dest_g,g,u);
			b = this.mixI(dest_b,b,u);
		}
		if(height - stitch_h < py) {
			var dest1 = bitmap.getPixel32(px,height - py);
			var dest_r1 = dest1 >> 16 & 255;
			var dest_g1 = dest1 >> 8 & 255;
			var dest_b1 = dest1 & 255;
			var u1 = (height - py) / stitch_h;
			var uu1 = u1 * u1;
			r = this.mixI(dest_r1,r,u1);
			g = this.mixI(dest_g1,g,u1);
			b = this.mixI(dest_b1,b,u1);
		}
		return -16777216 | r << 16 | g << 8 | b;
	},
	color: function(r_noise,g_noise,b_noise) {
		var color_r = 0;
		var color_g = 0;
		var color_b = 0;
		if(null != r_noise) {
			color_r = this.noiseToColor(r_noise);
		}
		if(null != g_noise) {
			color_g = this.noiseToColor(g_noise);
		}
		if(null != b_noise) {
			color_b = this.noiseToColor(b_noise);
		}
		return -16777216 | color_r << 16 | color_g << 8 | color_b;
	},
	noiseToColor: function(noise) {
		return (Std().default).int((noise * this.persistence_max + 1.0) * 128);
	},
	fade: function(t) {
		return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
	},
	mixI: function(x,y,t) {
		return (Std().default).int((1.0 - t) * x + t * y);
	},
	mix: function(x,y,t) {
		return (1.0 - t) * x + t * y;
	},
	fastfloor: function(x) {
		if(x > 0) {
			return (Std().default).int(x);
		} else {
			return (Std().default).int(x - 1);
		}
	},
	dot2d: function(grad,x,y) {
		return grad[0] * x + grad[1] * y;
	},
	dot: function(grad,x,y,z) {
		return grad[0] * x + grad[1] * y + grad[2] * z;
	},
	calculateOctaves: function(fPersistence) {
		var fFreq;
		var fPers;
		this.octaves_frequencies = [];
		this.octaves_persistences = [];
		this.persistence_max = 0;
		var _g = 0;
		var _g1 = this.octaves;
		while(_g < _g1) {
			var i = _g++;
			fFreq = Math.pow(2.0,i);
			fPers = Math.pow(fPersistence,i);
			this.persistence_max += fPers;
			this.octaves_frequencies.push(fFreq);
			this.octaves_persistences.push(fPers);
		}
		this.persistence_max = 1.0 / this.persistence_max;
	}
};
AbstractNoise.prototype.__class__ = AbstractNoise.prototype.constructor = $hxClasses["openfl._internal.utils.AbstractNoise"] = AbstractNoise;

// Init



// Statics


AbstractNoise.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = AbstractNoise;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/utils/PerlinNoise.js":
/*!****************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/utils/PerlinNoise.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.utils.PerlinNoise

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl__$internal_utils_AbstractNoise() {return __webpack_require__(/*! ./../../../openfl/_internal/utils/AbstractNoise */ "./node_modules/openfl/lib/_gen/openfl/_internal/utils/AbstractNoise.js");}
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var PerlinNoise = function(seed,octaves,channels,grayScale,falloff,stitch,stitch_threshold) {
	if(stitch_threshold == null) {
		stitch_threshold = 0.05;
	}
	if(stitch == null) {
		stitch = false;
	}
	(openfl__$internal_utils_AbstractNoise().default).call(this,seed,octaves,channels,grayScale,falloff,stitch,stitch_threshold);
	this.p_perm = [];
	var _g = 0;
	while(_g < 512) {
		var i = _g++;
		this.p_perm[i] = PerlinNoise.P[i & 255];
	}
	this.base_factor = 0.03125;
	this.setSeed(seed);
}

// Meta

PerlinNoise.__name__ = "openfl._internal.utils.PerlinNoise";
PerlinNoise.__isInterface__ = false;
PerlinNoise.__super__ = (openfl__$internal_utils_AbstractNoise().default);
PerlinNoise.prototype = $extend((openfl__$internal_utils_AbstractNoise().default).prototype, {
	fill: function(bitmap,_scale_x,_scale_y,_scale_z) {
		var width = bitmap.width;
		var height = bitmap.height;
		var octaves = this.octaves;
		var octaves_frequencies = this.octaves_frequencies;
		var octaves_persistences = this.octaves_persistences;
		var isRed = (1 & this.channels) == 1;
		var isGreen = (2 & this.channels) == 2;
		var isBlue = (4 & this.channels) == 4;
		var channels = 0;
		if(isRed) {
			++channels;
		}
		if(isGreen) {
			++channels;
		}
		if(isBlue) {
			++channels;
		}
		var grayscale = this.grayscale;
		var stitch_w = (Std().default).int(this.stitch_threshold * width);
		var stitch_h = (Std().default).int(this.stitch_threshold * height);
		var base_x = _scale_x * this.base_factor + this.x_offset;
		_scale_y = _scale_y * this.base_factor + this.y_offset;
		_scale_z = _scale_z * this.base_factor + this.z_offset;
		var g_offset = 1.0;
		var b_offset = 2.0;
		var _g = 0;
		var _g1 = height;
		while(_g < _g1) {
			var py = _g++;
			_scale_x = base_x;
			var _g2 = 0;
			var _g11 = width;
			while(_g2 < _g11) {
				var px = _g2++;
				var color1 = 0.0;
				var color2 = 0.0;
				var color3 = 0.0;
				var _g3 = 0;
				var _g12 = octaves;
				while(_g3 < _g12) {
					var i = _g3++;
					var frequency = octaves_frequencies[i];
					var persistence = octaves_persistences[i];
					color1 += this.noise(_scale_x * frequency,_scale_y * frequency,_scale_z * frequency) * persistence;
					if(!grayscale) {
						if(1 < channels) {
							color2 += this.noise((_scale_x + g_offset) * frequency,(_scale_y + g_offset) * frequency,_scale_z * frequency) * persistence;
						}
						if(2 < channels) {
							color3 += this.noise((_scale_x + b_offset) * frequency,(_scale_y + b_offset) * frequency,_scale_z * frequency) * persistence;
						}
					}
				}
				var color = 0;
				if(grayscale) {
					color = this.color(color1,color1,color1);
				} else if(isRed && isGreen && isBlue) {
					color = this.color(color1,color2,color3);
				} else if(isRed && isGreen) {
					color = this.color(color1,color2,null);
				} else if(isRed && isBlue) {
					color = this.color(color1,null,color2);
				} else if(isGreen && isBlue) {
					color = this.color(null,color1,color2);
				} else if(isRed) {
					color = this.color(color1,null,null);
				} else if(isGreen) {
					color = this.color(null,color1,null);
				} else if(isBlue) {
					color = this.color(null,null,color1);
				}
				if(this.stitch) {
					color = this.stitching(bitmap,color,px,py,stitch_w,stitch_h,width,height);
				}
				bitmap.setPixel32(px,py,color);
				_scale_x += this.base_factor;
			}
			_scale_y += this.base_factor;
		}
	},
	noise: function(x,y,z) {
		var xf = x - x % 1;
		var yf = y - y % 1;
		var zf = z - z % 1;
		x -= xf;
		y -= yf;
		z -= zf;
		var X = (Std().default).int(xf) & 255;
		var Y = (Std().default).int(yf) & 255;
		var Z = (Std().default).int(zf) & 255;
		var u = this.fade(x);
		var v = this.fade(y);
		var w = this.fade(z);
		var A = this.p_perm[X] + Y;
		var AA = this.p_perm[A] + Z;
		var AB = this.p_perm[A + 1] + Z;
		var B = this.p_perm[X + 1] + Y;
		var BA = this.p_perm[B] + Z;
		var BB = this.p_perm[B + 1] + Z;
		var x1 = x - 1;
		var y1 = y - 1;
		var z1 = z - 1;
		var hash = this.p_perm[BB + 1] & 15;
		var g1 = ((hash & 1) == 0 ? hash < 8 ? x1 : y1 : hash < 8 ? -x1 : -y1) + ((hash & 2) == 0 ? hash < 4 ? y1 : hash == 12 ? x1 : z1 : hash < 4 ? -y1 : hash == 14 ? -x1 : -z1);
		hash = this.p_perm[AB + 1] & 15;
		var g2 = ((hash & 1) == 0 ? hash < 8 ? x : y1 : hash < 8 ? -x : -y1) + ((hash & 2) == 0 ? hash < 4 ? y1 : hash == 12 ? x : z1 : hash < 4 ? -y1 : hash == 14 ? -x : -z1);
		hash = this.p_perm[BA + 1] & 15;
		var g3 = ((hash & 1) == 0 ? hash < 8 ? x1 : y : hash < 8 ? -x1 : -y) + ((hash & 2) == 0 ? hash < 4 ? y : hash == 12 ? x1 : z1 : hash < 4 ? -y : hash == 14 ? -x1 : -z1);
		hash = this.p_perm[AA + 1] & 15;
		var g4 = ((hash & 1) == 0 ? hash < 8 ? x : y : hash < 8 ? -x : -y) + ((hash & 2) == 0 ? hash < 4 ? y : hash == 12 ? x : z1 : hash < 4 ? -y : hash == 14 ? -x : -z1);
		hash = this.p_perm[BB] & 15;
		var g5 = ((hash & 1) == 0 ? hash < 8 ? x1 : y1 : hash < 8 ? -x1 : -y1) + ((hash & 2) == 0 ? hash < 4 ? y1 : hash == 12 ? x1 : z : hash < 4 ? -y1 : hash == 14 ? -x1 : -z);
		hash = this.p_perm[AB] & 15;
		var g6 = ((hash & 1) == 0 ? hash < 8 ? x : y1 : hash < 8 ? -x : -y1) + ((hash & 2) == 0 ? hash < 4 ? y1 : hash == 12 ? x : z : hash < 4 ? -y1 : hash == 14 ? -x : -z);
		hash = this.p_perm[BA] & 15;
		var g7 = ((hash & 1) == 0 ? hash < 8 ? x1 : y : hash < 8 ? -x1 : -y) + ((hash & 2) == 0 ? hash < 4 ? y : hash == 12 ? x1 : z : hash < 4 ? -y : hash == 14 ? -x1 : -z);
		hash = this.p_perm[AA] & 15;
		var g8 = ((hash & 1) == 0 ? hash < 8 ? x : y : hash < 8 ? -x : -y) + ((hash & 2) == 0 ? hash < 4 ? y : hash == 12 ? x : z : hash < 4 ? -y : hash == 14 ? -x : -z);
		g2 += u * (g1 - g2);
		g4 += u * (g3 - g4);
		g6 += u * (g5 - g6);
		g8 += u * (g7 - g8);
		g4 += v * (g2 - g4);
		g8 += v * (g6 - g8);
		return g8 + w * (g4 - g8);
	},
	setSeed: function(seed) {
		seed = (Std().default).int(seed * 16807.0 % 2147483647);
		this.x_offset = seed;
		seed = (Std().default).int(seed * 16807.0 % 2147483647);
		this.y_offset = seed;
		seed = (Std().default).int(seed * 16807.0 % 2147483647);
		this.z_offset = seed;
	}
});
PerlinNoise.prototype.__class__ = PerlinNoise.prototype.constructor = $hxClasses["openfl._internal.utils.PerlinNoise"] = PerlinNoise;

// Init



// Statics


PerlinNoise.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, statics : { P : { SuppressWarnings : ["checkstyle:ConstantName"]}}}
PerlinNoise.P = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]

// Export

exports.default = PerlinNoise;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/_internal/utils/TouchData.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/_internal/utils/TouchData.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl._internal.utils.TouchData

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var TouchData = function() {
	this.rollOutStack = [];
}

// Meta

TouchData.__name__ = "openfl._internal.utils.TouchData";
TouchData.__isInterface__ = false;
TouchData.prototype = {
	reset: function() {
		this.touch = null;
		this.touchDownTarget = null;
		this.touchOverTarget = null;
		this.rollOutStack.splice(0,this.rollOutStack.length);
	}
};
TouchData.prototype.__class__ = TouchData.prototype.constructor = $hxClasses["openfl._internal.utils.TouchData"] = TouchData;

// Init



// Statics


TouchData.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, fields : { touch : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
TouchData.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new TouchData();
},function(data) {
	data.reset();
})

// Export

exports.default = TouchData;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Application.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Application.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Application

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_app_Application() {return __webpack_require__(/*! ./../../lime/app/Application */ "./node_modules/openfl/lib/_gen/lime/app/Application.js");}
function openfl_display_Window() {return __webpack_require__(/*! ./../../openfl/display/Window */ "./node_modules/openfl/lib/_gen/openfl/display/Window.js");}
function openfl__$internal_Lib() {return __webpack_require__(/*! ./../../openfl/_internal/Lib */ "./node_modules/openfl/lib/_gen/openfl/_internal/Lib.js");}
function openfl_display_MovieClip() {return __webpack_require__(/*! ./../../openfl/display/MovieClip */ "./node_modules/openfl/lib/_gen/openfl/display/MovieClip.js");}
function openfl_display_LoaderInfo() {return __webpack_require__(/*! ./../../openfl/display/LoaderInfo */ "./node_modules/openfl/lib/_gen/openfl/display/LoaderInfo.js");}

// Constructor

var Application = function() {
	(lime_app_Application().default).call(this);
	if((openfl__$internal_Lib().default).application == null) {
		(openfl__$internal_Lib().default).application = this;
	}
	if((openfl__$internal_Lib().default).current == null) {
		(openfl__$internal_Lib().default).current = new (openfl_display_MovieClip().default)();
	}
	(openfl__$internal_Lib().default).current.__loaderInfo = (openfl_display_LoaderInfo().default).create(null);
	(openfl__$internal_Lib().default).current.__loaderInfo.content = (openfl__$internal_Lib().default).current;
}

// Meta

Application.__name__ = "openfl.display.Application";
Application.__isInterface__ = false;
Application.__super__ = (lime_app_Application().default);
Application.prototype = $extend((lime_app_Application().default).prototype, {
	createWindow: function(attributes) {
		var $window = new (openfl_display_Window().default)(this,attributes);
		this.__windows.push($window);
		this.__windowByID.set($window.id,$window);
		var f = $bind(this,this.__onWindowClose);
		var window1 = $window;
		var tmp = function() {
			f(window1);
		};
		$window.onClose.add(tmp,false,-10000);
		if(this.__window == null) {
			this.__window = $window;
			$window.onActivate.add($bind(this,this.onWindowActivate));
			$window.onRenderContextLost.add($bind(this,this.onRenderContextLost));
			$window.onRenderContextRestored.add($bind(this,this.onRenderContextRestored));
			$window.onDeactivate.add($bind(this,this.onWindowDeactivate));
			$window.onDropFile.add($bind(this,this.onWindowDropFile));
			$window.onEnter.add($bind(this,this.onWindowEnter));
			$window.onExpose.add($bind(this,this.onWindowExpose));
			$window.onFocusIn.add($bind(this,this.onWindowFocusIn));
			$window.onFocusOut.add($bind(this,this.onWindowFocusOut));
			$window.onFullscreen.add($bind(this,this.onWindowFullscreen));
			$window.onKeyDown.add($bind(this,this.onKeyDown));
			$window.onKeyUp.add($bind(this,this.onKeyUp));
			$window.onLeave.add($bind(this,this.onWindowLeave));
			$window.onMinimize.add($bind(this,this.onWindowMinimize));
			$window.onMouseDown.add($bind(this,this.onMouseDown));
			$window.onMouseMove.add($bind(this,this.onMouseMove));
			$window.onMouseMoveRelative.add($bind(this,this.onMouseMoveRelative));
			$window.onMouseUp.add($bind(this,this.onMouseUp));
			$window.onMouseWheel.add($bind(this,this.onMouseWheel));
			$window.onMove.add($bind(this,this.onWindowMove));
			$window.onRender.add($bind(this,this.render));
			$window.onResize.add($bind(this,this.onWindowResize));
			$window.onRestore.add($bind(this,this.onWindowRestore));
			$window.onTextEdit.add($bind(this,this.onTextEdit));
			$window.onTextInput.add($bind(this,this.onTextInput));
			this.onWindowCreate();
		}
		this.onCreateWindow.dispatch($window);
		return $window;
	}
});
Application.prototype.__class__ = Application.prototype.constructor = $hxClasses["openfl.display.Application"] = Application;

// Init



// Statics


Application.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Application;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Bitmap.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Bitmap.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Bitmap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_DisplayObject() {return __webpack_require__(/*! ./../../openfl/display/DisplayObject */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function openfl__$internal_renderer_canvas_CanvasBitmap() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/canvas/CanvasBitmap */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasBitmap.js");}
function openfl__$internal_renderer_canvas_CanvasDisplayObject() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/canvas/CanvasDisplayObject */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasDisplayObject.js");}
function openfl__$internal_renderer_dom_DOMBitmap() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/dom/DOMBitmap */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMBitmap.js");}
function openfl__$internal_renderer_dom_DOMDisplayObject() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/dom/DOMDisplayObject */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMDisplayObject.js");}
function openfl__$internal_renderer_context3D_Context3DBitmap() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DBitmap */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DBitmap.js");}
function openfl__$internal_renderer_context3D_Context3DDisplayObject() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DDisplayObject */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DDisplayObject.js");}

// Constructor

var Bitmap = function(bitmapData,pixelSnapping,smoothing) {
	if(smoothing == null) {
		smoothing = false;
	}
	(openfl_display_DisplayObject().default).call(this);
	this.__bitmapData = bitmapData;
	this.pixelSnapping = pixelSnapping;
	this.smoothing = smoothing;
	if(pixelSnapping == null) {
		this.pixelSnapping = "auto";
	}
}

// Meta

Bitmap.__name__ = "openfl.display.Bitmap";
Bitmap.__isInterface__ = false;
Bitmap.__super__ = (openfl_display_DisplayObject().default);
Bitmap.prototype = $extend((openfl_display_DisplayObject().default).prototype, {
	__enterFrame: function(deltaTime) {
		if(this.__bitmapData != null && this.__bitmapData.image != null && this.__bitmapData.image.version != this.__imageVersion) {
			this.__setRenderDirty();
		}
	},
	__getBounds: function(rect,matrix) {
		var bounds = (openfl_geom_Rectangle().default).__pool.get();
		if(this.__bitmapData != null) {
			bounds.setTo(0,0,this.__bitmapData.width,this.__bitmapData.height);
		} else {
			bounds.setTo(0,0,0,0);
		}
		bounds.__transform(bounds,matrix);
		rect.__expand(bounds.x,bounds.y,bounds.width,bounds.height);
		(openfl_geom_Rectangle().default).__pool.release(bounds);
	},
	__hitTest: function(x,y,shapeFlag,stack,interactiveOnly,hitObject) {
		if(!hitObject.get_visible() || this.__isMask || this.__bitmapData == null) {
			return false;
		}
		if(this.get_mask() != null && !this.get_mask().__hitTestMask(x,y)) {
			return false;
		}
		this.__getRenderTransform();
		var px = this.__renderTransform.__transformInverseX(x,y);
		var py = this.__renderTransform.__transformInverseY(x,y);
		if(px > 0 && py > 0 && px <= this.__bitmapData.width && py <= this.__bitmapData.height) {
			if(this.__scrollRect != null && !this.__scrollRect.contains(px,py)) {
				return false;
			}
			if(stack != null && !interactiveOnly) {
				stack.push(hitObject);
			}
			return true;
		}
		return false;
	},
	__hitTestMask: function(x,y) {
		if(this.__bitmapData == null) {
			return false;
		}
		this.__getRenderTransform();
		var px = this.__renderTransform.__transformInverseX(x,y);
		var py = this.__renderTransform.__transformInverseY(x,y);
		if(px > 0 && py > 0 && px <= this.__bitmapData.width && py <= this.__bitmapData.height) {
			return true;
		}
		return false;
	},
	__renderCairo: function(renderer) {
	},
	__renderCairoMask: function(renderer) {
		renderer.cairo.rectangle(0,0,this.get_width(),this.get_height());
	},
	__renderCanvas: function(renderer) {
		this.__updateCacheBitmap(renderer,false);
		if(this.__bitmapData != null && this.__bitmapData.image != null) {
			this.__imageVersion = this.__bitmapData.image.version;
		}
		if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
			(openfl__$internal_renderer_canvas_CanvasBitmap().default).render(this.__cacheBitmap,renderer);
		} else {
			(openfl__$internal_renderer_canvas_CanvasDisplayObject().default).render(this,renderer);
			(openfl__$internal_renderer_canvas_CanvasBitmap().default).render(this,renderer);
		}
		this.__renderEvent(renderer);
	},
	__renderCanvasMask: function(renderer) {
		renderer.context.rect(0,0,this.get_width(),this.get_height());
	},
	__renderDOM: function(renderer) {
		this.__updateCacheBitmap(renderer,false);
		if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
			this.__renderDOMClear(renderer);
			this.__cacheBitmap.stage = this.stage;
			(openfl__$internal_renderer_dom_DOMBitmap().default).render(this.__cacheBitmap,renderer);
		} else {
			(openfl__$internal_renderer_dom_DOMDisplayObject().default).render(this,renderer);
			(openfl__$internal_renderer_dom_DOMBitmap().default).render(this,renderer);
		}
		this.__renderEvent(renderer);
	},
	__renderDOMClear: function(renderer) {
		(openfl__$internal_renderer_dom_DOMBitmap().default).clear(this,renderer);
	},
	__renderGL: function(renderer) {
		this.__updateCacheBitmap(renderer,false);
		if(this.__bitmapData != null && this.__bitmapData.image != null) {
			this.__imageVersion = this.__bitmapData.image.version;
		}
		if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
			(openfl__$internal_renderer_context3D_Context3DBitmap().default).render(this.__cacheBitmap,renderer);
		} else {
			(openfl__$internal_renderer_context3D_Context3DDisplayObject().default).render(this,renderer);
			(openfl__$internal_renderer_context3D_Context3DBitmap().default).render(this,renderer);
		}
		this.__renderEvent(renderer);
	},
	__renderGLMask: function(renderer) {
		(openfl__$internal_renderer_context3D_Context3DBitmap().default).renderMask(this,renderer);
	},
	__updateCacheBitmap: function(renderer,force) {
		if(this.__bitmapData == null || this.__filters == null && renderer.__type == "opengl" && this.__cacheBitmap == null) {
			return false;
		}
		return (openfl_display_DisplayObject().default).prototype.__updateCacheBitmap.call(this,renderer,this.__bitmapData.image != null && this.__bitmapData.image.version != this.__imageVersion);
	},
	get_bitmapData: function() {
		return this.__bitmapData;
	},
	set_bitmapData: function(value) {
		this.__bitmapData = value;
		this.smoothing = false;
		this.__setRenderDirty();
		var tmp = this.__filters != null;
		this.__imageVersion = -1;
		return this.__bitmapData;
	},
	set_height: function(value) {
		if(this.__bitmapData != null) {
			this.set_scaleY(value / this.__bitmapData.height);
		} else {
			this.set_scaleY(0);
		}
		return value;
	},
	set_width: function(value) {
		if(this.__bitmapData != null) {
			this.set_scaleX(value / this.__bitmapData.width);
		} else {
			this.set_scaleX(0);
		}
		return value;
	}
});
Bitmap.prototype.__class__ = Bitmap.prototype.constructor = $hxClasses["openfl.display.Bitmap"] = Bitmap;

// Init

Object.defineProperty(Bitmap.prototype,"bitmapData",{ get : function () { return this.get_bitmapData (); }, set : function (v) { return this.set_bitmapData (v); }});

// Statics




// Export

exports.default = Bitmap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.BitmapData

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_display_IBitmapDrawable() {return __webpack_require__(/*! ./../../openfl/display/IBitmapDrawable */ "./node_modules/openfl/lib/_gen/openfl/display/IBitmapDrawable.js");}
function lime_graphics_ImageChannel() {return __webpack_require__(/*! ./../../lime/graphics/ImageChannel */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageChannel.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function openfl_geom_ColorTransform() {return __webpack_require__(/*! ./../../openfl/geom/ColorTransform */ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js");}
function openfl_Lib() {return __webpack_require__(/*! ./../../openfl/Lib */ "./node_modules/openfl/lib/_gen/openfl/Lib.js");}
function lime_app_Application() {return __webpack_require__(/*! ./../../lime/app/Application */ "./node_modules/openfl/lib/_gen/lime/app/Application.js");}
function openfl_display_OpenGLRenderer() {return __webpack_require__(/*! ./../../openfl/display/OpenGLRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/OpenGLRenderer.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function openfl_display_CanvasRenderer() {return __webpack_require__(/*! ./../../openfl/display/CanvasRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/CanvasRenderer.js");}
function openfl_utils_ByteArrayData() {return __webpack_require__(/*! ./../../openfl/utils/ByteArrayData */ "./node_modules/openfl/lib/_gen/openfl/utils/ByteArrayData.js");}
function openfl_display_PNGEncoderOptions() {return __webpack_require__(/*! ./../../openfl/display/PNGEncoderOptions */ "./node_modules/openfl/lib/_gen/openfl/display/PNGEncoderOptions.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function lime_graphics_ImageFileFormat() {return __webpack_require__(/*! ./../../lime/graphics/ImageFileFormat */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageFileFormat.js");}
function openfl_display_JPEGEncoderOptions() {return __webpack_require__(/*! ./../../openfl/display/JPEGEncoderOptions */ "./node_modules/openfl/lib/_gen/openfl/display/JPEGEncoderOptions.js");}
function js_Boot() {return __webpack_require__(/*! ./../../js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}
function lime_graphics_cairo__$CairoImageSurface_CairoImageSurface_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/cairo/_CairoImageSurface/CairoImageSurface_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/cairo/_CairoImageSurface/CairoImageSurface_Impl_.js");}
function lime_graphics_cairo__$CairoSurface_CairoSurface_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/cairo/_CairoSurface/CairoSurface_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/cairo/_CairoSurface/CairoSurface_Impl_.js");}
function openfl_display3D_textures_TextureBase() {return __webpack_require__(/*! ./../../openfl/display3D/textures/TextureBase */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/TextureBase.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl_display_Bitmap() {return __webpack_require__(/*! ./../../openfl/display/Bitmap */ "./node_modules/openfl/lib/_gen/openfl/display/Bitmap.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function openfl__$internal_utils_PerlinNoise() {return __webpack_require__(/*! ./../../openfl/_internal/utils/PerlinNoise */ "./node_modules/openfl/lib/_gen/openfl/_internal/utils/PerlinNoise.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_Error() {return __webpack_require__(/*! ./../../openfl/errors/Error */ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js");}
function openfl_utils__$Endian_Endian_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_Endian/Endian_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_Endian/Endian_Impl_.js");}
function openfl__$Vector_VectorIterator() {return __webpack_require__(/*! ./../../openfl/_Vector/VectorIterator */ "./node_modules/openfl/lib/_gen/openfl/_Vector/VectorIterator.js");}
function lime_graphics_Image() {return __webpack_require__(/*! ./../../lime/graphics/Image */ "./node_modules/openfl/lib/_gen/lime/graphics/Image.js");}
function lime_math_Vector2() {return __webpack_require__(/*! ./../../lime/math/Vector2 */ "./node_modules/openfl/lib/_gen/lime/math/Vector2.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function lime_graphics_ImageType() {return __webpack_require__(/*! ./../../lime/graphics/ImageType */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageType.js");}

// Constructor

var BitmapData = function(width,height,transparent,fillColor) {
	if(fillColor == null) {
		fillColor = -1;
	}
	if(transparent == null) {
		transparent = true;
	}
	this.transparent = transparent;
	width = width == null ? 0 : width;
	height = height == null ? 0 : height;
	width = width < 0 ? 0 : width;
	height = height < 0 ? 0 : height;
	this.width = width;
	this.height = height;
	this.rect = new (openfl_geom_Rectangle().default)(0,0,width,height);
	this.__textureWidth = width;
	this.__textureHeight = height;
	if(width > 0 && height > 0) {
		if(transparent) {
			if((fillColor & -16777216) == 0) {
				fillColor = 0;
			}
		} else {
			fillColor = -16777216 | fillColor & 16777215;
		}
		fillColor = fillColor << 8 | fillColor >>> 24 & 255;
		this.image = new (lime_graphics_Image().default)(null,0,0,width,height,fillColor);
		this.image.set_transparent(transparent);
		this.__isValid = true;
		this.readable = true;
	}
	this.__renderTransform = new (openfl_geom_Matrix().default)();
	this.__worldAlpha = 1;
	this.__worldTransform = new (openfl_geom_Matrix().default)();
	this.__worldColorTransform = new (openfl_geom_ColorTransform().default)();
	this.__renderable = true;
}

// Meta

BitmapData.__name__ = "openfl.display.BitmapData";
BitmapData.__isInterface__ = false;
BitmapData.__interfaces__ = [(openfl_display_IBitmapDrawable().default)];
BitmapData.prototype = {
	applyFilter: function(sourceBitmapData,sourceRect,destPoint,filter) {
		if(!this.readable || sourceBitmapData == null || !sourceBitmapData.readable) {
			return;
		}
		var needSecondBitmapData = filter.__needSecondBitmapData;
		var needCopyOfOriginal = filter.__preserveObject;
		var bitmapData2 = null;
		var bitmapData3 = null;
		if(needSecondBitmapData) {
			bitmapData2 = new BitmapData(this.width,this.height,true,0);
		} else {
			bitmapData2 = this;
		}
		if(needCopyOfOriginal) {
			bitmapData3 = new BitmapData(this.width,this.height,true,0);
		}
		if(filter.__preserveObject) {
			bitmapData3.copyPixels(this,this.rect,destPoint);
		}
		var lastBitmap = filter.__applyFilter(bitmapData2,this,sourceRect,destPoint);
		if(filter.__preserveObject) {
			lastBitmap.draw(bitmapData3,null,null);
		}
		if(needSecondBitmapData && lastBitmap == bitmapData2) {
			bitmapData2.image.version = this.image.version;
			this.image = bitmapData2.image;
		}
		this.image.dirty = true;
		this.image.version++;
	},
	clone: function() {
		var bitmapData;
		if(!this.__isValid) {
			bitmapData = new BitmapData(this.width,this.height,this.transparent,0);
		} else if(!this.readable && this.image == null) {
			bitmapData = new BitmapData(0,0,this.transparent,0);
			bitmapData.width = this.width;
			bitmapData.height = this.height;
			bitmapData.__textureWidth = this.__textureWidth;
			bitmapData.__textureHeight = this.__textureHeight;
			bitmapData.rect.copyFrom(this.rect);
			bitmapData.__framebuffer = this.__framebuffer;
			bitmapData.__framebufferContext = this.__framebufferContext;
			bitmapData.__texture = this.__texture;
			bitmapData.__textureContext = this.__textureContext;
			bitmapData.__isValid = true;
		} else {
			bitmapData = BitmapData.fromImage(this.image.clone(),this.transparent);
		}
		bitmapData.__worldTransform.copyFrom(this.__worldTransform);
		bitmapData.__renderTransform.copyFrom(this.__renderTransform);
		return bitmapData;
	},
	colorTransform: function(rect,colorTransform) {
		if(!this.readable) {
			return;
		}
		this.image.colorTransform(rect.__toLimeRectangle(),colorTransform.__toLimeColorMatrix());
	},
	compare: function(otherBitmapData) {
		if(otherBitmapData == this) {
			return 0;
		} else if(otherBitmapData == null) {
			return -1;
		} else if(this.readable == false || otherBitmapData.readable == false) {
			return -2;
		} else if(this.width != otherBitmapData.width) {
			return -3;
		} else if(this.height != otherBitmapData.height) {
			return -4;
		}
		if(this.image != null && otherBitmapData.image != null && this.image.get_format() == otherBitmapData.image.get_format()) {
			var bytes = this.image.get_data();
			var otherBytes = otherBitmapData.image.get_data();
			var equal = true;
			var _g = 0;
			var _g1 = bytes.length;
			while(_g < _g1) {
				var i = _g++;
				if(bytes[i] != otherBytes[i]) {
					equal = false;
					break;
				}
			}
			if(equal) {
				return 0;
			}
		}
		var bitmapData = null;
		var foundDifference;
		var pixel;
		var otherPixel;
		var comparePixel;
		var r;
		var g;
		var b;
		var a;
		var _g2 = 0;
		var _g11 = this.height;
		while(_g2 < _g11) {
			var y = _g2++;
			var _g3 = 0;
			var _g12 = this.width;
			while(_g3 < _g12) {
				var x = _g3++;
				foundDifference = false;
				pixel = this.getPixel32(x,y);
				otherPixel = otherBitmapData.getPixel32(x,y);
				comparePixel = 0;
				if(pixel != otherPixel) {
					r = (pixel >>> 16 & 255) - (otherPixel >>> 16 & 255);
					g = (pixel >>> 8 & 255) - (otherPixel >>> 8 & 255);
					b = (pixel & 255) - (otherPixel & 255);
					if(r < 0) {
						r *= -1;
					}
					if(g < 0) {
						g *= -1;
					}
					if(b < 0) {
						b *= -1;
					}
					if(r == 0 && g == 0 && b == 0) {
						a = (pixel >>> 24 & 255) - (otherPixel >>> 24 & 255);
						if(a != 0) {
							comparePixel = (comparePixel >>> 24 & 255 & 255) << 24 | 16711680 | (comparePixel >>> 8 & 255 & 255) << 8 | comparePixel & 255 & 255;
							comparePixel = (comparePixel >>> 24 & 255 & 255) << 24 | (comparePixel >>> 16 & 255 & 255) << 16 | 65280 | comparePixel & 255 & 255;
							comparePixel = (comparePixel >>> 24 & 255 & 255) << 24 | (comparePixel >>> 16 & 255 & 255) << 16 | (comparePixel >>> 8 & 255 & 255) << 8 | 255;
							comparePixel = (a & 255) << 24 | (comparePixel >>> 16 & 255 & 255) << 16 | (comparePixel >>> 8 & 255 & 255) << 8 | comparePixel & 255 & 255;
							foundDifference = true;
						}
					} else {
						comparePixel = (comparePixel >>> 24 & 255 & 255) << 24 | (r & 255) << 16 | (comparePixel >>> 8 & 255 & 255) << 8 | comparePixel & 255 & 255;
						comparePixel = (comparePixel >>> 24 & 255 & 255) << 24 | (comparePixel >>> 16 & 255 & 255) << 16 | (g & 255) << 8 | comparePixel & 255 & 255;
						comparePixel = (comparePixel >>> 24 & 255 & 255) << 24 | (comparePixel >>> 16 & 255 & 255) << 16 | (comparePixel >>> 8 & 255 & 255) << 8 | b & 255;
						comparePixel = -16777216 | (comparePixel >>> 16 & 255 & 255) << 16 | (comparePixel >>> 8 & 255 & 255) << 8 | comparePixel & 255 & 255;
						foundDifference = true;
					}
				}
				if(foundDifference) {
					if(bitmapData == null) {
						bitmapData = new BitmapData(this.width,this.height,this.transparent || otherBitmapData.transparent,0);
					}
					bitmapData.setPixel32(x,y,comparePixel);
				}
			}
		}
		if(bitmapData == null) {
			return 0;
		}
		return bitmapData;
	},
	copyChannel: function(sourceBitmapData,sourceRect,destPoint,sourceChannel,destChannel) {
		if(!this.readable) {
			return;
		}
		var sourceChannel1;
		switch(sourceChannel) {
		case 1:
			sourceChannel1 = (lime_graphics_ImageChannel().default).RED;
			break;
		case 2:
			sourceChannel1 = (lime_graphics_ImageChannel().default).GREEN;
			break;
		case 4:
			sourceChannel1 = (lime_graphics_ImageChannel().default).BLUE;
			break;
		case 8:
			sourceChannel1 = (lime_graphics_ImageChannel().default).ALPHA;
			break;
		default:
			return;
		}
		var destChannel1;
		switch(destChannel) {
		case 1:
			destChannel1 = (lime_graphics_ImageChannel().default).RED;
			break;
		case 2:
			destChannel1 = (lime_graphics_ImageChannel().default).GREEN;
			break;
		case 4:
			destChannel1 = (lime_graphics_ImageChannel().default).BLUE;
			break;
		case 8:
			destChannel1 = (lime_graphics_ImageChannel().default).ALPHA;
			break;
		default:
			return;
		}
		this.image.copyChannel(sourceBitmapData.image,sourceRect.__toLimeRectangle(),destPoint.__toLimeVector2(),sourceChannel1,destChannel1);
	},
	copyPixels: function(sourceBitmapData,sourceRect,destPoint,alphaBitmapData,alphaPoint,mergeAlpha) {
		if(mergeAlpha == null) {
			mergeAlpha = false;
		}
		if(!this.readable || sourceBitmapData == null) {
			return;
		}
		if(alphaPoint != null) {
			BitmapData.__tempVector.x = alphaPoint.x;
			BitmapData.__tempVector.y = alphaPoint.y;
		}
		this.image.copyPixels(sourceBitmapData.image,sourceRect.__toLimeRectangle(),destPoint.__toLimeVector2(),alphaBitmapData != null ? alphaBitmapData.image : null,alphaPoint != null ? BitmapData.__tempVector : null,mergeAlpha);
	},
	dispose: function() {
		this.image = null;
		this.width = 0;
		this.height = 0;
		this.rect = null;
		this.__isValid = false;
		this.readable = false;
		this.__surface = null;
		this.__vertexBuffer = null;
		this.__framebuffer = null;
		this.__framebufferContext = null;
		this.__texture = null;
		this.__textureContext = null;
	},
	disposeImage: function() {
		this.readable = false;
	},
	draw: function(source,matrix,colorTransform,blendMode,clipRect,smoothing) {
		if(smoothing == null) {
			smoothing = false;
		}
		if(source == null) {
			return;
		}
		source.__update(false,true);
		var transform = (openfl_geom_Matrix().default).__pool.get();
		transform.copyFrom(source.__renderTransform);
		transform.invert();
		if(matrix != null) {
			transform.concat(matrix);
		}
		var clipMatrix = null;
		if(clipRect != null) {
			clipMatrix = (openfl_geom_Matrix().default).__pool.get();
			clipMatrix.copyFrom(transform);
			clipMatrix.invert();
		}
		var _colorTransform = new (openfl_geom_ColorTransform().default)();
		_colorTransform.__copyFrom(source.__worldColorTransform);
		_colorTransform.__invert();
		if(!this.readable && (openfl_Lib().default).get_current().stage.context3D != null) {
			if(this.__textureContext == null) {
				this.__textureContext = (lime_app_Application().default).current.get_window().context;
			}
			if(colorTransform != null) {
				_colorTransform.__combine(colorTransform);
			}
			var renderer = new (openfl_display_OpenGLRenderer().default)((openfl_Lib().default).get_current().stage.context3D,this);
			renderer.__allowSmoothing = smoothing;
			renderer.__overrideBlendMode = blendMode;
			renderer.__worldTransform = transform;
			renderer.__worldAlpha = 1 / source.__worldAlpha;
			renderer.__worldColorTransform = _colorTransform;
			renderer.__resize(this.width,this.height);
			if(clipRect != null) {
				renderer.__pushMaskRect(clipRect,clipMatrix);
			}
			this.__drawGL(source,renderer);
			if(clipRect != null) {
				renderer.__popMaskRect();
				(openfl_geom_Matrix().default).__pool.release(clipMatrix);
			}
		} else {
			if(colorTransform != null) {
				var bounds = (openfl_geom_Rectangle().default).__pool.get();
				var boundsMatrix = (openfl_geom_Matrix().default).__pool.get();
				source.__getBounds(bounds,boundsMatrix);
				var width = Math.ceil(bounds.width);
				var height = Math.ceil(bounds.height);
				boundsMatrix.tx = -bounds.x;
				boundsMatrix.ty = -bounds.y;
				var copy = new BitmapData(width,height,true,0);
				copy.draw(source,boundsMatrix);
				copy.colorTransform(copy.rect,colorTransform);
				copy.__renderTransform.identity();
				copy.__renderTransform.tx = bounds.x;
				copy.__renderTransform.ty = bounds.y;
				copy.__renderTransform.concat(source.__renderTransform);
				copy.__worldAlpha = source.__worldAlpha;
				copy.__worldColorTransform.__copyFrom(source.__worldColorTransform);
				source = copy;
				(openfl_geom_Rectangle().default).__pool.release(bounds);
				(openfl_geom_Matrix().default).__pool.release(boundsMatrix);
			}
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(this.image);
			var renderer1 = new (openfl_display_CanvasRenderer().default)(this.image.buffer.__srcContext);
			renderer1.__allowSmoothing = smoothing;
			renderer1.__overrideBlendMode = blendMode;
			renderer1.__worldTransform = transform;
			renderer1.__worldAlpha = 1 / source.__worldAlpha;
			renderer1.__worldColorTransform = _colorTransform;
			if(clipRect != null) {
				renderer1.__pushMaskRect(clipRect,clipMatrix);
			}
			this.__drawCanvas(source,renderer1);
			if(clipRect != null) {
				renderer1.__popMaskRect();
				(openfl_geom_Matrix().default).__pool.release(clipMatrix);
			}
		}
		(openfl_geom_Matrix().default).__pool.release(transform);
	},
	drawWithQuality: function(source,matrix,colorTransform,blendMode,clipRect,smoothing,quality) {
		if(smoothing == null) {
			smoothing = false;
		}
		this.draw(source,matrix,colorTransform,blendMode,clipRect,quality != "low" && smoothing);
	},
	encode: function(rect,compressor,byteArray) {
		if(!this.readable || rect == null) {
			byteArray = null;
			return byteArray;
		}
		if(byteArray == null) {
			var this1 = new (openfl_utils_ByteArrayData().default)(0);
			byteArray = this1;
		}
		var image = this.image;
		if(!rect.equals(this.rect)) {
			var matrix = (openfl_geom_Matrix().default).__pool.get();
			matrix.tx = Math.round(-rect.x);
			matrix.ty = Math.round(-rect.y);
			var bitmapData = new BitmapData(Math.ceil(rect.width),Math.ceil(rect.height),true,0);
			bitmapData.draw(this,matrix);
			image = bitmapData.image;
			(openfl_geom_Matrix().default).__pool.release(matrix);
		}
		if(((compressor) instanceof (openfl_display_PNGEncoderOptions().default))) {
			byteArray.writeBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(image.encode((lime_graphics_ImageFileFormat().default).PNG)),0,0);
			return byteArray;
		} else if(((compressor) instanceof (openfl_display_JPEGEncoderOptions().default))) {
			byteArray.writeBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(image.encode((lime_graphics_ImageFileFormat().default).JPEG,((js_Boot().default).__cast(compressor , (openfl_display_JPEGEncoderOptions().default))).quality)),0,0);
			return byteArray;
		}
		byteArray = null;
		return byteArray;
	},
	fillRect: function(rect,color) {
		this.__fillRect(rect,color,true);
	},
	floodFill: function(x,y,color) {
		if(!this.readable) {
			return;
		}
		this.image.floodFill(x,y,color,1);
	},
	generateFilterRect: function(sourceRect,filter) {
		return sourceRect.clone();
	},
	getIndexBuffer: function(context,scale9Grid) {
		var gl = context.gl;
		if(this.__indexBuffer == null || this.__indexBufferContext != context.__context || scale9Grid != null && this.__indexBufferGrid == null || this.__indexBufferGrid != null && !this.__indexBufferGrid.equals(scale9Grid)) {
			this.__indexBufferContext = context.__context;
			this.__indexBuffer = null;
			if(scale9Grid != null) {
				if(this.__indexBufferGrid == null) {
					this.__indexBufferGrid = new (openfl_geom_Rectangle().default)();
				}
				this.__indexBufferGrid.copyFrom(scale9Grid);
				var centerX = scale9Grid.width;
				var centerY = scale9Grid.height;
				if(centerX != 0 && centerY != 0) {
					var array = null;
					var view = null;
					var buffer = null;
					var len = null;
					var this1 = new Uint16Array(54);
					this.__indexBufferData = this1;
					this.__indexBufferData[0] = 0;
					this.__indexBufferData[1] = 1;
					this.__indexBufferData[2] = 2;
					this.__indexBufferData[3] = 2;
					this.__indexBufferData[4] = 1;
					this.__indexBufferData[5] = 3;
					this.__indexBufferData[6] = 4;
					this.__indexBufferData[7] = 0;
					this.__indexBufferData[8] = 5;
					this.__indexBufferData[9] = 5;
					this.__indexBufferData[10] = 0;
					this.__indexBufferData[11] = 2;
					this.__indexBufferData[12] = 6;
					this.__indexBufferData[13] = 4;
					this.__indexBufferData[14] = 7;
					this.__indexBufferData[15] = 7;
					this.__indexBufferData[16] = 4;
					this.__indexBufferData[17] = 5;
					this.__indexBufferData[18] = 8;
					this.__indexBufferData[19] = 9;
					this.__indexBufferData[20] = 0;
					this.__indexBufferData[21] = 0;
					this.__indexBufferData[22] = 9;
					this.__indexBufferData[23] = 1;
					this.__indexBufferData[24] = 10;
					this.__indexBufferData[25] = 8;
					this.__indexBufferData[26] = 4;
					this.__indexBufferData[27] = 4;
					this.__indexBufferData[28] = 8;
					this.__indexBufferData[29] = 0;
					this.__indexBufferData[30] = 11;
					this.__indexBufferData[31] = 10;
					this.__indexBufferData[32] = 6;
					this.__indexBufferData[33] = 6;
					this.__indexBufferData[34] = 10;
					this.__indexBufferData[35] = 4;
					this.__indexBufferData[36] = 12;
					this.__indexBufferData[37] = 13;
					this.__indexBufferData[38] = 8;
					this.__indexBufferData[39] = 8;
					this.__indexBufferData[40] = 13;
					this.__indexBufferData[41] = 9;
					this.__indexBufferData[42] = 14;
					this.__indexBufferData[43] = 12;
					this.__indexBufferData[44] = 10;
					this.__indexBufferData[45] = 10;
					this.__indexBufferData[46] = 12;
					this.__indexBufferData[47] = 8;
					this.__indexBufferData[48] = 15;
					this.__indexBufferData[49] = 14;
					this.__indexBufferData[50] = 11;
					this.__indexBufferData[51] = 11;
					this.__indexBufferData[52] = 14;
					this.__indexBufferData[53] = 10;
					this.__indexBuffer = context.createIndexBuffer(54);
				} else if(centerX == 0 && centerY != 0) {
					var array1 = null;
					var view1 = null;
					var buffer1 = null;
					var len1 = null;
					var this2 = new Uint16Array(18);
					this.__indexBufferData = this2;
					this.__indexBufferData[0] = 0;
					this.__indexBufferData[1] = 1;
					this.__indexBufferData[2] = 2;
					this.__indexBufferData[3] = 2;
					this.__indexBufferData[4] = 1;
					this.__indexBufferData[5] = 3;
					this.__indexBufferData[6] = 4;
					this.__indexBufferData[7] = 5;
					this.__indexBufferData[8] = 0;
					this.__indexBufferData[9] = 0;
					this.__indexBufferData[10] = 5;
					this.__indexBufferData[11] = 1;
					this.__indexBufferData[12] = 6;
					this.__indexBufferData[13] = 7;
					this.__indexBufferData[14] = 4;
					this.__indexBufferData[15] = 4;
					this.__indexBufferData[16] = 7;
					this.__indexBufferData[17] = 5;
					this.__indexBuffer = context.createIndexBuffer(18);
				} else if(centerX != 0 && centerY == 0) {
					var array2 = null;
					var view2 = null;
					var buffer2 = null;
					var len2 = null;
					var this3 = new Uint16Array(18);
					this.__indexBufferData = this3;
					this.__indexBufferData[0] = 0;
					this.__indexBufferData[1] = 1;
					this.__indexBufferData[2] = 2;
					this.__indexBufferData[3] = 2;
					this.__indexBufferData[4] = 1;
					this.__indexBufferData[5] = 3;
					this.__indexBufferData[6] = 4;
					this.__indexBufferData[7] = 0;
					this.__indexBufferData[8] = 5;
					this.__indexBufferData[9] = 5;
					this.__indexBufferData[10] = 0;
					this.__indexBufferData[11] = 2;
					this.__indexBufferData[12] = 6;
					this.__indexBufferData[13] = 4;
					this.__indexBufferData[14] = 7;
					this.__indexBufferData[15] = 7;
					this.__indexBufferData[16] = 4;
					this.__indexBufferData[17] = 5;
					this.__indexBuffer = context.createIndexBuffer(18);
				}
			} else {
				this.__indexBufferGrid = null;
			}
			if(this.__indexBuffer == null) {
				var array3 = null;
				var view3 = null;
				var buffer3 = null;
				var len3 = null;
				var this4 = new Uint16Array(6);
				this.__indexBufferData = this4;
				this.__indexBufferData[0] = 0;
				this.__indexBufferData[1] = 1;
				this.__indexBufferData[2] = 2;
				this.__indexBufferData[3] = 2;
				this.__indexBufferData[4] = 1;
				this.__indexBufferData[5] = 3;
				this.__indexBuffer = context.createIndexBuffer(6);
			}
			this.__indexBuffer.uploadFromTypedArray(this.__indexBufferData);
		}
		return this.__indexBuffer;
	},
	getVertexBuffer: function(context,scale9Grid,targetObject) {
		var gl = context.gl;
		if(this.__vertexBuffer == null || this.__vertexBufferContext != context.__context || scale9Grid != null && this.__vertexBufferGrid == null || this.__vertexBufferGrid != null && !this.__vertexBufferGrid.equals(scale9Grid) || targetObject != null && (this.__vertexBufferWidth != targetObject.get_width() || this.__vertexBufferHeight != targetObject.get_height() || this.__vertexBufferScaleX != targetObject.get_scaleX() || this.__vertexBufferScaleY != targetObject.get_scaleY())) {
			this.__uvRect = new (openfl_geom_Rectangle().default)(0,0,this.width,this.height);
			var uvWidth = 1;
			var uvHeight = 1;
			this.__vertexBufferContext = context.__context;
			this.__vertexBuffer = null;
			if(targetObject != null) {
				this.__vertexBufferWidth = targetObject.get_width();
				this.__vertexBufferHeight = targetObject.get_height();
				this.__vertexBufferScaleX = targetObject.get_scaleX();
				this.__vertexBufferScaleY = targetObject.get_scaleY();
			}
			if(scale9Grid != null && targetObject != null) {
				if(this.__vertexBufferGrid == null) {
					this.__vertexBufferGrid = new (openfl_geom_Rectangle().default)();
				}
				this.__vertexBufferGrid.copyFrom(scale9Grid);
				this.__vertexBufferWidth = targetObject.get_width();
				this.__vertexBufferHeight = targetObject.get_height();
				this.__vertexBufferScaleX = targetObject.get_scaleX();
				this.__vertexBufferScaleY = targetObject.get_scaleY();
				var centerX = scale9Grid.width;
				var centerY = scale9Grid.height;
				if(centerX != 0 && centerY != 0) {
					var array = null;
					var view = null;
					var buffer = null;
					var len = null;
					var this1 = new Float32Array(224);
					this.__vertexBufferData = this1;
					var left = scale9Grid.x;
					var top = scale9Grid.y;
					var right = this.width - centerX - left;
					var bottom = this.height - centerY - top;
					var uvLeft = left / this.width;
					var uvTop = top / this.height;
					var uvCenterX = centerX / this.width;
					var uvCenterY = centerY / this.height;
					var uvRight = right / this.width;
					var uvBottom = bottom / this.height;
					var renderedLeft = left / targetObject.get_scaleX();
					var renderedTop = top / targetObject.get_scaleY();
					var renderedRight = right / targetObject.get_scaleX();
					var renderedBottom = bottom / targetObject.get_scaleY();
					var renderedCenterX = targetObject.get_width() / targetObject.get_scaleX() - renderedLeft - renderedRight;
					var renderedCenterY = targetObject.get_height() / targetObject.get_scaleY() - renderedTop - renderedBottom;
					this.__vertexBufferData[0] = renderedLeft;
					this.__vertexBufferData[1] = renderedTop;
					this.__vertexBufferData[3] = uvWidth * uvLeft;
					this.__vertexBufferData[4] = uvHeight * uvTop;
					this.__vertexBufferData[15] = renderedTop;
					this.__vertexBufferData[18] = uvHeight * uvTop;
					this.__vertexBufferData[28] = renderedLeft;
					this.__vertexBufferData[31] = uvWidth * uvLeft;
					this.__vertexBufferData[56] = renderedLeft + renderedCenterX;
					this.__vertexBufferData[57] = renderedTop;
					this.__vertexBufferData[59] = uvWidth * (uvLeft + uvCenterX);
					this.__vertexBufferData[60] = uvHeight * uvTop;
					this.__vertexBufferData[70] = renderedLeft + renderedCenterX;
					this.__vertexBufferData[73] = uvWidth * (uvLeft + uvCenterX);
					this.__vertexBufferData[84] = this.width;
					this.__vertexBufferData[85] = renderedTop;
					this.__vertexBufferData[87] = uvWidth;
					this.__vertexBufferData[88] = uvHeight * uvTop;
					this.__vertexBufferData[98] = this.width;
					this.__vertexBufferData[101] = uvWidth;
					this.__vertexBufferData[112] = renderedLeft;
					this.__vertexBufferData[113] = renderedTop + renderedCenterY;
					this.__vertexBufferData[115] = uvWidth * uvLeft;
					this.__vertexBufferData[116] = uvHeight * (uvTop + uvCenterY);
					this.__vertexBufferData[127] = renderedTop + renderedCenterY;
					this.__vertexBufferData[130] = uvHeight * (uvTop + uvCenterY);
					this.__vertexBufferData[140] = renderedLeft + renderedCenterX;
					this.__vertexBufferData[141] = renderedTop + renderedCenterY;
					this.__vertexBufferData[143] = uvWidth * (uvLeft + uvCenterX);
					this.__vertexBufferData[144] = uvHeight * (uvTop + uvCenterY);
					this.__vertexBufferData[154] = this.width;
					this.__vertexBufferData[155] = renderedTop + renderedCenterY;
					this.__vertexBufferData[157] = uvWidth;
					this.__vertexBufferData[158] = uvHeight * (uvTop + uvCenterY);
					this.__vertexBufferData[168] = renderedLeft;
					this.__vertexBufferData[169] = this.height;
					this.__vertexBufferData[171] = uvWidth * uvLeft;
					this.__vertexBufferData[172] = uvHeight;
					this.__vertexBufferData[183] = this.height;
					this.__vertexBufferData[186] = uvHeight;
					this.__vertexBufferData[196] = renderedLeft + renderedCenterX;
					this.__vertexBufferData[197] = this.height;
					this.__vertexBufferData[199] = uvWidth * (uvLeft + uvCenterX);
					this.__vertexBufferData[200] = uvHeight;
					this.__vertexBufferData[210] = this.width;
					this.__vertexBufferData[211] = this.height;
					this.__vertexBufferData[213] = uvWidth;
					this.__vertexBufferData[214] = uvHeight;
					this.__vertexBuffer = context.createVertexBuffer(16,14);
				} else if(centerX == 0 && centerY != 0) {
					var array1 = null;
					var view1 = null;
					var buffer1 = null;
					var len1 = null;
					var this2 = new Float32Array(112);
					this.__vertexBufferData = this2;
					var top1 = scale9Grid.y;
					var bottom1 = this.height - centerY - top1;
					var uvTop1 = top1 / this.height;
					var uvCenterY1 = centerY / this.height;
					var uvBottom1 = bottom1 / this.height;
					var renderedTop1 = top1 / targetObject.get_scaleY();
					var renderedBottom1 = bottom1 / targetObject.get_scaleY();
					var renderedCenterY1 = targetObject.get_height() / targetObject.get_scaleY() - renderedTop1 - renderedBottom1;
					var renderedWidth = targetObject.get_width() / targetObject.get_scaleX();
					this.__vertexBufferData[0] = renderedWidth;
					this.__vertexBufferData[1] = renderedTop1;
					this.__vertexBufferData[3] = uvWidth;
					this.__vertexBufferData[4] = uvHeight * uvTop1;
					this.__vertexBufferData[15] = renderedTop1;
					this.__vertexBufferData[18] = uvHeight * uvTop1;
					this.__vertexBufferData[28] = renderedWidth;
					this.__vertexBufferData[31] = uvWidth;
					this.__vertexBufferData[56] = renderedWidth;
					this.__vertexBufferData[57] = renderedTop1 + renderedCenterY1;
					this.__vertexBufferData[59] = uvWidth;
					this.__vertexBufferData[60] = uvHeight * (uvTop1 + uvCenterY1);
					this.__vertexBufferData[71] = renderedTop1 + renderedCenterY1;
					this.__vertexBufferData[74] = uvHeight * (uvTop1 + uvCenterY1);
					this.__vertexBufferData[84] = renderedWidth;
					this.__vertexBufferData[85] = this.height;
					this.__vertexBufferData[87] = uvWidth;
					this.__vertexBufferData[88] = uvHeight;
					this.__vertexBufferData[99] = this.height;
					this.__vertexBufferData[102] = uvHeight;
					this.__vertexBuffer = context.createVertexBuffer(8,14);
				} else if(centerY == 0 && centerX != 0) {
					var array2 = null;
					var view2 = null;
					var buffer2 = null;
					var len2 = null;
					var this3 = new Float32Array(112);
					this.__vertexBufferData = this3;
					var left1 = scale9Grid.x;
					var right1 = this.width - centerX - left1;
					var uvLeft1 = left1 / this.width;
					var uvCenterX1 = centerX / this.width;
					var uvRight1 = right1 / this.width;
					var renderedLeft1 = left1 / targetObject.get_scaleX();
					var renderedRight1 = right1 / targetObject.get_scaleX();
					var renderedCenterX1 = targetObject.get_width() / targetObject.get_scaleX() - renderedLeft1 - renderedRight1;
					var renderedHeight = targetObject.get_height() / targetObject.get_scaleY();
					this.__vertexBufferData[0] = renderedLeft1;
					this.__vertexBufferData[1] = renderedHeight;
					this.__vertexBufferData[3] = uvWidth * uvLeft1;
					this.__vertexBufferData[4] = uvHeight;
					this.__vertexBufferData[15] = renderedHeight;
					this.__vertexBufferData[18] = uvHeight;
					this.__vertexBufferData[28] = renderedLeft1;
					this.__vertexBufferData[31] = uvWidth * uvLeft1;
					this.__vertexBufferData[56] = renderedLeft1 + renderedCenterX1;
					this.__vertexBufferData[57] = renderedHeight;
					this.__vertexBufferData[59] = uvWidth * (uvLeft1 + uvCenterX1);
					this.__vertexBufferData[60] = uvHeight;
					this.__vertexBufferData[70] = renderedLeft1 + renderedCenterX1;
					this.__vertexBufferData[73] = uvWidth * (uvLeft1 + uvCenterX1);
					this.__vertexBufferData[84] = this.width;
					this.__vertexBufferData[85] = renderedHeight;
					this.__vertexBufferData[87] = uvWidth;
					this.__vertexBufferData[88] = uvHeight;
					this.__vertexBufferData[98] = this.width;
					this.__vertexBufferData[101] = uvWidth;
					this.__vertexBuffer = context.createVertexBuffer(8,14);
				}
			} else {
				this.__vertexBufferGrid = null;
			}
			if(this.__vertexBuffer == null) {
				var array3 = null;
				var view3 = null;
				var buffer3 = null;
				var len3 = null;
				var this4 = new Float32Array(56);
				this.__vertexBufferData = this4;
				this.__vertexBufferData[0] = this.width;
				this.__vertexBufferData[1] = this.height;
				this.__vertexBufferData[3] = uvWidth;
				this.__vertexBufferData[4] = uvHeight;
				this.__vertexBufferData[15] = this.height;
				this.__vertexBufferData[18] = uvHeight;
				this.__vertexBufferData[28] = this.width;
				this.__vertexBufferData[31] = uvWidth;
				this.__vertexBuffer = context.createVertexBuffer(3,14);
			}
			this.__vertexBuffer.uploadFromTypedArray(this.__vertexBufferData);
		}
		return this.__vertexBuffer;
	},
	getColorBoundsRect: function(mask,color,findColor) {
		if(findColor == null) {
			findColor = true;
		}
		if(!this.readable) {
			return new (openfl_geom_Rectangle().default)(0,0,this.width,this.height);
		}
		if(!this.transparent || (mask >> 24 & 255) > 0) {
			var color1 = color;
			if((color1 >>> 24 & 255) == 0) {
				color1 = 0;
			}
		}
		var rect = this.image.getColorBoundsRect(mask,color,findColor,1);
		return new (openfl_geom_Rectangle().default)(rect.x,rect.y,rect.width,rect.height);
	},
	getPixel: function(x,y) {
		if(!this.readable) {
			return 0;
		}
		return this.image.getPixel(x,y,1);
	},
	getPixel32: function(x,y) {
		if(!this.readable) {
			return 0;
		}
		return this.image.getPixel32(x,y,1);
	},
	getPixels: function(rect) {
		if(!this.readable) {
			return null;
		}
		if(rect == null) {
			rect = this.rect;
		}
		var byteArray = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(this.image.getPixels(rect.__toLimeRectangle(),1));
		byteArray.set_endian("bigEndian");
		return byteArray;
	},
	getSurface: function() {
		if(!this.readable) {
			return null;
		}
		if(this.__surface == null) {
			this.__surface = (lime_graphics_cairo__$CairoImageSurface_CairoImageSurface_$Impl_$().default).fromImage(this.image);
		}
		return this.__surface;
	},
	getTexture: function(context) {
		if(!this.__isValid) {
			return null;
		}
		if(this.__texture == null || this.__textureContext != context.__context) {
			this.__textureContext = context.__context;
			this.__texture = context.createRectangleTexture(this.width,this.height,"bgra",false);
			this.__textureVersion = -1;
		}
		(lime__$internal_graphics_ImageCanvasUtil().default).sync(this.image,false);
		if(this.image != null && this.image.version > this.__textureVersion) {
			if(this.__surface != null) {
				(lime_graphics_cairo__$CairoSurface_CairoSurface_$Impl_$().default).flush(this.__surface);
			}
			var textureImage = this.image;
			if(!(openfl_display3D_textures_TextureBase().default).__supportsBGRA && textureImage.get_format() != 0) {
				textureImage = textureImage.clone();
				textureImage.set_format(0);
			}
			this.__texture.__uploadFromImage(textureImage);
			this.__textureVersion = this.image.version;
			this.__textureWidth = textureImage.buffer.width;
			this.__textureHeight = textureImage.buffer.height;
		}
		if(!this.readable && this.image != null) {
			this.__surface = null;
			this.image = null;
		}
		return this.__texture;
	},
	getVector: function(rect) {
		var pixels = this.getPixels(rect);
		var length = (Std().default).int((_$UInt_UInt_$Impl_$().default).toFloat((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(pixels)) / (_$UInt_UInt_$Impl_$().default).toFloat(4));
		var result = (openfl__$Vector_Vector_$Impl_$().default)._new(length,true);
		var _g = 0;
		var _g1 = length;
		while(_g < _g1) {
			var i = _g++;
			(openfl__$Vector_Vector_$Impl_$().default).set(result,i,pixels.readUnsignedInt());
		}
		return result;
	},
	histogram: function(hRect) {
		var rect = hRect != null ? hRect : new (openfl_geom_Rectangle().default)(0,0,this.width,this.height);
		var pixels = this.getPixels(rect);
		var _g = [];
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < 256) {
			var j = _g2++;
			_g1.push(0);
		}
		_g.push(_g1);
		var _g11 = [];
		var _g21 = 0;
		while(_g21 < 256) {
			var j1 = _g21++;
			_g11.push(0);
		}
		_g.push(_g11);
		var _g12 = [];
		var _g22 = 0;
		while(_g22 < 256) {
			var j2 = _g22++;
			_g12.push(0);
		}
		_g.push(_g12);
		var _g13 = [];
		var _g23 = 0;
		while(_g23 < 256) {
			var j3 = _g23++;
			_g13.push(0);
		}
		_g.push(_g13);
		var result = _g;
		var _g14 = 0;
		var _g24 = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(pixels);
		while(_g14 < _g24) {
			var i = _g14++;
			var result1 = result[i % 4];
			++result1[pixels.readUnsignedByte()];
		}
		return result;
	},
	hitTest: function(firstPoint,firstAlphaThreshold,secondObject,secondBitmapDataPoint,secondAlphaThreshold) {
		if(secondAlphaThreshold == null) {
			secondAlphaThreshold = 1;
		}
		if(!this.readable) {
			return false;
		}
		if(((secondObject) instanceof (openfl_display_Bitmap().default))) {
			secondObject = ((js_Boot().default).__cast(secondObject , (openfl_display_Bitmap().default))).__bitmapData;
		}
		if(((secondObject) instanceof (openfl_geom_Point().default))) {
			var secondPoint = secondObject;
			var x = (Std().default).int(secondPoint.x - firstPoint.x);
			var y = (Std().default).int(secondPoint.y - firstPoint.y);
			if(this.rect.contains(x,y)) {
				var pixel = this.getPixel32(x,y);
				if((pixel >> 24 & 255) > firstAlphaThreshold) {
					return true;
				}
			}
		} else if(((secondObject) instanceof BitmapData)) {
			var secondBitmapData = secondObject;
			var x1;
			var y1;
			if(secondBitmapDataPoint == null) {
				x1 = 0;
				y1 = 0;
			} else {
				x1 = Math.round(secondBitmapDataPoint.x - firstPoint.x);
				y1 = Math.round(secondBitmapDataPoint.y - firstPoint.y);
			}
			var hitRect = (openfl_geom_Rectangle().default).__pool.get();
			hitRect.setTo(x1,y1,secondBitmapData.width,secondBitmapData.height);
			if(this.rect.intersects(hitRect)) {
				if(x1 < 0) {
					hitRect.x = 0;
					hitRect.width = Math.min(secondBitmapData.width + x1,this.width);
				} else {
					hitRect.width = Math.min(secondBitmapData.width,this.width - x1);
				}
				if(y1 < 0) {
					hitRect.y = 0;
					hitRect.height = Math.min(secondBitmapData.height + y1,this.height);
				} else {
					hitRect.height = Math.min(secondBitmapData.height,this.height - y1);
				}
				var pixels = this.getPixels(hitRect);
				hitRect.x = x1 < 0 ? -x1 : 0;
				hitRect.y = y1 < 0 ? -y1 : 0;
				var testPixels = secondBitmapData.getPixels(hitRect);
				var length = (Std().default).int(hitRect.width * hitRect.height);
				var pixel1;
				var testPixel;
				var _g = 0;
				var _g1 = length;
				while(_g < _g1) {
					var i = _g++;
					pixel1 = pixels.readUnsignedInt();
					testPixel = testPixels.readUnsignedInt();
					if((_$UInt_UInt_$Impl_$().default).gt(pixel1 >>> 24 & 255,firstAlphaThreshold) && (_$UInt_UInt_$Impl_$().default).gt(testPixel >>> 24 & 255,secondAlphaThreshold)) {
						(openfl_geom_Rectangle().default).__pool.release(hitRect);
						return true;
					}
				}
			}
			(openfl_geom_Rectangle().default).__pool.release(hitRect);
		} else if(((secondObject) instanceof (openfl_geom_Rectangle().default))) {
			var secondRectangle = (openfl_geom_Rectangle().default).__pool.get();
			secondRectangle.copyFrom(secondObject);
			secondRectangle.offset(-firstPoint.x,-firstPoint.y);
			secondRectangle.__contract(0,0,this.width,this.height);
			if(secondRectangle.width > 0 && secondRectangle.height > 0) {
				var pixels1 = this.getPixels(secondRectangle);
				var length1 = (Std().default).int((_$UInt_UInt_$Impl_$().default).toFloat((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(pixels1)) / (_$UInt_UInt_$Impl_$().default).toFloat(4));
				var pixel2;
				var _g2 = 0;
				var _g11 = length1;
				while(_g2 < _g11) {
					var i1 = _g2++;
					pixel2 = pixels1.readUnsignedInt();
					if((_$UInt_UInt_$Impl_$().default).gt(pixel2 >>> 24 & 255,firstAlphaThreshold)) {
						(openfl_geom_Rectangle().default).__pool.release(secondRectangle);
						return true;
					}
				}
			}
			(openfl_geom_Rectangle().default).__pool.release(secondRectangle);
		}
		return false;
	},
	lock: function() {
	},
	merge: function(sourceBitmapData,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier) {
		if(!this.readable || sourceBitmapData == null || !sourceBitmapData.readable || sourceRect == null || destPoint == null) {
			return;
		}
		this.image.merge(sourceBitmapData.image,sourceRect.__toLimeRectangle(),destPoint.__toLimeVector2(),redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier);
	},
	noise: function(randomSeed,low,high,channelOptions,grayScale) {
		if(grayScale == null) {
			grayScale = false;
		}
		if(channelOptions == null) {
			channelOptions = 7;
		}
		if(high == null) {
			high = 255;
		}
		if(low == null) {
			low = 0;
		}
		if(!this.readable) {
			return;
		}
		var func = function() {
			randomSeed = randomSeed * 1103515245 + 12345;
			return (Std().default).int(Math.abs(randomSeed / 65536)) % 32768;
		};
		var rand = func;
		rand();
		var range = high - low;
		var redChannel = (channelOptions & 1) == 1;
		var greenChannel = (channelOptions & 2) >> 1 == 1;
		var blueChannel = (channelOptions & 4) >> 2 == 1;
		var alphaChannel = (channelOptions & 8) >> 3 == 1;
		var _g = 0;
		var _g1 = this.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g11 = this.width;
			while(_g2 < _g11) {
				var x = _g2++;
				var red = 0;
				var blue = 0;
				var green = 0;
				var alpha = 255;
				if(grayScale) {
					blue = low + rand() % range;
					green = blue;
					red = green;
					alpha = 255;
				} else {
					if(redChannel) {
						red = low + rand() % range;
					}
					if(greenChannel) {
						green = low + rand() % range;
					}
					if(blueChannel) {
						blue = low + rand() % range;
					}
					if(alphaChannel) {
						alpha = low + rand() % range;
					}
				}
				var rgb = alpha;
				rgb = (rgb << 8) + red;
				rgb = (rgb << 8) + green;
				rgb = (rgb << 8) + blue;
				this.setPixel32(x,y,rgb);
			}
		}
	},
	paletteMap: function(sourceBitmapData,sourceRect,destPoint,redArray,greenArray,blueArray,alphaArray) {
		var sw = (Std().default).int(sourceRect.width);
		var sh = (Std().default).int(sourceRect.height);
		var pixels = sourceBitmapData.getPixels(sourceRect);
		var pixelValue;
		var r;
		var g;
		var b;
		var a;
		var color;
		var _g = 0;
		var _g1 = sh * sw;
		while(_g < _g1) {
			var i = _g++;
			pixelValue = pixels.readUnsignedInt();
			a = alphaArray == null ? pixelValue & -16777216 : alphaArray[pixelValue >> 24 & 255];
			r = redArray == null ? pixelValue & 16711680 : redArray[pixelValue >> 16 & 255];
			g = greenArray == null ? pixelValue & 65280 : greenArray[pixelValue >> 8 & 255];
			b = blueArray == null ? pixelValue & 255 : blueArray[pixelValue & 255];
			color = a + r + g + b;
			pixels.position = i * 4;
			pixels.writeUnsignedInt(color);
		}
		pixels.position = 0;
		var destRect = (openfl_geom_Rectangle().default).__pool.get();
		destRect.setTo(destPoint.x,destPoint.y,sw,sh);
		this.setPixels(destRect,pixels);
		(openfl_geom_Rectangle().default).__pool.release(destRect);
	},
	perlinNoise: function(baseX,baseY,numOctaves,randomSeed,stitch,fractalNoise,channelOptions,grayScale,offsets) {
		if(grayScale == null) {
			grayScale = false;
		}
		if(channelOptions == null) {
			channelOptions = 7;
		}
		if(!this.readable) {
			return;
		}
		var noise = new (openfl__$internal_utils_PerlinNoise().default)(randomSeed,numOctaves,channelOptions,grayScale,0.5,stitch,0.15);
		noise.fill(this,baseX,baseY,0);
	},
	scroll: function(x,y) {
		if(!this.readable) {
			return;
		}
		this.image.scroll(x,y);
	},
	setPixel: function(x,y,color) {
		if(!this.readable) {
			return;
		}
		this.image.setPixel(x,y,color,1);
	},
	setPixel32: function(x,y,color) {
		if(!this.readable) {
			return;
		}
		this.image.setPixel32(x,y,color,1);
	},
	setPixels: function(rect,byteArray) {
		if(!this.readable || rect == null) {
			return;
		}
		var length = rect.width * rect.height * 4;
		if((_$UInt_UInt_$Impl_$().default).toFloat(byteArray.get_bytesAvailable()) < length) {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_Error().default)("End of file was encountered.",2030));
		}
		this.image.setPixels(rect.__toLimeRectangle(),(openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytePointer(byteArray),1,(openfl_utils__$Endian_Endian_$Impl_$().default).toLimeEndian(byteArray.get_endian()));
	},
	setVector: function(rect,inputVector) {
		var this1 = new (openfl_utils_ByteArrayData().default)(0);
		var byteArray = this1;
		(openfl_utils__$ByteArray_ByteArray_$Impl_$().default).set_length(byteArray,inputVector.get_length() * 4);
		var color = new (openfl__$Vector_VectorIterator().default)(inputVector);
		while(color.hasNext()) {
			var color1 = color.next();
			byteArray.writeUnsignedInt(color1);
		}
		byteArray.position = 0;
		this.setPixels(rect,byteArray);
	},
	threshold: function(sourceBitmapData,sourceRect,destPoint,operation,threshold,color,mask,copySource) {
		if(copySource == null) {
			copySource = false;
		}
		if(mask == null) {
			mask = -1;
		}
		if(color == null) {
			color = 0;
		}
		if(sourceBitmapData == null || sourceRect == null || destPoint == null || sourceRect.x > sourceBitmapData.width || sourceRect.y > sourceBitmapData.height || destPoint.x > this.width || destPoint.y > this.height) {
			return 0;
		}
		return this.image.threshold(sourceBitmapData.image,sourceRect.__toLimeRectangle(),destPoint.__toLimeVector2(),operation,threshold,color,mask,copySource,1);
	},
	unlock: function(changeRect) {
	},
	__applyAlpha: function(alpha) {
		(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(this.image);
		(lime__$internal_graphics_ImageCanvasUtil().default).createImageData(this.image);
		var data = this.image.buffer.data;
		var _g = 0;
		var _g1 = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(alpha);
		while(_g < _g1) {
			var i = _g++;
			data[i * 4 + 3] = alpha.readUnsignedByte();
		}
		this.image.version++;
	},
	__drawCairo: function(source,renderer) {
	},
	__drawCanvas: function(source,renderer) {
		var buffer = this.image.buffer;
		if(!renderer.__allowSmoothing) {
			renderer.applySmoothing(buffer.__srcContext,false);
		}
		renderer.__render(source);
		if(!renderer.__allowSmoothing) {
			renderer.applySmoothing(buffer.__srcContext,true);
		}
		buffer.__srcContext.setTransform(1,0,0,1,0,0);
		buffer.__srcImageData = null;
		buffer.data = null;
		this.image.dirty = true;
		this.image.version++;
	},
	__drawGL: function(source,renderer) {
		var context = renderer.__context3D;
		var cacheRTT = context.__state.renderToTexture;
		var cacheRTTDepthStencil = context.__state.renderToTextureDepthStencil;
		var cacheRTTAntiAlias = context.__state.renderToTextureAntiAlias;
		var cacheRTTSurfaceSelector = context.__state.renderToTextureSurfaceSelector;
		context.setRenderToTexture(this.getTexture(context),true);
		renderer.__render(source);
		if(cacheRTT != null) {
			context.setRenderToTexture(cacheRTT,cacheRTTDepthStencil,cacheRTTAntiAlias,cacheRTTSurfaceSelector);
		} else {
			context.setRenderToBackBuffer();
		}
	},
	__fillRect: function(rect,color,allowFramebuffer) {
		if(rect == null) {
			return;
		}
		if(this.transparent && (color & -16777216) == 0) {
			color = 0;
		}
		if(allowFramebuffer && this.__texture != null && this.__texture.__glFramebuffer != null && (openfl_Lib().default).get_current().stage.__renderer.__type == "opengl") {
			var renderer = (openfl_Lib().default).get_current().stage.__renderer;
			var context = renderer.__context3D;
			var color1 = color;
			var useScissor = !this.rect.equals(rect);
			var cacheRTT = context.__state.renderToTexture;
			var cacheRTTDepthStencil = context.__state.renderToTextureDepthStencil;
			var cacheRTTAntiAlias = context.__state.renderToTextureAntiAlias;
			var cacheRTTSurfaceSelector = context.__state.renderToTextureSurfaceSelector;
			context.setRenderToTexture(this.__texture);
			if(useScissor) {
				context.setScissorRectangle(rect);
			}
			context.clear((color1 >>> 16 & 255) / 255,(color1 >>> 8 & 255) / 255,(color1 & 255) / 255,this.transparent ? (color1 >>> 24 & 255) / 255 : 1,0,0,1);
			if(useScissor) {
				context.setScissorRectangle(null);
			}
			if(cacheRTT != null) {
				context.setRenderToTexture(cacheRTT,cacheRTTDepthStencil,cacheRTTAntiAlias,cacheRTTSurfaceSelector);
			} else {
				context.setRenderToBackBuffer();
			}
		} else if(this.readable) {
			this.image.fillRect(rect.__toLimeRectangle(),color,1);
		}
	},
	__fromBase64: function(base64,type) {
		var image = (lime_graphics_Image().default).fromBase64(base64,type);
		this.__fromImage(image);
	},
	__fromBytes: function(bytes,rawAlpha) {
		var image = (lime_graphics_Image().default).fromBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(bytes));
		this.__fromImage(image);
		if(rawAlpha != null) {
			this.__applyAlpha(rawAlpha);
		}
	},
	__fromFile: function(path) {
		var image = (lime_graphics_Image().default).fromFile(path);
		this.__fromImage(image);
	},
	__fromImage: function(image) {
		if(image != null && image.buffer != null) {
			this.image = image;
			this.width = image.width;
			this.height = image.height;
			this.rect = new (openfl_geom_Rectangle().default)(0,0,image.width,image.height);
			this.__textureWidth = this.width;
			this.__textureHeight = this.height;
			this.readable = true;
			this.__isValid = true;
		}
	},
	__fromSymbol: function(swf,symbol) {
		var _gthis = this;
		this.__symbol = symbol;
		(lime_graphics_Image().default).loadFromFile(symbol.path).onComplete(function(image) {
			if(symbol.alpha != null) {
				(lime_graphics_Image().default).loadFromFile(symbol.alpha).onComplete(function(alpha) {
					if(image != null && alpha != null) {
						var tmp = alpha.get_rect();
						image.copyChannel(alpha,tmp,new (lime_math_Vector2().default)(),(lime_graphics_ImageChannel().default).RED,(lime_graphics_ImageChannel().default).ALPHA);
						image.buffer.premultiplied = true;
						image.set_premultiplied(false);
					}
					_gthis.__fromImage(image);
				});
			} else {
				_gthis.__fromImage(image);
			}
		});
	},
	__getBounds: function(rect,matrix) {
		var bounds = (openfl_geom_Rectangle().default).__pool.get();
		this.rect.__transform(bounds,matrix);
		rect.__expand(bounds.x,bounds.y,bounds.width,bounds.height);
		(openfl_geom_Rectangle().default).__pool.release(bounds);
	},
	__loadFromBase64: function(base64,type) {
		var _gthis = this;
		return (lime_graphics_Image().default).loadFromBase64(base64,type).then(function(image) {
			_gthis.__fromImage(image);
			return (lime_app_Future().default).withValue(_gthis);
		});
	},
	__loadFromBytes: function(bytes,rawAlpha) {
		var _gthis = this;
		return (lime_graphics_Image().default).loadFromBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(bytes)).then(function(image) {
			_gthis.__fromImage(image);
			if(rawAlpha != null) {
				_gthis.__applyAlpha(rawAlpha);
			}
			return (lime_app_Future().default).withValue(_gthis);
		});
	},
	__loadFromFile: function(path) {
		var _gthis = this;
		return (lime_graphics_Image().default).loadFromFile(path).then(function(image) {
			_gthis.__fromImage(image);
			return (lime_app_Future().default).withValue(_gthis);
		});
	},
	__renderCairo: function(renderer) {
	},
	__renderCairoMask: function(renderer) {
	},
	__renderCanvas: function(renderer) {
		if(!this.readable) {
			return;
		}
		if(this.image.type == (lime_graphics_ImageType().default).DATA) {
			(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(this.image);
		}
		var context = renderer.context;
		context.globalAlpha = 1;
		renderer.setTransform(this.__renderTransform,context);
		context.drawImage(this.image.get_src(),0,0,this.image.width,this.image.height);
	},
	__renderCanvasMask: function(renderer) {
	},
	__renderDOM: function(renderer) {
	},
	__renderGL: function(renderer) {
		var context = renderer.__context3D;
		var gl = context.gl;
		renderer.__setBlendMode("normal");
		var shader = renderer.__defaultDisplayShader;
		renderer.setShader(shader);
		renderer.applyBitmapData(this,renderer.__upscaled);
		renderer.applyMatrix(renderer.__getMatrix(this.__worldTransform,"auto"));
		renderer.applyAlpha(this.__worldAlpha);
		renderer.applyColorTransform(this.__worldColorTransform);
		renderer.updateShader();
		var vertexBuffer = this.getVertexBuffer(context);
		if(shader.__position != null) {
			context.setVertexBufferAt(shader.__position.index,vertexBuffer,0,"float3");
		}
		if(shader.__textureCoord != null) {
			context.setVertexBufferAt(shader.__textureCoord.index,vertexBuffer,3,"float2");
		}
		var indexBuffer = this.getIndexBuffer(context);
		context.drawTriangles(indexBuffer);
		renderer.__clearShader();
	},
	__renderGLMask: function(renderer) {
		var context = renderer.__context3D;
		var gl = context.gl;
		var shader = renderer.__maskShader;
		renderer.setShader(shader);
		renderer.applyBitmapData(this,renderer.__upscaled);
		renderer.applyMatrix(renderer.__getMatrix(this.__worldTransform,"auto"));
		renderer.updateShader();
		var vertexBuffer = this.getVertexBuffer(context);
		if(shader.__position != null) {
			context.setVertexBufferAt(shader.__position.index,vertexBuffer,0,"float3");
		}
		if(shader.__textureCoord != null) {
			context.setVertexBufferAt(shader.__textureCoord.index,vertexBuffer,3,"float2");
		}
		var indexBuffer = this.getIndexBuffer(context);
		context.drawTriangles(indexBuffer);
		renderer.__clearShader();
	},
	__resize: function(width,height) {
		this.width = width;
		this.height = height;
		this.rect.width = width;
		this.rect.height = height;
		this.__textureWidth = width;
		this.__textureHeight = height;
	},
	__setUVRect: function(context,x,y,width,height) {
		var buffer = this.getVertexBuffer(context);
		if(buffer != null && (width != this.__uvRect.width || height != this.__uvRect.height || x != this.__uvRect.x || y != this.__uvRect.y)) {
			var gl = context.gl;
			if(this.__uvRect == null) {
				this.__uvRect = new (openfl_geom_Rectangle().default)();
			}
			this.__uvRect.setTo(x,y,width,height);
			var uvX = this.__textureWidth > 0 ? x / this.__textureWidth : 0;
			var uvY = this.__textureHeight > 0 ? y / this.__textureHeight : 0;
			var uvWidth = this.__textureWidth > 0 ? width / this.__textureWidth : 0;
			var uvHeight = this.__textureHeight > 0 ? height / this.__textureHeight : 0;
			this.__vertexBufferData[0] = width;
			this.__vertexBufferData[1] = height;
			this.__vertexBufferData[3] = uvX + uvWidth;
			this.__vertexBufferData[4] = uvY + uvHeight;
			this.__vertexBufferData[15] = height;
			this.__vertexBufferData[17] = uvX;
			this.__vertexBufferData[18] = uvY + uvHeight;
			this.__vertexBufferData[28] = width;
			this.__vertexBufferData[31] = uvX + uvWidth;
			this.__vertexBufferData[32] = uvY;
			this.__vertexBufferData[45] = uvX;
			this.__vertexBufferData[46] = uvY;
			this.__vertexBuffer.uploadFromTypedArray(this.__vertexBufferData);
		}
	},
	__sync: function() {
		(lime__$internal_graphics_ImageCanvasUtil().default).sync(this.image,false);
	},
	__update: function(transformOnly,updateChildren) {
		this.__updateTransforms();
	},
	__updateTransforms: function(overrideTransform) {
		if(overrideTransform == null) {
			this.__worldTransform.identity();
		} else {
			this.__worldTransform.copyFrom(overrideTransform);
		}
		this.__renderTransform.copyFrom(this.__worldTransform);
	}
};
BitmapData.prototype.__class__ = BitmapData.prototype.constructor = $hxClasses["openfl.display.BitmapData"] = BitmapData;

// Init



// Statics

BitmapData.fromBase64 = function(base64,type) {
	return null;
}
BitmapData.fromBytes = function(bytes,rawAlpha) {
	return null;
}
BitmapData.fromCanvas = function(canvas,transparent) {
	if(transparent == null) {
		transparent = true;
	}
	if(canvas == null) {
		return null;
	}
	var bitmapData = new BitmapData(0,0,transparent,0);
	bitmapData.__fromImage((lime_graphics_Image().default).fromCanvas(canvas));
	bitmapData.image.set_transparent(transparent);
	return bitmapData;
}
BitmapData.fromFile = function(path) {
	return null;
}
BitmapData.fromImage = function(image,transparent) {
	if(transparent == null) {
		transparent = true;
	}
	if(image == null || image.buffer == null) {
		return null;
	}
	var bitmapData = new BitmapData(0,0,transparent,0);
	bitmapData.__fromImage(image);
	bitmapData.image.set_transparent(transparent);
	if(bitmapData.image != null) {
		return bitmapData;
	} else {
		return null;
	}
}
BitmapData.fromTexture = function(texture) {
	if(texture == null) {
		return null;
	}
	var bitmapData = new BitmapData(texture.__width,texture.__height,true,0);
	bitmapData.readable = false;
	bitmapData.__texture = texture;
	bitmapData.__textureContext = texture.__textureContext;
	bitmapData.image = null;
	return bitmapData;
}
BitmapData.loadFromBase64 = function(base64,type) {
	return (lime_graphics_Image().default).loadFromBase64(base64,type).then(function(image) {
		return (lime_app_Future().default).withValue(BitmapData.fromImage(image));
	});
}
BitmapData.loadFromBytes = function(bytes,rawAlpha) {
	return (lime_graphics_Image().default).loadFromBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(bytes)).then(function(image) {
		var bitmapData = BitmapData.fromImage(image);
		if(rawAlpha != null) {
			bitmapData.__applyAlpha(rawAlpha);
		}
		return (lime_app_Future().default).withValue(bitmapData);
	});
}
BitmapData.loadFromFile = function(path) {
	return (lime_graphics_Image().default).loadFromFile(path).then(function(image) {
		return (lime_app_Future().default).withValue(BitmapData.fromImage(image));
	});
}
BitmapData.__meta__ = { fields : { image : { SuppressWarnings : ["checkstyle:Dynamic"]}, __framebufferContext : { SuppressWarnings : ["checkstyle:Dynamic"]}, __indexBufferContext : { SuppressWarnings : ["checkstyle:Dynamic"]}, __surface : { SuppressWarnings : ["checkstyle:Dynamic"]}, __textureContext : { SuppressWarnings : ["checkstyle:Dynamic"]}, __vertexBufferContext : { SuppressWarnings : ["checkstyle:Dynamic"]}, compare : { SuppressWarnings : ["checkstyle:Dynamic"]}, getSurface : { SuppressWarnings : ["checkstyle:Dynamic"]}, __fromImage : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
BitmapData.VERTEX_BUFFER_STRIDE = 14
BitmapData.__supportsBGRA = null
BitmapData.__tempVector = new (lime_math_Vector2().default)()

// Export

exports.default = BitmapData;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/CanvasRenderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/CanvasRenderer.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.CanvasRenderer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_DisplayObjectRenderer() {return __webpack_require__(/*! ./../../openfl/display/DisplayObjectRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectRenderer.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}

// Constructor

var CanvasRenderer = function(context) {
	this.pixelRatio = 1;
	(openfl_display_DisplayObjectRenderer().default).call(this);
	this.context = context;
	this.__tempMatrix = new (openfl_geom_Matrix().default)();
	this.__type = "canvas";
}

// Meta

CanvasRenderer.__name__ = "openfl.display.CanvasRenderer";
CanvasRenderer.__isInterface__ = false;
CanvasRenderer.__super__ = (openfl_display_DisplayObjectRenderer().default);
CanvasRenderer.prototype = $extend((openfl_display_DisplayObjectRenderer().default).prototype, {
	applySmoothing: function(context,value) {
		context.imageSmoothingEnabled = value;
	},
	setTransform: function(transform,context) {
		if(context == null) {
			context = this.context;
		} else if(this.context == context && this.__worldTransform != null) {
			this.__tempMatrix.copyFrom(transform);
			this.__tempMatrix.concat(this.__worldTransform);
			transform = this.__tempMatrix;
		}
		if(this.__roundPixels) {
			context.setTransform(transform.a,transform.b,transform.c,transform.d,(Std().default).int(transform.tx),(Std().default).int(transform.ty));
		} else {
			context.setTransform(transform.a,transform.b,transform.c,transform.d,transform.tx,transform.ty);
		}
	},
	__clear: function() {
		if(this.__stage != null) {
			var cacheBlendMode = this.__blendMode;
			this.__blendMode = null;
			this.__setBlendMode("normal");
			this.context.setTransform(1,0,0,1,0,0);
			this.context.globalAlpha = 1;
			if(!this.__stage.__transparent && this.__stage.__clearBeforeRender) {
				this.context.fillStyle = this.__stage.__colorString;
				this.context.fillRect(0,0,this.__stage.stageWidth * this.__stage.window.get_scale(),this.__stage.stageHeight * this.__stage.window.get_scale());
			} else if(this.__stage.__transparent && this.__stage.__clearBeforeRender) {
				this.context.clearRect(0,0,this.__stage.stageWidth * this.__stage.window.get_scale(),this.__stage.stageHeight * this.__stage.window.get_scale());
			}
			this.__setBlendMode(cacheBlendMode);
		}
	},
	__popMask: function() {
		this.context.restore();
	},
	__popMaskObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
		if(!object.__isCacheBitmapRender && object.__mask != null) {
			this.__popMask();
		}
		if(handleScrollRect && object.__scrollRect != null) {
			this.__popMaskRect();
		}
	},
	__popMaskRect: function() {
		this.context.restore();
	},
	__pushMask: function(mask) {
		this.context.save();
		this.setTransform(mask.__renderTransform,this.context);
		this.context.beginPath();
		mask.__renderCanvasMask(this);
		this.context.closePath();
		this.context.clip();
	},
	__pushMaskObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
		if(handleScrollRect && object.__scrollRect != null) {
			this.__pushMaskRect(object.__scrollRect,object.__renderTransform);
		}
		if(!object.__isCacheBitmapRender && object.__mask != null) {
			this.__pushMask(object.__mask);
		}
	},
	__pushMaskRect: function(rect,transform) {
		this.context.save();
		this.setTransform(transform,this.context);
		this.context.beginPath();
		this.context.rect(rect.x,rect.y,rect.width,rect.height);
		this.context.clip();
	},
	__render: function(object) {
		object.__renderCanvas(this);
	},
	__setBlendMode: function(value) {
		if(this.__overrideBlendMode != null) {
			value = this.__overrideBlendMode;
		}
		if(this.__blendMode == value) {
			return;
		}
		this.__blendMode = value;
		this.__setBlendModeContext(this.context,value);
	},
	__setBlendModeContext: function(context,value) {
		switch(value) {
		case "add":
			context.globalCompositeOperation = "lighter";
			break;
		case "darken":
			context.globalCompositeOperation = "darken";
			break;
		case "difference":
			context.globalCompositeOperation = "difference";
			break;
		case "hardlight":
			context.globalCompositeOperation = "hard-light";
			break;
		case "lighten":
			context.globalCompositeOperation = "lighten";
			break;
		case "multiply":
			context.globalCompositeOperation = "multiply";
			break;
		case "overlay":
			context.globalCompositeOperation = "overlay";
			break;
		case "screen":
			context.globalCompositeOperation = "screen";
			break;
		default:
			context.globalCompositeOperation = "source-over";
		}
	}
});
CanvasRenderer.prototype.__class__ = CanvasRenderer.prototype.constructor = $hxClasses["openfl.display.CanvasRenderer"] = CanvasRenderer;

// Init



// Statics


CanvasRenderer.__meta__ = { fields : { context : { SuppressWarnings : ["checkstyle:Dynamic"]}, applySmoothing : { SuppressWarnings : ["checkstyle:Dynamic"]}, setTransform : { SuppressWarnings : ["checkstyle:Dynamic"]}, __setBlendModeContext : { SuppressWarnings : ["checkstyle:Dynamic"]}, _ : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = CanvasRenderer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/DOMRenderer.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/DOMRenderer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.DOMRenderer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_DisplayObjectRenderer() {return __webpack_require__(/*! ./../../openfl/display/DisplayObjectRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectRenderer.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function openfl_display_DisplayObject() {return __webpack_require__(/*! ./../../openfl/display/DisplayObject */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js");}
function openfl_display_CanvasRenderer() {return __webpack_require__(/*! ./../../openfl/display/CanvasRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/CanvasRenderer.js");}

// Constructor

var DOMRenderer = function(element) {
	this.pixelRatio = 1;
	(openfl_display_DisplayObjectRenderer().default).call(this);
	this.element = element;
	(openfl_display_DisplayObject().default).__supportDOM = true;
	var prefix = (function () {
		  var styles = window.getComputedStyle(document.documentElement, ''),
			pre = (Array.prototype.slice
			  .call(styles)
			  .join('')
			  .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
			)[1],
			dom = ('WebKit|Moz|MS|O').match(new RegExp('(' + pre + ')', 'i'))[1];
		  return {
			dom: dom,
			lowercase: pre,
			css: '-' + pre + '-',
			js: pre[0].toUpperCase() + pre.substr(1)
		  };
		})();
	this.__vendorPrefix = prefix.lowercase;
	this.__transformProperty = prefix.lowercase == "webkit" ? "-webkit-transform" : "transform";
	this.__transformOriginProperty = prefix.lowercase == "webkit" ? "-webkit-transform-origin" : "transform-origin";
	this.__clipRects = [];
	this.__numClipRects = 0;
	this.__z = 0;
	this.__type = "dom";
	this.__canvasRenderer = new (openfl_display_CanvasRenderer().default)(null);
	this.__canvasRenderer.__isDOM = true;
}

// Meta

DOMRenderer.__name__ = "openfl.display.DOMRenderer";
DOMRenderer.__isInterface__ = false;
DOMRenderer.__super__ = (openfl_display_DisplayObjectRenderer().default);
DOMRenderer.prototype = $extend((openfl_display_DisplayObjectRenderer().default).prototype, {
	applyStyle: function(parent,childElement) {
		if(parent != null && childElement != null) {
			if(parent.__style == null || childElement.parentElement != this.element) {
				this.__initializeElement(parent,childElement);
			}
			parent.__style = childElement.style;
			this.__updateClip(parent);
			this.__applyStyle(parent,true,true,true);
		}
	},
	clearStyle: function(childElement) {
		if(childElement != null && childElement.parentElement == this.element) {
			this.element.removeChild(childElement);
		}
	},
	__applyStyle: function(displayObject,setTransform,setAlpha,setClip) {
		var style = displayObject.__style;
		if(setTransform && displayObject.__renderTransformChanged) {
			style.setProperty(this.__transformProperty,displayObject.__renderTransform.to3DString(this.__roundPixels),null);
		}
		if(displayObject.__worldZ != ++this.__z) {
			displayObject.__worldZ = this.__z;
			style.setProperty("z-index",displayObject.__worldZ == null ? "null" : "" + displayObject.__worldZ,null);
		}
		if(setAlpha && displayObject.__worldAlphaChanged) {
			if(displayObject.__worldAlpha < 1) {
				style.setProperty("opacity",displayObject.__worldAlpha == null ? "null" : "" + displayObject.__worldAlpha,null);
			} else {
				style.removeProperty("opacity");
			}
		}
		if(setClip && displayObject.__worldClipChanged) {
			if(displayObject.__worldClip == null) {
				style.removeProperty("clip");
			} else {
				var clip = displayObject.__worldClip;
				style.setProperty("clip","rect(" + clip.y + "px, " + clip.get_right() + "px, " + clip.get_bottom() + "px, " + clip.x + "px)",null);
			}
		}
	},
	__initializeElement: function(displayObject,element) {
		var style = displayObject.__style = element.style;
		style.setProperty("position","absolute",null);
		style.setProperty("top","0",null);
		style.setProperty("left","0",null);
		style.setProperty(this.__transformOriginProperty,"0 0 0",null);
		this.element.appendChild(element);
		displayObject.__worldAlphaChanged = true;
		displayObject.__renderTransformChanged = true;
		displayObject.__worldVisibleChanged = true;
		displayObject.__worldClipChanged = true;
		displayObject.__worldClip = null;
		displayObject.__worldZ = -1;
	},
	__popMask: function() {
		this.__popMaskRect();
	},
	__popMaskObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
		if(object.__mask != null) {
			this.__popMask();
		}
		if(handleScrollRect && object.__scrollRect != null) {
			this.__popMaskRect();
		}
	},
	__popMaskRect: function() {
		if(this.__numClipRects > 0) {
			this.__numClipRects--;
			if(this.__numClipRects > 0) {
				this.__currentClipRect = this.__clipRects[this.__numClipRects - 1];
			} else {
				this.__currentClipRect = null;
			}
		}
	},
	__pushMask: function(mask) {
		this.__pushMaskRect(mask.getBounds(mask),mask.__renderTransform);
	},
	__pushMaskObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
		if(handleScrollRect && object.__scrollRect != null) {
			this.__pushMaskRect(object.__scrollRect,object.__renderTransform);
		}
		if(object.__mask != null) {
			this.__pushMask(object.__mask);
		}
	},
	__pushMaskRect: function(rect,transform) {
		if(this.__numClipRects == this.__clipRects.length) {
			this.__clipRects[this.__numClipRects] = new (openfl_geom_Rectangle().default)();
		}
		var clipRect = this.__clipRects[this.__numClipRects];
		rect.__transform(clipRect,transform);
		if(this.__numClipRects > 0) {
			var parentClipRect = this.__clipRects[this.__numClipRects - 1];
			clipRect.__contract(parentClipRect.x,parentClipRect.y,parentClipRect.width,parentClipRect.height);
		}
		if(clipRect.height < 0) {
			clipRect.height = 0;
		}
		if(clipRect.width < 0) {
			clipRect.width = 0;
		}
		this.__currentClipRect = clipRect;
		this.__numClipRects++;
	},
	__render: function(object) {
		if(!this.__stage.__transparent) {
			this.element.style.background = this.__stage.__colorString;
		} else {
			this.element.style.background = "none";
		}
		this.__z = 1;
		object.__renderDOM(this);
	},
	__setBlendMode: function(value) {
		if(this.__overrideBlendMode != null) {
			value = this.__overrideBlendMode;
		}
		if(this.__blendMode == value) {
			return;
		}
		this.__blendMode = value;
	},
	__updateClip: function(displayObject) {
		if(this.__currentClipRect == null) {
			displayObject.__worldClipChanged = displayObject.__worldClip != null;
			displayObject.__worldClip = null;
		} else {
			if(displayObject.__worldClip == null) {
				displayObject.__worldClip = new (openfl_geom_Rectangle().default)();
			}
			var clip = (openfl_geom_Rectangle().default).__pool.get();
			var matrix = (openfl_geom_Matrix().default).__pool.get();
			matrix.copyFrom(displayObject.__renderTransform);
			matrix.invert();
			this.__currentClipRect.__transform(clip,matrix);
			if(clip.equals(displayObject.__worldClip)) {
				displayObject.__worldClipChanged = false;
			} else {
				displayObject.__worldClip.copyFrom(clip);
				displayObject.__worldClipChanged = true;
			}
			(openfl_geom_Rectangle().default).__pool.release(clip);
			(openfl_geom_Matrix().default).__pool.release(matrix);
		}
	}
});
DOMRenderer.prototype.__class__ = DOMRenderer.prototype.constructor = $hxClasses["openfl.display.DOMRenderer"] = DOMRenderer;

// Init



// Statics


DOMRenderer.__meta__ = { fields : { element : { SuppressWarnings : ["checkstyle:Dynamic"]}, applyStyle : { SuppressWarnings : ["checkstyle:Dynamic"]}, clearStyle : { SuppressWarnings : ["checkstyle:Dynamic"]}, _ : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = DOMRenderer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.DisplayObject

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_IBitmapDrawable() {return __webpack_require__(/*! ./../../openfl/display/IBitmapDrawable */ "./node_modules/openfl/lib/_gen/openfl/display/IBitmapDrawable.js");}
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function openfl_events_RenderEvent() {return __webpack_require__(/*! ./../../openfl/events/RenderEvent */ "./node_modules/openfl/lib/_gen/openfl/events/RenderEvent.js");}
function openfl_geom_ColorTransform() {return __webpack_require__(/*! ./../../openfl/geom/ColorTransform */ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function openfl_events_MouseEvent() {return __webpack_require__(/*! ./../../openfl/events/MouseEvent */ "./node_modules/openfl/lib/_gen/openfl/events/MouseEvent.js");}
function openfl_events_TouchEvent() {return __webpack_require__(/*! ./../../openfl/events/TouchEvent */ "./node_modules/openfl/lib/_gen/openfl/events/TouchEvent.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl__$internal_renderer_canvas_CanvasBitmap() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/canvas/CanvasBitmap */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasBitmap.js");}
function openfl__$internal_renderer_canvas_CanvasDisplayObject() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/canvas/CanvasDisplayObject */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasDisplayObject.js");}
function openfl__$internal_renderer_canvas_CanvasGraphics() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/canvas/CanvasGraphics */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasGraphics.js");}
function openfl__$internal_renderer_dom_DOMBitmap() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/dom/DOMBitmap */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMBitmap.js");}
function openfl__$internal_renderer_dom_DOMDisplayObject() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/dom/DOMDisplayObject */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/dom/DOMDisplayObject.js");}
function openfl__$internal_renderer_context3D_Context3DBitmap() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DBitmap */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DBitmap.js");}
function openfl__$internal_renderer_context3D_Context3DDisplayObject() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DDisplayObject */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DDisplayObject.js");}
function openfl__$internal_renderer_context3D_Context3DShape() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DShape */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DShape.js");}
function openfl__$internal_renderer_context3D_Context3DGraphics() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DGraphics */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DGraphics.js");}
function openfl_display_BitmapData() {return __webpack_require__(/*! ./../../openfl/display/BitmapData */ "./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js");}
function openfl_display_Bitmap() {return __webpack_require__(/*! ./../../openfl/display/Bitmap */ "./node_modules/openfl/lib/_gen/openfl/display/Bitmap.js");}
function openfl_display_OpenGLRenderer() {return __webpack_require__(/*! ./../../openfl/display/OpenGLRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/OpenGLRenderer.js");}
function js_Boot() {return __webpack_require__(/*! ./../../js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function openfl_display_CanvasRenderer() {return __webpack_require__(/*! ./../../openfl/display/CanvasRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/CanvasRenderer.js");}
function openfl__$internal_Lib() {return __webpack_require__(/*! ./../../openfl/_internal/Lib */ "./node_modules/openfl/lib/_gen/openfl/_internal/Lib.js");}
function openfl_geom_Transform() {return __webpack_require__(/*! ./../../openfl/geom/Transform */ "./node_modules/openfl/lib/_gen/openfl/geom/Transform.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_TypeError() {return __webpack_require__(/*! ./../../openfl/errors/TypeError */ "./node_modules/openfl/lib/_gen/openfl/errors/TypeError.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var DisplayObject = function() {
	(openfl_events_EventDispatcher().default).call(this);
	this.__alpha = 1;
	this.__blendMode = "normal";
	this.__cacheAsBitmap = false;
	this.__transform = new (openfl_geom_Matrix().default)();
	this.__visible = true;
	this.__rotation = 0;
	this.__rotationSine = 0;
	this.__rotationCosine = 1;
	this.__scaleX = 1;
	this.__scaleY = 1;
	this.__worldAlpha = 1;
	this.__worldBlendMode = "normal";
	this.__worldTransform = new (openfl_geom_Matrix().default)();
	this.__worldColorTransform = new (openfl_geom_ColorTransform().default)();
	this.__renderTransform = new (openfl_geom_Matrix().default)();
	this.__worldVisible = true;
	this.set_name("instance" + ++DisplayObject.__instanceCount);
	if(DisplayObject.__initStage != null) {
		this.stage = DisplayObject.__initStage;
		DisplayObject.__initStage = null;
		this.stage.addChild(this);
	}
}

// Meta

DisplayObject.__name__ = "openfl.display.DisplayObject";
DisplayObject.__isInterface__ = false;
DisplayObject.__interfaces__ = [(openfl_display_IBitmapDrawable().default)];
DisplayObject.__super__ = (openfl_events_EventDispatcher().default);
DisplayObject.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	addEventListener: function(type,listener,useCapture,priority,useWeakReference) {
		if(useWeakReference == null) {
			useWeakReference = false;
		}
		if(priority == null) {
			priority = 0;
		}
		if(useCapture == null) {
			useCapture = false;
		}
		switch(type) {
		case "activate":case "deactivate":case "enterFrame":case "exitFrame":case "frameConstructed":case "render":
			if(!DisplayObject.__broadcastEvents.exists(type)) {
				DisplayObject.__broadcastEvents.set(type,[]);
			}
			var dispatchers = DisplayObject.__broadcastEvents.get(type);
			if(dispatchers.indexOf(this) == -1) {
				dispatchers.push(this);
			}
			break;
		case "clearDOM":case "renderCairo":case "renderCanvas":case "renderDOM":case "renderOpenGL":
			if(this.__customRenderEvent == null) {
				this.__customRenderEvent = new (openfl_events_RenderEvent().default)(null);
				this.__customRenderEvent.objectColorTransform = new (openfl_geom_ColorTransform().default)();
				this.__customRenderEvent.objectMatrix = new (openfl_geom_Matrix().default)();
				this.__customRenderClear = true;
			}
			break;
		default:
		}
		(openfl_events_EventDispatcher().default).prototype.addEventListener.call(this,type,listener,useCapture,priority,useWeakReference);
	},
	dispatchEvent: function(event) {
		if(((event) instanceof (openfl_events_MouseEvent().default))) {
			var mouseEvent = event;
			mouseEvent.stageX = this.__getRenderTransform().__transformX(mouseEvent.localX,mouseEvent.localY);
			mouseEvent.stageY = this.__getRenderTransform().__transformY(mouseEvent.localX,mouseEvent.localY);
		} else if(((event) instanceof (openfl_events_TouchEvent().default))) {
			var touchEvent = event;
			touchEvent.stageX = this.__getRenderTransform().__transformX(touchEvent.localX,touchEvent.localY);
			touchEvent.stageY = this.__getRenderTransform().__transformY(touchEvent.localX,touchEvent.localY);
		}
		event.target = this;
		return this.__dispatchWithCapture(event);
	},
	getBounds: function(targetCoordinateSpace) {
		var matrix = (openfl_geom_Matrix().default).__pool.get();
		if(targetCoordinateSpace != null && targetCoordinateSpace != this) {
			matrix.copyFrom(this.__getWorldTransform());
			var targetMatrix = (openfl_geom_Matrix().default).__pool.get();
			targetMatrix.copyFrom(targetCoordinateSpace.__getWorldTransform());
			targetMatrix.invert();
			matrix.concat(targetMatrix);
			(openfl_geom_Matrix().default).__pool.release(targetMatrix);
		} else {
			matrix.identity();
		}
		var bounds = new (openfl_geom_Rectangle().default)();
		this.__getBounds(bounds,matrix);
		(openfl_geom_Matrix().default).__pool.release(matrix);
		return bounds;
	},
	getRect: function(targetCoordinateSpace) {
		return this.getBounds(targetCoordinateSpace);
	},
	globalToLocal: function(pos) {
		return this.__globalToLocal(pos,new (openfl_geom_Point().default)());
	},
	hitTestObject: function(obj) {
		if(obj != null && obj.parent != null && this.parent != null) {
			var currentBounds = this.getBounds(this);
			var targetBounds = obj.getBounds(this);
			return currentBounds.intersects(targetBounds);
		}
		return false;
	},
	hitTestPoint: function(x,y,shapeFlag) {
		if(shapeFlag == null) {
			shapeFlag = false;
		}
		if(this.stage != null) {
			return this.__hitTest(x,y,shapeFlag,null,false,this);
		} else {
			return false;
		}
	},
	invalidate: function() {
		this.__setRenderDirty();
	},
	localToGlobal: function(point) {
		return this.__getRenderTransform().transformPoint(point);
	},
	removeEventListener: function(type,listener,useCapture) {
		if(useCapture == null) {
			useCapture = false;
		}
		(openfl_events_EventDispatcher().default).prototype.removeEventListener.call(this,type,listener,useCapture);
		switch(type) {
		case "activate":case "deactivate":case "enterFrame":case "exitFrame":case "frameConstructed":case "render":
			if(!this.hasEventListener(type)) {
				if(DisplayObject.__broadcastEvents.exists(type)) {
					(HxOverrides().default).remove(DisplayObject.__broadcastEvents.get(type),this);
				}
			}
			break;
		case "clearDOM":case "renderCairo":case "renderCanvas":case "renderDOM":case "renderOpenGL":
			if(!this.hasEventListener("clearDOM") && !this.hasEventListener("renderCairo") && !this.hasEventListener("renderCanvas") && !this.hasEventListener("renderDOM") && !this.hasEventListener("renderOpenGL")) {
				this.__customRenderEvent = null;
			}
			break;
		default:
		}
	},
	__cleanup: function() {
		this.__cairo = null;
		this.__canvas = null;
		this.__context = null;
		if(this.__graphics != null) {
			this.__graphics.__cleanup();
		}
		if(this.__cacheBitmap != null) {
			this.__cacheBitmap.__cleanup();
			this.__cacheBitmap = null;
		}
		if(this.__cacheBitmapData != null) {
			this.__cacheBitmapData.dispose();
			this.__cacheBitmapData = null;
		}
	},
	__dispatch: function(event) {
		if(this.__eventMap != null && this.hasEventListener(event.type)) {
			var result = (openfl_events_EventDispatcher().default).prototype.__dispatchEvent.call(this,event);
			if(event.__isCanceled) {
				return true;
			}
			return result;
		}
		return true;
	},
	__dispatchChildren: function(event) {
	},
	__dispatchEvent: function(event) {
		var parent = event.bubbles ? this.parent : null;
		var result = (openfl_events_EventDispatcher().default).prototype.__dispatchEvent.call(this,event);
		if(event.__isCanceled) {
			return true;
		}
		if(parent != null && parent != this) {
			event.eventPhase = 3;
			if(event.target == null) {
				event.target = this;
			}
			parent.__dispatchEvent(event);
		}
		return result;
	},
	__dispatchWithCapture: function(event) {
		if(event.target == null) {
			event.target = this;
		}
		if(this.parent != null) {
			event.eventPhase = 1;
			if(this.parent == this.stage) {
				this.parent.__dispatch(event);
			} else {
				var stack = DisplayObject.__tempStack.get();
				var parent = this.parent;
				var i = 0;
				while(parent != null) {
					(openfl__$Vector_Vector_$Impl_$().default).set(stack,i,parent);
					parent = parent.parent;
					++i;
				}
				var _g = 0;
				var _g1 = i;
				while(_g < _g1) {
					var j = _g++;
					stack[i - j - 1].__dispatch(event);
				}
				DisplayObject.__tempStack.release(stack);
			}
		}
		event.eventPhase = 2;
		return this.__dispatchEvent(event);
	},
	__enterFrame: function(deltaTime) {
	},
	__getBounds: function(rect,matrix) {
		if(this.__graphics != null) {
			this.__graphics.__getBounds(rect,matrix);
		}
	},
	__getCursor: function() {
		return null;
	},
	__getFilterBounds: function(rect,matrix) {
		this.__getRenderBounds(rect,matrix);
		if(this.__filters != null) {
			var extension = (openfl_geom_Rectangle().default).__pool.get();
			var _g = 0;
			var _g1 = this.__filters;
			while(_g < _g1.length) {
				var filter = _g1[_g];
				++_g;
				extension.__expand(-filter.__leftExtension,-filter.__topExtension,filter.__leftExtension + filter.__rightExtension,filter.__topExtension + filter.__bottomExtension);
			}
			rect.width += extension.width;
			rect.height += extension.height;
			rect.x += extension.x;
			rect.y += extension.y;
			(openfl_geom_Rectangle().default).__pool.release(extension);
		}
	},
	__getInteractive: function(stack) {
		return false;
	},
	__getLocalBounds: function(rect) {
		this.__getBounds(rect,this.__transform);
		rect.x -= this.__transform.tx;
		rect.y -= this.__transform.ty;
	},
	__getRenderBounds: function(rect,matrix) {
		if(this.__scrollRect == null) {
			this.__getBounds(rect,matrix);
		} else {
			var r = (openfl_geom_Rectangle().default).__pool.get();
			r.copyFrom(this.__scrollRect);
			r.__transform(r,matrix);
			rect.__expand(r.x,r.y,r.width,r.height);
			(openfl_geom_Rectangle().default).__pool.release(r);
		}
	},
	__getRenderTransform: function() {
		this.__getWorldTransform();
		return this.__renderTransform;
	},
	__getWorldTransform: function() {
		var transformDirty = this.__transformDirty || this.__worldTransformInvalid;
		if(transformDirty) {
			var list = [];
			var current = this;
			if(this.parent == null) {
				this.__update(true,false);
			} else {
				while(current != this.stage) {
					list.push(current);
					current = current.parent;
					if(current == null) {
						break;
					}
				}
			}
			var i = list.length;
			while(--i >= 0) {
				current = list[i];
				current.__update(true,false);
			}
		}
		return this.__worldTransform;
	},
	__globalToLocal: function(global,local) {
		this.__getRenderTransform();
		if(global == local) {
			this.__renderTransform.__transformInversePoint(global);
		} else {
			local.x = this.__renderTransform.__transformInverseX(global.x,global.y);
			local.y = this.__renderTransform.__transformInverseY(global.x,global.y);
		}
		return local;
	},
	__hitTest: function(x,y,shapeFlag,stack,interactiveOnly,hitObject) {
		if(this.__graphics != null) {
			if(!hitObject.__visible || this.__isMask) {
				return false;
			}
			if(this.get_mask() != null && !this.get_mask().__hitTestMask(x,y)) {
				return false;
			}
			if(this.__graphics.__hitTest(x,y,shapeFlag,this.__getRenderTransform())) {
				if(stack != null && !interactiveOnly) {
					stack.push(hitObject);
				}
				return true;
			}
		}
		return false;
	},
	__hitTestMask: function(x,y) {
		if(this.__graphics != null) {
			if(this.__graphics.__hitTest(x,y,true,this.__getRenderTransform())) {
				return true;
			}
		}
		return false;
	},
	__readGraphicsData: function(graphicsData,recurse) {
		if(this.__graphics != null) {
			this.__graphics.__readGraphicsData(graphicsData);
		}
	},
	__renderCairo: function(renderer) {
	},
	__renderCairoMask: function(renderer) {
	},
	__renderCanvas: function(renderer) {
		if(this.get_mask() == null || this.get_mask().get_width() > 0 && this.get_mask().get_height() > 0) {
			this.__updateCacheBitmap(renderer,false);
			if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
				(openfl__$internal_renderer_canvas_CanvasBitmap().default).render(this.__cacheBitmap,renderer);
			} else {
				(openfl__$internal_renderer_canvas_CanvasDisplayObject().default).render(this,renderer);
			}
		}
		this.__renderEvent(renderer);
	},
	__renderCanvasMask: function(renderer) {
		if(this.__graphics != null) {
			(openfl__$internal_renderer_canvas_CanvasGraphics().default).renderMask(this.__graphics,renderer);
		}
	},
	__renderDOM: function(renderer) {
		this.__updateCacheBitmap(renderer,false);
		if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
			this.__renderDOMClear(renderer);
			this.__cacheBitmap.stage = this.stage;
			(openfl__$internal_renderer_dom_DOMBitmap().default).render(this.__cacheBitmap,renderer);
		} else {
			(openfl__$internal_renderer_dom_DOMDisplayObject().default).render(this,renderer);
		}
		this.__renderEvent(renderer);
	},
	__renderDOMClear: function(renderer) {
		(openfl__$internal_renderer_dom_DOMDisplayObject().default).clear(this,renderer);
	},
	__renderEvent: function(renderer) {
		if(this.__customRenderEvent != null && this.__renderable) {
			this.__customRenderEvent.allowSmoothing = renderer.__allowSmoothing;
			this.__customRenderEvent.objectMatrix.copyFrom(this.__renderTransform);
			this.__customRenderEvent.objectColorTransform.__copyFrom(this.__worldColorTransform);
			this.__customRenderEvent.renderer = renderer;
			switch(renderer.__type) {
			case "cairo":
				this.__customRenderEvent.type = "renderCairo";
				break;
			case "canvas":
				this.__customRenderEvent.type = "renderCanvas";
				break;
			case "dom":
				if(this.stage != null && this.__worldVisible) {
					this.__customRenderEvent.type = "renderDOM";
				} else {
					this.__customRenderEvent.type = "clearDOM";
				}
				break;
			case "opengl":
				if(!renderer.__cleared) {
					renderer.__clear();
				}
				var renderer1 = renderer;
				renderer1.setShader(this.__worldShader);
				renderer1.__context3D.__flushGL();
				this.__customRenderEvent.type = "renderOpenGL";
				break;
			default:
				return;
			}
			renderer.__setBlendMode(this.__worldBlendMode);
			renderer.__pushMaskObject(this);
			this.dispatchEvent(this.__customRenderEvent);
			renderer.__popMaskObject(this);
			if(renderer.__type == "opengl") {
				var renderer2 = renderer;
				renderer2.setViewport();
			}
		}
	},
	__renderGL: function(renderer) {
		this.__updateCacheBitmap(renderer,false);
		if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
			(openfl__$internal_renderer_context3D_Context3DBitmap().default).render(this.__cacheBitmap,renderer);
		} else {
			(openfl__$internal_renderer_context3D_Context3DDisplayObject().default).render(this,renderer);
		}
		this.__renderEvent(renderer);
	},
	__renderGLMask: function(renderer) {
		if(this.__graphics != null) {
			(openfl__$internal_renderer_context3D_Context3DShape().default).renderMask(this,renderer);
		}
	},
	__setParentRenderDirty: function() {
		var renderParent = this.__renderParent != null ? this.__renderParent : this.parent;
		if(renderParent != null && !renderParent.__renderDirty) {
			renderParent.__renderDirty = true;
			renderParent.__setParentRenderDirty();
		}
	},
	__setRenderDirty: function() {
		if(!this.__renderDirty) {
			this.__renderDirty = true;
			this.__setParentRenderDirty();
		}
	},
	__setStageReference: function(stage) {
		this.stage = stage;
	},
	__setTransformDirty: function() {
		if(!this.__transformDirty) {
			this.__transformDirty = true;
			this.__setWorldTransformInvalid();
			this.__setParentRenderDirty();
		}
	},
	__setWorldTransformInvalid: function() {
		this.__worldTransformInvalid = true;
	},
	__shouldCacheHardware: function(value) {
		if(value == true || this.__filters != null) {
			return true;
		}
		if(value == false || this.__graphics != null && !(openfl__$internal_renderer_context3D_Context3DGraphics().default).isCompatible(this.__graphics)) {
			return false;
		}
		return null;
	},
	__stopAllMovieClips: function() {
	},
	__update: function(transformOnly,updateChildren) {
		var renderParent = this.__renderParent != null ? this.__renderParent : this.parent;
		if(this.__isMask && renderParent == null) {
			renderParent = this.__maskTarget;
		}
		this.__renderable = this.__visible && this.__scaleX != 0 && this.__scaleY != 0 && !this.__isMask && (renderParent == null || !renderParent.__isMask);
		this.__updateTransforms();
		this.__transformDirty = false;
		this.__worldTransformInvalid = false;
		if(!transformOnly) {
			if(DisplayObject.__supportDOM) {
				this.__renderTransformChanged = !this.__renderTransform.equals(this.__renderTransformCache);
				if(this.__renderTransformCache == null) {
					this.__renderTransformCache = this.__renderTransform.clone();
				} else {
					this.__renderTransformCache.copyFrom(this.__renderTransform);
				}
			}
			if(renderParent != null) {
				if(DisplayObject.__supportDOM) {
					var worldVisible = renderParent.__worldVisible && this.__visible;
					this.__worldVisibleChanged = this.__worldVisible != worldVisible;
					this.__worldVisible = worldVisible;
					var worldAlpha = this.get_alpha() * renderParent.__worldAlpha;
					this.__worldAlphaChanged = this.__worldAlpha != worldAlpha;
					this.__worldAlpha = worldAlpha;
				} else {
					this.__worldAlpha = this.get_alpha() * renderParent.__worldAlpha;
				}
				if(this.__objectTransform != null) {
					this.__worldColorTransform.__copyFrom(this.__objectTransform.get_colorTransform());
					this.__worldColorTransform.__combine(renderParent.__worldColorTransform);
				} else {
					this.__worldColorTransform.__copyFrom(renderParent.__worldColorTransform);
				}
				if(this.__blendMode == null || this.__blendMode == "normal") {
					this.__worldBlendMode = renderParent.__worldBlendMode;
				} else {
					this.__worldBlendMode = this.__blendMode;
				}
				if(this.__shader == null) {
					this.__worldShader = renderParent.__shader;
				} else {
					this.__worldShader = this.__shader;
				}
				if(this.__scale9Grid == null) {
					this.__worldScale9Grid = renderParent.__scale9Grid;
				} else {
					this.__worldScale9Grid = this.__scale9Grid;
				}
			} else {
				this.__worldAlpha = this.get_alpha();
				if(DisplayObject.__supportDOM) {
					this.__worldVisibleChanged = this.__worldVisible != this.__visible;
					this.__worldVisible = this.__visible;
					this.__worldAlphaChanged = this.__worldAlpha != this.get_alpha();
				}
				if(this.__objectTransform != null) {
					this.__worldColorTransform.__copyFrom(this.__objectTransform.get_colorTransform());
				} else {
					this.__worldColorTransform.__identity();
				}
				this.__worldBlendMode = this.__blendMode;
				this.__worldShader = this.__shader;
				this.__worldScale9Grid = this.__scale9Grid;
			}
		}
		if(updateChildren && this.get_mask() != null) {
			this.get_mask().__update(transformOnly,true);
		}
	},
	__updateCacheBitmap: function(renderer,force) {
		if(this.__isCacheBitmapRender) {
			return false;
		}
		var colorTransform = (openfl_geom_ColorTransform().default).__pool.get();
		colorTransform.__copyFrom(this.__worldColorTransform);
		if(renderer.__worldColorTransform != null) {
			colorTransform.__combine(renderer.__worldColorTransform);
		}
		var updated = false;
		if(this.get_cacheAsBitmap() || renderer.__type != "opengl" && !colorTransform.__isDefault(true)) {
			var rect = null;
			var needRender = this.__cacheBitmap == null || this.__renderDirty && (force || this.__children != null && this.__children.length > 0) || this.opaqueBackground != this.__cacheBitmapBackground;
			var softwareDirty = needRender || this.__graphics != null && this.__graphics.__softwareDirty || !this.__cacheBitmapColorTransform.__equals(colorTransform,true);
			var hardwareDirty = needRender || this.__graphics != null && this.__graphics.__hardwareDirty;
			var renderType = renderer.__type;
			if(softwareDirty || hardwareDirty) {
				if(renderType == "opengl") {
					if(this.__shouldCacheHardware(null) == false) {
						renderType = "canvas";
					}
				}
				if(softwareDirty && (renderType == "canvas" || renderType == "cairo")) {
					needRender = true;
				}
				if(hardwareDirty && renderType == "opengl") {
					needRender = true;
				}
			}
			var updateTransform = needRender || !this.__cacheBitmap.__worldTransform.equals(this.__worldTransform);
			var hasFilters = this.__filters != null;
			if(hasFilters && !needRender) {
				var _g = 0;
				var _g1 = this.__filters;
				while(_g < _g1.length) {
					var filter = _g1[_g];
					++_g;
					if(filter.__renderDirty) {
						needRender = true;
						break;
					}
				}
			}
			if(this.__cacheBitmapMatrix == null) {
				this.__cacheBitmapMatrix = new (openfl_geom_Matrix().default)();
			}
			var bitmapMatrix = this.__cacheAsBitmapMatrix != null ? this.__cacheAsBitmapMatrix : this.__renderTransform;
			if(!needRender && (bitmapMatrix.a != this.__cacheBitmapMatrix.a || bitmapMatrix.b != this.__cacheBitmapMatrix.b || bitmapMatrix.c != this.__cacheBitmapMatrix.c || bitmapMatrix.d != this.__cacheBitmapMatrix.d)) {
				needRender = true;
			}
			if(!needRender && renderer.__type != "opengl" && this.__cacheBitmapData != null && this.__cacheBitmapData.image != null && this.__cacheBitmapData.image.version < this.__cacheBitmapData.__textureVersion) {
				needRender = true;
			}
			this.__cacheBitmapMatrix.copyFrom(bitmapMatrix);
			this.__cacheBitmapMatrix.tx = 0;
			this.__cacheBitmapMatrix.ty = 0;
			var bitmapWidth = 0;
			var bitmapHeight = 0;
			var filterWidth = 0;
			var filterHeight = 0;
			var offsetX = 0.;
			var offsetY = 0.;
			if(updateTransform || needRender) {
				rect = (openfl_geom_Rectangle().default).__pool.get();
				this.__getFilterBounds(rect,this.__cacheBitmapMatrix);
				filterWidth = Math.ceil(rect.width);
				filterHeight = Math.ceil(rect.height);
				offsetX = rect.x > 0 ? Math.ceil(rect.x) : Math.floor(rect.x);
				offsetY = rect.y > 0 ? Math.ceil(rect.y) : Math.floor(rect.y);
				if(this.__cacheBitmapData != null) {
					if(filterWidth > this.__cacheBitmapData.width || filterHeight > this.__cacheBitmapData.height) {
						bitmapWidth = Math.ceil(Math.max(filterWidth * 1.25,this.__cacheBitmapData.width));
						bitmapHeight = Math.ceil(Math.max(filterHeight * 1.25,this.__cacheBitmapData.height));
						needRender = true;
					} else {
						bitmapWidth = this.__cacheBitmapData.width;
						bitmapHeight = this.__cacheBitmapData.height;
					}
				} else {
					bitmapWidth = filterWidth;
					bitmapHeight = filterHeight;
				}
			}
			if(needRender) {
				updateTransform = true;
				this.__cacheBitmapBackground = this.opaqueBackground;
				if(filterWidth >= 0.5 && filterHeight >= 0.5) {
					var needsFill = this.opaqueBackground != null && (bitmapWidth != filterWidth || bitmapHeight != filterHeight);
					var fillColor = this.opaqueBackground != null ? -16777216 | this.opaqueBackground : 0;
					var bitmapColor = needsFill ? 0 : fillColor;
					var allowFramebuffer = renderer.__type == "opengl";
					if(this.__cacheBitmapData == null || bitmapWidth > this.__cacheBitmapData.width || bitmapHeight > this.__cacheBitmapData.height) {
						this.__cacheBitmapData = new (openfl_display_BitmapData().default)(bitmapWidth,bitmapHeight,true,bitmapColor);
						if(this.__cacheBitmap == null) {
							this.__cacheBitmap = new (openfl_display_Bitmap().default)();
						}
						this.__cacheBitmap.__bitmapData = this.__cacheBitmapData;
						this.__cacheBitmapRenderer = null;
					} else {
						this.__cacheBitmapData.__fillRect(this.__cacheBitmapData.rect,bitmapColor,allowFramebuffer);
					}
					if(needsFill) {
						rect.setTo(0,0,filterWidth,filterHeight);
						this.__cacheBitmapData.__fillRect(rect,fillColor,allowFramebuffer);
					}
				} else {
					(openfl_geom_ColorTransform().default).__pool.release(colorTransform);
					this.__cacheBitmap = null;
					this.__cacheBitmapData = null;
					this.__cacheBitmapData2 = null;
					this.__cacheBitmapData3 = null;
					this.__cacheBitmapRenderer = null;
					return true;
				}
			} else {
				this.__cacheBitmapData = this.__cacheBitmap.get_bitmapData();
				this.__cacheBitmapData2 = null;
				this.__cacheBitmapData3 = null;
			}
			if(updateTransform || needRender) {
				this.__cacheBitmap.__worldTransform.copyFrom(this.__worldTransform);
				if(bitmapMatrix == this.__renderTransform) {
					this.__cacheBitmap.__renderTransform.identity();
					this.__cacheBitmap.__renderTransform.tx = this.__renderTransform.tx + offsetX;
					this.__cacheBitmap.__renderTransform.ty = this.__renderTransform.ty + offsetY;
				} else {
					this.__cacheBitmap.__renderTransform.copyFrom(this.__cacheBitmapMatrix);
					this.__cacheBitmap.__renderTransform.invert();
					this.__cacheBitmap.__renderTransform.concat(this.__renderTransform);
					this.__cacheBitmap.__renderTransform.tx += offsetX;
					this.__cacheBitmap.__renderTransform.ty += offsetY;
				}
			}
			this.__cacheBitmap.smoothing = renderer.__allowSmoothing;
			this.__cacheBitmap.__renderable = this.__renderable;
			this.__cacheBitmap.__worldAlpha = this.__worldAlpha;
			this.__cacheBitmap.__worldBlendMode = this.__worldBlendMode;
			this.__cacheBitmap.__worldShader = this.__worldShader;
			this.__cacheBitmap.set_mask(this.__mask);
			if(needRender) {
				if(this.__cacheBitmapRenderer == null || renderType != this.__cacheBitmapRenderer.__type) {
					if(renderType == "opengl") {
						this.__cacheBitmapRenderer = new (openfl_display_OpenGLRenderer().default)(((js_Boot().default).__cast(renderer , (openfl_display_OpenGLRenderer().default))).__context3D,this.__cacheBitmapData);
					} else {
						if(this.__cacheBitmapData.image == null) {
							var color = this.opaqueBackground != null ? -16777216 | this.opaqueBackground : 0;
							this.__cacheBitmapData = new (openfl_display_BitmapData().default)(bitmapWidth,bitmapHeight,true,color);
							this.__cacheBitmap.__bitmapData = this.__cacheBitmapData;
						}
						(lime__$internal_graphics_ImageCanvasUtil().default).convertToCanvas(this.__cacheBitmapData.image);
						this.__cacheBitmapRenderer = new (openfl_display_CanvasRenderer().default)(this.__cacheBitmapData.image.buffer.__srcContext);
					}
					this.__cacheBitmapRenderer.__worldTransform = new (openfl_geom_Matrix().default)();
					this.__cacheBitmapRenderer.__worldColorTransform = new (openfl_geom_ColorTransform().default)();
				}
				if(this.__cacheBitmapColorTransform == null) {
					this.__cacheBitmapColorTransform = new (openfl_geom_ColorTransform().default)();
				}
				this.__cacheBitmapRenderer.__stage = this.stage;
				this.__cacheBitmapRenderer.__allowSmoothing = renderer.__allowSmoothing;
				this.__cacheBitmapRenderer.__setBlendMode("normal");
				this.__cacheBitmapRenderer.__worldAlpha = 1 / this.__worldAlpha;
				this.__cacheBitmapRenderer.__worldTransform.copyFrom(this.__renderTransform);
				this.__cacheBitmapRenderer.__worldTransform.invert();
				this.__cacheBitmapRenderer.__worldTransform.concat(this.__cacheBitmapMatrix);
				this.__cacheBitmapRenderer.__worldTransform.tx -= offsetX;
				this.__cacheBitmapRenderer.__worldTransform.ty -= offsetY;
				this.__cacheBitmapRenderer.__worldColorTransform.__copyFrom(colorTransform);
				this.__cacheBitmapRenderer.__worldColorTransform.__invert();
				this.__isCacheBitmapRender = true;
				if(this.__cacheBitmapRenderer.__type == "opengl") {
					var parentRenderer = renderer;
					var childRenderer = this.__cacheBitmapRenderer;
					var context = childRenderer.__context3D;
					var cacheRTT = context.__state.renderToTexture;
					var cacheRTTDepthStencil = context.__state.renderToTextureDepthStencil;
					var cacheRTTAntiAlias = context.__state.renderToTextureAntiAlias;
					var cacheRTTSurfaceSelector = context.__state.renderToTextureSurfaceSelector;
					var cacheBlendMode = parentRenderer.__blendMode;
					parentRenderer.__suspendClipAndMask();
					childRenderer.__copyShader(parentRenderer);
					this.__cacheBitmapData.__setUVRect(context,0,0,filterWidth,filterHeight);
					childRenderer.__setRenderTarget(this.__cacheBitmapData);
					if(this.__cacheBitmapData.image != null) {
						this.__cacheBitmapData.__textureVersion = this.__cacheBitmapData.image.version + 1;
					}
					this.__cacheBitmapData.__drawGL(this,childRenderer);
					if(hasFilters) {
						var needSecondBitmapData = true;
						var needCopyOfOriginal = false;
						var _g2 = 0;
						var _g11 = this.__filters;
						while(_g2 < _g11.length) {
							var filter1 = _g11[_g2];
							++_g2;
							if(filter1.__preserveObject) {
								needCopyOfOriginal = true;
							}
						}
						var bitmap = this.__cacheBitmapData;
						var bitmap2 = null;
						var bitmap3 = null;
						if(this.__cacheBitmapData2 == null || bitmapWidth > this.__cacheBitmapData2.width || bitmapHeight > this.__cacheBitmapData2.height) {
							this.__cacheBitmapData2 = new (openfl_display_BitmapData().default)(bitmapWidth,bitmapHeight,true,0);
						} else {
							this.__cacheBitmapData2.fillRect(this.__cacheBitmapData2.rect,0);
							if(this.__cacheBitmapData2.image != null) {
								this.__cacheBitmapData2.__textureVersion = this.__cacheBitmapData2.image.version + 1;
							}
						}
						this.__cacheBitmapData2.__setUVRect(context,0,0,filterWidth,filterHeight);
						bitmap2 = this.__cacheBitmapData2;
						if(needCopyOfOriginal) {
							if(this.__cacheBitmapData3 == null || bitmapWidth > this.__cacheBitmapData3.width || bitmapHeight > this.__cacheBitmapData3.height) {
								this.__cacheBitmapData3 = new (openfl_display_BitmapData().default)(bitmapWidth,bitmapHeight,true,0);
							} else {
								this.__cacheBitmapData3.fillRect(this.__cacheBitmapData3.rect,0);
								if(this.__cacheBitmapData3.image != null) {
									this.__cacheBitmapData3.__textureVersion = this.__cacheBitmapData3.image.version + 1;
								}
							}
							this.__cacheBitmapData3.__setUVRect(context,0,0,filterWidth,filterHeight);
							bitmap3 = this.__cacheBitmapData3;
						}
						childRenderer.__setBlendMode("normal");
						childRenderer.__worldAlpha = 1;
						childRenderer.__worldTransform.identity();
						childRenderer.__worldColorTransform.__identity();
						var shader;
						var cacheBitmap;
						var _g21 = 0;
						var _g3 = this.__filters;
						while(_g21 < _g3.length) {
							var filter2 = _g3[_g21];
							++_g21;
							if(filter2.__preserveObject) {
								childRenderer.__setRenderTarget(bitmap3);
								childRenderer.__renderFilterPass(bitmap,childRenderer.__defaultDisplayShader,filter2.__smooth);
							}
							var _g22 = 0;
							var _g31 = filter2.__numShaderPasses;
							while(_g22 < _g31) {
								var i = _g22++;
								shader = filter2.__initShader(childRenderer,i);
								childRenderer.__setBlendMode(filter2.__shaderBlendMode);
								childRenderer.__setRenderTarget(bitmap2);
								childRenderer.__renderFilterPass(bitmap,shader,filter2.__smooth);
								cacheBitmap = bitmap;
								bitmap = bitmap2;
								bitmap2 = cacheBitmap;
							}
							if(filter2.__preserveObject) {
								childRenderer.__setBlendMode("normal");
								childRenderer.__setRenderTarget(bitmap);
								childRenderer.__renderFilterPass(bitmap3,childRenderer.__defaultDisplayShader,filter2.__smooth,false);
							}
							filter2.__renderDirty = false;
						}
						this.__cacheBitmap.__bitmapData = bitmap;
					}
					parentRenderer.__blendMode = "normal";
					parentRenderer.__setBlendMode(cacheBlendMode);
					parentRenderer.__copyShader(childRenderer);
					if(cacheRTT != null) {
						context.setRenderToTexture(cacheRTT,cacheRTTDepthStencil,cacheRTTAntiAlias,cacheRTTSurfaceSelector);
					} else {
						context.setRenderToBackBuffer();
					}
					parentRenderer.__resumeClipAndMask(childRenderer);
					parentRenderer.setViewport();
					this.__cacheBitmapColorTransform.__copyFrom(colorTransform);
				} else {
					this.__cacheBitmapData.__drawCanvas(this,this.__cacheBitmapRenderer);
					if(hasFilters) {
						var needSecondBitmapData1 = false;
						var needCopyOfOriginal1 = false;
						var _g4 = 0;
						var _g12 = this.__filters;
						while(_g4 < _g12.length) {
							var filter3 = _g12[_g4];
							++_g4;
							if(filter3.__needSecondBitmapData) {
								needSecondBitmapData1 = true;
							}
							if(filter3.__preserveObject) {
								needCopyOfOriginal1 = true;
							}
						}
						var bitmap1 = this.__cacheBitmapData;
						var bitmap21 = null;
						var bitmap31 = null;
						if(needSecondBitmapData1) {
							if(this.__cacheBitmapData2 == null || this.__cacheBitmapData2.image == null || bitmapWidth > this.__cacheBitmapData2.width || bitmapHeight > this.__cacheBitmapData2.height) {
								this.__cacheBitmapData2 = new (openfl_display_BitmapData().default)(bitmapWidth,bitmapHeight,true,0);
							} else {
								this.__cacheBitmapData2.fillRect(this.__cacheBitmapData2.rect,0);
							}
							bitmap21 = this.__cacheBitmapData2;
						} else {
							bitmap21 = bitmap1;
						}
						if(needCopyOfOriginal1) {
							if(this.__cacheBitmapData3 == null || this.__cacheBitmapData3.image == null || bitmapWidth > this.__cacheBitmapData3.width || bitmapHeight > this.__cacheBitmapData3.height) {
								this.__cacheBitmapData3 = new (openfl_display_BitmapData().default)(bitmapWidth,bitmapHeight,true,0);
							} else {
								this.__cacheBitmapData3.fillRect(this.__cacheBitmapData3.rect,0);
							}
							bitmap31 = this.__cacheBitmapData3;
						}
						if(this.__tempPoint == null) {
							this.__tempPoint = new (openfl_geom_Point().default)();
						}
						var destPoint = this.__tempPoint;
						var cacheBitmap1;
						var lastBitmap;
						var _g23 = 0;
						var _g32 = this.__filters;
						while(_g23 < _g32.length) {
							var filter4 = _g32[_g23];
							++_g23;
							if(filter4.__preserveObject) {
								bitmap31.copyPixels(bitmap1,bitmap1.rect,destPoint);
							}
							lastBitmap = filter4.__applyFilter(bitmap21,bitmap1,bitmap1.rect,destPoint);
							if(filter4.__preserveObject) {
								lastBitmap.draw(bitmap31,null,this.__objectTransform != null ? this.__objectTransform.get_colorTransform() : null);
							}
							filter4.__renderDirty = false;
							if(needSecondBitmapData1 && lastBitmap == bitmap21) {
								cacheBitmap1 = bitmap1;
								bitmap1 = bitmap21;
								bitmap21 = cacheBitmap1;
							}
						}
						if(this.__cacheBitmapData != bitmap1) {
							cacheBitmap1 = this.__cacheBitmapData;
							this.__cacheBitmapData = bitmap1;
							this.__cacheBitmapData2 = cacheBitmap1;
							this.__cacheBitmap.__bitmapData = this.__cacheBitmapData;
							this.__cacheBitmapRenderer = null;
						}
						this.__cacheBitmap.__imageVersion = this.__cacheBitmapData.__textureVersion;
					}
					this.__cacheBitmapColorTransform.__copyFrom(colorTransform);
					if(!this.__cacheBitmapColorTransform.__isDefault(true)) {
						this.__cacheBitmapColorTransform.alphaMultiplier = 1;
						this.__cacheBitmapData.colorTransform(this.__cacheBitmapData.rect,this.__cacheBitmapColorTransform);
					}
				}
				this.__isCacheBitmapRender = false;
			}
			if(updateTransform || needRender) {
				(openfl_geom_Rectangle().default).__pool.release(rect);
			}
			updated = updateTransform;
		} else if(this.__cacheBitmap != null) {
			if(renderer.__type == "dom") {
				this.__cacheBitmap.__renderDOMClear(renderer);
			}
			this.__cacheBitmap = null;
			this.__cacheBitmapData = null;
			this.__cacheBitmapData2 = null;
			this.__cacheBitmapData3 = null;
			this.__cacheBitmapColorTransform = null;
			this.__cacheBitmapRenderer = null;
			updated = true;
		}
		(openfl_geom_ColorTransform().default).__pool.release(colorTransform);
		return updated;
	},
	__updateTransforms: function(overrideTransform) {
		var overrided = overrideTransform != null;
		var local = overrided ? overrideTransform : this.__transform;
		if(this.__worldTransform == null) {
			this.__worldTransform = new (openfl_geom_Matrix().default)();
		}
		if(this.__renderTransform == null) {
			this.__renderTransform = new (openfl_geom_Matrix().default)();
		}
		var renderParent = this.__renderParent != null ? this.__renderParent : this.parent;
		if(!overrided && this.parent != null) {
			DisplayObject.__calculateAbsoluteTransform(local,this.parent.__worldTransform,this.__worldTransform);
		} else {
			this.__worldTransform.copyFrom(local);
		}
		if(!overrided && renderParent != null) {
			DisplayObject.__calculateAbsoluteTransform(local,renderParent.__renderTransform,this.__renderTransform);
		} else {
			this.__renderTransform.copyFrom(local);
		}
		if(this.__scrollRect != null) {
			this.__renderTransform.__translateTransformed(-this.__scrollRect.x,-this.__scrollRect.y);
		}
	},
	get_alpha: function() {
		return this.__alpha;
	},
	set_alpha: function(value) {
		if(value > 1.0) {
			value = 1.0;
		}
		if(value < 0.0) {
			value = 0.0;
		}
		if(value != this.__alpha && !this.get_cacheAsBitmap()) {
			this.__setRenderDirty();
		}
		return this.__alpha = value;
	},
	get_blendMode: function() {
		return this.__blendMode;
	},
	set_blendMode: function(value) {
		if(value == null) {
			value = "normal";
		}
		if(value != this.__blendMode) {
			this.__setRenderDirty();
		}
		return this.__blendMode = value;
	},
	get_cacheAsBitmap: function() {
		if(this.__filters == null) {
			return this.__cacheAsBitmap;
		} else {
			return true;
		}
	},
	set_cacheAsBitmap: function(value) {
		if(value != this.__cacheAsBitmap) {
			this.__setRenderDirty();
		}
		return this.__cacheAsBitmap = value;
	},
	get_cacheAsBitmapMatrix: function() {
		return this.__cacheAsBitmapMatrix;
	},
	set_cacheAsBitmapMatrix: function(value) {
		this.__setRenderDirty();
		return this.__cacheAsBitmapMatrix = value != null ? value.clone() : value;
	},
	get_filters: function() {
		if(this.__filters == null) {
			return [];
		} else {
			return this.__filters.slice();
		}
	},
	set_filters: function(value) {
		if(value != null && value.length > 0) {
			this.__filters = value;
			this.__setRenderDirty();
		} else if(this.__filters != null) {
			this.__filters = null;
			this.__setRenderDirty();
		}
		return value;
	},
	get_height: function() {
		var rect = (openfl_geom_Rectangle().default).__pool.get();
		this.__getLocalBounds(rect);
		var height = rect.height;
		(openfl_geom_Rectangle().default).__pool.release(rect);
		return height;
	},
	set_height: function(value) {
		var rect = (openfl_geom_Rectangle().default).__pool.get();
		var matrix = (openfl_geom_Matrix().default).__pool.get();
		matrix.identity();
		this.__getBounds(rect,matrix);
		if(value != rect.height) {
			this.set_scaleY(value / rect.height);
		} else {
			this.set_scaleY(1);
		}
		(openfl_geom_Rectangle().default).__pool.release(rect);
		(openfl_geom_Matrix().default).__pool.release(matrix);
		return value;
	},
	get_loaderInfo: function() {
		if(this.stage != null) {
			return (openfl__$internal_Lib().default).current.__loaderInfo;
		}
		return null;
	},
	get_mask: function() {
		return this.__mask;
	},
	set_mask: function(value) {
		if(value == this.__mask) {
			return value;
		}
		if(value != this.__mask) {
			this.__setTransformDirty();
			this.__setRenderDirty();
		}
		if(this.__mask != null) {
			this.__mask.__isMask = false;
			this.__mask.__maskTarget = null;
			this.__mask.__setTransformDirty();
			this.__mask.__setRenderDirty();
		}
		if(value != null) {
			value.__isMask = true;
			value.__maskTarget = this;
			value.__setWorldTransformInvalid();
		}
		if(this.__cacheBitmap != null && this.__cacheBitmap.get_mask() != value) {
			this.__cacheBitmap.set_mask(value);
		}
		return this.__mask = value;
	},
	get_mouseX: function() {
		var mouseX = this.stage != null ? this.stage.__mouseX : (openfl__$internal_Lib().default).current.stage.__mouseX;
		var mouseY = this.stage != null ? this.stage.__mouseY : (openfl__$internal_Lib().default).current.stage.__mouseY;
		return this.__getRenderTransform().__transformInverseX(mouseX,mouseY);
	},
	get_mouseY: function() {
		var mouseX = this.stage != null ? this.stage.__mouseX : (openfl__$internal_Lib().default).current.stage.__mouseX;
		var mouseY = this.stage != null ? this.stage.__mouseY : (openfl__$internal_Lib().default).current.stage.__mouseY;
		return this.__getRenderTransform().__transformInverseY(mouseX,mouseY);
	},
	get_name: function() {
		return this.__name;
	},
	set_name: function(value) {
		return this.__name = value;
	},
	get_root: function() {
		if(this.stage != null) {
			return (openfl__$internal_Lib().default).current;
		}
		return null;
	},
	get_rotation: function() {
		return this.__rotation;
	},
	set_rotation: function(value) {
		if(value != this.__rotation) {
			this.__rotation = value;
			var radians = this.__rotation * (Math.PI / 180);
			this.__rotationSine = Math.sin(radians);
			this.__rotationCosine = Math.cos(radians);
			this.__transform.a = this.__rotationCosine * this.__scaleX;
			this.__transform.b = this.__rotationSine * this.__scaleX;
			this.__transform.c = -this.__rotationSine * this.__scaleY;
			this.__transform.d = this.__rotationCosine * this.__scaleY;
			this.__setTransformDirty();
		}
		return value;
	},
	get_scale9Grid: function() {
		if(this.__scale9Grid == null) {
			return null;
		}
		return this.__scale9Grid.clone();
	},
	set_scale9Grid: function(value) {
		if(value == null && this.__scale9Grid == null) {
			return value;
		}
		if(value != null && this.__scale9Grid != null && this.__scale9Grid.equals(value)) {
			return value;
		}
		if(value != null) {
			if(this.__scale9Grid == null) {
				this.__scale9Grid = new (openfl_geom_Rectangle().default)();
			}
			this.__scale9Grid.copyFrom(value);
		} else {
			this.__scale9Grid = null;
		}
		this.__setRenderDirty();
		return value;
	},
	get_scaleX: function() {
		return this.__scaleX;
	},
	set_scaleX: function(value) {
		if(value != this.__scaleX) {
			this.__scaleX = value;
			if(this.__transform.b == 0) {
				if(value != this.__transform.a) {
					this.__setTransformDirty();
				}
				this.__transform.a = value;
			} else {
				var a = this.__rotationCosine * value;
				var b = this.__rotationSine * value;
				if(this.__transform.a != a || this.__transform.b != b) {
					this.__setTransformDirty();
				}
				this.__transform.a = a;
				this.__transform.b = b;
			}
		}
		return value;
	},
	get_scaleY: function() {
		return this.__scaleY;
	},
	set_scaleY: function(value) {
		if(value != this.__scaleY) {
			this.__scaleY = value;
			if(this.__transform.c == 0) {
				if(value != this.__transform.d) {
					this.__setTransformDirty();
				}
				this.__transform.d = value;
			} else {
				var c = -this.__rotationSine * value;
				var d = this.__rotationCosine * value;
				if(this.__transform.d != d || this.__transform.c != c) {
					this.__setTransformDirty();
				}
				this.__transform.c = c;
				this.__transform.d = d;
			}
		}
		return value;
	},
	get_scrollRect: function() {
		if(this.__scrollRect == null) {
			return null;
		}
		return this.__scrollRect.clone();
	},
	set_scrollRect: function(value) {
		if(value == null && this.__scrollRect == null) {
			return value;
		}
		if(value != null && this.__scrollRect != null && this.__scrollRect.equals(value)) {
			return value;
		}
		if(value != null) {
			if(this.__scrollRect == null) {
				this.__scrollRect = new (openfl_geom_Rectangle().default)();
			}
			this.__scrollRect.copyFrom(value);
		} else {
			this.__scrollRect = null;
		}
		this.__setTransformDirty();
		if(DisplayObject.__supportDOM) {
			this.__setRenderDirty();
		}
		return value;
	},
	get_shader: function() {
		return this.__shader;
	},
	set_shader: function(value) {
		this.__shader = value;
		this.__setRenderDirty();
		return value;
	},
	get_transform: function() {
		if(this.__objectTransform == null) {
			this.__objectTransform = new (openfl_geom_Transform().default)(this);
		}
		return this.__objectTransform;
	},
	set_transform: function(value) {
		if(value == null) {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_TypeError().default)("Parameter transform must be non-null."));
		}
		if(this.__objectTransform == null) {
			this.__objectTransform = new (openfl_geom_Transform().default)(this);
		}
		this.__setTransformDirty();
		this.__objectTransform.set_matrix(value.get_matrix());
		if(!this.__objectTransform.get_colorTransform().__equals(value.get_colorTransform(),true) || !this.get_cacheAsBitmap() && this.__objectTransform.get_colorTransform().alphaMultiplier != value.get_colorTransform().alphaMultiplier) {
			this.__objectTransform.get_colorTransform().__copyFrom(value.get_colorTransform());
			this.__setRenderDirty();
		}
		return this.__objectTransform;
	},
	get_visible: function() {
		return this.__visible;
	},
	set_visible: function(value) {
		if(value != this.__visible) {
			this.__setRenderDirty();
		}
		return this.__visible = value;
	},
	get_width: function() {
		var rect = (openfl_geom_Rectangle().default).__pool.get();
		this.__getLocalBounds(rect);
		var width = rect.width;
		(openfl_geom_Rectangle().default).__pool.release(rect);
		return width;
	},
	set_width: function(value) {
		var rect = (openfl_geom_Rectangle().default).__pool.get();
		var matrix = (openfl_geom_Matrix().default).__pool.get();
		matrix.identity();
		this.__getBounds(rect,matrix);
		if(value != rect.width) {
			this.set_scaleX(value / rect.width);
		} else {
			this.set_scaleX(1);
		}
		(openfl_geom_Rectangle().default).__pool.release(rect);
		(openfl_geom_Matrix().default).__pool.release(matrix);
		return value;
	},
	get_x: function() {
		return this.__transform.tx;
	},
	set_x: function(value) {
		if(value != this.__transform.tx) {
			this.__setTransformDirty();
		}
		return this.__transform.tx = value;
	},
	get_y: function() {
		return this.__transform.ty;
	},
	set_y: function(value) {
		if(value != this.__transform.ty) {
			this.__setTransformDirty();
		}
		return this.__transform.ty = value;
	}
});
DisplayObject.prototype.__class__ = DisplayObject.prototype.constructor = $hxClasses["openfl.display.DisplayObject"] = DisplayObject;

// Init

Object.defineProperties(DisplayObject.prototype,{ alpha : { get : function () { return this.get_alpha (); }, set : function (v) { return this.set_alpha (v); }}, blendMode : { get : function () { return this.get_blendMode (); }, set : function (v) { return this.set_blendMode (v); }}, cacheAsBitmap : { get : function () { return this.get_cacheAsBitmap (); }, set : function (v) { return this.set_cacheAsBitmap (v); }}, cacheAsBitmapMatrix : { get : function () { return this.get_cacheAsBitmapMatrix (); }, set : function (v) { return this.set_cacheAsBitmapMatrix (v); }}, filters : { get : function () { return this.get_filters (); }, set : function (v) { return this.set_filters (v); }}, height : { get : function () { return this.get_height (); }, set : function (v) { return this.set_height (v); }}, loaderInfo : { get : function () { return this.get_loaderInfo (); }}, mask : { get : function () { return this.get_mask (); }, set : function (v) { return this.set_mask (v); }}, mouseX : { get : function () { return this.get_mouseX (); }}, mouseY : { get : function () { return this.get_mouseY (); }}, name : { get : function () { return this.get_name (); }, set : function (v) { return this.set_name (v); }}, root : { get : function () { return this.get_root (); }}, rotation : { get : function () { return this.get_rotation (); }, set : function (v) { return this.set_rotation (v); }}, scaleX : { get : function () { return this.get_scaleX (); }, set : function (v) { return this.set_scaleX (v); }}, scaleY : { get : function () { return this.get_scaleY (); }, set : function (v) { return this.set_scaleY (v); }}, scrollRect : { get : function () { return this.get_scrollRect (); }, set : function (v) { return this.set_scrollRect (v); }}, shader : { get : function () { return this.get_shader (); }, set : function (v) { return this.set_shader (v); }}, transform : { get : function () { return this.get_transform (); }, set : function (v) { return this.set_transform (v); }}, visible : { get : function () { return this.get_visible (); }, set : function (v) { return this.set_visible (v); }}, width : { get : function () { return this.get_width (); }, set : function (v) { return this.set_width (v); }}, x : { get : function () { return this.get_x (); }, set : function (v) { return this.set_x (v); }}, y : { get : function () { return this.get_y (); }, set : function (v) { return this.set_y (v); }}});

// Statics

DisplayObject.__calculateAbsoluteTransform = function(local,parentTransform,target) {
	target.a = local.a * parentTransform.a + local.b * parentTransform.c;
	target.b = local.a * parentTransform.b + local.b * parentTransform.d;
	target.c = local.c * parentTransform.a + local.d * parentTransform.c;
	target.d = local.c * parentTransform.b + local.d * parentTransform.d;
	target.tx = local.tx * parentTransform.a + local.ty * parentTransform.c + parentTransform.tx;
	target.ty = local.tx * parentTransform.b + local.ty * parentTransform.d + parentTransform.ty;
}
DisplayObject.__meta__ = { fields : { __cairo : { SuppressWarnings : ["checkstyle:Dynamic"]}, addEventListener : { SuppressWarnings : ["checkstyle:Dynamic"]}, removeEventListener : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
DisplayObject.__broadcastEvents = new (haxe_ds_StringMap().default)()
DisplayObject.__instanceCount = 0
DisplayObject.__tempStack = new (lime_utils_ObjectPool().default)(function() {
	return (openfl__$Vector_Vector_$Impl_$().default)._new();
},function(stack) {
	stack.set_length(0);
})

// Export

exports.default = DisplayObject;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectContainer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectContainer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.DisplayObjectContainer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_InteractiveObject() {return __webpack_require__(/*! ./../../openfl/display/InteractiveObject */ "./node_modules/openfl/lib/_gen/openfl/display/InteractiveObject.js");}
function openfl_errors_TypeError() {return __webpack_require__(/*! ./../../openfl/errors/TypeError */ "./node_modules/openfl/lib/_gen/openfl/errors/TypeError.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_ArgumentError() {return __webpack_require__(/*! ./../../openfl/errors/ArgumentError */ "./node_modules/openfl/lib/_gen/openfl/errors/ArgumentError.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl_errors_RangeError() {return __webpack_require__(/*! ./../../openfl/errors/RangeError */ "./node_modules/openfl/lib/_gen/openfl/errors/RangeError.js");}
function openfl__$Vector_VectorIterator() {return __webpack_require__(/*! ./../../openfl/_Vector/VectorIterator */ "./node_modules/openfl/lib/_gen/openfl/_Vector/VectorIterator.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function openfl_display_DisplayObject() {return __webpack_require__(/*! ./../../openfl/display/DisplayObject */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function openfl__$internal_renderer_canvas_CanvasGraphics() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/canvas/CanvasGraphics */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasGraphics.js");}
function openfl__$internal_renderer_context3D_Context3DShape() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DShape */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DShape.js");}

// Constructor

var DisplayObjectContainer = function() {
	(openfl_display_InteractiveObject().default).call(this);
	this.mouseChildren = true;
	this.__tabChildren = true;
	this.__children = [];
	this.__removedChildren = (openfl__$Vector_Vector_$Impl_$().default)._new();
}

// Meta

DisplayObjectContainer.__name__ = "openfl.display.DisplayObjectContainer";
DisplayObjectContainer.__isInterface__ = false;
DisplayObjectContainer.__super__ = (openfl_display_InteractiveObject().default);
DisplayObjectContainer.prototype = $extend((openfl_display_InteractiveObject().default).prototype, {
	addChild: function(child) {
		return this.addChildAt(child,this.get_numChildren());
	},
	addChildAt: function(child,index) {
		if(child == null) {
			var error = new (openfl_errors_TypeError().default)("Error #2007: Parameter child must be non-null.");
			error.errorID = 2007;
			throw new (js__$Boot_HaxeError().default)(error);
		} else if(child.stage == child) {
			var error1 = new (openfl_errors_ArgumentError().default)("Error #3783: A Stage object cannot be added as the child of another object.");
			error1.errorID = 3783;
			throw new (js__$Boot_HaxeError().default)(error1);
		}
		if(index > this.__children.length || index < 0) {
			throw new (js__$Boot_HaxeError().default)("Invalid index position " + index);
		}
		if(child.parent == this) {
			if(this.__children[index] != child) {
				(HxOverrides().default).remove(this.__children,child);
				this.__children.splice(index,0,child);
				this.__setRenderDirty();
			}
		} else {
			if(child.parent != null) {
				child.parent.removeChild(child);
			}
			this.__children.splice(index,0,child);
			child.parent = this;
			var addedToStage = this.stage != null && child.stage == null;
			if(addedToStage) {
				this.__setStageReference(this.stage);
			}
			child.__setTransformDirty();
			child.__setRenderDirty();
			this.__setRenderDirty();
			var event = (openfl_events_Event().default).__pool.get();
			event.type = "added";
			event.bubbles = true;
			event.target = child;
			child.__dispatchWithCapture(event);
			(openfl_events_Event().default).__pool.release(event);
			if(addedToStage) {
				event = new (openfl_events_Event().default)("addedToStage",false,false);
				child.__dispatchWithCapture(event);
				child.__dispatchChildren(event);
			}
		}
		return child;
	},
	areInaccessibleObjectsUnderPoint: function(point) {
		return false;
	},
	contains: function(child) {
		while(child != this && child != null) child = child.parent;
		return child == this;
	},
	getChildAt: function(index) {
		if(index >= 0 && index < this.__children.length) {
			return this.__children[index];
		}
		return null;
	},
	getChildByName: function(name) {
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.get_name() == name) {
				return child;
			}
		}
		return null;
	},
	getChildIndex: function(child) {
		var _g = 0;
		var _g1 = this.__children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.__children[i] == child) {
				return i;
			}
		}
		return -1;
	},
	getObjectsUnderPoint: function(point) {
		var stack = [];
		this.__hitTest(point.x,point.y,false,stack,false,this);
		stack.reverse();
		return stack;
	},
	removeChild: function(child) {
		if(child != null && child.parent == this) {
			child.__setTransformDirty();
			child.__setRenderDirty();
			this.__setRenderDirty();
			var event = new (openfl_events_Event().default)("removed",true);
			child.__dispatchWithCapture(event);
			if(this.stage != null) {
				if(child.stage != null && this.stage.get_focus() == child) {
					this.stage.set_focus(null);
				}
				var event1 = new (openfl_events_Event().default)("removedFromStage",false,false);
				child.__dispatchWithCapture(event1);
				child.__dispatchChildren(event1);
				child.__setStageReference(null);
			}
			child.parent = null;
			(HxOverrides().default).remove(this.__children,child);
			(openfl__$Vector_Vector_$Impl_$().default).push(this.__removedChildren,child);
			child.__setTransformDirty();
		}
		return child;
	},
	removeChildAt: function(index) {
		if(index >= 0 && index < this.__children.length) {
			return this.removeChild(this.__children[index]);
		}
		return null;
	},
	removeChildren: function(beginIndex,endIndex) {
		if(endIndex == null) {
			endIndex = 2147483647;
		}
		if(beginIndex == null) {
			beginIndex = 0;
		}
		if(endIndex == 2147483647) {
			endIndex = this.__children.length - 1;
			if(endIndex < 0) {
				return;
			}
		}
		if(beginIndex > this.__children.length - 1) {
			return;
		} else if(endIndex < beginIndex || beginIndex < 0 || endIndex > this.__children.length) {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_RangeError().default)("The supplied index is out of bounds."));
		}
		var numRemovals = endIndex - beginIndex;
		while(numRemovals >= 0) {
			this.removeChildAt(beginIndex);
			--numRemovals;
		}
	},
	resolve: function(fieldName) {
		if(this.__children == null) {
			return null;
		}
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.get_name() == fieldName) {
				return child;
			}
		}
		return null;
	},
	setChildIndex: function(child,index) {
		if(index >= 0 && index <= this.__children.length && child.parent == this) {
			(HxOverrides().default).remove(this.__children,child);
			this.__children.splice(index,0,child);
		}
	},
	stopAllMovieClips: function() {
		this.__stopAllMovieClips();
	},
	swapChildren: function(child1,child2) {
		if(child1.parent == this && child2.parent == this) {
			var index1 = this.__children.indexOf(child1);
			var index2 = this.__children.indexOf(child2);
			this.__children[index1] = child2;
			this.__children[index2] = child1;
			this.__setRenderDirty();
		}
	},
	swapChildrenAt: function(index1,index2) {
		var swap = this.__children[index1];
		this.__children[index1] = this.__children[index2];
		this.__children[index2] = swap;
		swap = null;
		this.__setRenderDirty();
	},
	__cleanup: function() {
		(openfl_display_InteractiveObject().default).prototype.__cleanup.call(this);
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			child.__cleanup();
		}
		this.__cleanupRemovedChildren();
	},
	__cleanupRemovedChildren: function() {
		var orphan = new (openfl__$Vector_VectorIterator().default)(this.__removedChildren);
		while(orphan.hasNext()) {
			var orphan1 = orphan.next();
			if(orphan1.stage == null) {
				orphan1.__cleanup();
			}
		}
		this.__removedChildren.set_length(0);
	},
	__dispatchChildren: function(event) {
		if(this.__children != null) {
			var _g = 0;
			var _g1 = this.__children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				event.target = child;
				if(!child.__dispatchWithCapture(event)) {
					break;
				}
				child.__dispatchChildren(event);
			}
		}
	},
	__enterFrame: function(deltaTime) {
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			child.__enterFrame(deltaTime);
		}
	},
	__getBounds: function(rect,matrix) {
		(openfl_display_InteractiveObject().default).prototype.__getBounds.call(this,rect,matrix);
		if(this.__children.length == 0) {
			return;
		}
		var childWorldTransform = (openfl_geom_Matrix().default).__pool.get();
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.__scaleX == 0 || child.__scaleY == 0) {
				continue;
			}
			(openfl_display_DisplayObject().default).__calculateAbsoluteTransform(child.__transform,matrix,childWorldTransform);
			child.__getBounds(rect,childWorldTransform);
		}
		(openfl_geom_Matrix().default).__pool.release(childWorldTransform);
	},
	__getFilterBounds: function(rect,matrix) {
		(openfl_display_InteractiveObject().default).prototype.__getFilterBounds.call(this,rect,matrix);
		if(this.__scrollRect != null) {
			return;
		}
		if(this.__children.length == 0) {
			return;
		}
		var childWorldTransform = (openfl_geom_Matrix().default).__pool.get();
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.__scaleX == 0 || child.__scaleY == 0 || child.__isMask) {
				continue;
			}
			(openfl_display_DisplayObject().default).__calculateAbsoluteTransform(child.__transform,matrix,childWorldTransform);
			child.__getFilterBounds(rect,childWorldTransform);
		}
		(openfl_geom_Matrix().default).__pool.release(childWorldTransform);
	},
	__getRenderBounds: function(rect,matrix) {
		if(this.__scrollRect != null) {
			(openfl_display_InteractiveObject().default).prototype.__getRenderBounds.call(this,rect,matrix);
			return;
		} else {
			(openfl_display_InteractiveObject().default).prototype.__getBounds.call(this,rect,matrix);
		}
		if(this.__children.length == 0) {
			return;
		}
		var childWorldTransform = (openfl_geom_Matrix().default).__pool.get();
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.__scaleX == 0 || child.__scaleY == 0 || child.__isMask) {
				continue;
			}
			(openfl_display_DisplayObject().default).__calculateAbsoluteTransform(child.__transform,matrix,childWorldTransform);
			child.__getRenderBounds(rect,childWorldTransform);
		}
		(openfl_geom_Matrix().default).__pool.release(childWorldTransform);
	},
	__hitTest: function(x,y,shapeFlag,stack,interactiveOnly,hitObject) {
		if(!hitObject.get_visible() || this.__isMask || interactiveOnly && !this.mouseEnabled && !this.mouseChildren) {
			return false;
		}
		if(this.get_mask() != null && !this.get_mask().__hitTestMask(x,y)) {
			return false;
		}
		if(this.__scrollRect != null) {
			var point = (openfl_geom_Point().default).__pool.get();
			point.setTo(x,y);
			this.__getRenderTransform().__transformInversePoint(point);
			if(!this.__scrollRect.containsPoint(point)) {
				(openfl_geom_Point().default).__pool.release(point);
				return false;
			}
			(openfl_geom_Point().default).__pool.release(point);
		}
		var i = this.__children.length;
		if(interactiveOnly) {
			if(stack == null || !this.mouseChildren) {
				while(--i >= 0) if(this.__children[i].__hitTest(x,y,shapeFlag,null,true,this.__children[i])) {
					if(stack != null) {
						stack.push(hitObject);
					}
					return true;
				}
			} else if(stack != null) {
				var length = stack.length;
				var interactive = false;
				var hitTest = false;
				while(--i >= 0) {
					interactive = this.__children[i].__getInteractive(null);
					if(interactive || this.mouseEnabled && !hitTest) {
						if(this.__children[i].__hitTest(x,y,shapeFlag,stack,true,this.__children[i])) {
							hitTest = true;
							if(interactive && stack.length > length) {
								break;
							}
						}
					}
				}
				if(hitTest) {
					stack.splice(length,0,hitObject);
					return true;
				}
			}
		} else {
			var hitTest1 = false;
			while(--i >= 0) if(this.__children[i].__hitTest(x,y,shapeFlag,stack,false,this.__children[i])) {
				hitTest1 = true;
				if(stack == null) {
					break;
				}
			}
			return hitTest1;
		}
		return false;
	},
	__hitTestMask: function(x,y) {
		var i = this.__children.length;
		while(--i >= 0) if(this.__children[i].__hitTestMask(x,y)) {
			return true;
		}
		return false;
	},
	__readGraphicsData: function(graphicsData,recurse) {
		(openfl_display_InteractiveObject().default).prototype.__readGraphicsData.call(this,graphicsData,recurse);
		if(recurse) {
			var _g = 0;
			var _g1 = this.__children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				child.__readGraphicsData(graphicsData,recurse);
			}
		}
	},
	__renderCairo: function(renderer) {
	},
	__renderCairoMask: function(renderer) {
	},
	__renderCanvas: function(renderer) {
		this.__cleanupRemovedChildren();
		if(!this.__renderable || this.__worldAlpha <= 0 || this.get_mask() != null && (this.get_mask().get_width() <= 0 || this.get_mask().get_height() <= 0)) {
			return;
		}
		(openfl_display_InteractiveObject().default).prototype.__renderCanvas.call(this,renderer);
		if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
			return;
		}
		renderer.__pushMaskObject(this);
		if(renderer.__stage != null) {
			var _g = 0;
			var _g1 = this.__children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				child.__renderCanvas(renderer);
				child.__renderDirty = false;
			}
			this.__renderDirty = false;
		} else {
			var _g2 = 0;
			var _g11 = this.__children;
			while(_g2 < _g11.length) {
				var child1 = _g11[_g2];
				++_g2;
				child1.__renderCanvas(renderer);
			}
		}
		renderer.__popMaskObject(this);
	},
	__renderCanvasMask: function(renderer) {
		this.__cleanupRemovedChildren();
		if(this.__graphics != null) {
			(openfl__$internal_renderer_canvas_CanvasGraphics().default).renderMask(this.__graphics,renderer);
		}
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			child.__renderCanvasMask(renderer);
		}
	},
	__renderDOM: function(renderer) {
		var orphan = new (openfl__$Vector_VectorIterator().default)(this.__removedChildren);
		while(orphan.hasNext()) {
			var orphan1 = orphan.next();
			if(orphan1.stage == null) {
				orphan1.__renderDOM(renderer);
			}
		}
		this.__cleanupRemovedChildren();
		(openfl_display_InteractiveObject().default).prototype.__renderDOM.call(this,renderer);
		if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
			return;
		}
		renderer.__pushMaskObject(this);
		if(renderer.__stage != null) {
			var _g = 0;
			var _g1 = this.__children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				child.__renderDOM(renderer);
				child.__renderDirty = false;
			}
			this.__renderDirty = false;
		} else {
			var _g2 = 0;
			var _g11 = this.__children;
			while(_g2 < _g11.length) {
				var child1 = _g11[_g2];
				++_g2;
				child1.__renderDOM(renderer);
			}
		}
		renderer.__popMaskObject(this);
	},
	__renderDOMClear: function(renderer) {
		var orphan = new (openfl__$Vector_VectorIterator().default)(this.__removedChildren);
		while(orphan.hasNext()) {
			var orphan1 = orphan.next();
			if(orphan1.stage == null) {
				orphan1.__renderDOMClear(renderer);
			}
		}
		this.__cleanupRemovedChildren();
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			child.__renderDOMClear(renderer);
		}
	},
	__renderGL: function(renderer) {
		this.__cleanupRemovedChildren();
		if(!this.__renderable || this.__worldAlpha <= 0) {
			return;
		}
		(openfl_display_InteractiveObject().default).prototype.__renderGL.call(this,renderer);
		if(this.__cacheBitmap != null && !this.__isCacheBitmapRender) {
			return;
		}
		if(this.__children.length > 0) {
			renderer.__pushMaskObject(this);
			if(renderer.__stage != null) {
				var _g = 0;
				var _g1 = this.__children;
				while(_g < _g1.length) {
					var child = _g1[_g];
					++_g;
					child.__renderGL(renderer);
					child.__renderDirty = false;
				}
				this.__renderDirty = false;
			} else {
				var _g2 = 0;
				var _g11 = this.__children;
				while(_g2 < _g11.length) {
					var child1 = _g11[_g2];
					++_g2;
					child1.__renderGL(renderer);
				}
			}
		}
		if(this.__children.length > 0) {
			renderer.__popMaskObject(this);
		}
	},
	__renderGLMask: function(renderer) {
		this.__cleanupRemovedChildren();
		if(this.__graphics != null) {
			(openfl__$internal_renderer_context3D_Context3DShape().default).renderMask(this,renderer);
		}
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			child.__renderGLMask(renderer);
		}
	},
	__setStageReference: function(stage) {
		(openfl_display_InteractiveObject().default).prototype.__setStageReference.call(this,stage);
		if(this.__children != null) {
			var _g = 0;
			var _g1 = this.__children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				child.__setStageReference(stage);
			}
		}
	},
	__setWorldTransformInvalid: function() {
		if(!this.__worldTransformInvalid) {
			this.__worldTransformInvalid = true;
			if(this.__children != null) {
				var _g = 0;
				var _g1 = this.__children;
				while(_g < _g1.length) {
					var child = _g1[_g];
					++_g;
					child.__setWorldTransformInvalid();
				}
			}
		}
	},
	__shouldCacheHardware: function(value) {
		if(value == true) {
			return true;
		}
		value = (openfl_display_InteractiveObject().default).prototype.__shouldCacheHardware.call(this,value);
		if(value == true) {
			return true;
		}
		if(this.__children != null) {
			var _g = 0;
			var _g1 = this.__children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				value = child.__shouldCacheHardware(value);
				if(value == true) {
					return true;
				}
			}
		}
		return value;
	},
	__stopAllMovieClips: function() {
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			child.__stopAllMovieClips();
		}
	},
	__tabTest: function(stack) {
		(openfl_display_InteractiveObject().default).prototype.__tabTest.call(this,stack);
		if(!this.get_tabChildren()) {
			return;
		}
		var interactive = false;
		var interactiveObject = null;
		var _g = 0;
		var _g1 = this.__children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			interactive = child.__getInteractive(null);
			if(interactive) {
				interactiveObject = child;
				interactiveObject.__tabTest(stack);
			}
		}
	},
	__update: function(transformOnly,updateChildren) {
		(openfl_display_InteractiveObject().default).prototype.__update.call(this,transformOnly,updateChildren);
		if(updateChildren) {
			var _g = 0;
			var _g1 = this.__children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				child.__update(transformOnly,true);
			}
		}
	},
	get_numChildren: function() {
		return this.__children.length;
	},
	get_tabChildren: function() {
		return this.__tabChildren;
	},
	set_tabChildren: function(value) {
		if(this.__tabChildren != value) {
			this.__tabChildren = value;
			this.dispatchEvent(new (openfl_events_Event().default)("tabChildrenChange",true,false));
		}
		return this.__tabChildren;
	}
});
DisplayObjectContainer.prototype.__class__ = DisplayObjectContainer.prototype.constructor = $hxClasses["openfl.display.DisplayObjectContainer"] = DisplayObjectContainer;

// Init

Object.defineProperty(DisplayObjectContainer.prototype,"numChildren",{ get : function () { return this.get_numChildren (); }});

// Statics




// Export

exports.default = DisplayObjectContainer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectRenderer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectRenderer.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.DisplayObjectRenderer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function openfl_geom_ColorTransform() {return __webpack_require__(/*! ./../../openfl/geom/ColorTransform */ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js");}

// Constructor

var DisplayObjectRenderer = function() {
	(openfl_events_EventDispatcher().default).call(this);
	this.__allowSmoothing = true;
	this.__tempColorTransform = new (openfl_geom_ColorTransform().default)();
	this.__worldAlpha = 1;
}

// Meta

DisplayObjectRenderer.__name__ = "openfl.display.DisplayObjectRenderer";
DisplayObjectRenderer.__isInterface__ = false;
DisplayObjectRenderer.__super__ = (openfl_events_EventDispatcher().default);
DisplayObjectRenderer.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	__clear: function() {
	},
	__getAlpha: function(value) {
		return value * this.__worldAlpha;
	},
	__getColorTransform: function(value) {
		if(this.__worldColorTransform != null) {
			this.__tempColorTransform.__copyFrom(this.__worldColorTransform);
			this.__tempColorTransform.__combine(value);
			return this.__tempColorTransform;
		} else {
			return value;
		}
	},
	__popMask: function() {
	},
	__popMaskObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
	},
	__popMaskRect: function() {
	},
	__pushMask: function(mask) {
	},
	__pushMaskObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
	},
	__pushMaskRect: function(rect,transform) {
	},
	__render: function(object) {
	},
	__resize: function(width,height) {
	},
	__setBlendMode: function(value) {
	}
});
DisplayObjectRenderer.prototype.__class__ = DisplayObjectRenderer.prototype.constructor = $hxClasses["openfl.display.DisplayObjectRenderer"] = DisplayObjectRenderer;

// Init



// Statics


DisplayObjectRenderer.__meta__ = { fields : { __context : { SuppressWarnings : ["checkstyle:Dynamic"]}, __type : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = DisplayObjectRenderer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectShader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectShader.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.DisplayObjectShader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_Shader() {return __webpack_require__(/*! ./../../openfl/display/Shader */ "./node_modules/openfl/lib/_gen/openfl/display/Shader.js");}

// Constructor

var DisplayObjectShader = function(code) {
	if(this.__glFragmentSource == null) {
		this.__glFragmentSource = "varying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform sampler2D openfl_Texture;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\tvoid main(void) {\n\n\t\t\tvec4 color = texture2D (openfl_Texture, openfl_TextureCoordv);\n\n\t\tif (color.a == 0.0) {\n\n\t\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\n\n\t\t} else if (openfl_HasColorTransform) {\n\n\t\t\tcolor = vec4 (color.rgb / color.a, color.a);\n\n\t\t\tmat4 colorMultiplier = mat4 (0);\n\t\t\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\n\t\t\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\n\t\t\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\n\t\t\tcolorMultiplier[3][3] = 1.0; // openfl_ColorMultiplierv.w;\n\n\t\t\tcolor = clamp (openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\n\n\t\t\tif (color.a > 0.0) {\n\n\t\t\t\tgl_FragColor = vec4 (color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\n\n\t\t\t} else {\n\n\t\t\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl_FragColor = color * openfl_Alphav;\n\n\t\t}\n\n\t\t}";
	}
	if(this.__glVertexSource == null) {
		this.__glVertexSource = "attribute float openfl_Alpha;\n\t\tattribute vec4 openfl_ColorMultiplier;\n\t\tattribute vec4 openfl_ColorOffset;\n\t\tattribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\tvoid main(void) {\n\n\t\t\topenfl_Alphav = openfl_Alpha;\n\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\n\t\tif (openfl_HasColorTransform) {\n\n\t\t\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\n\t\t\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\n\n\t\t}\n\n\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\t\t}";
	}
	(openfl_display_Shader().default).call(this,code);
	this.__isGenerated = true;
	this.__initGL();
}

// Meta

DisplayObjectShader.__name__ = "openfl.display.DisplayObjectShader";
DisplayObjectShader.__isInterface__ = false;
DisplayObjectShader.__super__ = (openfl_display_Shader().default);
DisplayObjectShader.prototype = $extend((openfl_display_Shader().default).prototype, {
	
});
DisplayObjectShader.prototype.__class__ = DisplayObjectShader.prototype.constructor = $hxClasses["openfl.display.DisplayObjectShader"] = DisplayObjectShader;

// Init



// Statics




// Export

exports.default = DisplayObjectShader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/FrameLabel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/FrameLabel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.FrameLabel

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}

// Constructor

var FrameLabel = function(name,frame) {
	(openfl_events_EventDispatcher().default).call(this);
	this.__name = name;
	this.__frame = frame;
}

// Meta

FrameLabel.__name__ = "openfl.display.FrameLabel";
FrameLabel.__isInterface__ = false;
FrameLabel.__super__ = (openfl_events_EventDispatcher().default);
FrameLabel.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	get_frame: function() {
		return this.__frame;
	},
	get_name: function() {
		return this.__name;
	}
});
FrameLabel.prototype.__class__ = FrameLabel.prototype.constructor = $hxClasses["openfl.display.FrameLabel"] = FrameLabel;

// Init

{
	Object.defineProperty(FrameLabel.prototype,"frame",{ get : function () { return this.get_frame (); }});
	Object.defineProperty(FrameLabel.prototype,"name",{ get : function () { return this.get_name (); }});
};

// Statics




// Export

exports.default = FrameLabel;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Graphics.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Graphics.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Graphics

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$Vector_VectorIterator() {return __webpack_require__(/*! ./../../openfl/_Vector/VectorIterator */ "./node_modules/openfl/lib/_gen/openfl/_Vector/VectorIterator.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_ArgumentError() {return __webpack_require__(/*! ./../../openfl/errors/ArgumentError */ "./node_modules/openfl/lib/_gen/openfl/errors/ArgumentError.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl__$internal_renderer_canvas_CanvasGraphics() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/canvas/CanvasGraphics */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/canvas/CanvasGraphics.js");}
function openfl__$internal_renderer_DrawCommandReader() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/DrawCommandReader */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandReader.js");}
function openfl_display_GraphicsPath() {return __webpack_require__(/*! ./../../openfl/display/GraphicsPath */ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsPath.js");}
function openfl_display_GraphicsBitmapFill() {return __webpack_require__(/*! ./../../openfl/display/GraphicsBitmapFill */ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsBitmapFill.js");}
function openfl_display_GraphicsSolidFill() {return __webpack_require__(/*! ./../../openfl/display/GraphicsSolidFill */ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsSolidFill.js");}
function openfl_display_GraphicsGradientFill() {return __webpack_require__(/*! ./../../openfl/display/GraphicsGradientFill */ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsGradientFill.js");}
function openfl_display_GraphicsEndFill() {return __webpack_require__(/*! ./../../openfl/display/GraphicsEndFill */ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsEndFill.js");}
function openfl_display_GraphicsStroke() {return __webpack_require__(/*! ./../../openfl/display/GraphicsStroke */ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsStroke.js");}
function openfl__$internal_renderer_DrawCommandBuffer() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/DrawCommandBuffer */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/DrawCommandBuffer.js");}
function haxe_ds_List() {return __webpack_require__(/*! ./../../haxe/ds/List */ "./node_modules/openfl/lib/_gen/haxe/ds/List.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}
function openfl__$internal_renderer_ShaderBuffer() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/ShaderBuffer */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/ShaderBuffer.js");}

// Constructor

var Graphics = function(owner) {
	this.__dirty = true;
	this.__owner = owner;
	this.__commands = new (openfl__$internal_renderer_DrawCommandBuffer().default)();
	this.__strokePadding = 0;
	this.__positionX = 0;
	this.__positionY = 0;
	this.__renderTransform = new (openfl_geom_Matrix().default)();
	this.__usedShaderBuffers = new (haxe_ds_List().default)();
	this.__worldTransform = new (openfl_geom_Matrix().default)();
	this.__width = 0;
	this.__height = 0;
	this.__shaderBufferPool = new (lime_utils_ObjectPool().default)(function() {
		return new (openfl__$internal_renderer_ShaderBuffer().default)();
	});
	this.moveTo(0,0);
}

// Meta

Graphics.__name__ = "openfl.display.Graphics";
Graphics.__isInterface__ = false;
Graphics.prototype = {
	beginBitmapFill: function(bitmap,matrix,repeat,smooth) {
		if(smooth == null) {
			smooth = false;
		}
		if(repeat == null) {
			repeat = true;
		}
		this.__commands.beginBitmapFill(bitmap,matrix != null ? matrix.clone() : null,repeat,smooth);
		this.__visible = true;
	},
	beginFill: function(color,alpha) {
		if(alpha == null) {
			alpha = 1;
		}
		if(color == null) {
			color = 0;
		}
		this.__commands.beginFill(color & 16777215,alpha);
		if(alpha > 0) {
			this.__visible = true;
		}
	},
	beginGradientFill: function(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio) {
		if(focalPointRatio == null) {
			focalPointRatio = 0;
		}
		if(interpolationMethod == null) {
			interpolationMethod = "rgb";
		}
		if(spreadMethod == null) {
			spreadMethod = "pad";
		}
		if(colors == null || colors.length == 0) {
			return;
		}
		if(alphas == null) {
			alphas = [];
			var _g = 0;
			var _g1 = colors.length;
			while(_g < _g1) {
				var i = _g++;
				alphas.push(1);
			}
		}
		if(ratios == null) {
			ratios = [];
			var _g2 = 0;
			var _g11 = colors.length;
			while(_g2 < _g11) {
				var i1 = _g2++;
				ratios.push(Math.ceil(i1 / colors.length * 255));
			}
		}
		if(alphas.length < colors.length || ratios.length < colors.length) {
			return;
		}
		this.__commands.beginGradientFill(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio);
		var _g3 = 0;
		while(_g3 < alphas.length) {
			var alpha = alphas[_g3];
			++_g3;
			if(alpha > 0) {
				this.__visible = true;
				break;
			}
		}
	},
	beginShaderFill: function(shader,matrix) {
		if(shader != null) {
			var shaderBuffer = this.__shaderBufferPool.get();
			this.__usedShaderBuffers.add(shaderBuffer);
			shaderBuffer.update(shader);
			this.__commands.beginShaderFill(shaderBuffer);
		}
	},
	clear: function() {
		var shaderBuffer = this.__usedShaderBuffers.iterator();
		while(shaderBuffer.hasNext()) {
			var shaderBuffer1 = shaderBuffer.next();
			this.__shaderBufferPool.release(shaderBuffer1);
		}
		this.__usedShaderBuffers.clear();
		this.__commands.clear();
		this.__strokePadding = 0;
		if(this.__bounds != null) {
			this.set___dirty(true);
			this.__transformDirty = true;
			this.__bounds = null;
		}
		this.__visible = false;
		this.__positionX = 0;
		this.__positionY = 0;
		this.moveTo(0,0);
	},
	copyFrom: function(sourceGraphics) {
		this.__bounds = sourceGraphics.__bounds != null ? sourceGraphics.__bounds.clone() : null;
		this.__commands = sourceGraphics.__commands.copy();
		this.set___dirty(true);
		this.__strokePadding = sourceGraphics.__strokePadding;
		this.__positionX = sourceGraphics.__positionX;
		this.__positionY = sourceGraphics.__positionY;
		this.__transformDirty = true;
		this.__visible = sourceGraphics.__visible;
	},
	cubicCurveTo: function(controlX1,controlY1,controlX2,controlY2,anchorX,anchorY) {
		this.__inflateBounds(this.__positionX - this.__strokePadding,this.__positionY - this.__strokePadding);
		this.__inflateBounds(this.__positionX + this.__strokePadding,this.__positionY + this.__strokePadding);
		var ix1 = anchorX;
		var ix2 = anchorX;
		if(!((controlX1 < anchorX && controlX1 > this.__positionX || controlX1 > anchorX && controlX1 < this.__positionX) && (controlX2 < anchorX && controlX2 > this.__positionX || controlX2 > anchorX && controlX2 < this.__positionX))) {
			var u = 2 * this.__positionX - 4 * controlX1 + 2 * controlX2;
			var v = controlX1 - this.__positionX;
			var w = -this.__positionX + 3 * controlX1 + anchorX - 3 * controlX2;
			var t1 = (-u + Math.sqrt(u * u - 4 * v * w)) / (2 * w);
			var t2 = (-u - Math.sqrt(u * u - 4 * v * w)) / (2 * w);
			if(t1 > 0 && t1 < 1) {
				ix1 = this.__calculateBezierCubicPoint(t1,this.__positionX,controlX1,controlX2,anchorX);
			}
			if(t2 > 0 && t2 < 1) {
				ix2 = this.__calculateBezierCubicPoint(t2,this.__positionX,controlX1,controlX2,anchorX);
			}
		}
		var iy1 = anchorY;
		var iy2 = anchorY;
		if(!((controlY1 < anchorY && controlY1 > this.__positionX || controlY1 > anchorY && controlY1 < this.__positionX) && (controlY2 < anchorY && controlY2 > this.__positionX || controlY2 > anchorY && controlY2 < this.__positionX))) {
			var u1 = 2 * this.__positionX - 4 * controlY1 + 2 * controlY2;
			var v1 = controlY1 - this.__positionX;
			var w1 = -this.__positionX + 3 * controlY1 + anchorY - 3 * controlY2;
			var t11 = (-u1 + Math.sqrt(u1 * u1 - 4 * v1 * w1)) / (2 * w1);
			var t21 = (-u1 - Math.sqrt(u1 * u1 - 4 * v1 * w1)) / (2 * w1);
			if(t11 > 0 && t11 < 1) {
				iy1 = this.__calculateBezierCubicPoint(t11,this.__positionX,controlY1,controlY2,anchorY);
			}
			if(t21 > 0 && t21 < 1) {
				iy2 = this.__calculateBezierCubicPoint(t21,this.__positionX,controlY1,controlY2,anchorY);
			}
		}
		this.__inflateBounds(ix1 - this.__strokePadding,iy1 - this.__strokePadding);
		this.__inflateBounds(ix1 + this.__strokePadding,iy1 + this.__strokePadding);
		this.__inflateBounds(ix2 - this.__strokePadding,iy2 - this.__strokePadding);
		this.__inflateBounds(ix2 + this.__strokePadding,iy2 + this.__strokePadding);
		this.__positionX = anchorX;
		this.__positionY = anchorY;
		this.__inflateBounds(this.__positionX - this.__strokePadding,this.__positionY - this.__strokePadding);
		this.__inflateBounds(this.__positionX + this.__strokePadding,this.__positionY + this.__strokePadding);
		this.__commands.cubicCurveTo(controlX1,controlY1,controlX2,controlY2,anchorX,anchorY);
		this.set___dirty(true);
	},
	curveTo: function(controlX,controlY,anchorX,anchorY) {
		this.__inflateBounds(this.__positionX - this.__strokePadding,this.__positionY - this.__strokePadding);
		this.__inflateBounds(this.__positionX + this.__strokePadding,this.__positionY + this.__strokePadding);
		var ix;
		var iy;
		if(controlX < anchorX && controlX > this.__positionX || controlX > anchorX && controlX < this.__positionX) {
			ix = anchorX;
		} else {
			var tx = (this.__positionX - controlX) / (this.__positionX - 2 * controlX + anchorX);
			ix = this.__calculateBezierQuadPoint(tx,this.__positionX,controlX,anchorX);
		}
		if(controlY < anchorY && controlY > this.__positionY || controlY > anchorY && controlY < this.__positionY) {
			iy = anchorY;
		} else {
			var ty = (this.__positionY - controlY) / (this.__positionY - 2 * controlY + anchorY);
			iy = this.__calculateBezierQuadPoint(ty,this.__positionY,controlY,anchorY);
		}
		this.__inflateBounds(ix - this.__strokePadding,iy - this.__strokePadding);
		this.__inflateBounds(ix + this.__strokePadding,iy + this.__strokePadding);
		this.__positionX = anchorX;
		this.__positionY = anchorY;
		this.__commands.curveTo(controlX,controlY,anchorX,anchorY);
		this.set___dirty(true);
	},
	drawCircle: function(x,y,radius) {
		if(radius <= 0) {
			return;
		}
		this.__inflateBounds(x - radius - this.__strokePadding,y - radius - this.__strokePadding);
		this.__inflateBounds(x + radius + this.__strokePadding,y + radius + this.__strokePadding);
		this.__commands.drawCircle(x,y,radius);
		this.set___dirty(true);
	},
	drawEllipse: function(x,y,width,height) {
		if(width <= 0 || height <= 0) {
			return;
		}
		this.__inflateBounds(x - this.__strokePadding,y - this.__strokePadding);
		this.__inflateBounds(x + width + this.__strokePadding,y + height + this.__strokePadding);
		this.__commands.drawEllipse(x,y,width,height);
		this.set___dirty(true);
	},
	drawGraphicsData: function(graphicsData) {
		var fill;
		var bitmapFill;
		var gradientFill;
		var shaderFill;
		var stroke;
		var path;
		var trianglePath;
		var quadPath;
		var graphics = new (openfl__$Vector_VectorIterator().default)(graphicsData);
		while(graphics.hasNext()) {
			var graphics1 = graphics.next();
			switch(graphics1.__graphicsDataType) {
			case 0:
				stroke = graphics1;
				if(stroke.fill != null) {
					var thickness = stroke.thickness;
					if(isNaN(thickness)) {
						thickness = null;
					}
					switch(stroke.fill.__graphicsFillType) {
					case 0:
						fill = stroke.fill;
						this.lineStyle(thickness,fill.color,fill.alpha,stroke.pixelHinting,stroke.scaleMode,stroke.caps,stroke.joints,stroke.miterLimit);
						break;
					case 1:
						gradientFill = stroke.fill;
						this.lineStyle(thickness,0,1,stroke.pixelHinting,stroke.scaleMode,stroke.caps,stroke.joints,stroke.miterLimit);
						this.lineGradientStyle(gradientFill.type,gradientFill.colors,gradientFill.alphas,gradientFill.ratios,gradientFill.matrix,gradientFill.spreadMethod,gradientFill.interpolationMethod,gradientFill.focalPointRatio);
						break;
					case 2:
						bitmapFill = stroke.fill;
						this.lineStyle(thickness,0,1,stroke.pixelHinting,stroke.scaleMode,stroke.caps,stroke.joints,stroke.miterLimit);
						this.lineBitmapStyle(bitmapFill.bitmapData,bitmapFill.matrix,bitmapFill.repeat,bitmapFill.smooth);
						break;
					default:
					}
				} else {
					this.lineStyle();
				}
				break;
			case 1:
				fill = graphics1;
				this.beginFill(fill.color,fill.alpha);
				break;
			case 2:
				gradientFill = graphics1;
				this.beginGradientFill(gradientFill.type,gradientFill.colors,gradientFill.alphas,gradientFill.ratios,gradientFill.matrix,gradientFill.spreadMethod,gradientFill.interpolationMethod,gradientFill.focalPointRatio);
				break;
			case 3:
				path = graphics1;
				this.drawPath(path.commands,path.data,path.winding);
				break;
			case 4:
				bitmapFill = graphics1;
				this.beginBitmapFill(bitmapFill.bitmapData,bitmapFill.matrix,bitmapFill.repeat,bitmapFill.smooth);
				break;
			case 5:
				this.endFill();
				break;
			case 6:
				quadPath = graphics1;
				this.drawQuads(quadPath.rects,quadPath.indices,quadPath.transforms);
				break;
			case 7:
				trianglePath = graphics1;
				this.drawTriangles(trianglePath.vertices,trianglePath.indices,trianglePath.uvtData,trianglePath.culling);
				break;
			case 8:
				shaderFill = graphics1;
				this.beginShaderFill(shaderFill.shader,shaderFill.matrix);
				break;
			}
		}
	},
	drawPath: function(commands,data,winding) {
		if(winding == null) {
			winding = "evenOdd";
		}
		var dataIndex = 0;
		if(winding == "nonZero") {
			this.__commands.windingNonZero();
		}
		var command = new (openfl__$Vector_VectorIterator().default)(commands);
		_hx_loop1: while(command.hasNext()) {
			var command1 = command.next();
			switch(command1) {
			case 1:
				this.moveTo(data[dataIndex],data[dataIndex + 1]);
				dataIndex += 2;
				break;
			case 2:
				this.lineTo(data[dataIndex],data[dataIndex + 1]);
				dataIndex += 2;
				break;
			case 3:
				this.curveTo(data[dataIndex],data[dataIndex + 1],data[dataIndex + 2],data[dataIndex + 3]);
				dataIndex += 4;
				break;
			case 4:
				this.moveTo(data[dataIndex + 2],data[dataIndex + 3]);
				break _hx_loop1;
			case 5:
				this.lineTo(data[dataIndex + 2],data[dataIndex + 3]);
				break _hx_loop1;
			case 6:
				this.cubicCurveTo(data[dataIndex],data[dataIndex + 1],data[dataIndex + 2],data[dataIndex + 3],data[dataIndex + 4],data[dataIndex + 5]);
				dataIndex += 6;
				break;
			default:
			}
		}
	},
	drawQuads: function(rects,indices,transforms) {
		if(rects == null) {
			return;
		}
		var hasIndices = indices != null;
		var transformABCD = false;
		var transformXY = false;
		var length = hasIndices ? indices.get_length() : Math.floor(rects.get_length() / 4);
		if(length == 0) {
			return;
		}
		if(transforms != null) {
			if(transforms.get_length() >= length * 6) {
				transformABCD = true;
				transformXY = true;
			} else if(transforms.get_length() >= length * 4) {
				transformABCD = true;
			} else if(transforms.get_length() >= length * 2) {
				transformXY = true;
			}
		}
		var tileRect = (openfl_geom_Rectangle().default).__pool.get();
		var tileTransform = (openfl_geom_Matrix().default).__pool.get();
		var minX = Infinity;
		var minY = Infinity;
		var maxX = -Infinity;
		var maxY = -Infinity;
		var ri;
		var ti;
		var _g = 0;
		var _g1 = length;
		while(_g < _g1) {
			var i = _g++;
			ri = hasIndices ? indices[i] * 4 : i * 4;
			if(ri < 0) {
				continue;
			}
			tileRect.setTo(0,0,rects[ri + 2],rects[ri + 3]);
			if(tileRect.width <= 0 || tileRect.height <= 0) {
				continue;
			}
			if(transformABCD && transformXY) {
				ti = i * 6;
				tileTransform.setTo(transforms[ti],transforms[ti + 1],transforms[ti + 2],transforms[ti + 3],transforms[ti + 4],transforms[ti + 5]);
			} else if(transformABCD) {
				ti = i * 4;
				tileTransform.setTo(transforms[ti],transforms[ti + 1],transforms[ti + 2],transforms[ti + 3],tileRect.x,tileRect.y);
			} else if(transformXY) {
				ti = i * 2;
				tileTransform.tx = transforms[ti];
				tileTransform.ty = transforms[ti + 1];
			} else {
				tileTransform.tx = tileRect.x;
				tileTransform.ty = tileRect.y;
			}
			tileRect.__transform(tileRect,tileTransform);
			if(minX > tileRect.x) {
				minX = tileRect.x;
			}
			if(minY > tileRect.y) {
				minY = tileRect.y;
			}
			if(maxX < tileRect.get_right()) {
				maxX = tileRect.get_right();
			}
			if(maxY < tileRect.get_bottom()) {
				maxY = tileRect.get_bottom();
			}
		}
		this.__inflateBounds(minX,minY);
		this.__inflateBounds(maxX,maxY);
		this.__commands.drawQuads(rects,indices,transforms);
		this.set___dirty(true);
		this.__visible = true;
		(openfl_geom_Rectangle().default).__pool.release(tileRect);
		(openfl_geom_Matrix().default).__pool.release(tileTransform);
	},
	drawRect: function(x,y,width,height) {
		if(width == 0 && height == 0) {
			return;
		}
		var xSign = width < 0 ? -1 : 1;
		var ySign = height < 0 ? -1 : 1;
		this.__inflateBounds(x - this.__strokePadding * xSign,y - this.__strokePadding * ySign);
		this.__inflateBounds(x + width + this.__strokePadding * xSign,y + height + this.__strokePadding * ySign);
		this.__commands.drawRect(x,y,width,height);
		this.set___dirty(true);
	},
	drawRoundRect: function(x,y,width,height,ellipseWidth,ellipseHeight) {
		if(width == 0 && height == 0) {
			return;
		}
		var xSign = width < 0 ? -1 : 1;
		var ySign = height < 0 ? -1 : 1;
		this.__inflateBounds(x - this.__strokePadding * xSign,y - this.__strokePadding * ySign);
		this.__inflateBounds(x + width + this.__strokePadding * xSign,y + height + this.__strokePadding * ySign);
		this.__commands.drawRoundRect(x,y,width,height,ellipseWidth,ellipseHeight);
		this.set___dirty(true);
	},
	drawRoundRectComplex: function(x,y,width,height,topLeftRadius,topRightRadius,bottomLeftRadius,bottomRightRadius) {
		if(width <= 0 || height <= 0) {
			return;
		}
		this.__inflateBounds(x - this.__strokePadding,y - this.__strokePadding);
		this.__inflateBounds(x + width + this.__strokePadding,y + height + this.__strokePadding);
		var xw = x + width;
		var yh = y + height;
		var minSize = width < height ? width * 2 : height * 2;
		topLeftRadius = topLeftRadius < minSize ? topLeftRadius : minSize;
		topRightRadius = topRightRadius < minSize ? topRightRadius : minSize;
		bottomLeftRadius = bottomLeftRadius < minSize ? bottomLeftRadius : minSize;
		bottomRightRadius = bottomRightRadius < minSize ? bottomRightRadius : minSize;
		var anchor = 1 - Math.sin(45 * (Math.PI / 180));
		var control = 1 - Math.tan(22.5 * (Math.PI / 180));
		var a = bottomRightRadius * anchor;
		var s = bottomRightRadius * control;
		this.moveTo(xw,yh - bottomRightRadius);
		this.curveTo(xw,yh - s,xw - a,yh - a);
		this.curveTo(xw - s,yh,xw - bottomRightRadius,yh);
		a = bottomLeftRadius * anchor;
		s = bottomLeftRadius * control;
		this.lineTo(x + bottomLeftRadius,yh);
		this.curveTo(x + s,yh,x + a,yh - a);
		this.curveTo(x,yh - s,x,yh - bottomLeftRadius);
		a = topLeftRadius * anchor;
		s = topLeftRadius * control;
		this.lineTo(x,y + topLeftRadius);
		this.curveTo(x,y + s,x + a,y + a);
		this.curveTo(x + s,y,x + topLeftRadius,y);
		a = topRightRadius * anchor;
		s = topRightRadius * control;
		this.lineTo(xw - topRightRadius,y);
		this.curveTo(xw - s,y,xw - a,y + a);
		this.curveTo(xw,y + s,xw,y + topRightRadius);
		this.lineTo(xw,yh - bottomRightRadius);
		this.set___dirty(true);
	},
	drawTriangles: function(vertices,indices,uvtData,culling) {
		if(culling == null) {
			culling = "none";
		}
		if(vertices == null || vertices.get_length() == 0) {
			return;
		}
		var vertLength = (Std().default).int(vertices.get_length() / 2);
		if(indices == null) {
			if(vertLength % 3 != 0) {
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_ArgumentError().default)("Not enough vertices to close a triangle."));
			}
			indices = (openfl__$Vector_Vector_$Impl_$().default)._new();
			var _g = 0;
			var _g1 = vertLength;
			while(_g < _g1) {
				var i = _g++;
				(openfl__$Vector_Vector_$Impl_$().default).push(indices,i);
			}
		}
		if(culling == null) {
			culling = "none";
		}
		var x;
		var y;
		var minX = Infinity;
		var minY = Infinity;
		var maxX = -Infinity;
		var maxY = -Infinity;
		var _g2 = 0;
		var _g11 = vertLength;
		while(_g2 < _g11) {
			var i1 = _g2++;
			x = vertices[i1 * 2];
			y = vertices[i1 * 2 + 1];
			if(minX > x) {
				minX = x;
			}
			if(minY > y) {
				minY = y;
			}
			if(maxX < x) {
				maxX = x;
			}
			if(maxY < y) {
				maxY = y;
			}
		}
		this.__inflateBounds(minX,minY);
		this.__inflateBounds(maxX,maxY);
		this.__commands.drawTriangles(vertices,indices,uvtData,culling);
		this.set___dirty(true);
		this.__visible = true;
	},
	endFill: function() {
		this.__commands.endFill();
	},
	lineBitmapStyle: function(bitmap,matrix,repeat,smooth) {
		if(smooth == null) {
			smooth = false;
		}
		if(repeat == null) {
			repeat = true;
		}
		this.__commands.lineBitmapStyle(bitmap,matrix != null ? matrix.clone() : null,repeat,smooth);
	},
	lineGradientStyle: function(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio) {
		if(focalPointRatio == null) {
			focalPointRatio = 0;
		}
		if(interpolationMethod == null) {
			interpolationMethod = "rgb";
		}
		if(spreadMethod == null) {
			spreadMethod = "pad";
		}
		this.__commands.lineGradientStyle(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio);
	},
	lineStyle: function(thickness,color,alpha,pixelHinting,scaleMode,caps,joints,miterLimit) {
		if(miterLimit == null) {
			miterLimit = 3;
		}
		if(scaleMode == null) {
			scaleMode = "normal";
		}
		if(pixelHinting == null) {
			pixelHinting = false;
		}
		if(alpha == null) {
			alpha = 1;
		}
		if(color == null) {
			color = 0;
		}
		if(thickness != null) {
			if(joints == "miter") {
				if(thickness > this.__strokePadding) {
					this.__strokePadding = thickness;
				}
			} else if(thickness / 2 > this.__strokePadding) {
				this.__strokePadding = thickness / 2;
			}
		}
		this.__commands.lineStyle(thickness,color,alpha,pixelHinting,scaleMode,caps,joints,miterLimit);
		if(thickness != null) {
			this.__visible = true;
		}
	},
	lineTo: function(x,y) {
		if(!isFinite(x) || !isFinite(y)) {
			return;
		}
		this.__inflateBounds(this.__positionX - this.__strokePadding,this.__positionY - this.__strokePadding);
		this.__inflateBounds(this.__positionX + this.__strokePadding,this.__positionY + this.__strokePadding);
		this.__positionX = x;
		this.__positionY = y;
		this.__inflateBounds(this.__positionX - this.__strokePadding,this.__positionY - this.__strokePadding);
		this.__inflateBounds(this.__positionX + this.__strokePadding * 2,this.__positionY + this.__strokePadding);
		this.__commands.lineTo(x,y);
		this.set___dirty(true);
	},
	moveTo: function(x,y) {
		this.__positionX = x;
		this.__positionY = y;
		this.__commands.moveTo(x,y);
	},
	overrideBlendMode: function(blendMode) {
		if(blendMode == null) {
			blendMode = "normal";
		}
		this.__commands.overrideBlendMode(blendMode);
	},
	readGraphicsData: function(recurse) {
		if(recurse == null) {
			recurse = true;
		}
		var graphicsData = (openfl__$Vector_Vector_$Impl_$().default)._new();
		this.__owner.__readGraphicsData(graphicsData,recurse);
		return graphicsData;
	},
	__calculateBezierCubicPoint: function(t,p1,p2,p3,p4) {
		var iT = 1 - t;
		return p1 * (iT * iT * iT) + 3 * p2 * t * (iT * iT) + 3 * p3 * iT * (t * t) + p4 * (t * t * t);
	},
	__calculateBezierQuadPoint: function(t,p1,p2,p3) {
		var iT = 1 - t;
		return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;
	},
	__cleanup: function() {
		if(this.__bounds != null && this.__canvas != null) {
			this.set___dirty(true);
			this.__transformDirty = true;
		}
		this.__bitmap = null;
		this.__canvas = null;
		this.__context = null;
	},
	__getBounds: function(rect,matrix) {
		if(this.__bounds == null) {
			return;
		}
		var bounds = (openfl_geom_Rectangle().default).__pool.get();
		this.__bounds.__transform(bounds,matrix);
		rect.__expand(bounds.x,bounds.y,bounds.width,bounds.height);
		(openfl_geom_Rectangle().default).__pool.release(bounds);
	},
	__hitTest: function(x,y,shapeFlag,matrix) {
		if(this.__bounds == null) {
			return false;
		}
		var px = matrix.__transformInverseX(x,y);
		var py = matrix.__transformInverseY(x,y);
		if(px > this.__bounds.x && py > this.__bounds.y && this.__bounds.contains(px,py)) {
			if(shapeFlag) {
				return (openfl__$internal_renderer_canvas_CanvasGraphics().default).hitTest(this,px,py);
			}
			return true;
		}
		return false;
	},
	__inflateBounds: function(x,y) {
		if(this.__bounds == null) {
			this.__bounds = new (openfl_geom_Rectangle().default)(x,y,0,0);
			this.__transformDirty = true;
			return;
		}
		if(x < this.__bounds.x) {
			this.__bounds.width += this.__bounds.x - x;
			this.__bounds.x = x;
			this.__transformDirty = true;
		}
		if(y < this.__bounds.y) {
			this.__bounds.height += this.__bounds.y - y;
			this.__bounds.y = y;
			this.__transformDirty = true;
		}
		if(x > this.__bounds.x + this.__bounds.width) {
			this.__bounds.width = x - this.__bounds.x;
		}
		if(y > this.__bounds.y + this.__bounds.height) {
			this.__bounds.height = y - this.__bounds.y;
		}
	},
	__readGraphicsData: function(graphicsData) {
		var data = new (openfl__$internal_renderer_DrawCommandReader().default)(this.__commands);
		var path = null;
		var stroke;
		var _g = 0;
		var _g1 = this.__commands.types;
		while(_g < _g1.length) {
			var type = _g1[_g];
			++_g;
			switch(type._hx_index) {
			case 4:case 5:case 6:case 7:case 9:case 10:case 17:case 18:
				if(path == null) {
					path = new (openfl_display_GraphicsPath().default)();
				}
				break;
			default:
				if(path != null) {
					(openfl__$Vector_Vector_$Impl_$().default).push(graphicsData,path);
					path = null;
				}
			}
			switch(type._hx_index) {
			case 0:
				var c = data.readBeginBitmapFill();
				(openfl__$Vector_Vector_$Impl_$().default).push(graphicsData,new (openfl_display_GraphicsBitmapFill().default)(c.obj(0),c.obj(1),c.bool(0),c.bool(1)));
				break;
			case 1:
				var c1 = data.readBeginFill();
				(openfl__$Vector_Vector_$Impl_$().default).push(graphicsData,new (openfl_display_GraphicsSolidFill().default)(c1.int(0),1));
				break;
			case 2:
				var c2 = data.readBeginGradientFill();
				(openfl__$Vector_Vector_$Impl_$().default).push(graphicsData,new (openfl_display_GraphicsGradientFill().default)(c2.obj(0),c2.iArr(0),c2.fArr(0),c2.iArr(1),c2.obj(1),c2.obj(2),c2.obj(3),c2.float(0)));
				break;
			case 3:
				break;
			case 4:
				var c3 = data.readCubicCurveTo();
				path.cubicCurveTo(c3.float(0),c3.float(1),c3.float(2),c3.float(3),c3.float(4),c3.float(5));
				break;
			case 5:
				var c4 = data.readCurveTo();
				path.curveTo(c4.float(0),c4.float(1),c4.float(2),c4.float(3));
				break;
			case 6:
				var c5 = data.readDrawCircle();
				path.__drawCircle(c5.float(0),c5.float(1),c5.float(2));
				break;
			case 7:
				var c6 = data.readDrawEllipse();
				path.__drawEllipse(c6.float(0),c6.float(1),c6.float(2),c6.float(3));
				break;
			case 9:
				var c7 = data.readDrawRect();
				path.__drawRect(c7.float(0),c7.float(1),c7.float(2),c7.float(3));
				break;
			case 10:
				var c8 = data.readDrawRoundRect();
				path.__drawRoundRect(c8.float(0),c8.float(1),c8.float(2),c8.float(3),c8.float(4),c8.obj(0) != null ? c8.obj(0) : c8.float(4));
				break;
			case 13:
				data.readEndFill();
				(openfl__$Vector_Vector_$Impl_$().default).push(graphicsData,new (openfl_display_GraphicsEndFill().default)());
				break;
			case 14:
				var c9 = data.readLineBitmapStyle();
				path = null;
				break;
			case 15:
				var c10 = data.readLineGradientStyle();
				break;
			case 16:
				var c11 = data.readLineStyle();
				stroke = new (openfl_display_GraphicsStroke().default)(c11.obj(0),c11.bool(0),c11.obj(1),c11.obj(2),c11.obj(3),c11.float(1));
				stroke.fill = new (openfl_display_GraphicsSolidFill().default)(c11.int(0),c11.float(0));
				(openfl__$Vector_Vector_$Impl_$().default).push(graphicsData,stroke);
				break;
			case 17:
				var c12 = data.readLineTo();
				path.lineTo(c12.float(0),c12.float(1));
				break;
			case 18:
				var c13 = data.readMoveTo();
				path.moveTo(c13.float(0),c13.float(1));
				break;
			default:
				data.skip(type);
			}
		}
		if(path != null) {
			(openfl__$Vector_Vector_$Impl_$().default).push(graphicsData,path);
		}
	},
	__update: function(displayMatrix) {
		if(this.__bounds == null || this.__bounds.width <= 0 || this.__bounds.height <= 0) {
			return;
		}
		var parentTransform = this.__owner.__renderTransform;
		var scaleX = 1.0;
		var scaleY = 1.0;
		if(parentTransform != null) {
			if(parentTransform.b == 0) {
				scaleX = Math.abs(parentTransform.a);
			} else {
				scaleX = Math.sqrt(parentTransform.a * parentTransform.a + parentTransform.b * parentTransform.b);
			}
			if(parentTransform.c == 0) {
				scaleY = Math.abs(parentTransform.d);
			} else {
				scaleY = Math.sqrt(parentTransform.c * parentTransform.c + parentTransform.d * parentTransform.d);
			}
		} else {
			return;
		}
		if(displayMatrix != null) {
			if(displayMatrix.b == 0) {
				scaleX *= displayMatrix.a;
			} else {
				scaleX *= Math.sqrt(displayMatrix.a * displayMatrix.a + displayMatrix.b * displayMatrix.b);
			}
			if(displayMatrix.c == 0) {
				scaleY *= displayMatrix.d;
			} else {
				scaleY *= Math.sqrt(displayMatrix.c * displayMatrix.c + displayMatrix.d * displayMatrix.d);
			}
		}
		var width = this.__bounds.width * scaleX;
		var height = this.__bounds.height * scaleY;
		if(width < 1 || height < 1) {
			if(this.__width >= 1 || this.__height >= 1) {
				this.set___dirty(true);
			}
			this.__width = 0;
			this.__height = 0;
			return;
		}
		if(Graphics.maxTextureWidth != null && width > Graphics.maxTextureWidth) {
			width = Graphics.maxTextureWidth;
			scaleX = Graphics.maxTextureWidth / this.__bounds.width;
		}
		if(Graphics.maxTextureWidth != null && height > Graphics.maxTextureHeight) {
			height = Graphics.maxTextureHeight;
			scaleY = Graphics.maxTextureHeight / this.__bounds.height;
		}
		this.__renderTransform.a = width / this.__bounds.width;
		this.__renderTransform.d = height / this.__bounds.height;
		var inverseA = 1 / this.__renderTransform.a;
		var inverseD = 1 / this.__renderTransform.d;
		this.__worldTransform.a = inverseA * parentTransform.a;
		this.__worldTransform.b = inverseA * parentTransform.b;
		this.__worldTransform.c = inverseD * parentTransform.c;
		this.__worldTransform.d = inverseD * parentTransform.d;
		var x = this.__bounds.x;
		var y = this.__bounds.y;
		var tx = x * parentTransform.a + y * parentTransform.c + parentTransform.tx;
		var ty = x * parentTransform.b + y * parentTransform.d + parentTransform.ty;
		this.__worldTransform.tx = Math.floor(tx);
		this.__worldTransform.ty = Math.floor(ty);
		this.__renderTransform.tx = this.__worldTransform.__transformInverseX(tx,ty);
		this.__renderTransform.ty = this.__worldTransform.__transformInverseY(tx,ty);
		var newWidth = Math.ceil(width + 1.0);
		var newHeight = Math.ceil(height + 1.0);
		if(newWidth != this.__width || newHeight != this.__height) {
			this.set___dirty(true);
		}
		this.__width = newWidth;
		this.__height = newHeight;
	},
	set___dirty: function(value) {
		if(value && this.__owner != null) {
			this.__owner.__setRenderDirty();
		}
		if(value) {
			this.__softwareDirty = true;
			this.__hardwareDirty = true;
		}
		return this.__dirty = value;
	}
};
Graphics.prototype.__class__ = Graphics.prototype.constructor = $hxClasses["openfl.display.Graphics"] = Graphics;

// Init



// Statics


Graphics.__meta__ = { fields : { overrideBlendMode : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}}
Graphics.maxTextureHeight = null
Graphics.maxTextureWidth = null

// Export

exports.default = Graphics;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsBitmapFill.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/GraphicsBitmapFill.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.GraphicsBitmapFill

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
function openfl_display_IGraphicsFill() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsFill */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsFill.js");}
function openfl_display_IGraphicsData() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsData */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsData.js");}

// Constructor

var GraphicsBitmapFill = function(bitmapData,matrix,repeat,smooth) {
	if(smooth == null) {
		smooth = false;
	}
	if(repeat == null) {
		repeat = true;
	}
	this.bitmapData = bitmapData;
	this.matrix = matrix;
	this.repeat = repeat;
	this.smooth = smooth;
	this.__graphicsDataType = 4;
	this.__graphicsFillType = 2;
}

// Meta

GraphicsBitmapFill.__name__ = "openfl.display.GraphicsBitmapFill";
GraphicsBitmapFill.__isInterface__ = false;
GraphicsBitmapFill.__interfaces__ = [(openfl_display_IGraphicsFill().default),(openfl_display_IGraphicsData().default)];
GraphicsBitmapFill.prototype = {
	
};
GraphicsBitmapFill.prototype.__class__ = GraphicsBitmapFill.prototype.constructor = $hxClasses["openfl.display.GraphicsBitmapFill"] = GraphicsBitmapFill;

// Init



// Statics




// Export

exports.default = GraphicsBitmapFill;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsEndFill.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/GraphicsEndFill.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.GraphicsEndFill

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
function openfl_display_IGraphicsFill() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsFill */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsFill.js");}
function openfl_display_IGraphicsData() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsData */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsData.js");}

// Constructor

var GraphicsEndFill = function() {
	this.__graphicsDataType = 5;
	this.__graphicsFillType = 3;
}

// Meta

GraphicsEndFill.__name__ = "openfl.display.GraphicsEndFill";
GraphicsEndFill.__isInterface__ = false;
GraphicsEndFill.__interfaces__ = [(openfl_display_IGraphicsFill().default),(openfl_display_IGraphicsData().default)];
GraphicsEndFill.prototype = {
	
};
GraphicsEndFill.prototype.__class__ = GraphicsEndFill.prototype.constructor = $hxClasses["openfl.display.GraphicsEndFill"] = GraphicsEndFill;

// Init



// Statics




// Export

exports.default = GraphicsEndFill;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsGradientFill.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/GraphicsGradientFill.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.GraphicsGradientFill

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
function openfl_display_IGraphicsFill() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsFill */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsFill.js");}
function openfl_display_IGraphicsData() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsData */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsData.js");}

// Constructor

var GraphicsGradientFill = function(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio) {
	if(focalPointRatio == null) {
		focalPointRatio = 0;
	}
	if(type == null) {
		type = "linear";
	}
	if(spreadMethod == null) {
		spreadMethod = "pad";
	}
	if(interpolationMethod == null) {
		interpolationMethod = "rgb";
	}
	this.type = type;
	this.colors = colors;
	this.alphas = alphas;
	this.ratios = ratios;
	this.matrix = matrix;
	this.spreadMethod = spreadMethod;
	this.interpolationMethod = interpolationMethod;
	this.focalPointRatio = focalPointRatio;
	this.__graphicsDataType = 2;
	this.__graphicsFillType = 1;
}

// Meta

GraphicsGradientFill.__name__ = "openfl.display.GraphicsGradientFill";
GraphicsGradientFill.__isInterface__ = false;
GraphicsGradientFill.__interfaces__ = [(openfl_display_IGraphicsFill().default),(openfl_display_IGraphicsData().default)];
GraphicsGradientFill.prototype = {
	
};
GraphicsGradientFill.prototype.__class__ = GraphicsGradientFill.prototype.constructor = $hxClasses["openfl.display.GraphicsGradientFill"] = GraphicsGradientFill;

// Init



// Statics




// Export

exports.default = GraphicsGradientFill;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsPath.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/GraphicsPath.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.GraphicsPath

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_display_IGraphicsPath() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsPath */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsPath.js");}
function openfl_display_IGraphicsData() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsData */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsData.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}

// Constructor

var GraphicsPath = function(commands,data,winding) {
	if(winding == null) {
		winding = "evenOdd";
	}
	this.commands = commands;
	this.data = data;
	this.winding = winding;
	this.__graphicsDataType = 3;
}

// Meta

GraphicsPath.__name__ = "openfl.display.GraphicsPath";
GraphicsPath.__isInterface__ = false;
GraphicsPath.__interfaces__ = [(openfl_display_IGraphicsPath().default),(openfl_display_IGraphicsData().default)];
GraphicsPath.prototype = {
	cubicCurveTo: function(controlX1,controlY1,controlX2,controlY2,anchorX,anchorY) {
		if(this.commands == null) {
			this.commands = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		if(this.data == null) {
			this.data = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		(openfl__$Vector_Vector_$Impl_$().default).push(this.commands,6);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,controlX1);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,controlY1);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,controlX2);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,controlY2);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,anchorX);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,anchorY);
	},
	curveTo: function(controlX,controlY,anchorX,anchorY) {
		if(this.commands == null) {
			this.commands = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		if(this.data == null) {
			this.data = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		(openfl__$Vector_Vector_$Impl_$().default).push(this.commands,3);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,controlX);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,controlY);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,anchorX);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,anchorY);
	},
	lineTo: function(x,y) {
		if(this.commands == null) {
			this.commands = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		if(this.data == null) {
			this.data = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		(openfl__$Vector_Vector_$Impl_$().default).push(this.commands,2);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,x);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,y);
	},
	moveTo: function(x,y) {
		if(this.commands == null) {
			this.commands = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		if(this.data == null) {
			this.data = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		(openfl__$Vector_Vector_$Impl_$().default).push(this.commands,1);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,x);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,y);
	},
	wideLineTo: function(x,y) {
		if(this.commands == null) {
			this.commands = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		if(this.data == null) {
			this.data = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		(openfl__$Vector_Vector_$Impl_$().default).push(this.commands,2);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,x);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,y);
	},
	wideMoveTo: function(x,y) {
		if(this.commands == null) {
			this.commands = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		if(this.data == null) {
			this.data = (openfl__$Vector_Vector_$Impl_$().default)._new();
		}
		(openfl__$Vector_Vector_$Impl_$().default).push(this.commands,1);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,x);
		(openfl__$Vector_Vector_$Impl_$().default).push(this.data,y);
	},
	__drawCircle: function(x,y,radius) {
		this.__drawRoundRect(x - radius,y - radius,radius * 2,radius * 2,radius * 2,radius * 2);
	},
	__drawEllipse: function(x,y,width,height) {
		this.__drawRoundRect(x,y,width,height,width,height);
	},
	__drawRect: function(x,y,width,height) {
		this.moveTo(x,y);
		this.lineTo(x + width,y);
		this.lineTo(x + width,y + height);
		this.lineTo(x,y + height);
		this.lineTo(x,y);
	},
	__drawRoundRect: function(x,y,width,height,ellipseWidth,ellipseHeight) {
		ellipseWidth *= 0.5;
		ellipseHeight *= 0.5;
		if(ellipseWidth > width / 2) {
			ellipseWidth = width / 2;
		}
		if(ellipseHeight > height / 2) {
			ellipseHeight = height / 2;
		}
		var xe = x + width;
		var ye = y + height;
		var cx1 = -ellipseWidth + ellipseWidth * 0.70710678118654752440084436210485;
		var cx2 = -ellipseWidth + ellipseWidth * 0.4142135623730950488016887242097;
		var cy1 = -ellipseHeight + ellipseHeight * 0.70710678118654752440084436210485;
		var cy2 = -ellipseHeight + ellipseHeight * 0.4142135623730950488016887242097;
		this.moveTo(xe,ye - ellipseHeight);
		this.curveTo(xe,ye + cy2,xe + cx1,ye + cy1);
		this.curveTo(xe + cx2,ye,xe - ellipseWidth,ye);
		this.lineTo(x + ellipseWidth,ye);
		this.curveTo(x - cx2,ye,x - cx1,ye + cy1);
		this.curveTo(x,ye + cy2,x,ye - ellipseHeight);
		this.lineTo(x,y + ellipseHeight);
		this.curveTo(x,y - cy2,x - cx1,y - cy1);
		this.curveTo(x - cx2,y,x + ellipseWidth,y);
		this.lineTo(xe - ellipseWidth,y);
		this.curveTo(xe + cx2,y,xe + cx1,y - cy1);
		this.curveTo(xe,y - cy2,xe,y + ellipseHeight);
		this.lineTo(xe,ye - ellipseHeight);
	}
};
GraphicsPath.prototype.__class__ = GraphicsPath.prototype.constructor = $hxClasses["openfl.display.GraphicsPath"] = GraphicsPath;

// Init



// Statics


GraphicsPath.SIN45 = 0.70710678118654752440084436210485
GraphicsPath.TAN22 = 0.4142135623730950488016887242097

// Export

exports.default = GraphicsPath;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsShader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/GraphicsShader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.GraphicsShader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_Shader() {return __webpack_require__(/*! ./../../openfl/display/Shader */ "./node_modules/openfl/lib/_gen/openfl/display/Shader.js");}

// Constructor

var GraphicsShader = function(code) {
	if(this.__glFragmentSource == null) {
		this.__glFragmentSource = "varying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\t\tuniform sampler2D bitmap;\n\n\t\tvoid main(void) {\n\n\t\t\tvec4 color = texture2D (bitmap, openfl_TextureCoordv);\n\n\t\tif (color.a == 0.0) {\n\n\t\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\n\n\t\t} else if (openfl_HasColorTransform) {\n\n\t\t\tcolor = vec4 (color.rgb / color.a, color.a);\n\n\t\t\tmat4 colorMultiplier = mat4 (0);\n\t\t\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\n\t\t\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\n\t\t\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\n\t\t\tcolorMultiplier[3][3] = 1.0; // openfl_ColorMultiplierv.w;\n\n\t\t\tcolor = clamp (openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\n\n\t\t\tif (color.a > 0.0) {\n\n\t\t\t\tgl_FragColor = vec4 (color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\n\n\t\t\t} else {\n\n\t\t\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl_FragColor = color * openfl_Alphav;\n\n\t\t}\n\n\t\t}";
	}
	if(this.__glVertexSource == null) {
		this.__glVertexSource = "attribute float openfl_Alpha;\n\t\tattribute vec4 openfl_ColorMultiplier;\n\t\tattribute vec4 openfl_ColorOffset;\n\t\tattribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\tvoid main(void) {\n\n\t\t\topenfl_Alphav = openfl_Alpha;\n\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\n\t\tif (openfl_HasColorTransform) {\n\n\t\t\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\n\t\t\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\n\n\t\t}\n\n\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\t\t}";
	}
	(openfl_display_Shader().default).call(this,code);
	this.__isGenerated = true;
	this.__initGL();
}

// Meta

GraphicsShader.__name__ = "openfl.display.GraphicsShader";
GraphicsShader.__isInterface__ = false;
GraphicsShader.__super__ = (openfl_display_Shader().default);
GraphicsShader.prototype = $extend((openfl_display_Shader().default).prototype, {
	
});
GraphicsShader.prototype.__class__ = GraphicsShader.prototype.constructor = $hxClasses["openfl.display.GraphicsShader"] = GraphicsShader;

// Init



// Statics




// Export

exports.default = GraphicsShader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsSolidFill.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/GraphicsSolidFill.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.GraphicsSolidFill

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
function openfl_display_IGraphicsFill() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsFill */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsFill.js");}
function openfl_display_IGraphicsData() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsData */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsData.js");}

// Constructor

var GraphicsSolidFill = function(color,alpha) {
	if(alpha == null) {
		alpha = 1;
	}
	if(color == null) {
		color = 0;
	}
	this.alpha = alpha;
	this.color = color;
	this.__graphicsDataType = 1;
	this.__graphicsFillType = 0;
}

// Meta

GraphicsSolidFill.__name__ = "openfl.display.GraphicsSolidFill";
GraphicsSolidFill.__isInterface__ = false;
GraphicsSolidFill.__interfaces__ = [(openfl_display_IGraphicsFill().default),(openfl_display_IGraphicsData().default)];
GraphicsSolidFill.prototype = {
	
};
GraphicsSolidFill.prototype.__class__ = GraphicsSolidFill.prototype.constructor = $hxClasses["openfl.display.GraphicsSolidFill"] = GraphicsSolidFill;

// Init



// Statics




// Export

exports.default = GraphicsSolidFill;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsStroke.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/GraphicsStroke.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.GraphicsStroke

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
function openfl_display_IGraphicsStroke() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsStroke */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsStroke.js");}
function openfl_display_IGraphicsData() {return __webpack_require__(/*! ./../../openfl/display/IGraphicsData */ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsData.js");}

// Constructor

var GraphicsStroke = function(thickness,pixelHinting,scaleMode,caps,joints,miterLimit,fill) {
	if(miterLimit == null) {
		miterLimit = 3;
	}
	if(joints == null) {
		joints = "round";
	}
	if(caps == null) {
		caps = "none";
	}
	if(scaleMode == null) {
		scaleMode = "normal";
	}
	if(pixelHinting == null) {
		pixelHinting = false;
	}
	if(thickness == null) {
		thickness = NaN;
	}
	this.caps = caps;
	this.fill = fill;
	this.joints = joints;
	this.miterLimit = miterLimit;
	this.pixelHinting = pixelHinting;
	this.scaleMode = scaleMode;
	this.thickness = thickness;
	this.__graphicsDataType = 0;
}

// Meta

GraphicsStroke.__name__ = "openfl.display.GraphicsStroke";
GraphicsStroke.__isInterface__ = false;
GraphicsStroke.__interfaces__ = [(openfl_display_IGraphicsStroke().default),(openfl_display_IGraphicsData().default)];
GraphicsStroke.prototype = {
	
};
GraphicsStroke.prototype.__class__ = GraphicsStroke.prototype.constructor = $hxClasses["openfl.display.GraphicsStroke"] = GraphicsStroke;

// Init



// Statics




// Export

exports.default = GraphicsStroke;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/IBitmapDrawable.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/IBitmapDrawable.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.IBitmapDrawable

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IBitmapDrawable = function() {}

// Meta

IBitmapDrawable.__name__ = "openfl.display.IBitmapDrawable";
IBitmapDrawable.__isInterface__ = true;
IBitmapDrawable.prototype = {
	
};
IBitmapDrawable.prototype.__class__ = IBitmapDrawable.prototype.constructor = $hxClasses["openfl.display.IBitmapDrawable"] = IBitmapDrawable;

// Init



// Statics




// Export

exports.default = IBitmapDrawable;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsData.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/IGraphicsData.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.IGraphicsData

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IGraphicsData = function() {}

// Meta

IGraphicsData.__name__ = "openfl.display.IGraphicsData";
IGraphicsData.__isInterface__ = true;
IGraphicsData.prototype = {
	
};
IGraphicsData.prototype.__class__ = IGraphicsData.prototype.constructor = $hxClasses["openfl.display.IGraphicsData"] = IGraphicsData;

// Init



// Statics




// Export

exports.default = IGraphicsData;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsFill.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/IGraphicsFill.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.IGraphicsFill

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IGraphicsFill = function() {}

// Meta

IGraphicsFill.__name__ = "openfl.display.IGraphicsFill";
IGraphicsFill.__isInterface__ = true;
IGraphicsFill.prototype = {
	
};
IGraphicsFill.prototype.__class__ = IGraphicsFill.prototype.constructor = $hxClasses["openfl.display.IGraphicsFill"] = IGraphicsFill;

// Init



// Statics




// Export

exports.default = IGraphicsFill;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsPath.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/IGraphicsPath.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.IGraphicsPath

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IGraphicsPath = function() {}

// Meta

IGraphicsPath.__name__ = "openfl.display.IGraphicsPath";
IGraphicsPath.__isInterface__ = true;
IGraphicsPath.prototype = {
	
};
IGraphicsPath.prototype.__class__ = IGraphicsPath.prototype.constructor = $hxClasses["openfl.display.IGraphicsPath"] = IGraphicsPath;

// Init



// Statics




// Export

exports.default = IGraphicsPath;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/IGraphicsStroke.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/IGraphicsStroke.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.IGraphicsStroke

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IGraphicsStroke = function() {}

// Meta

IGraphicsStroke.__name__ = "openfl.display.IGraphicsStroke";
IGraphicsStroke.__isInterface__ = true;
IGraphicsStroke.prototype = {
	
};
IGraphicsStroke.prototype.__class__ = IGraphicsStroke.prototype.constructor = $hxClasses["openfl.display.IGraphicsStroke"] = IGraphicsStroke;

// Init



// Statics




// Export

exports.default = IGraphicsStroke;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/InteractiveObject.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/InteractiveObject.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.InteractiveObject

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_DisplayObject() {return __webpack_require__(/*! ./../../openfl/display/DisplayObject */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js");}
function openfl__$internal_Lib() {return __webpack_require__(/*! ./../../openfl/_internal/Lib */ "./node_modules/openfl/lib/_gen/openfl/_internal/Lib.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_RangeError() {return __webpack_require__(/*! ./../../openfl/errors/RangeError */ "./node_modules/openfl/lib/_gen/openfl/errors/RangeError.js");}

// Constructor

var InteractiveObject = function() {
	(openfl_display_DisplayObject().default).call(this);
	this.doubleClickEnabled = false;
	this.mouseEnabled = true;
	this.needsSoftKeyboard = false;
	this.__tabEnabled = null;
	this.__tabIndex = -1;
}

// Meta

InteractiveObject.__name__ = "openfl.display.InteractiveObject";
InteractiveObject.__isInterface__ = false;
InteractiveObject.__super__ = (openfl_display_DisplayObject().default);
InteractiveObject.prototype = $extend((openfl_display_DisplayObject().default).prototype, {
	requestSoftKeyboard: function() {
		(openfl__$internal_Lib().default).notImplemented({ fileName : "../src/openfl/display/InteractiveObject.hx", lineNumber : 1251, className : "openfl.display.InteractiveObject", methodName : "requestSoftKeyboard"});
		return false;
	},
	__allowMouseFocus: function() {
		return this.get_tabEnabled();
	},
	__getInteractive: function(stack) {
		if(stack != null) {
			stack.push(this);
			if(this.parent != null) {
				this.parent.__getInteractive(stack);
			}
		}
		return true;
	},
	__hitTest: function(x,y,shapeFlag,stack,interactiveOnly,hitObject) {
		if(!hitObject.get_visible() || this.__isMask || interactiveOnly && !this.mouseEnabled) {
			return false;
		}
		return (openfl_display_DisplayObject().default).prototype.__hitTest.call(this,x,y,shapeFlag,stack,interactiveOnly,hitObject);
	},
	__tabTest: function(stack) {
		if(this.get_tabEnabled()) {
			stack.push(this);
		}
	},
	get_tabEnabled: function() {
		if(this.__tabEnabled == true) {
			return true;
		} else {
			return false;
		}
	},
	set_tabEnabled: function(value) {
		if(this.__tabEnabled != value) {
			this.__tabEnabled = value;
			this.dispatchEvent(new (openfl_events_Event().default)("tabEnabledChange",true,false));
		}
		return this.__tabEnabled;
	},
	get_tabIndex: function() {
		return this.__tabIndex;
	},
	set_tabIndex: function(value) {
		if(this.__tabIndex != value) {
			if(value < -1) {
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_RangeError().default)("Parameter tabIndex must be a non-negative number; got " + value));
			}
			this.__tabIndex = value;
			this.dispatchEvent(new (openfl_events_Event().default)("tabIndexChange",true,false));
		}
		return this.__tabIndex;
	}
});
InteractiveObject.prototype.__class__ = InteractiveObject.prototype.constructor = $hxClasses["openfl.display.InteractiveObject"] = InteractiveObject;

// Init

Object.defineProperties(InteractiveObject.prototype,{ tabEnabled : { get : function () { return this.get_tabEnabled (); }, set : function (v) { return this.set_tabEnabled (v); }}, tabIndex : { get : function () { return this.get_tabIndex (); }, set : function (v) { return this.set_tabIndex (v); }}});

// Statics




// Export

exports.default = InteractiveObject;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/JPEGEncoderOptions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/JPEGEncoderOptions.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.JPEGEncoderOptions

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var JPEGEncoderOptions = function(quality) {
	if(quality == null) {
		quality = 80;
	}
	this.quality = quality;
}

// Meta

JPEGEncoderOptions.__name__ = "openfl.display.JPEGEncoderOptions";
JPEGEncoderOptions.__isInterface__ = false;
JPEGEncoderOptions.prototype = {
	
};
JPEGEncoderOptions.prototype.__class__ = JPEGEncoderOptions.prototype.constructor = $hxClasses["openfl.display.JPEGEncoderOptions"] = JPEGEncoderOptions;

// Init



// Statics




// Export

exports.default = JPEGEncoderOptions;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Loader.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Loader.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Loader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_DisplayObjectContainer() {return __webpack_require__(/*! ./../../openfl/display/DisplayObjectContainer */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectContainer.js");}
function openfl__$internal_Lib() {return __webpack_require__(/*! ./../../openfl/_internal/Lib */ "./node_modules/openfl/lib/_gen/openfl/_internal/Lib.js");}
function openfl_Lib() {return __webpack_require__(/*! ./../../openfl/Lib */ "./node_modules/openfl/lib/_gen/openfl/Lib.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function openfl_display_BitmapData() {return __webpack_require__(/*! ./../../openfl/display/BitmapData */ "./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js");}
function openfl_net_URLLoader() {return __webpack_require__(/*! ./../../openfl/net/URLLoader */ "./node_modules/openfl/lib/_gen/openfl/net/URLLoader.js");}
function openfl_utils_Assets() {return __webpack_require__(/*! ./../../openfl/utils/Assets */ "./node_modules/openfl/lib/_gen/openfl/utils/Assets.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function openfl_events_IOErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/IOErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/IOErrorEvent.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl_display_Bitmap() {return __webpack_require__(/*! ./../../openfl/display/Bitmap */ "./node_modules/openfl/lib/_gen/openfl/display/Bitmap.js");}
function openfl_events_ProgressEvent() {return __webpack_require__(/*! ./../../openfl/events/ProgressEvent */ "./node_modules/openfl/lib/_gen/openfl/events/ProgressEvent.js");}
function lime_utils_AssetManifest() {return __webpack_require__(/*! ./../../lime/utils/AssetManifest */ "./node_modules/openfl/lib/_gen/lime/utils/AssetManifest.js");}
function haxe_io_Path() {return __webpack_require__(/*! ./../../haxe/io/Path */ "./node_modules/openfl/lib/_gen/haxe/io/Path.js");}
function lime_utils_AssetLibrary() {return __webpack_require__(/*! ./../../lime/utils/AssetLibrary */ "./node_modules/openfl/lib/_gen/lime/utils/AssetLibrary.js");}
function openfl_utils_AssetLibrary() {return __webpack_require__(/*! ./../../openfl/utils/AssetLibrary */ "./node_modules/openfl/lib/_gen/openfl/utils/AssetLibrary.js");}
function openfl_display_Sprite() {return __webpack_require__(/*! ./../../openfl/display/Sprite */ "./node_modules/openfl/lib/_gen/openfl/display/Sprite.js");}
function openfl_display_LoaderInfo() {return __webpack_require__(/*! ./../../openfl/display/LoaderInfo */ "./node_modules/openfl/lib/_gen/openfl/display/LoaderInfo.js");}

// Constructor

var Loader = function() {
	(openfl_display_DisplayObjectContainer().default).call(this);
	this.contentLoaderInfo = (openfl_display_LoaderInfo().default).create(this);
	this.uncaughtErrorEvents = this.contentLoaderInfo.uncaughtErrorEvents;
	this.__unloaded = true;
}

// Meta

Loader.__name__ = "openfl.display.Loader";
Loader.__isInterface__ = false;
Loader.__super__ = (openfl_display_DisplayObjectContainer().default);
Loader.prototype = $extend((openfl_display_DisplayObjectContainer().default).prototype, {
	close: function() {
		(openfl__$internal_Lib().default).notImplemented({ fileName : "../src/openfl/display/Loader.hx", lineNumber : 229, className : "openfl.display.Loader", methodName : "close"});
	},
	load: function(request,context) {
		this.unload();
		this.contentLoaderInfo.loaderURL = (openfl_Lib().default).get_current().get_loaderInfo().url;
		this.contentLoaderInfo.url = request.url;
		this.__unloaded = false;
		if(request.contentType == null || request.contentType == "") {
			var extension = "";
			this.__path = request.url;
			var queryIndex = this.__path.indexOf("?");
			if(queryIndex > -1) {
				this.__path = this.__path.substring(0,queryIndex);
			}
			while((StringTools().default).endsWith(this.__path,"/")) this.__path = this.__path.substring(0,this.__path.length - 1);
			if((StringTools().default).endsWith(this.__path,".bundle")) {
				this.__path += "/library.json";
				if(queryIndex > -1) {
					request.url = this.__path + request.url.substring(queryIndex);
				} else {
					request.url = this.__path;
				}
			}
			var extIndex = this.__path.lastIndexOf(".");
			if(extIndex > -1) {
				extension = this.__path.substring(extIndex + 1);
			}
			var tmp;
			switch(extension) {
			case "gif":
				tmp = "image/gif";
				break;
			case "jpeg":case "jpg":
				tmp = "image/jpeg";
				break;
			case "js":
				tmp = "application/javascript";
				break;
			case "json":
				tmp = "application/json";
				break;
			case "png":
				tmp = "image/png";
				break;
			case "swf":
				tmp = "application/x-shockwave-flash";
				break;
			default:
				tmp = "application/x-www-form-urlencoded";
			}
			this.contentLoaderInfo.contentType = tmp;
		} else {
			this.contentLoaderInfo.contentType = request.contentType;
		}
		if(this.contentLoaderInfo.contentType.indexOf("image/") > -1 && request.method == "GET" && (request.requestHeaders == null || request.requestHeaders.length == 0) && request.userAgent == null) {
			(openfl_display_BitmapData().default).loadFromFile(request.url).onComplete($bind(this,this.BitmapData_onLoad)).onError($bind(this,this.BitmapData_onError)).onProgress($bind(this,this.BitmapData_onProgress));
			return;
		}
		var loader = new (openfl_net_URLLoader().default)();
		loader.dataFormat = "binary";
		if(this.contentLoaderInfo.contentType.indexOf("/json") > -1 || this.contentLoaderInfo.contentType.indexOf("/javascript") > -1 || this.contentLoaderInfo.contentType.indexOf("/ecmascript") > -1) {
			loader.dataFormat = "text";
		}
		loader.addEventListener("complete",$bind(this,this.loader_onComplete));
		loader.addEventListener("ioError",$bind(this,this.loader_onError));
		loader.addEventListener("progress",$bind(this,this.loader_onProgress));
		loader.load(request);
	},
	loadBytes: function(buffer,context) {
		(openfl_display_BitmapData().default).loadFromBytes(buffer).onComplete($bind(this,this.BitmapData_onLoad)).onError($bind(this,this.BitmapData_onError));
	},
	unload: function() {
		if(!this.__unloaded) {
			if(this.content != null && this.content.parent == this) {
				(openfl_display_DisplayObjectContainer().default).prototype.removeChild.call(this,this.content);
			}
			if(this.__library != null) {
				(openfl_utils_Assets().default).unloadLibrary(this.contentLoaderInfo.url);
				this.__library = null;
			}
			this.content = null;
			this.contentLoaderInfo.url = null;
			this.contentLoaderInfo.contentType = null;
			this.contentLoaderInfo.content = null;
			this.contentLoaderInfo.bytesLoaded = 0;
			this.contentLoaderInfo.bytesTotal = 0;
			this.contentLoaderInfo.width = 0;
			this.contentLoaderInfo.height = 0;
			this.__unloaded = true;
			this.contentLoaderInfo.dispatchEvent(new (openfl_events_Event().default)("unload"));
		}
	},
	unloadAndStop: function(gc) {
		if(gc == null) {
			gc = true;
		}
		if(this.content != null) {
			this.content.__stopAllMovieClips();
		}
		var _g = 0;
		var _g1 = this.get_numChildren();
		while(_g < _g1) {
			var i = _g++;
			this.getChildAt(i).__stopAllMovieClips();
		}
		this.unload();
		var gc1 = gc;
	},
	__dispatchError: function(text) {
		var event = new (openfl_events_IOErrorEvent().default)("ioError");
		event.text = text;
		this.contentLoaderInfo.dispatchEvent(event);
	},
	__setContent: function(content,width,height) {
		this.content = content;
		this.contentLoaderInfo.content = content;
		this.contentLoaderInfo.width = width;
		this.contentLoaderInfo.height = height;
		if(content != null) {
			(openfl_display_DisplayObjectContainer().default).prototype.addChildAt.call(this,content,0);
		}
	},
	BitmapData_onError: function(error) {
		this.__dispatchError((Std().default).string(error));
	},
	BitmapData_onLoad: function(bitmapData) {
		if(bitmapData == null) {
			this.__dispatchError("Unknown error");
			return;
		}
		this.__setContent(new (openfl_display_Bitmap().default)(bitmapData),bitmapData.width,bitmapData.height);
		this.contentLoaderInfo.dispatchEvent(new (openfl_events_Event().default)("complete"));
	},
	BitmapData_onProgress: function(bytesLoaded,bytesTotal) {
		var event = new (openfl_events_ProgressEvent().default)("progress");
		event.bytesLoaded = bytesLoaded;
		event.bytesTotal = bytesTotal;
		this.contentLoaderInfo.dispatchEvent(event);
	},
	loader_onComplete: function(event) {
		var _gthis = this;
		var loader = event.target;
		if(this.contentLoaderInfo.contentType != null && this.contentLoaderInfo.contentType.indexOf("/json") > -1) {
			var manifest = (lime_utils_AssetManifest().default).parse(loader.data,(haxe_io_Path().default).directory(this.__path));
			if(manifest == null) {
				this.__dispatchError("Cannot parse asset manifest");
				return;
			}
			var library = (lime_utils_AssetLibrary().default).fromManifest(manifest);
			if(library == null) {
				this.__dispatchError("Cannot open library");
				return;
			}
			if(((library) instanceof (openfl_utils_AssetLibrary().default))) {
				library.load().onComplete(function(_) {
					_gthis.__library = library;
					(openfl_utils_Assets().default).registerLibrary(_gthis.contentLoaderInfo.url,_gthis.__library);
					if(manifest.name != null && !(openfl_utils_Assets().default).hasLibrary(manifest.name)) {
						(openfl_utils_Assets().default).registerLibrary(manifest.name,_gthis.__library);
					}
					var clip = _gthis.__library.getMovieClip("");
					var tmp = (Std().default).int(clip.get_width());
					var tmp1 = (Std().default).int(clip.get_height());
					_gthis.__setContent(clip,tmp,tmp1);
					_gthis.contentLoaderInfo.dispatchEvent(new (openfl_events_Event().default)("complete"));
				}).onError(function(e) {
					_gthis.__dispatchError(e);
				});
			}
		} else if(this.contentLoaderInfo.contentType != null && (this.contentLoaderInfo.contentType.indexOf("/javascript") > -1 || this.contentLoaderInfo.contentType.indexOf("/ecmascript") > -1)) {
			this.__setContent(new (openfl_display_Sprite().default)(),0,0);
			eval("(function () {" + (Std().default).string(loader.data) + "})()");
			this.contentLoaderInfo.dispatchEvent(new (openfl_events_Event().default)("complete"));
		} else {
			this.contentLoaderInfo.bytes = loader.data;
			(openfl_display_BitmapData().default).loadFromBytes(loader.data).onComplete($bind(this,this.BitmapData_onLoad)).onError($bind(this,this.BitmapData_onError));
		}
	},
	loader_onError: function(event) {
		event.target = this.contentLoaderInfo;
		this.contentLoaderInfo.dispatchEvent(event);
	},
	loader_onProgress: function(event) {
		event.target = this.contentLoaderInfo;
		this.contentLoaderInfo.dispatchEvent(event);
	}
});
Loader.prototype.__class__ = Loader.prototype.constructor = $hxClasses["openfl.display.Loader"] = Loader;

// Init



// Statics


Loader.__meta__ = { fields : { BitmapData_onError : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = Loader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/LoaderInfo.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/LoaderInfo.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.LoaderInfo

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function openfl_events_ProgressEvent() {return __webpack_require__(/*! ./../../openfl/events/ProgressEvent */ "./node_modules/openfl/lib/_gen/openfl/events/ProgressEvent.js");}
function openfl_events_UncaughtErrorEvents() {return __webpack_require__(/*! ./../../openfl/events/UncaughtErrorEvents */ "./node_modules/openfl/lib/_gen/openfl/events/UncaughtErrorEvents.js");}
function openfl_system_ApplicationDomain() {return __webpack_require__(/*! ./../../openfl/system/ApplicationDomain */ "./node_modules/openfl/lib/_gen/openfl/system/ApplicationDomain.js");}

// Constructor

var LoaderInfo = function() {
	(openfl_events_EventDispatcher().default).call(this);
	this.applicationDomain = (openfl_system_ApplicationDomain().default).currentDomain;
	this.bytesLoaded = 0;
	this.bytesTotal = 0;
	this.childAllowsParent = true;
	this.parameters = { };
}

// Meta

LoaderInfo.__name__ = "openfl.display.LoaderInfo";
LoaderInfo.__isInterface__ = false;
LoaderInfo.__super__ = (openfl_events_EventDispatcher().default);
LoaderInfo.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	__complete: function() {
		if(!this.__completed) {
			if(this.bytesLoaded < this.bytesTotal) {
				this.bytesLoaded = this.bytesTotal;
			}
			this.__update(this.bytesLoaded,this.bytesTotal);
			this.__completed = true;
			this.dispatchEvent(new (openfl_events_Event().default)("complete"));
		}
	},
	__update: function(bytesLoaded,bytesTotal) {
		this.bytesLoaded = bytesLoaded;
		this.bytesTotal = bytesTotal;
		this.dispatchEvent(new (openfl_events_ProgressEvent().default)("progress",false,false,bytesLoaded,bytesTotal));
	}
});
LoaderInfo.prototype.__class__ = LoaderInfo.prototype.constructor = $hxClasses["openfl.display.LoaderInfo"] = LoaderInfo;

// Init



// Statics

LoaderInfo.create = function(loader) {
	var loaderInfo = new LoaderInfo();
	loaderInfo.uncaughtErrorEvents = new (openfl_events_UncaughtErrorEvents().default)();
	if(loader != null) {
		loaderInfo.loader = loader;
	} else {
		loaderInfo.url = LoaderInfo.__rootURL;
	}
	return loaderInfo;
}
LoaderInfo.__meta__ = { statics : { create : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}, fields : { parameters : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
LoaderInfo.__rootURL = typeof(window) != "undefined" ? window.document.URL : ""

// Export

exports.default = LoaderInfo;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/MovieClip.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/MovieClip.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.MovieClip

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_Sprite() {return __webpack_require__(/*! ./../../openfl/display/Sprite */ "./node_modules/openfl/lib/_gen/openfl/display/Sprite.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl_display_FrameLabel() {return __webpack_require__(/*! ./../../openfl/display/FrameLabel */ "./node_modules/openfl/lib/_gen/openfl/display/FrameLabel.js");}
function haxe_CallStack() {return __webpack_require__(/*! ./../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function openfl__$internal_symbols_timeline_FrameObjectType() {return __webpack_require__(/*! ./../../openfl/_internal/symbols/timeline/FrameObjectType */ "./node_modules/openfl/lib/_gen/openfl/_internal/symbols/timeline/FrameObjectType.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function openfl_display__$MovieClip_FrameSymbolInstance() {return __webpack_require__(/*! ./../../openfl/display/_MovieClip/FrameSymbolInstance */ "./node_modules/openfl/lib/_gen/openfl/display/_MovieClip/FrameSymbolInstance.js");}
function openfl_errors_ArgumentError() {return __webpack_require__(/*! ./../../openfl/errors/ArgumentError */ "./node_modules/openfl/lib/_gen/openfl/errors/ArgumentError.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function openfl_geom_ColorTransform() {return __webpack_require__(/*! ./../../openfl/geom/ColorTransform */ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js");}
function openfl_filters_BlurFilter() {return __webpack_require__(/*! ./../../openfl/filters/BlurFilter */ "./node_modules/openfl/lib/_gen/openfl/filters/BlurFilter.js");}
function openfl_filters_ColorMatrixFilter() {return __webpack_require__(/*! ./../../openfl/filters/ColorMatrixFilter */ "./node_modules/openfl/lib/_gen/openfl/filters/ColorMatrixFilter.js");}
function openfl_filters_DropShadowFilter() {return __webpack_require__(/*! ./../../openfl/filters/DropShadowFilter */ "./node_modules/openfl/lib/_gen/openfl/filters/DropShadowFilter.js");}
function openfl_filters_GlowFilter() {return __webpack_require__(/*! ./../../openfl/filters/GlowFilter */ "./node_modules/openfl/lib/_gen/openfl/filters/GlowFilter.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var MovieClip = function() {
	(openfl_display_Sprite().default).call(this);
	this.__currentFrame = 1;
	this.__currentLabels = [];
	this.__instanceFields = [];
	this.__totalFrames = 0;
	this.__enabled = true;
	if(MovieClip.__initSymbol != null) {
		this.__swf = MovieClip.__initSWF;
		this.__symbol = MovieClip.__initSymbol;
		MovieClip.__initSWF = null;
		MovieClip.__initSymbol = null;
		this.__fromSymbol(this.__swf,this.__symbol);
	}
}

// Meta

MovieClip.__name__ = "openfl.display.MovieClip";
MovieClip.__isInterface__ = false;
MovieClip.__super__ = (openfl_display_Sprite().default);
MovieClip.prototype = $extend((openfl_display_Sprite().default).prototype, {
	addFrameScript: function(index,method) {
		if(index < 0) {
			return;
		}
		var frame = index + 1;
		if(method != null) {
			if(this.__frameScripts == null) {
				this.__frameScripts = new (haxe_ds_IntMap().default)();
			}
			this.__frameScripts.set(frame,method);
		} else if(this.__frameScripts != null) {
			this.__frameScripts.remove(frame);
		}
	},
	gotoAndPlay: function(frame,scene) {
		this.play();
		this.__goto(this.__resolveFrameReference(frame));
	},
	gotoAndStop: function(frame,scene) {
		this.stop();
		this.__goto(this.__resolveFrameReference(frame));
	},
	nextFrame: function() {
		this.stop();
		this.__goto(this.__currentFrame + 1);
	},
	play: function() {
		if(this.__symbol == null || this.__playing || this.__totalFrames < 2) {
			return;
		}
		this.__playing = true;
		if(!MovieClip.__useParentFPS) {
			this.__frameTime = (Std().default).int(1000 / this.__swf.frameRate);
			this.__timeElapsed = 0;
		}
	},
	prevFrame: function() {
		this.stop();
		this.__goto(this.__currentFrame - 1);
	},
	stop: function() {
		this.__playing = false;
	},
	__enterFrame: function(deltaTime) {
		this.__updateFrameScript(deltaTime);
		this.__updateSymbol(this.__currentFrame);
		(openfl_display_Sprite().default).prototype.__enterFrame.call(this,deltaTime);
	},
	__updateFrameScript: function(deltaTime) {
		if(this.__symbol != null && this.__playing) {
			var nextFrame = this.__getNextFrame(deltaTime);
			if(this.__lastFrameScriptEval == nextFrame) {
				(openfl_display_Sprite().default).prototype.__enterFrame.call(this,deltaTime);
				return;
			}
			if(this.__frameScripts != null) {
				if(nextFrame < this.__currentFrame) {
					if(!this.__evaluateFrameScripts(this.__totalFrames)) {
						(openfl_display_Sprite().default).prototype.__enterFrame.call(this,deltaTime);
						return;
					}
					this.__currentFrame = 1;
				}
				if(!this.__evaluateFrameScripts(nextFrame)) {
					(openfl_display_Sprite().default).prototype.__enterFrame.call(this,deltaTime);
					return;
				}
			} else {
				this.__currentFrame = nextFrame;
			}
		}
	},
	__updateSymbol: function(targetFrame) {
		if(this.__symbol != null && this.__currentFrame != this.__lastFrameUpdate) {
			this.__updateFrameLabel();
			var currentInstancesByFrameObjectID = new (haxe_ds_IntMap().default)();
			var frame;
			var frameData;
			var instance;
			var _g = 0;
			var _g1 = targetFrame;
			while(_g < _g1) {
				var i = _g++;
				frame = i + 1;
				frameData = this.__symbol.frames[i];
				if(frameData.objects == null) {
					continue;
				}
				var _g2 = 0;
				var _g11 = frameData.objects;
				while(_g2 < _g11.length) {
					var frameObject = _g11[_g2];
					++_g2;
					switch(frameObject.type._hx_index) {
					case 0:
						instance = this.__activeInstancesByFrameObjectID.get(frameObject.id);
						if(instance != null) {
							currentInstancesByFrameObjectID.set(frameObject.id,instance);
							this.__updateDisplayObject(instance.displayObject,frameObject,true);
						}
						break;
					case 1:
						instance = currentInstancesByFrameObjectID.get(frameObject.id);
						if(instance != null && instance.displayObject != null) {
							this.__updateDisplayObject(instance.displayObject,frameObject);
						}
						break;
					case 2:
						currentInstancesByFrameObjectID.remove(frameObject.id);
						break;
					}
				}
			}
			var currentInstances = [];
			var currentMasks = [];
			var instance1 = currentInstancesByFrameObjectID.iterator();
			while(instance1.hasNext()) {
				var instance2 = instance1.next();
				if(currentInstances.indexOf(instance2) == -1) {
					currentInstances.push(instance2);
					if(instance2.clipDepth > 0) {
						currentMasks.push(instance2);
					}
				}
			}
			currentInstances.sort($bind(this,this.__sortDepths));
			var existingChild;
			var targetDepth;
			var targetChild;
			var child;
			var maskApplied;
			var _g21 = 0;
			var _g3 = currentInstances.length;
			while(_g21 < _g3) {
				var i1 = _g21++;
				existingChild = this.__children[i1];
				instance = currentInstances[i1];
				targetDepth = instance.depth;
				targetChild = instance.displayObject;
				if(existingChild != targetChild) {
					child = targetChild;
					this.addChildAt(targetChild,i1);
				} else {
					child = this.__children[i1];
				}
				maskApplied = false;
				var _g22 = 0;
				while(_g22 < currentMasks.length) {
					var mask = currentMasks[_g22];
					++_g22;
					if(targetDepth > mask.depth && targetDepth <= mask.clipDepth) {
						child.set_mask(mask.displayObject);
						maskApplied = true;
						break;
					}
				}
				if(currentMasks.length > 0 && !maskApplied && child.get_mask() != null) {
					child.set_mask(null);
				}
			}
			var child1;
			var i2 = currentInstances.length;
			var length = this.__children.length;
			while(i2 < length) {
				child1 = this.__children[i2];
				var _g4 = 0;
				var _g5 = this.__activeInstances;
				while(_g4 < _g5.length) {
					var instance3 = _g5[_g4];
					++_g4;
					if(instance3.displayObject == child1) {
						if(((child1) instanceof MovieClip)) {
							var movie = child1;
							movie.gotoAndPlay(1);
						}
						this.removeChild(child1);
						--i2;
						--length;
					}
				}
				++i2;
			}
			this.__lastFrameUpdate = this.__currentFrame;
		}
	},
	__evaluateFrameScripts: function(advanceToFrame) {
		var _g = this.__currentFrame;
		var _g1 = advanceToFrame + 1;
		while(_g < _g1) {
			var frame = _g++;
			if(frame == this.__lastFrameScriptEval) {
				continue;
			}
			this.__lastFrameScriptEval = frame;
			this.__currentFrame = frame;
			if(this.__frameScripts.exists(frame)) {
				this.__updateSymbol(frame);
				var script = this.__frameScripts.get(frame);
				script();
				if(this.__currentFrame != frame) {
					return false;
				}
			}
			if(!this.__playing) {
				return false;
			}
		}
		return true;
	},
	__fromSymbol: function(swf,symbol) {
		var _gthis = this;
		if(this.__activeInstances != null) {
			return;
		}
		this.__swf = swf;
		this.__symbol = symbol;
		this.__activeInstances = [];
		this.__activeInstancesByFrameObjectID = new (haxe_ds_IntMap().default)();
		this.__currentFrame = 1;
		this.__lastFrameScriptEval = -1;
		this.__lastFrameUpdate = -1;
		this.__totalFrames = this.__symbol.frames.length;
		var frame;
		var frameData;
		var _g = 0;
		var _g1 = this.__symbol.frames.length;
		while(_g < _g1) {
			var i = _g++;
			frame = i + 1;
			frameData = this.__symbol.frames[i];
			if(frameData.label != null) {
				this.__currentLabels.push(new (openfl_display_FrameLabel().default)(frameData.label,i + 1));
			}
			if(frameData.script != null) {
				if(this.__frameScripts == null) {
					this.__frameScripts = new (haxe_ds_IntMap().default)();
				}
				this.__frameScripts.set(frame,frameData.script);
			} else if(frameData.scriptSource != null) {
				if(this.__frameScripts == null) {
					this.__frameScripts = new (haxe_ds_IntMap().default)();
				}
				try {
					var script = [eval(("(function(){" + frameData.scriptSource + "})"))];
					var wrapper = (function(script1) {
						return function() {
							try {
								script1[0].call(_gthis);
							} catch( e ) {
								(haxe_CallStack().default).lastException = e;
								var e1 = ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e;
								var wrapper1 = "Error evaluating frame script\n " + (Std().default).string(e1) + "\n";
								var _this = (haxe_CallStack().default).exceptionStack();
								var result = new Array(_this.length);
								var _g2 = 0;
								var _g11 = _this.length;
								while(_g2 < _g11) {
									var i1 = _g2++;
									result[i1] = _this[i1][2];
								}
								(lime_utils_Log().default).info(wrapper1 + result.join("\n") + "\n" + (Std().default).string(e1.stack) + "\n" + script1[0].toString(),{ fileName : "../src/openfl/display/MovieClip.hx", lineNumber : 654, className : "openfl.display.MovieClip", methodName : "__fromSymbol"});
							}
						};
					})(script);
					this.__frameScripts.set(frame,wrapper);
				} catch( e2 ) {
					(haxe_CallStack().default).lastException = e2;
					var e3 = ((e2) instanceof (js__$Boot_HaxeError().default)) ? e2.val : e2;
					if(this.__symbol.className != null) {
						(lime_utils_Log().default).warn("Unable to evaluate frame script source for symbol \"" + this.__symbol.className + "\" frame " + frame + "\n" + frameData.scriptSource,{ fileName : "../src/openfl/display/MovieClip.hx", lineNumber : 675, className : "openfl.display.MovieClip", methodName : "__fromSymbol"});
					} else {
						(lime_utils_Log().default).warn("Unable to evaluate frame script source:\n" + frameData.scriptSource,{ fileName : "../src/openfl/display/MovieClip.hx", lineNumber : 680, className : "openfl.display.MovieClip", methodName : "__fromSymbol"});
					}
				}
			}
		}
		var frame1;
		var frameData1;
		var instance;
		var duplicate;
		var symbol1;
		var displayObject;
		var _g21 = 0;
		var _g3 = this.__totalFrames;
		while(_g21 < _g3) {
			var i2 = _g21++;
			frame1 = i2 + 1;
			frameData1 = this.__symbol.frames[i2];
			if(frameData1.objects == null) {
				continue;
			}
			var _g22 = 0;
			var _g31 = frameData1.objects;
			while(_g22 < _g31.length) {
				var frameObject = _g31[_g22];
				++_g22;
				if(frameObject.type == (openfl__$internal_symbols_timeline_FrameObjectType().default).CREATE) {
					if(this.__activeInstancesByFrameObjectID.exists(frameObject.id)) {
						continue;
					} else {
						instance = null;
						duplicate = false;
						var _g23 = 0;
						var _g32 = this.__activeInstances;
						while(_g23 < _g32.length) {
							var activeInstance = _g32[_g23];
							++_g23;
							if(activeInstance.displayObject != null && activeInstance.characterID == frameObject.symbol && activeInstance.depth == frameObject.depth) {
								instance = activeInstance;
								duplicate = true;
								break;
							}
						}
					}
					if(instance == null) {
						symbol1 = this.__swf.symbols.get(frameObject.symbol);
						if(symbol1 != null) {
							displayObject = symbol1.__createObject(this.__swf);
							if(displayObject != null) {
								displayObject.parent = this;
								displayObject.stage = this.stage;
								if(this.stage != null) {
									displayObject.dispatchEvent(new (openfl_events_Event().default)("addedToStage",false,false));
								}
								instance = new (openfl_display__$MovieClip_FrameSymbolInstance().default)(frame1,frameObject.id,frameObject.symbol,frameObject.depth,displayObject,frameObject.clipDepth);
							}
						}
					}
					if(instance != null) {
						this.__activeInstancesByFrameObjectID.set(frameObject.id,instance);
						if(!duplicate) {
							this.__activeInstances.push(instance);
							this.__updateDisplayObject(instance.displayObject,frameObject);
						}
					}
				}
			}
		}
		if(this.__totalFrames > 1) {
			this.play();
		}
		this.__enterFrame(0);
	},
	__getNextFrame: function(deltaTime) {
		var nextFrame = 0;
		if(!MovieClip.__useParentFPS) {
			this.__timeElapsed += deltaTime;
			nextFrame = this.__currentFrame + Math.floor(this.__timeElapsed / this.__frameTime);
			if(nextFrame < 1) {
				nextFrame = 1;
			}
			if(nextFrame > this.__totalFrames) {
				nextFrame = Math.floor((nextFrame - 1) % this.__totalFrames) + 1;
			}
			this.__timeElapsed %= this.__frameTime;
		} else {
			nextFrame = this.__currentFrame + 1;
			if(nextFrame > this.__totalFrames) {
				nextFrame = 1;
			}
		}
		return nextFrame;
	},
	__goto: function(frame) {
		if(this.__symbol == null) {
			return;
		}
		if(frame < 1) {
			frame = 1;
		} else if(frame > this.__totalFrames) {
			frame = this.__totalFrames;
		}
		this.__currentFrame = frame;
		this.__enterFrame(0);
	},
	__resolveFrameReference: function(frame) {
		if(typeof(frame) == "number" && ((frame | 0) === frame)) {
			return frame;
		} else if(typeof(frame) == "string") {
			var label = frame;
			var _g = 0;
			var _g1 = this.__currentLabels;
			while(_g < _g1.length) {
				var frameLabel = _g1[_g];
				++_g;
				if(frameLabel.get_name() == label) {
					return frameLabel.get_frame();
				}
			}
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_ArgumentError().default)("Error #2109: Frame label " + label + " not found in scene."));
		} else {
			throw new (js__$Boot_HaxeError().default)("Invalid type for frame " + (Type().default).getClassName(frame));
		}
	},
	__sortDepths: function(a,b) {
		return a.depth - b.depth;
	},
	__stopAllMovieClips: function() {
		(openfl_display_Sprite().default).prototype.__stopAllMovieClips.call(this);
		this.stop();
	},
	__tabTest: function(stack) {
		if(!this.__enabled) {
			return;
		}
		(openfl_display_Sprite().default).prototype.__tabTest.call(this,stack);
	},
	__updateDisplayObject: function(displayObject,frameObject,reset) {
		if(reset == null) {
			reset = false;
		}
		if(displayObject == null) {
			return;
		}
		if(frameObject.name != null) {
			displayObject.set_name(frameObject.name);
		}
		if(frameObject.matrix != null) {
			displayObject.get_transform().set_matrix(frameObject.matrix);
		}
		if(frameObject.colorTransform != null) {
			displayObject.get_transform().set_colorTransform(frameObject.colorTransform);
		} else if(reset && !displayObject.get_transform().get_colorTransform().__isDefault(true)) {
			displayObject.get_transform().set_colorTransform(new (openfl_geom_ColorTransform().default)());
		}
		if(frameObject.filters != null) {
			var filters = [];
			var _g = 0;
			var _g1 = frameObject.filters;
			while(_g < _g1.length) {
				var filter = _g1[_g];
				++_g;
				switch(filter._hx_index) {
				case 0:
					var quality = filter.quality;
					var blurY = filter.blurY;
					var blurX = filter.blurX;
					filters.push(new (openfl_filters_BlurFilter().default)(blurX,blurY,quality));
					break;
				case 1:
					var matrix = filter.matrix;
					filters.push(new (openfl_filters_ColorMatrixFilter().default)(matrix));
					break;
				case 2:
					var hideObject = filter.hideObject;
					var knockout = filter.knockout;
					var inner = filter.inner;
					var quality1 = filter.quality;
					var strength = filter.strength;
					var blurY1 = filter.blurY;
					var blurX1 = filter.blurX;
					var alpha = filter.alpha;
					var color = filter.color;
					var angle = filter.angle;
					var distance = filter.distance;
					filters.push(new (openfl_filters_DropShadowFilter().default)(distance,angle,color,alpha,blurX1,blurY1,strength,quality1,inner,knockout,hideObject));
					break;
				case 3:
					var knockout1 = filter.knockout;
					var inner1 = filter.inner;
					var quality2 = filter.quality;
					var strength1 = filter.strength;
					var blurY2 = filter.blurY;
					var blurX2 = filter.blurX;
					var alpha1 = filter.alpha;
					var color1 = filter.color;
					filters.push(new (openfl_filters_GlowFilter().default)(color1,alpha1,blurX2,blurY2,strength1,quality2,inner1,knockout1));
					break;
				}
			}
			displayObject.set_filters(filters);
		} else {
			displayObject.set_filters(null);
		}
		if(frameObject.visible != null) {
			displayObject.set_visible(frameObject.visible);
		}
		if(frameObject.blendMode != null) {
			displayObject.set_blendMode(frameObject.blendMode);
		}
		if(frameObject.cacheAsBitmap != null) {
			displayObject.set_cacheAsBitmap(frameObject.cacheAsBitmap);
		}
		(Reflect().default).setField(this,displayObject.get_name(),displayObject);
	},
	__updateFrameLabel: function() {
		this.__currentFrameLabel = this.__symbol.frames[this.__currentFrame - 1].label;
		if(this.__currentFrameLabel != null) {
			this.__currentLabel = this.__currentFrameLabel;
		} else {
			this.__currentLabel = null;
			var _g = 0;
			var _g1 = this.__currentLabels;
			while(_g < _g1.length) {
				var label = _g1[_g];
				++_g;
				if(label.get_frame() < this.__currentFrame) {
					this.__currentLabel = label.get_name();
				} else {
					break;
				}
			}
		}
	},
	__updateInstanceFields: function() {
		var _g = 0;
		var _g1 = this.__instanceFields;
		while(_g < _g1.length) {
			var field = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g11 = this.__children;
			while(_g2 < _g11.length) {
				var child = _g11[_g2];
				++_g2;
				if(child.get_name() == field) {
					(Reflect().default).setField(this,field,child);
					break;
				}
			}
		}
	},
	__onMouseDown: function(event) {
		if(this.__enabled && this.__hasDown) {
			this.gotoAndStop("_down");
		}
		this.__mouseIsDown = true;
		this.stage.addEventListener("mouseUp",$bind(this,this.__onMouseUp),true);
	},
	__onMouseUp: function(event) {
		this.__mouseIsDown = false;
		if(this.stage != null) {
			this.stage.removeEventListener("mouseUp",$bind(this,this.__onMouseUp));
		}
		if(!this.__buttonMode) {
			return;
		}
		if(event.target == this && this.__enabled && this.__hasOver) {
			this.gotoAndStop("_over");
		} else if(this.__enabled && this.__hasUp) {
			this.gotoAndStop("_up");
		}
	},
	__onRollOut: function(event) {
		if(!this.__enabled) {
			return;
		}
		if(this.__mouseIsDown && this.__hasOver) {
			this.gotoAndStop("_over");
		} else if(this.__hasUp) {
			this.gotoAndStop("_up");
		}
	},
	__onRollOver: function(event) {
		if(this.__enabled && this.__hasOver) {
			this.gotoAndStop("_over");
		}
	},
	set_buttonMode: function(value) {
		if(this.__buttonMode != value) {
			if(value) {
				this.__hasDown = false;
				this.__hasOver = false;
				this.__hasUp = false;
				var _g = 0;
				var _g1 = this.__currentLabels;
				while(_g < _g1.length) {
					var frameLabel = _g1[_g];
					++_g;
					switch(frameLabel.get_name()) {
					case "_down":
						this.__hasDown = true;
						break;
					case "_over":
						this.__hasOver = true;
						break;
					case "_up":
						this.__hasUp = true;
						break;
					default:
					}
				}
				if(this.__hasDown || this.__hasOver || this.__hasUp) {
					this.addEventListener("rollOver",$bind(this,this.__onRollOver));
					this.addEventListener("rollOut",$bind(this,this.__onRollOut));
					this.addEventListener("mouseDown",$bind(this,this.__onMouseDown));
				}
			} else {
				this.removeEventListener("rollOver",$bind(this,this.__onRollOver));
				this.removeEventListener("rollOut",$bind(this,this.__onRollOut));
				this.removeEventListener("mouseDown",$bind(this,this.__onMouseDown));
			}
			this.__buttonMode = value;
		}
		return value;
	},
	get_currentFrame: function() {
		return this.__currentFrame;
	},
	get_currentFrameLabel: function() {
		return this.__currentFrameLabel;
	},
	get_currentLabel: function() {
		return this.__currentLabel;
	},
	get_currentLabels: function() {
		return this.__currentLabels;
	},
	get_enabled: function() {
		return this.__enabled;
	},
	set_enabled: function(value) {
		return this.__enabled = value;
	},
	get_framesLoaded: function() {
		return this.__totalFrames;
	},
	get_isPlaying: function() {
		return this.__playing;
	},
	get_totalFrames: function() {
		return this.__totalFrames;
	}
});
MovieClip.prototype.__class__ = MovieClip.prototype.constructor = $hxClasses["openfl.display.MovieClip"] = MovieClip;

// Init

{
	MovieClip.__useParentFPS = true;
	/// #if (typeof ENV === 'undefined' || (!ENV['swflite-parent-fps'] && !ENV['swf-parent-fps'])) && (typeof swf_parent_fps === 'undefined' || !swf_parent_fps) && (typeof swflite_parent_fps === 'undefined' || !swflite-parent-fps) && (typeof defines === 'undefined' || (!defines['swf-parent-fps'] && !defines['swflite-parent-fps']))
	MovieClip.__useParentFPS = false;
	/// #endif 
	Object.defineProperties(MovieClip.prototype,{ currentFrame : { get : function () { return this.get_currentFrame (); }}, currentFrameLabel : { get : function () { return this.get_currentFrameLabel (); }}, currentLabel : { get : function () { return this.get_currentLabel (); }}, currentLabels : { get : function () { return this.get_currentLabels (); }}, enabled : { get : function () { return this.get_enabled (); }, set : function (v) { return this.set_enabled (v); }}, framesLoaded : { get : function () { return this.get_framesLoaded (); }}, isPlaying : { get : function () { return this.get_isPlaying (); }}, totalFrames : { get : function () { return this.get_totalFrames (); }}});
};

// Statics




// Export

exports.default = MovieClip;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/OpenGLRenderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/OpenGLRenderer.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.OpenGLRenderer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_DisplayObjectRenderer() {return __webpack_require__(/*! ./../../openfl/display/DisplayObjectRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectRenderer.js");}
function lime_math__$Matrix4_Matrix4_$Impl_$() {return __webpack_require__(/*! ./../../lime/math/_Matrix4/Matrix4_Impl_ */ "./node_modules/openfl/lib/_gen/lime/math/_Matrix4/Matrix4_Impl_.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function openfl_display_Graphics() {return __webpack_require__(/*! ./../../openfl/display/Graphics */ "./node_modules/openfl/lib/_gen/openfl/display/Graphics.js");}
function openfl_display_CanvasRenderer() {return __webpack_require__(/*! ./../../openfl/display/CanvasRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/CanvasRenderer.js");}
function openfl_display_DisplayObjectShader() {return __webpack_require__(/*! ./../../openfl/display/DisplayObjectShader */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectShader.js");}
function openfl_display_GraphicsShader() {return __webpack_require__(/*! ./../../openfl/display/GraphicsShader */ "./node_modules/openfl/lib/_gen/openfl/display/GraphicsShader.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}
function openfl_display_Shape() {return __webpack_require__(/*! ./../../openfl/display/Shape */ "./node_modules/openfl/lib/_gen/openfl/display/Shape.js");}
function openfl__$internal_renderer_context3D_Context3DMaskShader() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DMaskShader */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DMaskShader.js");}

// Constructor

var OpenGLRenderer = function(context,defaultRenderTarget) {
	(openfl_display_DisplayObjectRenderer().default).call(this);
	this.__context3D = context;
	this.__context = context.__context;
	this.gl = context.__context.webgl;
	this.__gl = this.gl;
	this.__defaultRenderTarget = defaultRenderTarget;
	this.__flipped = this.__defaultRenderTarget == null;
	if((openfl_display_Graphics().default).maxTextureWidth == null) {
		(openfl_display_Graphics().default).maxTextureWidth = (openfl_display_Graphics().default).maxTextureHeight = this.__gl.getParameter(this.__gl.MAX_TEXTURE_SIZE);
	}
	this.__matrix = (lime_math__$Matrix4_Matrix4_$Impl_$().default)._new();
	this.__values = [];
	this.__softwareRenderer = new (openfl_display_CanvasRenderer().default)(null);
	this.__type = "opengl";
	this.__setBlendMode("normal");
	this.__context3D.__setGLBlend(true);
	this.__clipRects = [];
	this.__maskObjects = [];
	this.__numClipRects = 0;
	this.__projection = (lime_math__$Matrix4_Matrix4_$Impl_$().default)._new();
	this.__projectionFlipped = (lime_math__$Matrix4_Matrix4_$Impl_$().default)._new();
	this.__stencilReference = 0;
	this.__tempRect = new (openfl_geom_Rectangle().default)();
	this.__defaultDisplayShader = new (openfl_display_DisplayObjectShader().default)();
	this.__defaultGraphicsShader = new (openfl_display_GraphicsShader().default)();
	this.__defaultShader = this.__defaultDisplayShader;
	this.__initShader(this.__defaultShader);
	this.__scrollRectMasks = new (lime_utils_ObjectPool().default)(function() {
		return new (openfl_display_Shape().default)();
	});
	this.__maskShader = new (openfl__$internal_renderer_context3D_Context3DMaskShader().default)();
}

// Meta

OpenGLRenderer.__name__ = "openfl.display.OpenGLRenderer";
OpenGLRenderer.__isInterface__ = false;
OpenGLRenderer.__super__ = (openfl_display_DisplayObjectRenderer().default);
OpenGLRenderer.prototype = $extend((openfl_display_DisplayObjectRenderer().default).prototype, {
	applyAlpha: function(alpha) {
		OpenGLRenderer.__alphaValue[0] = alpha;
		if(this.__currentShaderBuffer != null) {
			this.__currentShaderBuffer.addFloatOverride("openfl_Alpha",OpenGLRenderer.__alphaValue);
		} else if(this.__currentShader != null) {
			if(this.__currentShader.__alpha != null) {
				this.__currentShader.__alpha.value = OpenGLRenderer.__alphaValue;
			}
		}
	},
	applyBitmapData: function(bitmapData,smooth,repeat) {
		if(repeat == null) {
			repeat = false;
		}
		if(this.__currentShaderBuffer != null) {
			if(bitmapData != null) {
				OpenGLRenderer.__textureSizeValue[0] = bitmapData.__textureWidth;
				OpenGLRenderer.__textureSizeValue[1] = bitmapData.__textureHeight;
				this.__currentShaderBuffer.addFloatOverride("openfl_TextureSize",OpenGLRenderer.__textureSizeValue);
			}
		} else if(this.__currentShader != null) {
			if(this.__currentShader.__bitmap != null) {
				this.__currentShader.__bitmap.input = bitmapData;
				this.__currentShader.__bitmap.filter = smooth && this.__allowSmoothing ? "linear" : "nearest";
				this.__currentShader.__bitmap.mipFilter = "mipnone";
				this.__currentShader.__bitmap.wrap = repeat ? "repeat" : "clamp";
			}
			if(this.__currentShader.__texture != null) {
				this.__currentShader.__texture.input = bitmapData;
				this.__currentShader.__texture.filter = smooth && this.__allowSmoothing ? "linear" : "nearest";
				this.__currentShader.__texture.mipFilter = "mipnone";
				this.__currentShader.__texture.wrap = repeat ? "repeat" : "clamp";
			}
			if(this.__currentShader.__textureSize != null) {
				if(bitmapData != null) {
					OpenGLRenderer.__textureSizeValue[0] = bitmapData.__textureWidth;
					OpenGLRenderer.__textureSizeValue[1] = bitmapData.__textureHeight;
					this.__currentShader.__textureSize.value = OpenGLRenderer.__textureSizeValue;
				} else {
					this.__currentShader.__textureSize.value = null;
				}
			}
		}
	},
	applyColorTransform: function(colorTransform) {
		var enabled = colorTransform != null && !colorTransform.__isDefault(true);
		this.applyHasColorTransform(enabled);
		if(enabled) {
			colorTransform.__setArrays(OpenGLRenderer.__colorMultipliersValue,OpenGLRenderer.__colorOffsetsValue);
			if(this.__currentShaderBuffer != null) {
				this.__currentShaderBuffer.addFloatOverride("openfl_ColorMultiplier",OpenGLRenderer.__colorMultipliersValue);
				this.__currentShaderBuffer.addFloatOverride("openfl_ColorOffset",OpenGLRenderer.__colorOffsetsValue);
			} else if(this.__currentShader != null) {
				if(this.__currentShader.__colorMultiplier != null) {
					this.__currentShader.__colorMultiplier.value = OpenGLRenderer.__colorMultipliersValue;
				}
				if(this.__currentShader.__colorOffset != null) {
					this.__currentShader.__colorOffset.value = OpenGLRenderer.__colorOffsetsValue;
				}
			}
		} else if(this.__currentShaderBuffer != null) {
			this.__currentShaderBuffer.addFloatOverride("openfl_ColorMultiplier",OpenGLRenderer.__emptyColorValue);
			this.__currentShaderBuffer.addFloatOverride("openfl_ColorOffset",OpenGLRenderer.__emptyColorValue);
		} else if(this.__currentShader != null) {
			if(this.__currentShader.__colorMultiplier != null) {
				this.__currentShader.__colorMultiplier.value = OpenGLRenderer.__emptyColorValue;
			}
			if(this.__currentShader.__colorOffset != null) {
				this.__currentShader.__colorOffset.value = OpenGLRenderer.__emptyColorValue;
			}
		}
	},
	applyHasColorTransform: function(enabled) {
		OpenGLRenderer.__hasColorTransformValue[0] = enabled;
		if(this.__currentShaderBuffer != null) {
			this.__currentShaderBuffer.addBoolOverride("openfl_HasColorTransform",OpenGLRenderer.__hasColorTransformValue);
		} else if(this.__currentShader != null) {
			if(this.__currentShader.__hasColorTransform != null) {
				this.__currentShader.__hasColorTransform.value = OpenGLRenderer.__hasColorTransformValue;
			}
		}
	},
	applyMatrix: function(matrix) {
		if(this.__currentShaderBuffer != null) {
			this.__currentShaderBuffer.addFloatOverride("openfl_Matrix",matrix);
		} else if(this.__currentShader != null) {
			if(this.__currentShader.__matrix != null) {
				this.__currentShader.__matrix.value = matrix;
			}
		}
	},
	getMatrix: function(transform) {
		if(this.gl != null) {
			var values = this.__getMatrix(transform,"auto");
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,0,values[0]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,1,values[1]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,2,values[2]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,3,values[3]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,4,values[4]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,5,values[5]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,6,values[6]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,7,values[7]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,8,values[8]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,9,values[9]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,10,values[10]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,11,values[11]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,12,values[12]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,13,values[13]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,14,values[14]);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,15,values[15]);
			return this.__matrix;
		} else {
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).identity(this.__matrix);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,0,transform.a);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,1,transform.b);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,4,transform.c);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,5,transform.d);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,12,transform.tx);
			(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,13,transform.ty);
			return this.__matrix;
		}
	},
	setShader: function(shader) {
		this.__currentShaderBuffer = null;
		if(this.__currentShader == shader) {
			return;
		}
		var tmp = this.__currentShader != null;
		if(shader == null) {
			this.__currentShader = null;
			this.__context3D.setProgram(null);
			return;
		} else {
			this.__currentShader = shader;
			this.__initShader(shader);
			this.__context3D.setProgram(shader.program);
			this.__context3D.__flushGLProgram();
			this.__currentShader.__enable();
			this.__context3D.__state.shader = shader;
		}
	},
	setViewport: function() {
		this.__gl.viewport(this.__offsetX,this.__offsetY,this.__displayWidth,this.__displayHeight);
	},
	updateShader: function() {
		if(this.__currentShader != null) {
			if(this.__currentShader.__position != null) {
				this.__currentShader.__position.__useArray = true;
			}
			if(this.__currentShader.__textureCoord != null) {
				this.__currentShader.__textureCoord.__useArray = true;
			}
			this.__context3D.setProgram(this.__currentShader.program);
			this.__context3D.__flushGLProgram();
			this.__context3D.__flushGLTextures();
			this.__currentShader.__update();
		}
	},
	useAlphaArray: function() {
		if(this.__currentShader != null) {
			if(this.__currentShader.__alpha != null) {
				this.__currentShader.__alpha.__useArray = true;
			}
		}
	},
	useColorTransformArray: function() {
		if(this.__currentShader != null) {
			if(this.__currentShader.__colorMultiplier != null) {
				this.__currentShader.__colorMultiplier.__useArray = true;
			}
			if(this.__currentShader.__colorOffset != null) {
				this.__currentShader.__colorOffset.__useArray = true;
			}
		}
	},
	__cleanup: function() {
		if(this.__stencilReference > 0) {
			this.__stencilReference = 0;
			this.__context3D.setStencilActions();
			this.__context3D.setStencilReferenceValue(0,0,0);
		}
		if(this.__numClipRects > 0) {
			this.__numClipRects = 0;
			this.__scissorRect();
		}
	},
	__clear: function() {
		if(this.__stage == null || this.__stage.__transparent) {
			this.__context3D.clear(0,0,0,0,0,0,1);
		} else {
			this.__context3D.clear(this.__stage.__colorSplit[0],this.__stage.__colorSplit[1],this.__stage.__colorSplit[2],1,0,0,1);
		}
		this.__cleared = true;
	},
	__clearShader: function() {
		if(this.__currentShader != null) {
			if(this.__currentShaderBuffer == null) {
				if(this.__currentShader.__bitmap != null) {
					this.__currentShader.__bitmap.input = null;
				}
			} else {
				this.__currentShaderBuffer.clearOverride();
			}
			if(this.__currentShader.__texture != null) {
				this.__currentShader.__texture.input = null;
			}
			if(this.__currentShader.__textureSize != null) {
				this.__currentShader.__textureSize.value = null;
			}
			if(this.__currentShader.__hasColorTransform != null) {
				this.__currentShader.__hasColorTransform.value = null;
			}
			if(this.__currentShader.__position != null) {
				this.__currentShader.__position.value = null;
			}
			if(this.__currentShader.__matrix != null) {
				this.__currentShader.__matrix.value = null;
			}
			this.__currentShader.__clearUseArray();
		}
	},
	__copyShader: function(other) {
		this.__currentShader = other.__currentShader;
		this.__currentShaderBuffer = other.__currentShaderBuffer;
		this.__currentDisplayShader = other.__currentDisplayShader;
		this.__currentGraphicsShader = other.__currentGraphicsShader;
	},
	__getMatrix: function(transform,pixelSnapping) {
		var _matrix = (openfl_geom_Matrix().default).__pool.get();
		_matrix.copyFrom(transform);
		_matrix.concat(this.__worldTransform);
		if(pixelSnapping == "always" || pixelSnapping == "auto" && _matrix.b == 0 && _matrix.c == 0 && (_matrix.a < 1.001 && _matrix.a > 0.999) && (_matrix.d < 1.001 && _matrix.d > 0.999)) {
			_matrix.tx = Math.round(_matrix.tx);
			_matrix.ty = Math.round(_matrix.ty);
		}
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).identity(this.__matrix);
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,0,_matrix.a);
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,1,_matrix.b);
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,4,_matrix.c);
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,5,_matrix.d);
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,12,_matrix.tx);
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).set(this.__matrix,13,_matrix.ty);
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).append(this.__matrix,this.__flipped ? this.__projectionFlipped : this.__projection);
		this.__values[0] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,0);
		this.__values[1] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,1);
		this.__values[2] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,2);
		this.__values[3] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,3);
		this.__values[4] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,4);
		this.__values[5] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,5);
		this.__values[6] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,6);
		this.__values[7] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,7);
		this.__values[8] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,8);
		this.__values[9] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,9);
		this.__values[10] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,10);
		this.__values[11] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,11);
		this.__values[12] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,12);
		this.__values[13] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,13);
		this.__values[14] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,14);
		this.__values[15] = (lime_math__$Matrix4_Matrix4_$Impl_$().default).get(this.__matrix,15);
		(openfl_geom_Matrix().default).__pool.release(_matrix);
		return this.__values;
	},
	__initShader: function(shader) {
		if(shader != null) {
			if(shader.__context == null) {
				shader.__context = this.__context3D;
				shader.__init();
			}
			return shader;
		}
		return this.__defaultShader;
	},
	__initDisplayShader: function(shader) {
		if(shader != null) {
			if(shader.__context == null) {
				shader.__context = this.__context3D;
				shader.__init();
			}
			return shader;
		}
		return this.__defaultDisplayShader;
	},
	__initGraphicsShader: function(shader) {
		if(shader != null) {
			if(shader.__context == null) {
				shader.__context = this.__context3D;
				shader.__init();
			}
			return shader;
		}
		return this.__defaultGraphicsShader;
	},
	__initShaderBuffer: function(shaderBuffer) {
		if(shaderBuffer != null) {
			return this.__initGraphicsShader(shaderBuffer.shader);
		}
		return this.__defaultGraphicsShader;
	},
	__popMask: function() {
		if(this.__stencilReference == 0) {
			return;
		}
		var mask = this.__maskObjects.pop();
		if(this.__stencilReference > 1) {
			this.__context3D.setStencilActions("frontAndBack","equal","decrementSaturate","decrementSaturate","keep");
			this.__context3D.setStencilReferenceValue(this.__stencilReference,255,255);
			this.__context3D.setColorMask(false,false,false,false);
			mask.__renderGLMask(this);
			this.__stencilReference--;
			this.__context3D.setStencilActions("frontAndBack","equal","keep","keep","keep");
			this.__context3D.setStencilReferenceValue(this.__stencilReference,255,0);
			this.__context3D.setColorMask(true,true,true,true);
		} else {
			this.__stencilReference = 0;
			this.__context3D.setStencilActions();
			this.__context3D.setStencilReferenceValue(0,0,0);
		}
	},
	__popMaskObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
		if(object.__mask != null) {
			this.__popMask();
		}
		if(handleScrollRect && object.__scrollRect != null) {
			if(object.__renderTransform.b != 0 || object.__renderTransform.c != 0) {
				this.__scrollRectMasks.release(this.__maskObjects[this.__maskObjects.length - 1]);
				this.__popMask();
			} else {
				this.__popMaskRect();
			}
		}
	},
	__popMaskRect: function() {
		if(this.__numClipRects > 0) {
			this.__numClipRects--;
			if(this.__numClipRects > 0) {
				this.__scissorRect(this.__clipRects[this.__numClipRects - 1]);
			} else {
				this.__scissorRect();
			}
		}
	},
	__pushMask: function(mask) {
		if(this.__stencilReference == 0) {
			this.__context3D.clear(0,0,0,0,0,0,4);
			this.__updatedStencil = true;
		}
		this.__context3D.setStencilActions("frontAndBack","equal","incrementSaturate","keep","keep");
		this.__context3D.setStencilReferenceValue(this.__stencilReference,255,255);
		this.__context3D.setColorMask(false,false,false,false);
		mask.__renderGLMask(this);
		this.__maskObjects.push(mask);
		this.__stencilReference++;
		this.__context3D.setStencilActions("frontAndBack","equal","keep","keep","keep");
		this.__context3D.setStencilReferenceValue(this.__stencilReference,255,0);
		this.__context3D.setColorMask(true,true,true,true);
	},
	__pushMaskObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
		if(handleScrollRect && object.__scrollRect != null) {
			if(object.__renderTransform.b != 0 || object.__renderTransform.c != 0) {
				var shape = this.__scrollRectMasks.get();
				shape.get_graphics().clear();
				shape.get_graphics().beginFill(65280);
				shape.get_graphics().drawRect(object.__scrollRect.x,object.__scrollRect.y,object.__scrollRect.width,object.__scrollRect.height);
				shape.__renderTransform.copyFrom(object.__renderTransform);
				this.__pushMask(shape);
			} else {
				this.__pushMaskRect(object.__scrollRect,object.__renderTransform);
			}
		}
		if(object.__mask != null) {
			this.__pushMask(object.__mask);
		}
	},
	__pushMaskRect: function(rect,transform) {
		if(this.__numClipRects == this.__clipRects.length) {
			this.__clipRects[this.__numClipRects] = new (openfl_geom_Rectangle().default)();
		}
		var _matrix = (openfl_geom_Matrix().default).__pool.get();
		_matrix.copyFrom(transform);
		_matrix.concat(this.__worldTransform);
		var clipRect = this.__clipRects[this.__numClipRects];
		rect.__transform(clipRect,_matrix);
		if(this.__numClipRects > 0) {
			var parentClipRect = this.__clipRects[this.__numClipRects - 1];
			clipRect.__contract(parentClipRect.x,parentClipRect.y,parentClipRect.width,parentClipRect.height);
		}
		if(clipRect.height < 0) {
			clipRect.height = 0;
		}
		if(clipRect.width < 0) {
			clipRect.width = 0;
		}
		(openfl_geom_Matrix().default).__pool.release(_matrix);
		this.__scissorRect(clipRect);
		this.__numClipRects++;
	},
	__render: function(object) {
		this.__context3D.setColorMask(true,true,true,true);
		this.__context3D.setCulling("none");
		this.__context3D.setDepthTest(false,"always");
		this.__context3D.setStencilActions();
		this.__context3D.setStencilReferenceValue(0,0,0);
		this.__context3D.setScissorRectangle(null);
		this.__blendMode = null;
		this.__setBlendMode("normal");
		if(this.__defaultRenderTarget == null) {
			OpenGLRenderer.__scissorRectangle.setTo(this.__offsetX,this.__offsetY,this.__displayWidth,this.__displayHeight);
			this.__context3D.setScissorRectangle(OpenGLRenderer.__scissorRectangle);
			this.__upscaled = this.__worldTransform.a != 1 || this.__worldTransform.d != 1;
			object.__renderGL(this);
			if(this.__offsetX > 0 || this.__offsetY > 0) {
				if(this.__offsetX > 0) {
					OpenGLRenderer.__scissorRectangle.setTo(0,0,this.__offsetX,this.__height);
					this.__context3D.setScissorRectangle(OpenGLRenderer.__scissorRectangle);
					this.__context3D.__flushGL();
					this.__gl.clearColor(0,0,0,1);
					this.__gl.clear(this.__gl.COLOR_BUFFER_BIT);
					OpenGLRenderer.__scissorRectangle.setTo(this.__offsetX + this.__displayWidth,0,this.__width,this.__height);
					this.__context3D.setScissorRectangle(OpenGLRenderer.__scissorRectangle);
					this.__context3D.__flushGL();
					this.__gl.clearColor(0,0,0,1);
					this.__gl.clear(this.__gl.COLOR_BUFFER_BIT);
				}
				if(this.__offsetY > 0) {
					OpenGLRenderer.__scissorRectangle.setTo(0,0,this.__width,this.__offsetY);
					this.__context3D.setScissorRectangle(OpenGLRenderer.__scissorRectangle);
					this.__context3D.__flushGL();
					this.__gl.clearColor(0,0,0,1);
					this.__gl.clear(this.__gl.COLOR_BUFFER_BIT);
					OpenGLRenderer.__scissorRectangle.setTo(0,this.__offsetY + this.__displayHeight,this.__width,this.__height);
					this.__context3D.setScissorRectangle(OpenGLRenderer.__scissorRectangle);
					this.__context3D.__flushGL();
					this.__gl.clearColor(0,0,0,1);
					this.__gl.clear(this.__gl.COLOR_BUFFER_BIT);
				}
				this.__context3D.setScissorRectangle(null);
			}
		} else {
			OpenGLRenderer.__scissorRectangle.setTo(this.__offsetX,this.__offsetY,this.__displayWidth,this.__displayHeight);
			this.__context3D.setScissorRectangle(OpenGLRenderer.__scissorRectangle);
			var cacheMask = object.__mask;
			var cacheScrollRect = object.__scrollRect;
			object.__mask = null;
			object.__scrollRect = null;
			object.__renderGL(this);
			object.__mask = cacheMask;
			object.__scrollRect = cacheScrollRect;
		}
		this.__context3D.present();
	},
	__renderFilterPass: function(source,shader,smooth,clear) {
		if(clear == null) {
			clear = true;
		}
		if(source == null || shader == null) {
			return;
		}
		if(this.__defaultRenderTarget == null) {
			return;
		}
		var cacheRTT = this.__context3D.__state.renderToTexture;
		var cacheRTTDepthStencil = this.__context3D.__state.renderToTextureDepthStencil;
		var cacheRTTAntiAlias = this.__context3D.__state.renderToTextureAntiAlias;
		var cacheRTTSurfaceSelector = this.__context3D.__state.renderToTextureSurfaceSelector;
		this.__context3D.setRenderToTexture(this.__defaultRenderTarget.getTexture(this.__context3D),false);
		if(clear) {
			this.__context3D.clear(0,0,0,0,0,0,1);
		}
		var shader1 = this.__initShader(shader);
		this.setShader(shader1);
		this.applyAlpha(1);
		this.applyBitmapData(source,smooth);
		this.applyColorTransform(null);
		this.applyMatrix(this.__getMatrix(source.__renderTransform,"auto"));
		this.updateShader();
		var vertexBuffer = source.getVertexBuffer(this.__context3D);
		if(shader1.__position != null) {
			this.__context3D.setVertexBufferAt(shader1.__position.index,vertexBuffer,0,"float3");
		}
		if(shader1.__textureCoord != null) {
			this.__context3D.setVertexBufferAt(shader1.__textureCoord.index,vertexBuffer,3,"float2");
		}
		var indexBuffer = source.getIndexBuffer(this.__context3D);
		this.__context3D.drawTriangles(indexBuffer);
		if(cacheRTT != null) {
			this.__context3D.setRenderToTexture(cacheRTT,cacheRTTDepthStencil,cacheRTTAntiAlias,cacheRTTSurfaceSelector);
		} else {
			this.__context3D.setRenderToBackBuffer();
		}
		this.__clearShader();
	},
	__resize: function(width,height) {
		this.__width = width;
		this.__height = height;
		var w = this.__defaultRenderTarget == null ? this.__stage.stageWidth : this.__defaultRenderTarget.width;
		var h = this.__defaultRenderTarget == null ? this.__stage.stageHeight : this.__defaultRenderTarget.height;
		this.__offsetX = this.__defaultRenderTarget == null ? Math.round(this.__worldTransform.__transformX(0,0)) : 0;
		this.__offsetY = this.__defaultRenderTarget == null ? Math.round(this.__worldTransform.__transformY(0,0)) : 0;
		this.__displayWidth = this.__defaultRenderTarget == null ? Math.round(this.__worldTransform.__transformX(w,0) - this.__offsetX) : w;
		this.__displayHeight = this.__defaultRenderTarget == null ? Math.round(this.__worldTransform.__transformY(0,h) - this.__offsetY) : h;
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).createOrtho(this.__projection,0,this.__displayWidth + this.__offsetX * 2,0,this.__displayHeight + this.__offsetY * 2,-1000,1000);
		(lime_math__$Matrix4_Matrix4_$Impl_$().default).createOrtho(this.__projectionFlipped,0,this.__displayWidth + this.__offsetX * 2,this.__displayHeight + this.__offsetY * 2,0,-1000,1000);
	},
	__resumeClipAndMask: function(childRenderer) {
		if(this.__stencilReference > 0) {
			this.__context3D.setStencilActions("frontAndBack","equal","keep","keep","keep");
			this.__context3D.setStencilReferenceValue(this.__stencilReference,255,0);
		} else {
			this.__context3D.setStencilActions();
			this.__context3D.setStencilReferenceValue(0,0,0);
		}
		if(this.__numClipRects > 0) {
			this.__scissorRect(this.__clipRects[this.__numClipRects - 1]);
		} else {
			this.__scissorRect();
		}
	},
	__scissorRect: function(clipRect) {
		if(clipRect != null) {
			var x = Math.floor(clipRect.x);
			var y = Math.floor(clipRect.y);
			var width = clipRect.width > 0 ? Math.ceil(clipRect.get_right()) - x : 0;
			var height = clipRect.height > 0 ? Math.ceil(clipRect.get_bottom()) - y : 0;
			if(width < 0) {
				width = 0;
			}
			if(height < 0) {
				height = 0;
			}
			OpenGLRenderer.__scissorRectangle.setTo(x,y,width,height);
			this.__context3D.setScissorRectangle(OpenGLRenderer.__scissorRectangle);
		} else {
			this.__context3D.setScissorRectangle(null);
		}
	},
	__setBlendMode: function(value) {
		if(this.__overrideBlendMode != null) {
			value = this.__overrideBlendMode;
		}
		if(this.__blendMode == value) {
			return;
		}
		this.__blendMode = value;
		switch(value) {
		case "add":
			this.__context3D.setBlendFactors("one","one");
			break;
		case "multiply":
			this.__context3D.setBlendFactors("destinationColor","oneMinusSourceAlpha");
			break;
		case "screen":
			this.__context3D.setBlendFactors("one","oneMinusSourceColor");
			break;
		case "subtract":
			this.__context3D.setBlendFactors("one","one");
			this.__context3D.__setGLBlendEquation(this.__gl.FUNC_REVERSE_SUBTRACT);
			break;
		default:
			this.__context3D.setBlendFactors("one","oneMinusSourceAlpha");
		}
	},
	__setRenderTarget: function(renderTarget) {
		this.__defaultRenderTarget = renderTarget;
		this.__flipped = renderTarget == null;
		if(renderTarget != null) {
			this.__resize(renderTarget.width,renderTarget.height);
		}
	},
	__setShaderBuffer: function(shaderBuffer) {
		this.setShader(shaderBuffer.shader);
		this.__currentShaderBuffer = shaderBuffer;
	},
	__suspendClipAndMask: function() {
		if(this.__stencilReference > 0) {
			this.__context3D.setStencilActions();
			this.__context3D.setStencilReferenceValue(0,0,0);
		}
		if(this.__numClipRects > 0) {
			this.__scissorRect();
		}
	},
	__updateShaderBuffer: function(bufferOffset) {
		if(this.__currentShader != null && this.__currentShaderBuffer != null) {
			this.__currentShader.__updateFromBuffer(this.__currentShaderBuffer,bufferOffset);
		}
	}
});
OpenGLRenderer.prototype.__class__ = OpenGLRenderer.prototype.constructor = $hxClasses["openfl.display.OpenGLRenderer"] = OpenGLRenderer;

// Init



// Statics


OpenGLRenderer.__meta__ = { fields : { gl : { SuppressWarnings : ["checkstyle:Dynamic"]}, __gl : { SuppressWarnings : ["checkstyle:Dynamic"]}, __matrix : { SuppressWarnings : ["checkstyle:Dynamic"]}, __projection : { SuppressWarnings : ["checkstyle:Dynamic"]}, __projectionFlipped : { SuppressWarnings : ["checkstyle:Dynamic"]}, getMatrix : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
OpenGLRenderer.__alphaValue = [1]
OpenGLRenderer.__colorMultipliersValue = [0,0,0,0]
OpenGLRenderer.__colorOffsetsValue = [0,0,0,0]
OpenGLRenderer.__defaultColorMultipliersValue = [1,1,1,1]
OpenGLRenderer.__emptyColorValue = [0,0,0,0]
OpenGLRenderer.__emptyAlphaValue = [1]
OpenGLRenderer.__hasColorTransformValue = [false]
OpenGLRenderer.__scissorRectangle = new (openfl_geom_Rectangle().default)()
OpenGLRenderer.__textureSizeValue = [0,0]

// Export

exports.default = OpenGLRenderer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/PNGEncoderOptions.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/PNGEncoderOptions.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.PNGEncoderOptions

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var PNGEncoderOptions = function(fastCompression) {
	if(fastCompression == null) {
		fastCompression = false;
	}
	this.fastCompression = fastCompression;
}

// Meta

PNGEncoderOptions.__name__ = "openfl.display.PNGEncoderOptions";
PNGEncoderOptions.__isInterface__ = false;
PNGEncoderOptions.prototype = {
	
};
PNGEncoderOptions.prototype.__class__ = PNGEncoderOptions.prototype.constructor = $hxClasses["openfl.display.PNGEncoderOptions"] = PNGEncoderOptions;

// Init



// Statics




// Export

exports.default = PNGEncoderOptions;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Shader.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Shader.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Shader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function openfl_display__$ShaderData_ShaderData_$Impl_$() {return __webpack_require__(/*! ./../../openfl/display/_ShaderData/ShaderData_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/display/_ShaderData/ShaderData_Impl_.js");}
function EReg() {return __webpack_require__(/*! ./../../EReg */ "./node_modules/openfl/lib/_gen/EReg.js");}
function openfl_display_ShaderInput() {return __webpack_require__(/*! ./../../openfl/display/ShaderInput */ "./node_modules/openfl/lib/_gen/openfl/display/ShaderInput.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function openfl_display_ShaderParameter() {return __webpack_require__(/*! ./../../openfl/display/ShaderParameter */ "./node_modules/openfl/lib/_gen/openfl/display/ShaderParameter.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}

// Constructor

var Shader = function(code) {
	this.byteCode = code;
	this.precisionHint = "full";
	this.__glSourceDirty = true;
	this.__numPasses = 1;
	this.__data = (openfl_display__$ShaderData_ShaderData_$Impl_$().default)._new(code);
}

// Meta

Shader.__name__ = "openfl.display.Shader";
Shader.__isInterface__ = false;
Shader.prototype = {
	__clearUseArray: function() {
		var _g = 0;
		var _g1 = this.__paramBool;
		while(_g < _g1.length) {
			var parameter = _g1[_g];
			++_g;
			parameter.__useArray = false;
		}
		var _g2 = 0;
		var _g3 = this.__paramFloat;
		while(_g2 < _g3.length) {
			var parameter1 = _g3[_g2];
			++_g2;
			parameter1.__useArray = false;
		}
		var _g4 = 0;
		var _g5 = this.__paramInt;
		while(_g4 < _g5.length) {
			var parameter2 = _g5[_g4];
			++_g4;
			parameter2.__useArray = false;
		}
	},
	__createGLShader: function(source,type) {
		var gl = this.__context.gl;
		var shader = gl.createShader(type);
		gl.shaderSource(shader,source);
		gl.compileShader(shader);
		if(gl.getShaderParameter(shader,gl.COMPILE_STATUS) == 0) {
			var message = type == gl.VERTEX_SHADER ? "Error compiling vertex shader" : "Error compiling fragment shader";
			message += "\n" + gl.getShaderInfoLog(shader);
			message += "\n" + source;
			(lime_utils_Log().default).error(message,{ fileName : "../src/openfl/display/Shader.hx", lineNumber : 328, className : "openfl.display.Shader", methodName : "__createGLShader"});
		}
		return shader;
	},
	__createGLProgram: function(vertexSource,fragmentSource) {
		var gl = this.__context.gl;
		var vertexShader = this.__createGLShader(vertexSource,gl.VERTEX_SHADER);
		var fragmentShader = this.__createGLShader(fragmentSource,gl.FRAGMENT_SHADER);
		var program = gl.createProgram();
		var _g = 0;
		var _g1 = this.__paramFloat;
		while(_g < _g1.length) {
			var param = _g1[_g];
			++_g;
			if(param.name.indexOf("Position") > -1 && (StringTools().default).startsWith(param.name,"openfl_")) {
				gl.bindAttribLocation(program,0,param.name);
				break;
			}
		}
		gl.attachShader(program,vertexShader);
		gl.attachShader(program,fragmentShader);
		gl.linkProgram(program);
		if(gl.getProgramParameter(program,gl.LINK_STATUS) == 0) {
			var message = "Unable to initialize the shader program";
			message += "\n" + gl.getProgramInfoLog(program);
			(lime_utils_Log().default).error(message,{ fileName : "../src/openfl/display/Shader.hx", lineNumber : 361, className : "openfl.display.Shader", methodName : "__createGLProgram"});
		}
		return program;
	},
	__disable: function() {
		if(this.program != null) {
			this.__disableGL();
		}
	},
	__disableGL: function() {
		var gl = this.__context.gl;
		var textureCount = 0;
		var _g = 0;
		var _g1 = this.__inputBitmapData;
		while(_g < _g1.length) {
			var input = _g1[_g];
			++_g;
			input.__disableGL(this.__context,textureCount);
			++textureCount;
		}
		var _g2 = 0;
		var _g3 = this.__paramBool;
		while(_g2 < _g3.length) {
			var parameter = _g3[_g2];
			++_g2;
			parameter.__disableGL(this.__context);
		}
		var _g4 = 0;
		var _g5 = this.__paramFloat;
		while(_g4 < _g5.length) {
			var parameter1 = _g5[_g4];
			++_g4;
			parameter1.__disableGL(this.__context);
		}
		var _g6 = 0;
		var _g7 = this.__paramInt;
		while(_g6 < _g7.length) {
			var parameter2 = _g7[_g6];
			++_g6;
			parameter2.__disableGL(this.__context);
		}
		this.__context.__bindGLArrayBuffer(null);
		if(this.__context.__context.type == "opengl") {
			gl.disable(gl.TEXTURE_2D);
		}
	},
	__enable: function() {
		this.__init();
		if(this.program != null) {
			this.__enableGL();
		}
	},
	__enableGL: function() {
		var textureCount = 0;
		var gl = this.__context.gl;
		var _g = 0;
		var _g1 = this.__inputBitmapData;
		while(_g < _g1.length) {
			var input = _g1[_g];
			++_g;
			gl.uniform1i(input.index,textureCount);
			++textureCount;
		}
		if(this.__context.__context.type == "opengl" && textureCount > 0) {
			gl.enable(gl.TEXTURE_2D);
		}
	},
	__init: function() {
		if(this.__data == null) {
			this.__data = (openfl_display__$ShaderData_ShaderData_$Impl_$().default)._new(null);
		}
		if(this.__glFragmentSource != null && this.__glVertexSource != null && (this.program == null || this.__glSourceDirty)) {
			this.__initGL();
		}
	},
	__initGL: function() {
		if(this.__glSourceDirty || this.__paramBool == null) {
			this.__glSourceDirty = false;
			this.program = null;
			this.__inputBitmapData = [];
			this.__paramBool = [];
			this.__paramFloat = [];
			this.__paramInt = [];
			this.__processGLData(this.get_glVertexSource(),"attribute");
			this.__processGLData(this.get_glVertexSource(),"uniform");
			this.__processGLData(this.get_glFragmentSource(),"uniform");
		}
		if(this.__context != null && this.program == null) {
			var gl = this.__context.gl;
			var prefix = "#ifdef GL_ES\n\t\t\t\t" + (this.precisionHint == "full" ? "#ifdef GL_FRAGMENT_PRECISION_HIGH\n\t\t\t\tprecision highp float;\n\t\t\t\t#else\n\t\t\t\tprecision mediump float;\n\t\t\t\t#endif" : "precision lowp float;") + "\n\t\t\t\t#endif\n\t\t\t\t";
			var vertex = prefix + this.get_glVertexSource();
			var fragment = prefix + this.get_glFragmentSource();
			var id = vertex + fragment;
			if(this.__context.__programs.exists(id)) {
				this.program = this.__context.__programs.get(id);
			} else {
				this.program = this.__context.createProgram("glsl");
				this.program.__glProgram = this.__createGLProgram(vertex,fragment);
				this.__context.__programs.set(id,this.program);
			}
			if(this.program != null) {
				this.glProgram = this.program.__glProgram;
				var _g = 0;
				var _g1 = this.__inputBitmapData;
				while(_g < _g1.length) {
					var input = _g1[_g];
					++_g;
					if(input.__isUniform) {
						input.index = gl.getUniformLocation(this.glProgram,input.name);
					} else {
						input.index = gl.getAttribLocation(this.glProgram,input.name);
					}
				}
				var _g2 = 0;
				var _g3 = this.__paramBool;
				while(_g2 < _g3.length) {
					var parameter = _g3[_g2];
					++_g2;
					if(parameter.__isUniform) {
						parameter.index = gl.getUniformLocation(this.glProgram,parameter.name);
					} else {
						parameter.index = gl.getAttribLocation(this.glProgram,parameter.name);
					}
				}
				var _g4 = 0;
				var _g5 = this.__paramFloat;
				while(_g4 < _g5.length) {
					var parameter1 = _g5[_g4];
					++_g4;
					if(parameter1.__isUniform) {
						parameter1.index = gl.getUniformLocation(this.glProgram,parameter1.name);
					} else {
						parameter1.index = gl.getAttribLocation(this.glProgram,parameter1.name);
					}
				}
				var _g6 = 0;
				var _g7 = this.__paramInt;
				while(_g6 < _g7.length) {
					var parameter2 = _g7[_g6];
					++_g6;
					if(parameter2.__isUniform) {
						parameter2.index = gl.getUniformLocation(this.glProgram,parameter2.name);
					} else {
						parameter2.index = gl.getAttribLocation(this.glProgram,parameter2.name);
					}
				}
			}
		}
	},
	__processGLData: function(source,storageType) {
		var lastMatch = 0;
		var position;
		var regex;
		var name;
		var type;
		if(storageType == "uniform") {
			regex = new (EReg().default)("uniform ([A-Za-z0-9]+) ([A-Za-z0-9_]+)","");
		} else {
			regex = new (EReg().default)("attribute ([A-Za-z0-9]+) ([A-Za-z0-9_]+)","");
		}
		while(regex.matchSub(source,lastMatch)) {
			type = regex.matched(1);
			name = regex.matched(2);
			if((StringTools().default).startsWith(name,"gl_")) {
				continue;
			}
			var isUniform = storageType == "uniform";
			if((StringTools().default).startsWith(type,"sampler")) {
				var input = new (openfl_display_ShaderInput().default)();
				input.name = name;
				input.__isUniform = isUniform;
				this.__inputBitmapData.push(input);
				switch(name) {
				case "bitmap":
					this.__bitmap = input;
					break;
				case "openfl_Texture":
					this.__texture = input;
					break;
				default:
				}
				(Reflect().default).setField(this.__data,name,input);
				if(this.__isGenerated) {
					(Reflect().default).setField(this,name,input);
				}
			} else if(!(Reflect().default).hasField(this.__data,name) || (Reflect().default).field(this.__data,name) == null) {
				var parameterType;
				switch(type) {
				case "bool":
					parameterType = "bool";
					break;
				case "bvec2":
					parameterType = "bool2";
					break;
				case "bvec3":
					parameterType = "bool3";
					break;
				case "bvec4":
					parameterType = "bool4";
					break;
				case "dvec2":case "vec2":
					parameterType = "float2";
					break;
				case "dvec3":case "vec3":
					parameterType = "float3";
					break;
				case "double":case "float":
					parameterType = "float";
					break;
				case "ivec3":case "uvec3":
					parameterType = "int3";
					break;
				case "ivec4":case "uvec4":
					parameterType = "int4";
					break;
				case "mat2":case "mat2x2":
					parameterType = "matrix2x2";
					break;
				case "mat2x3":
					parameterType = "matrix2x3";
					break;
				case "mat2x4":
					parameterType = "matrix2x4";
					break;
				case "mat3x2":
					parameterType = "matrix3x2";
					break;
				case "mat3":case "mat3x3":
					parameterType = "matrix3x3";
					break;
				case "mat3x4":
					parameterType = "matrix3x4";
					break;
				case "mat4":case "mat4x4":
					parameterType = "matrix4x4";
					break;
				case "mat4x2":
					parameterType = "matrix4x2";
					break;
				case "mat4x3":
					parameterType = "matrix4x3";
					break;
				case "int":case "uint":
					parameterType = "int";
					break;
				case "ivec2":case "uvec2":
					parameterType = "int2";
					break;
				case "dvec4":case "vec4":
					parameterType = "float4";
					break;
				default:
					parameterType = null;
				}
				var length;
				switch(parameterType) {
				case "bool2":case "float2":case "int2":
					length = 2;
					break;
				case "bool3":case "float3":case "int3":
					length = 3;
					break;
				case "bool4":case "float4":case "int4":case "matrix2x2":
					length = 4;
					break;
				case "matrix3x3":
					length = 9;
					break;
				case "matrix4x4":
					length = 16;
					break;
				default:
					length = 1;
				}
				var arrayLength;
				switch(parameterType) {
				case "matrix2x2":
					arrayLength = 2;
					break;
				case "matrix3x3":
					arrayLength = 3;
					break;
				case "matrix4x4":
					arrayLength = 4;
					break;
				default:
					arrayLength = 1;
				}
				switch(parameterType) {
				case "bool":case "bool2":case "bool3":case "bool4":
					var parameter = new (openfl_display_ShaderParameter().default)();
					parameter.set_name(name);
					parameter.type = parameterType;
					parameter.__arrayLength = arrayLength;
					parameter.__isBool = true;
					parameter.__isUniform = isUniform;
					parameter.__length = length;
					this.__paramBool.push(parameter);
					if(name == "openfl_HasColorTransform") {
						this.__hasColorTransform = parameter;
					}
					(Reflect().default).setField(this.__data,name,parameter);
					if(this.__isGenerated) {
						(Reflect().default).setField(this,name,parameter);
					}
					break;
				case "int":case "int2":case "int3":case "int4":
					var parameter1 = new (openfl_display_ShaderParameter().default)();
					parameter1.set_name(name);
					parameter1.type = parameterType;
					parameter1.__arrayLength = arrayLength;
					parameter1.__isInt = true;
					parameter1.__isUniform = isUniform;
					parameter1.__length = length;
					this.__paramInt.push(parameter1);
					(Reflect().default).setField(this.__data,name,parameter1);
					if(this.__isGenerated) {
						(Reflect().default).setField(this,name,parameter1);
					}
					break;
				default:
					var parameter2 = new (openfl_display_ShaderParameter().default)();
					parameter2.set_name(name);
					parameter2.type = parameterType;
					parameter2.__arrayLength = arrayLength;
					if(arrayLength > 0) {
						var elements = arrayLength * arrayLength;
						var array = null;
						var view = null;
						var buffer = null;
						var len = null;
						var this1;
						if(elements != null) {
							this1 = new Float32Array(elements);
						} else if(array != null) {
							this1 = new Float32Array(array);
						} else if(view != null) {
							this1 = new Float32Array(view);
						} else if(buffer != null) {
							if(len == null) {
								this1 = new Float32Array(buffer,0);
							} else {
								this1 = new Float32Array(buffer,0,len);
							}
						} else {
							this1 = null;
						}
						parameter2.__uniformMatrix = this1;
					}
					parameter2.__isFloat = true;
					parameter2.__isUniform = isUniform;
					parameter2.__length = length;
					this.__paramFloat.push(parameter2);
					if((StringTools().default).startsWith(name,"openfl_")) {
						switch(name) {
						case "openfl_Alpha":
							this.__alpha = parameter2;
							break;
						case "openfl_ColorMultiplier":
							this.__colorMultiplier = parameter2;
							break;
						case "openfl_ColorOffset":
							this.__colorOffset = parameter2;
							break;
						case "openfl_Matrix":
							this.__matrix = parameter2;
							break;
						case "openfl_Position":
							this.__position = parameter2;
							break;
						case "openfl_TextureCoord":
							this.__textureCoord = parameter2;
							break;
						case "openfl_TextureSize":
							this.__textureSize = parameter2;
							break;
						default:
						}
					}
					(Reflect().default).setField(this.__data,name,parameter2);
					if(this.__isGenerated) {
						(Reflect().default).setField(this,name,parameter2);
					}
				}
			}
			position = regex.matchedPos();
			lastMatch = position.pos + position.len;
		}
	},
	__update: function() {
		if(this.program != null) {
			this.__updateGL();
		}
	},
	__updateFromBuffer: function(shaderBuffer,bufferOffset) {
		if(this.program != null) {
			this.__updateGLFromBuffer(shaderBuffer,bufferOffset);
		}
	},
	__updateGL: function() {
		var textureCount = 0;
		var _g = 0;
		var _g1 = this.__inputBitmapData;
		while(_g < _g1.length) {
			var input = _g1[_g];
			++_g;
			input.__updateGL(this.__context,textureCount);
			++textureCount;
		}
		var _g2 = 0;
		var _g3 = this.__paramBool;
		while(_g2 < _g3.length) {
			var parameter = _g3[_g2];
			++_g2;
			parameter.__updateGL(this.__context);
		}
		var _g4 = 0;
		var _g5 = this.__paramFloat;
		while(_g4 < _g5.length) {
			var parameter1 = _g5[_g4];
			++_g4;
			parameter1.__updateGL(this.__context);
		}
		var _g6 = 0;
		var _g7 = this.__paramInt;
		while(_g6 < _g7.length) {
			var parameter2 = _g7[_g6];
			++_g6;
			parameter2.__updateGL(this.__context);
		}
	},
	__updateGLFromBuffer: function(shaderBuffer,bufferOffset) {
		var textureCount = 0;
		var input;
		var inputData;
		var inputFilter;
		var inputMipFilter;
		var inputWrap;
		var _g = 0;
		var _g1 = shaderBuffer.inputCount;
		while(_g < _g1) {
			var i = _g++;
			input = shaderBuffer.inputRefs[i];
			inputData = shaderBuffer.inputs[i];
			inputFilter = shaderBuffer.inputFilter[i];
			inputMipFilter = shaderBuffer.inputMipFilter[i];
			inputWrap = shaderBuffer.inputWrap[i];
			if(inputData != null) {
				input.__updateGL(this.__context,textureCount,inputData,inputFilter,inputMipFilter,inputWrap);
				++textureCount;
			}
		}
		var gl = this.__context.gl;
		if(shaderBuffer.paramDataLength > 0) {
			if(shaderBuffer.paramDataBuffer == null) {
				shaderBuffer.paramDataBuffer = gl.createBuffer();
			}
			this.__context.__bindGLArrayBuffer(shaderBuffer.paramDataBuffer);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).bufferData(gl,gl.ARRAY_BUFFER,shaderBuffer.paramData,gl.DYNAMIC_DRAW);
		} else {
			this.__context.__bindGLArrayBuffer(null);
		}
		var boolIndex = 0;
		var floatIndex = 0;
		var intIndex = 0;
		var boolCount = shaderBuffer.paramBoolCount;
		var floatCount = shaderBuffer.paramFloatCount;
		var paramData = shaderBuffer.paramData;
		var boolRef;
		var floatRef;
		var intRef;
		var hasOverride;
		var overrideBoolValue = null;
		var overrideFloatValue = null;
		var overrideIntValue = null;
		var _g2 = 0;
		var _g3 = shaderBuffer.paramCount;
		while(_g2 < _g3) {
			var i1 = _g2++;
			hasOverride = false;
			if(i1 < boolCount) {
				boolRef = shaderBuffer.paramRefs_Bool[boolIndex];
				var _g21 = 0;
				var _g31 = shaderBuffer.overrideBoolCount;
				while(_g21 < _g31) {
					var j = _g21++;
					if(boolRef.name == shaderBuffer.overrideBoolNames[j]) {
						overrideBoolValue = shaderBuffer.overrideBoolValues[j];
						hasOverride = true;
						break;
					}
				}
				if(hasOverride) {
					boolRef.__updateGL(this.__context,overrideBoolValue);
				} else {
					boolRef.__updateGLFromBuffer(this.__context,paramData,shaderBuffer.paramPositions[i1],shaderBuffer.paramLengths[i1],bufferOffset);
				}
				++boolIndex;
			} else if(i1 < boolCount + floatCount) {
				floatRef = shaderBuffer.paramRefs_Float[floatIndex];
				var _g22 = 0;
				var _g32 = shaderBuffer.overrideFloatCount;
				while(_g22 < _g32) {
					var j1 = _g22++;
					if(floatRef.name == shaderBuffer.overrideFloatNames[j1]) {
						overrideFloatValue = shaderBuffer.overrideFloatValues[j1];
						hasOverride = true;
						break;
					}
				}
				if(hasOverride) {
					floatRef.__updateGL(this.__context,overrideFloatValue);
				} else {
					floatRef.__updateGLFromBuffer(this.__context,paramData,shaderBuffer.paramPositions[i1],shaderBuffer.paramLengths[i1],bufferOffset);
				}
				++floatIndex;
			} else {
				intRef = shaderBuffer.paramRefs_Int[intIndex];
				var _g23 = 0;
				var _g33 = shaderBuffer.overrideIntCount;
				while(_g23 < _g33) {
					var j2 = _g23++;
					if(intRef.name == shaderBuffer.overrideIntNames[j2]) {
						overrideIntValue = shaderBuffer.overrideIntValues[j2];
						hasOverride = true;
						break;
					}
				}
				if(hasOverride) {
					intRef.__updateGL(this.__context,overrideIntValue);
				} else {
					intRef.__updateGLFromBuffer(this.__context,paramData,shaderBuffer.paramPositions[i1],shaderBuffer.paramLengths[i1],bufferOffset);
				}
				++intIndex;
			}
		}
	},
	get_data: function() {
		if(this.__glSourceDirty || this.__data == null) {
			this.__init();
		}
		return this.__data;
	},
	set_data: function(value) {
		return this.__data = value;
	},
	get_glFragmentSource: function() {
		return this.__glFragmentSource;
	},
	set_glFragmentSource: function(value) {
		if(value != this.__glFragmentSource) {
			this.__glSourceDirty = true;
		}
		return this.__glFragmentSource = value;
	},
	get_glVertexSource: function() {
		return this.__glVertexSource;
	},
	set_glVertexSource: function(value) {
		if(value != this.__glVertexSource) {
			this.__glSourceDirty = true;
		}
		return this.__glVertexSource = value;
	}
};
Shader.prototype.__class__ = Shader.prototype.constructor = $hxClasses["openfl.display.Shader"] = Shader;

// Init

Object.defineProperties(Shader.prototype,{ data : { get : function () { return this.get_data (); }, set : function (v) { return this.set_data (v); }}, glFragmentSource : { get : function () { return this.get_glFragmentSource (); }, set : function (v) { return this.set_glFragmentSource (v); }}, glVertexSource : { get : function () { return this.get_glVertexSource (); }, set : function (v) { return this.set_glVertexSource (v); }}});

// Statics


Shader.__meta__ = { fields : { glProgram : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = Shader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/ShaderInput.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/ShaderInput.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.ShaderInput

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var ShaderInput = function() {
	this.channels = 0;
	this.filter = "nearest";
	this.height = 0;
	this.index = 0;
	this.mipFilter = "mipnone";
	this.width = 0;
	this.wrap = "clamp";
}

// Meta

ShaderInput.__name__ = "openfl.display.ShaderInput";
ShaderInput.__isInterface__ = false;
ShaderInput.prototype = {
	__disableGL: function(context,id) {
		var gl = context.gl;
		context.setTextureAt(id,null);
	},
	__updateGL: function(context,id,overrideInput,overrideFilter,overrideMipFilter,overrideWrap) {
		var gl = context.gl;
		var input = overrideInput != null ? overrideInput : this.input;
		var filter = overrideFilter != null ? overrideFilter : this.filter;
		var mipFilter = overrideMipFilter != null ? overrideMipFilter : this.mipFilter;
		var wrap = overrideWrap != null ? overrideWrap : this.wrap;
		if(input != null) {
			var bitmapData = input;
			context.setTextureAt(id,bitmapData.getTexture(context));
			context.setSamplerStateAt(id,wrap,filter,mipFilter);
		} else {
			context.setTextureAt(id,null);
		}
	}
};
ShaderInput.prototype.__class__ = ShaderInput.prototype.constructor = $hxClasses["openfl.display.ShaderInput"] = ShaderInput;

// Init



// Statics


ShaderInput.__meta__ = { fields : { index : { SuppressWarnings : ["checkstyle:Dynamic"]}, name : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}}

// Export

exports.default = ShaderInput;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/ShaderParameter.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/ShaderParameter.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.ShaderParameter

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}

// Constructor

var ShaderParameter = function() {
	this.index = 0;
}

// Meta

ShaderParameter.__name__ = "openfl.display.ShaderParameter";
ShaderParameter.__isInterface__ = false;
ShaderParameter.prototype = {
	__disableGL: function(context) {
		var gl = context.gl;
		if(!this.__isUniform) {
			var _g = 0;
			var _g1 = this.__arrayLength;
			while(_g < _g1) {
				var i = _g++;
				gl.disableVertexAttribArray(this.index + i);
			}
		}
	},
	__updateGL: function(context,overrideValue) {
		var gl = context.gl;
		var value = overrideValue != null ? overrideValue : this.value;
		var boolValue = this.__isBool ? value : null;
		var floatValue = this.__isFloat ? value : null;
		var intValue = this.__isInt ? value : null;
		if(this.__isUniform) {
			if(value != null && value.length >= this.__length) {
				switch(this.type) {
				case "bool":
					gl.uniform1i(this.index,boolValue[0] ? 1 : 0);
					break;
				case "bool2":
					gl.uniform2i(this.index,boolValue[0] ? 1 : 0,boolValue[1] ? 1 : 0);
					break;
				case "bool3":
					gl.uniform3i(this.index,boolValue[0] ? 1 : 0,boolValue[1] ? 1 : 0,boolValue[2] ? 1 : 0);
					break;
				case "bool4":
					gl.uniform4i(this.index,boolValue[0] ? 1 : 0,boolValue[1] ? 1 : 0,boolValue[2] ? 1 : 0,boolValue[3] ? 1 : 0);
					break;
				case "float":
					gl.uniform1f(this.index,floatValue[0]);
					break;
				case "float2":
					gl.uniform2f(this.index,floatValue[0],floatValue[1]);
					break;
				case "float3":
					gl.uniform3f(this.index,floatValue[0],floatValue[1],floatValue[2]);
					break;
				case "float4":
					gl.uniform4f(this.index,floatValue[0],floatValue[1],floatValue[2],floatValue[3]);
					break;
				case "int":
					gl.uniform1i(this.index,intValue[0]);
					break;
				case "int2":
					gl.uniform2i(this.index,intValue[0],intValue[1]);
					break;
				case "int3":
					gl.uniform3i(this.index,intValue[0],intValue[1],intValue[2]);
					break;
				case "int4":
					gl.uniform4i(this.index,intValue[0],intValue[1],intValue[2],intValue[3]);
					break;
				case "matrix2x2":
					this.__uniformMatrix[0] = floatValue[0];
					this.__uniformMatrix[1] = floatValue[1];
					this.__uniformMatrix[2] = floatValue[2];
					this.__uniformMatrix[3] = floatValue[3];
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix2fv(gl,this.index,false,this.__uniformMatrix);
					break;
				case "matrix3x3":
					this.__uniformMatrix[0] = floatValue[0];
					this.__uniformMatrix[1] = floatValue[1];
					this.__uniformMatrix[2] = floatValue[2];
					this.__uniformMatrix[3] = floatValue[3];
					this.__uniformMatrix[4] = floatValue[4];
					this.__uniformMatrix[5] = floatValue[5];
					this.__uniformMatrix[6] = floatValue[6];
					this.__uniformMatrix[7] = floatValue[7];
					this.__uniformMatrix[8] = floatValue[8];
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix3fv(gl,this.index,false,this.__uniformMatrix);
					break;
				case "matrix4x4":
					this.__uniformMatrix[0] = floatValue[0];
					this.__uniformMatrix[1] = floatValue[1];
					this.__uniformMatrix[2] = floatValue[2];
					this.__uniformMatrix[3] = floatValue[3];
					this.__uniformMatrix[4] = floatValue[4];
					this.__uniformMatrix[5] = floatValue[5];
					this.__uniformMatrix[6] = floatValue[6];
					this.__uniformMatrix[7] = floatValue[7];
					this.__uniformMatrix[8] = floatValue[8];
					this.__uniformMatrix[9] = floatValue[9];
					this.__uniformMatrix[10] = floatValue[10];
					this.__uniformMatrix[11] = floatValue[11];
					this.__uniformMatrix[12] = floatValue[12];
					this.__uniformMatrix[13] = floatValue[13];
					this.__uniformMatrix[14] = floatValue[14];
					this.__uniformMatrix[15] = floatValue[15];
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix4fv(gl,this.index,false,this.__uniformMatrix);
					break;
				default:
				}
			} else {
				switch(this.type) {
				case "bool":case "int":
					gl.uniform1i(this.index,0);
					break;
				case "bool2":case "int2":
					gl.uniform2i(this.index,0,0);
					break;
				case "float":
					gl.uniform1f(this.index,0);
					break;
				case "float2":
					gl.uniform2f(this.index,0,0);
					break;
				case "float3":
					gl.uniform3f(this.index,0,0,0);
					break;
				case "float4":
					gl.uniform4f(this.index,0,0,0,0);
					break;
				case "bool3":case "int3":
					gl.uniform3i(this.index,0,0,0);
					break;
				case "bool4":case "int4":
					gl.uniform4i(this.index,0,0,0,0);
					break;
				case "matrix2x2":
					this.__uniformMatrix[0] = 0;
					this.__uniformMatrix[1] = 0;
					this.__uniformMatrix[2] = 0;
					this.__uniformMatrix[3] = 0;
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix2fv(gl,this.index,false,this.__uniformMatrix);
					break;
				case "matrix3x3":
					this.__uniformMatrix[0] = 0;
					this.__uniformMatrix[1] = 0;
					this.__uniformMatrix[2] = 0;
					this.__uniformMatrix[3] = 0;
					this.__uniformMatrix[4] = 0;
					this.__uniformMatrix[5] = 0;
					this.__uniformMatrix[6] = 0;
					this.__uniformMatrix[7] = 0;
					this.__uniformMatrix[8] = 0;
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix3fv(gl,this.index,false,this.__uniformMatrix);
					break;
				case "matrix4x4":
					this.__uniformMatrix[0] = 0;
					this.__uniformMatrix[1] = 0;
					this.__uniformMatrix[2] = 0;
					this.__uniformMatrix[3] = 0;
					this.__uniformMatrix[4] = 0;
					this.__uniformMatrix[5] = 0;
					this.__uniformMatrix[6] = 0;
					this.__uniformMatrix[7] = 0;
					this.__uniformMatrix[8] = 0;
					this.__uniformMatrix[9] = 0;
					this.__uniformMatrix[10] = 0;
					this.__uniformMatrix[11] = 0;
					this.__uniformMatrix[12] = 0;
					this.__uniformMatrix[13] = 0;
					this.__uniformMatrix[14] = 0;
					this.__uniformMatrix[15] = 0;
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix4fv(gl,this.index,false,this.__uniformMatrix);
					break;
				default:
				}
			}
		} else if(!this.__useArray && (value == null || value.length == this.__length)) {
			var _g = 0;
			var _g1 = this.__arrayLength;
			while(_g < _g1) {
				var i = _g++;
				gl.disableVertexAttribArray(this.index + i);
			}
			if(value != null) {
				switch(this.type) {
				case "bool":
					gl.vertexAttrib1f(this.index,boolValue[0] ? 1 : 0);
					break;
				case "bool2":
					gl.vertexAttrib2f(this.index,boolValue[0] ? 1 : 0,boolValue[1] ? 1 : 0);
					break;
				case "bool3":
					gl.vertexAttrib3f(this.index,boolValue[0] ? 1 : 0,boolValue[1] ? 1 : 0,boolValue[2] ? 1 : 0);
					break;
				case "bool4":
					gl.vertexAttrib4f(this.index,boolValue[0] ? 1 : 0,boolValue[1] ? 1 : 0,boolValue[2] ? 1 : 0,boolValue[3] ? 1 : 0);
					break;
				case "float":
					gl.vertexAttrib1f(this.index,floatValue[0]);
					break;
				case "float2":
					gl.vertexAttrib2f(this.index,floatValue[0],floatValue[1]);
					break;
				case "float3":
					gl.vertexAttrib3f(this.index,floatValue[0],floatValue[1],floatValue[2]);
					break;
				case "float4":
					gl.vertexAttrib4f(this.index,floatValue[0],floatValue[1],floatValue[2],floatValue[3]);
					break;
				case "int":
					gl.vertexAttrib1f(this.index,intValue[0]);
					break;
				case "int2":
					gl.vertexAttrib2f(this.index,intValue[0],intValue[1]);
					break;
				case "int3":
					gl.vertexAttrib3f(this.index,intValue[0],intValue[1],intValue[2]);
					break;
				case "int4":
					gl.vertexAttrib4f(this.index,intValue[0],intValue[1],intValue[2],intValue[3]);
					break;
				case "matrix2x2":
					gl.vertexAttrib2f(this.index + 0,floatValue[0],floatValue[1]);
					gl.vertexAttrib2f(this.index + 1,floatValue[2],floatValue[3]);
					break;
				case "matrix3x3":
					gl.vertexAttrib3f(this.index + 0,floatValue[0],floatValue[1],floatValue[2]);
					gl.vertexAttrib3f(this.index + 1,floatValue[3],floatValue[4],floatValue[5]);
					gl.vertexAttrib3f(this.index + 2,floatValue[6],floatValue[7],floatValue[8]);
					break;
				case "matrix4x4":
					gl.vertexAttrib4f(this.index + 0,floatValue[0],floatValue[1],floatValue[2],floatValue[3]);
					gl.vertexAttrib4f(this.index + 1,floatValue[4],floatValue[5],floatValue[6],floatValue[7]);
					gl.vertexAttrib4f(this.index + 2,floatValue[8],floatValue[9],floatValue[10],floatValue[11]);
					gl.vertexAttrib4f(this.index + 3,floatValue[12],floatValue[13],floatValue[14],floatValue[15]);
					break;
				default:
				}
			} else {
				switch(this.type) {
				case "bool":case "float":case "int":
					gl.vertexAttrib1f(this.index,0);
					break;
				case "bool2":case "float2":case "int2":
					gl.vertexAttrib2f(this.index,0,0);
					break;
				case "bool3":case "float3":case "int3":
					gl.vertexAttrib3f(this.index,0,0,0);
					break;
				case "bool4":case "float4":case "int4":
					gl.vertexAttrib4f(this.index,0,0,0,0);
					break;
				case "matrix2x2":
					gl.vertexAttrib2f(this.index + 0,0,0);
					gl.vertexAttrib2f(this.index + 1,0,0);
					break;
				case "matrix3x3":
					gl.vertexAttrib3f(this.index + 0,0,0,0);
					gl.vertexAttrib3f(this.index + 1,0,0,0);
					gl.vertexAttrib3f(this.index + 2,0,0,0);
					break;
				case "matrix4x4":
					gl.vertexAttrib4f(this.index + 0,0,0,0,0);
					gl.vertexAttrib4f(this.index + 1,0,0,0,0);
					gl.vertexAttrib4f(this.index + 2,0,0,0,0);
					gl.vertexAttrib4f(this.index + 3,0,0,0,0);
					break;
				default:
				}
			}
		} else {
			var _g2 = 0;
			var _g11 = this.__arrayLength;
			while(_g2 < _g11) {
				var i1 = _g2++;
				gl.enableVertexAttribArray(this.index + i1);
			}
		}
	},
	__updateGLFromBuffer: function(context,buffer,position,length,bufferOffset) {
		var gl = context.gl;
		if(this.__isUniform) {
			if(length >= this.__length) {
				switch(this.type) {
				case "bool":case "int":
					gl.uniform1i(this.index,(Std().default).int(buffer[position]));
					break;
				case "bool2":case "int2":
					gl.uniform2i(this.index,(Std().default).int(buffer[position]),(Std().default).int(buffer[position + 1]));
					break;
				case "float":
					gl.uniform1f(this.index,buffer[position]);
					break;
				case "float2":
					gl.uniform2f(this.index,buffer[position],buffer[position + 1]);
					break;
				case "float3":
					gl.uniform3f(this.index,buffer[position],buffer[position + 1],buffer[position + 2]);
					break;
				case "float4":
					gl.uniform4f(this.index,buffer[position],buffer[position + 1],buffer[position + 2],buffer[position + 3]);
					break;
				case "bool3":case "int3":
					gl.uniform3i(this.index,(Std().default).int(buffer[position]),(Std().default).int(buffer[position + 1]),(Std().default).int(buffer[position + 2]));
					break;
				case "bool4":case "int4":
					gl.uniform4i(this.index,(Std().default).int(buffer[position]),(Std().default).int(buffer[position + 1]),(Std().default).int(buffer[position + 2]),(Std().default).int(buffer[position + 3]));
					break;
				case "matrix2x2":
					this.__uniformMatrix[0] = buffer[position];
					this.__uniformMatrix[1] = buffer[position + 1];
					this.__uniformMatrix[2] = buffer[position + 2];
					this.__uniformMatrix[3] = buffer[position + 3];
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix2fv(gl,this.index,false,this.__uniformMatrix);
					break;
				case "matrix3x3":
					this.__uniformMatrix[0] = buffer[position];
					this.__uniformMatrix[1] = buffer[position + 1];
					this.__uniformMatrix[2] = buffer[position + 2];
					this.__uniformMatrix[3] = buffer[position + 3];
					this.__uniformMatrix[4] = buffer[position + 4];
					this.__uniformMatrix[5] = buffer[position + 5];
					this.__uniformMatrix[6] = buffer[position + 6];
					this.__uniformMatrix[7] = buffer[position + 7];
					this.__uniformMatrix[8] = buffer[position + 8];
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix3fv(gl,this.index,false,this.__uniformMatrix);
					break;
				case "matrix4x4":
					this.__uniformMatrix[0] = buffer[position];
					this.__uniformMatrix[1] = buffer[position + 1];
					this.__uniformMatrix[2] = buffer[position + 2];
					this.__uniformMatrix[3] = buffer[position + 3];
					this.__uniformMatrix[4] = buffer[position + 4];
					this.__uniformMatrix[5] = buffer[position + 5];
					this.__uniformMatrix[6] = buffer[position + 6];
					this.__uniformMatrix[7] = buffer[position + 7];
					this.__uniformMatrix[8] = buffer[position + 8];
					this.__uniformMatrix[9] = buffer[position + 9];
					this.__uniformMatrix[10] = buffer[position + 10];
					this.__uniformMatrix[11] = buffer[position + 11];
					this.__uniformMatrix[12] = buffer[position + 12];
					this.__uniformMatrix[13] = buffer[position + 13];
					this.__uniformMatrix[14] = buffer[position + 14];
					this.__uniformMatrix[15] = buffer[position + 15];
					(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix4fv(gl,this.index,false,this.__uniformMatrix);
					break;
				default:
				}
			}
		} else if(!this.__internal && (length == 0 || length == this.__length)) {
			var _g = 0;
			var _g1 = this.__arrayLength;
			while(_g < _g1) {
				var i = _g++;
				gl.disableVertexAttribArray(this.index + i);
			}
			if(length > 0) {
				switch(this.type) {
				case "bool":case "float":case "int":
					gl.vertexAttrib1f(this.index,buffer[position]);
					break;
				case "bool2":case "float2":case "int2":
					gl.vertexAttrib2f(this.index,buffer[position],buffer[position + 1]);
					break;
				case "bool3":case "float3":case "int3":
					gl.vertexAttrib3f(this.index,buffer[position],buffer[position + 1],buffer[position + 2]);
					break;
				case "bool4":case "float4":case "int4":
					gl.vertexAttrib4f(this.index,buffer[position],buffer[position + 1],buffer[position + 2],buffer[position + 3]);
					break;
				case "matrix2x2":
					gl.vertexAttrib2f(this.index + 0,buffer[position],buffer[position + 1]);
					gl.vertexAttrib2f(this.index + 1,buffer[position + 2],buffer[position + 2 + 1]);
					break;
				case "matrix3x3":
					gl.vertexAttrib3f(this.index + 0,buffer[position],buffer[position + 1],buffer[position + 2]);
					gl.vertexAttrib3f(this.index + 1,buffer[position + 3],buffer[position + 3 + 1],buffer[position + 3 + 2]);
					gl.vertexAttrib3f(this.index + 2,buffer[position + 6],buffer[position + 6 + 1],buffer[position + 6 + 2]);
					break;
				case "matrix4x4":
					gl.vertexAttrib4f(this.index + 0,buffer[position],buffer[position + 1],buffer[position + 2],buffer[position + 3]);
					gl.vertexAttrib4f(this.index + 1,buffer[position + 4],buffer[position + 4 + 1],buffer[position + 4 + 2],buffer[position + 4 + 3]);
					gl.vertexAttrib4f(this.index + 2,buffer[position + 8],buffer[position + 8 + 1],buffer[position + 8 + 2],buffer[position + 8 + 3]);
					gl.vertexAttrib4f(this.index + 3,buffer[position + 12],buffer[position + 12 + 1],buffer[position + 12 + 2],buffer[position + 12 + 3]);
					break;
				default:
				}
			} else {
				switch(this.type) {
				case "bool":case "float":case "int":
					gl.vertexAttrib1f(this.index,0);
					break;
				case "bool2":case "float2":case "int2":
					gl.vertexAttrib2f(this.index,0,0);
					break;
				case "bool3":case "float3":case "int3":
					gl.vertexAttrib3f(this.index,0,0,0);
					break;
				case "bool4":case "float4":case "int4":
					gl.vertexAttrib4f(this.index,0,0,0,0);
					break;
				case "matrix2x2":
					gl.vertexAttrib2f(this.index + 0,0,0);
					gl.vertexAttrib2f(this.index + 1,0,0);
					break;
				case "matrix3x3":
					gl.vertexAttrib3f(this.index + 0,0,0,0);
					gl.vertexAttrib3f(this.index + 1,0,0,0);
					gl.vertexAttrib3f(this.index + 2,0,0,0);
					break;
				case "matrix4x4":
					gl.vertexAttrib4f(this.index + 0,0,0,0,0);
					gl.vertexAttrib4f(this.index + 1,0,0,0,0);
					gl.vertexAttrib4f(this.index + 2,0,0,0,0);
					gl.vertexAttrib4f(this.index + 3,0,0,0,0);
					break;
				default:
				}
			}
		} else {
			var type = gl.FLOAT;
			if(this.__isBool) {
				type = gl.INT;
			} else if(this.__isInt) {
				type = gl.INT;
			}
			var _g2 = 0;
			var _g11 = this.__arrayLength;
			while(_g2 < _g11) {
				var i1 = _g2++;
				gl.enableVertexAttribArray(this.index + i1);
			}
			if(length > 0) {
				var _g21 = 0;
				var _g3 = this.__arrayLength;
				while(_g21 < _g3) {
					var i2 = _g21++;
					gl.vertexAttribPointer(this.index + i2,this.__length,type,false,this.__length * 4,(position + bufferOffset * this.__length + i2 * this.__arrayLength) * 4);
				}
			}
		}
	},
	set_name: function(value) {
		this.__internal = (StringTools().default).startsWith(value,"openfl_");
		return this.name = value;
	}
};
ShaderParameter.prototype.__class__ = ShaderParameter.prototype.constructor = $hxClasses["openfl.display.ShaderParameter"] = ShaderParameter;

// Init



// Statics


ShaderParameter.__meta__ = { fields : { index : { SuppressWarnings : ["checkstyle:Dynamic"]}, name : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}}

// Export

exports.default = ShaderParameter;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Shape.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Shape.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Shape

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_DisplayObject() {return __webpack_require__(/*! ./../../openfl/display/DisplayObject */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js");}
function openfl_display_Graphics() {return __webpack_require__(/*! ./../../openfl/display/Graphics */ "./node_modules/openfl/lib/_gen/openfl/display/Graphics.js");}

// Constructor

var Shape = function() {
	(openfl_display_DisplayObject().default).call(this);
}

// Meta

Shape.__name__ = "openfl.display.Shape";
Shape.__isInterface__ = false;
Shape.__super__ = (openfl_display_DisplayObject().default);
Shape.prototype = $extend((openfl_display_DisplayObject().default).prototype, {
	get_graphics: function() {
		if(this.__graphics == null) {
			this.__graphics = new (openfl_display_Graphics().default)(this);
		}
		return this.__graphics;
	}
});
Shape.prototype.__class__ = Shape.prototype.constructor = $hxClasses["openfl.display.Shape"] = Shape;

// Init

Object.defineProperty(Shape.prototype,"graphics",{ get : function () { return this.get_graphics (); }});

// Statics




// Export

exports.default = Shape;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Sprite.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Sprite.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Sprite

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_DisplayObjectContainer() {return __webpack_require__(/*! ./../../openfl/display/DisplayObjectContainer */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectContainer.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function openfl_display_Graphics() {return __webpack_require__(/*! ./../../openfl/display/Graphics */ "./node_modules/openfl/lib/_gen/openfl/display/Graphics.js");}

// Constructor

var Sprite = function() {
	(openfl_display_DisplayObjectContainer().default).call(this);
	this.__buttonMode = false;
	this.useHandCursor = true;
}

// Meta

Sprite.__name__ = "openfl.display.Sprite";
Sprite.__isInterface__ = false;
Sprite.__super__ = (openfl_display_DisplayObjectContainer().default);
Sprite.prototype = $extend((openfl_display_DisplayObjectContainer().default).prototype, {
	startDrag: function(lockCenter,bounds) {
		if(lockCenter == null) {
			lockCenter = false;
		}
		if(this.stage != null) {
			this.stage.__startDrag(this,lockCenter,bounds);
		}
	},
	stopDrag: function() {
		if(this.stage != null) {
			this.stage.__stopDrag(this);
		}
	},
	__getCursor: function() {
		if(this.__buttonMode && this.useHandCursor) {
			return "button";
		} else {
			return null;
		}
	},
	__hitTest: function(x,y,shapeFlag,stack,interactiveOnly,hitObject) {
		if(interactiveOnly && !this.mouseEnabled && !this.mouseChildren) {
			return false;
		}
		if(!hitObject.get_visible() || this.__isMask) {
			return this.__hitTestHitArea(x,y,shapeFlag,stack,interactiveOnly,hitObject);
		}
		if(this.get_mask() != null && !this.get_mask().__hitTestMask(x,y)) {
			return this.__hitTestHitArea(x,y,shapeFlag,stack,interactiveOnly,hitObject);
		}
		if(this.__scrollRect != null) {
			var point = (openfl_geom_Point().default).__pool.get();
			point.setTo(x,y);
			this.__getRenderTransform().__transformInversePoint(point);
			if(!this.__scrollRect.containsPoint(point)) {
				(openfl_geom_Point().default).__pool.release(point);
				return this.__hitTestHitArea(x,y,shapeFlag,stack,true,hitObject);
			}
			(openfl_geom_Point().default).__pool.release(point);
		}
		if((openfl_display_DisplayObjectContainer().default).prototype.__hitTest.call(this,x,y,shapeFlag,stack,interactiveOnly,hitObject)) {
			if(stack != null) {
				return interactiveOnly;
			} else {
				return true;
			}
		} else if(this.hitArea == null && this.__graphics != null && this.__graphics.__hitTest(x,y,shapeFlag,this.__getRenderTransform())) {
			if(stack != null && (!interactiveOnly || this.mouseEnabled)) {
				stack.push(hitObject);
			}
			return true;
		}
		return this.__hitTestHitArea(x,y,shapeFlag,stack,interactiveOnly,hitObject);
	},
	__hitTestHitArea: function(x,y,shapeFlag,stack,interactiveOnly,hitObject) {
		if(this.hitArea != null) {
			if(!this.hitArea.mouseEnabled) {
				this.hitArea.mouseEnabled = true;
				var hitTest = this.hitArea.__hitTest(x,y,shapeFlag,null,true,hitObject);
				this.hitArea.mouseEnabled = false;
				if(stack != null && hitTest) {
					stack[stack.length] = hitObject;
				}
				return hitTest;
			}
		}
		return false;
	},
	__hitTestMask: function(x,y) {
		if((openfl_display_DisplayObjectContainer().default).prototype.__hitTestMask.call(this,x,y)) {
			return true;
		} else if(this.__graphics != null && this.__graphics.__hitTest(x,y,true,this.__getRenderTransform())) {
			return true;
		}
		return false;
	},
	get_graphics: function() {
		if(this.__graphics == null) {
			this.__graphics = new (openfl_display_Graphics().default)(this);
		}
		return this.__graphics;
	},
	get_tabEnabled: function() {
		if(this.__tabEnabled == null) {
			return this.__buttonMode;
		} else {
			return this.__tabEnabled;
		}
	},
	get_buttonMode: function() {
		return this.__buttonMode;
	},
	set_buttonMode: function(value) {
		return this.__buttonMode = value;
	}
});
Sprite.prototype.__class__ = Sprite.prototype.constructor = $hxClasses["openfl.display.Sprite"] = Sprite;

// Init

Object.defineProperties(Sprite.prototype,{ buttonMode : { get : function () { return this.get_buttonMode (); }, set : function (v) { return this.set_buttonMode (v); }}, graphics : { get : function () { return this.get_graphics (); }}});

// Statics




// Export

exports.default = Sprite;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Stage.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Stage.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Stage

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_app_IModule() {return __webpack_require__(/*! ./../../lime/app/IModule */ "./node_modules/openfl/lib/_gen/lime/app/IModule.js");}
function openfl_display_DisplayObjectContainer() {return __webpack_require__(/*! ./../../openfl/display/DisplayObjectContainer */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectContainer.js");}
function openfl_display_DisplayObject() {return __webpack_require__(/*! ./../../openfl/display/DisplayObject */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js");}
function haxe_CallStack() {return __webpack_require__(/*! ./../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl_display_CanvasRenderer() {return __webpack_require__(/*! ./../../openfl/display/CanvasRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/CanvasRenderer.js");}
function js_Boot() {return __webpack_require__(/*! ./../../js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}
function openfl_display_DOMRenderer() {return __webpack_require__(/*! ./../../openfl/display/DOMRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/DOMRenderer.js");}
function openfl_display3D_Context3D() {return __webpack_require__(/*! ./../../openfl/display3D/Context3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/Context3D.js");}
function openfl_display_OpenGLRenderer() {return __webpack_require__(/*! ./../../openfl/display/OpenGLRenderer */ "./node_modules/openfl/lib/_gen/openfl/display/OpenGLRenderer.js");}
function openfl_events_UncaughtErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/UncaughtErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/UncaughtErrorEvent.js");}
function openfl_Lib() {return __webpack_require__(/*! ./../../openfl/Lib */ "./node_modules/openfl/lib/_gen/openfl/Lib.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function openfl_events_MouseEvent() {return __webpack_require__(/*! ./../../openfl/events/MouseEvent */ "./node_modules/openfl/lib/_gen/openfl/events/MouseEvent.js");}
function lime_ui__$KeyModifier_KeyModifier_$Impl_$() {return __webpack_require__(/*! ./../../lime/ui/_KeyModifier/KeyModifier_Impl_ */ "./node_modules/openfl/lib/_gen/lime/ui/_KeyModifier/KeyModifier_Impl_.js");}
function openfl_ui_Keyboard() {return __webpack_require__(/*! ./../../openfl/ui/Keyboard */ "./node_modules/openfl/lib/_gen/openfl/ui/Keyboard.js");}
function openfl_events_KeyboardEvent() {return __webpack_require__(/*! ./../../openfl/events/KeyboardEvent */ "./node_modules/openfl/lib/_gen/openfl/events/KeyboardEvent.js");}
function haxe_ds_ArraySort() {return __webpack_require__(/*! ./../../haxe/ds/ArraySort */ "./node_modules/openfl/lib/_gen/haxe/ds/ArraySort.js");}
function openfl_events_FocusEvent() {return __webpack_require__(/*! ./../../openfl/events/FocusEvent */ "./node_modules/openfl/lib/_gen/openfl/events/FocusEvent.js");}
function openfl_ui_GameInput() {return __webpack_require__(/*! ./../../openfl/ui/GameInput */ "./node_modules/openfl/lib/_gen/openfl/ui/GameInput.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_ui_MouseWheelMode() {return __webpack_require__(/*! ./../../lime/ui/MouseWheelMode */ "./node_modules/openfl/lib/_gen/lime/ui/MouseWheelMode.js");}
function openfl__$Vector_VectorIterator() {return __webpack_require__(/*! ./../../openfl/_Vector/VectorIterator */ "./node_modules/openfl/lib/_gen/openfl/_Vector/VectorIterator.js");}
function openfl_events_TextEvent() {return __webpack_require__(/*! ./../../openfl/events/TextEvent */ "./node_modules/openfl/lib/_gen/openfl/events/TextEvent.js");}
function openfl_events_FullScreenEvent() {return __webpack_require__(/*! ./../../openfl/events/FullScreenEvent */ "./node_modules/openfl/lib/_gen/openfl/events/FullScreenEvent.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function openfl_display_InteractiveObject() {return __webpack_require__(/*! ./../../openfl/display/InteractiveObject */ "./node_modules/openfl/lib/_gen/openfl/display/InteractiveObject.js");}
function openfl_ui_Mouse() {return __webpack_require__(/*! ./../../openfl/ui/Mouse */ "./node_modules/openfl/lib/_gen/openfl/ui/Mouse.js");}
function openfl_ui__$MouseCursor_MouseCursor_$Impl_$() {return __webpack_require__(/*! ./../../openfl/ui/_MouseCursor/MouseCursor_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/ui/_MouseCursor/MouseCursor_Impl_.js");}
function lime_ui_MouseCursor() {return __webpack_require__(/*! ./../../lime/ui/MouseCursor */ "./node_modules/openfl/lib/_gen/lime/ui/MouseCursor.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function openfl__$internal_utils_TouchData() {return __webpack_require__(/*! ./../../openfl/_internal/utils/TouchData */ "./node_modules/openfl/lib/_gen/openfl/_internal/utils/TouchData.js");}
function openfl_events_TouchEvent() {return __webpack_require__(/*! ./../../openfl/events/TouchEvent */ "./node_modules/openfl/lib/_gen/openfl/events/TouchEvent.js");}
function lime_ui_Gamepad() {return __webpack_require__(/*! ./../../lime/ui/Gamepad */ "./node_modules/openfl/lib/_gen/lime/ui/Gamepad.js");}
function lime_ui_Touch() {return __webpack_require__(/*! ./../../lime/ui/Touch */ "./node_modules/openfl/lib/_gen/lime/ui/Touch.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function openfl_errors_IllegalOperationError() {return __webpack_require__(/*! ./../../openfl/errors/IllegalOperationError */ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js");}
function openfl_geom_Matrix() {return __webpack_require__(/*! ./../../openfl/geom/Matrix */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl_display_Stage3D() {return __webpack_require__(/*! ./../../openfl/display/Stage3D */ "./node_modules/openfl/lib/_gen/openfl/display/Stage3D.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function openfl_display_LoaderInfo() {return __webpack_require__(/*! ./../../openfl/display/LoaderInfo */ "./node_modules/openfl/lib/_gen/openfl/display/LoaderInfo.js");}
function openfl_display_Application() {return __webpack_require__(/*! ./../../openfl/display/Application */ "./node_modules/openfl/lib/_gen/openfl/display/Application.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}

// Constructor

var Stage = function(width,height,color,documentClass,windowAttributes) {
	if(height == null) {
		height = 0;
	}
	if(width == null) {
		width = 0;
	}
	(openfl_display_DisplayObjectContainer().default).call(this);
	this.set_name(null);
	this.__color = -1;
	this.__colorSplit = [255,255,255];
	this.__colorString = "#FFFFFF";
	this.__contentsScaleFactor = 1;
	this.__currentTabOrderIndex = 0;
	this.__deltaTime = 0;
	this.__displayState = "normal";
	this.__mouseX = 0;
	this.__mouseY = 0;
	this.__lastClickTime = 0;
	this.__logicalWidth = 0;
	this.__logicalHeight = 0;
	this.__displayMatrix = new (openfl_geom_Matrix().default)();
	this.__displayRect = new (openfl_geom_Rectangle().default)();
	this.__renderDirty = true;
	this.stage3Ds = (openfl__$Vector_Vector_$Impl_$().default)._new();
	(openfl__$Vector_Vector_$Impl_$().default).push(this.stage3Ds,new (openfl_display_Stage3D().default)(this));
	(openfl__$Vector_Vector_$Impl_$().default).push(this.stage3Ds,new (openfl_display_Stage3D().default)(this));
	(openfl__$Vector_Vector_$Impl_$().default).push(this.stage3Ds,new (openfl_display_Stage3D().default)(this));
	(openfl__$Vector_Vector_$Impl_$().default).push(this.stage3Ds,new (openfl_display_Stage3D().default)(this));
	this.stage = this;
	this.align = "topLeft";
	this.allowsFullScreen = true;
	this.allowsFullScreenInteractive = true;
	this.__quality = "high";
	this.__scaleMode = "noScale";
	this.showDefaultContextMenu = true;
	this.softKeyboardRect = new (openfl_geom_Rectangle().default)();
	this.stageFocusRect = true;
	this.__macKeyboard = /AppleWebKit/.test (navigator.userAgent) && /Mobile\/\w+/.test (navigator.userAgent) || /Mac/.test (navigator.platform);
	this.__clearBeforeRender = true;
	this.__forceRender = false;
	this.__stack = [];
	this.__rollOutStack = [];
	this.__mouseOutStack = [];
	this.__touchData = new (haxe_ds_IntMap().default)();
	if(windowAttributes == null) {
		windowAttributes = { };
	}
	var app = null;
	if(!isNaN(width)) {
		if((openfl_Lib().default).get_current().__loaderInfo == null) {
			(openfl_Lib().default).get_current().__loaderInfo = (openfl_display_LoaderInfo().default).create(null);
			(openfl_Lib().default).get_current().__loaderInfo.content = (openfl_Lib().default).get_current();
		}
		var resizable = width == 0 && width == 0;
		this.element = window.document.createElement("div");
		if(resizable) {
			this.element.style.width = "100%";
			this.element.style.height = "100%";
		}
		windowAttributes.width = width;
		windowAttributes.height = height;
		windowAttributes.element = this.element;
		windowAttributes.resizable = resizable;
		windowAttributes.stage = this;
		if(!(Reflect().default).hasField(windowAttributes,"context")) {
			windowAttributes.context = { };
		}
		var contextAttributes = windowAttributes.context;
		if((Reflect().default).hasField(windowAttributes,"renderer")) {
			var type = (Std().default).string(windowAttributes.renderer);
			if(type == "webgl1") {
				contextAttributes.type = "webgl";
				contextAttributes.version = "1";
			} else if(type == "webgl2") {
				contextAttributes.type = "webgl";
				contextAttributes.version = "2";
			} else {
				(Reflect().default).setField(contextAttributes,"type",windowAttributes.renderer);
			}
		}
		if(!(Reflect().default).hasField(contextAttributes,"stencil")) {
			contextAttributes.stencil = true;
		}
		if(!(Reflect().default).hasField(contextAttributes,"depth")) {
			contextAttributes.depth = true;
		}
		if(!(Reflect().default).hasField(contextAttributes,"background")) {
			contextAttributes.background = null;
		}
		app = new (openfl_display_Application().default)();
		this.window = app.createWindow(windowAttributes);
		this.set_color(color);
	} else {
		this.window = width;
		this.set_color(height);
	}
	this.__contentsScaleFactor = this.window.get_scale();
	this.__wasFullscreen = this.window.get_fullscreen();
	this.__resize();
	if((openfl_Lib().default).get_current().stage == null) {
		this.stage.addChild((openfl_Lib().default).get_current());
	}
	if(documentClass != null) {
		(openfl_display_DisplayObject().default).__initStage = this;
		var sprite = (Type().default).createInstance(documentClass,[]);
		sprite.dispatchEvent(new (openfl_events_Event().default)("addedToStage",false,false));
	}
	if(app != null) {
		app.addModule(this);
		app.exec();
	}
}

// Meta

Stage.__name__ = "openfl.display.Stage";
Stage.__isInterface__ = false;
Stage.__interfaces__ = [(lime_app_IModule().default)];
Stage.__super__ = (openfl_display_DisplayObjectContainer().default);
Stage.prototype = $extend((openfl_display_DisplayObjectContainer().default).prototype, {
	invalidate: function() {
		this.__invalidated = true;
		this.__renderDirty = true;
	},
	localToGlobal: function(pos) {
		return pos.clone();
	},
	__broadcastEvent: function(event) {
		if((openfl_display_DisplayObject().default).__broadcastEvents.exists(event.type)) {
			var dispatchers = (openfl_display_DisplayObject().default).__broadcastEvents.get(event.type);
			var _g = 0;
			while(_g < dispatchers.length) {
				var dispatcher = dispatchers[_g];
				++_g;
				if(dispatcher.stage == this || dispatcher.stage == null) {
					try {
						dispatcher.__dispatch(event);
					} catch( e ) {
						(haxe_CallStack().default).lastException = e;
						this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
					}
				}
			}
		}
	},
	__createRenderer: function() {
		var pixelRatio = 1;
		if(this.window.get_scale() > 1) {
			pixelRatio = this.window.devicePixelRatio || 1;
		}
		var windowWidth = (Std().default).int(this.window.get_width() * this.window.get_scale());
		var windowHeight = (Std().default).int(this.window.get_height() * this.window.get_scale());
		switch(this.window.context.type) {
		case "cairo":
			break;
		case "canvas":
			this.__renderer = new (openfl_display_CanvasRenderer().default)(this.window.context.canvas2D);
			((js_Boot().default).__cast(this.__renderer , (openfl_display_CanvasRenderer().default))).pixelRatio = pixelRatio;
			break;
		case "dom":
			this.__renderer = new (openfl_display_DOMRenderer().default)(this.window.context.dom);
			((js_Boot().default).__cast(this.__renderer , (openfl_display_DOMRenderer().default))).pixelRatio = pixelRatio;
			break;
		case "opengl":case "opengles":case "webgl":
			this.context3D = new (openfl_display3D_Context3D().default)(this);
			this.context3D.configureBackBuffer(windowWidth,windowHeight,0,true,true,true);
			this.context3D.present();
			this.__renderer = new (openfl_display_OpenGLRenderer().default)(this.context3D);
			break;
		default:
		}
		if(this.__renderer != null) {
			var tmp = this.get_quality();
			this.__renderer.__allowSmoothing = tmp != "low";
			this.__renderer.__worldTransform = this.__displayMatrix;
			this.__renderer.__stage = this;
			this.__renderer.__resize(windowWidth,windowHeight);
		}
	},
	__dispatchEvent: function(event) {
		try {
			return (openfl_display_DisplayObjectContainer().default).prototype.__dispatchEvent.call(this,event);
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
			return false;
		}
	},
	__dispatchPendingMouseEvent: function() {
		if(this.__pendingMouseEvent) {
			this.__onMouse("mouseMove",this.__pendingMouseX,this.__pendingMouseY,0);
			this.__pendingMouseEvent = false;
		}
	},
	__dispatchStack: function(event,stack) {
		try {
			var target;
			var length = stack.length;
			if(length == 0) {
				event.eventPhase = 2;
				target = event.target;
				target.__dispatch(event);
			} else {
				event.eventPhase = 1;
				event.target = stack[stack.length - 1];
				var _g = 0;
				var _g1 = length - 1;
				while(_g < _g1) {
					var i = _g++;
					stack[i].__dispatch(event);
					if(event.__isCanceled) {
						return;
					}
				}
				event.eventPhase = 2;
				target = event.target;
				target.__dispatch(event);
				if(event.__isCanceled) {
					return;
				}
				if(event.bubbles) {
					event.eventPhase = 3;
					var i1 = length - 2;
					while(i1 >= 0) {
						stack[i1].__dispatch(event);
						if(event.__isCanceled) {
							return;
						}
						--i1;
					}
				}
			}
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
		}
	},
	__dispatchTarget: function(target,event) {
		try {
			return target.__dispatchEvent(event);
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
			return false;
		}
	},
	__drag: function(mouse) {
		var parent = this.__dragObject.parent;
		if(parent != null) {
			parent.__getWorldTransform().__transformInversePoint(mouse);
		}
		var x = mouse.x + this.__dragOffsetX;
		var y = mouse.y + this.__dragOffsetY;
		if(this.__dragBounds != null) {
			if(x < this.__dragBounds.x) {
				x = this.__dragBounds.x;
			} else if(x > this.__dragBounds.get_right()) {
				x = this.__dragBounds.get_right();
			}
			if(y < this.__dragBounds.y) {
				y = this.__dragBounds.y;
			} else if(y > this.__dragBounds.get_bottom()) {
				y = this.__dragBounds.get_bottom();
			}
		}
		this.__dragObject.set_x(x);
		this.__dragObject.set_y(y);
	},
	__getInteractive: function(stack) {
		if(stack != null) {
			stack.push(this);
		}
		return true;
	},
	__globalToLocal: function(global,local) {
		if(global != local) {
			local.copyFrom(global);
		}
		return local;
	},
	__handleError: function(e) {
		var event = new (openfl_events_UncaughtErrorEvent().default)("uncaughtError",true,true,e);
		try {
			(openfl_Lib().default).get_current().__loaderInfo.uncaughtErrorEvents.dispatchEvent(event);
		} catch( e1 ) {
			(haxe_CallStack().default).lastException = e1;
			var e2 = ((e1) instanceof (js__$Boot_HaxeError().default)) ? e1.val : e1;
		}
		if(!event.__preventDefault) {
			try {
				var exc = (haxe_CallStack().default).lastException;
				if(exc != null && (Reflect().default).hasField(exc,"stack") && exc.stack != null && exc.stack != "") {
					console.log(exc.stack);
					e.stack = exc.stack;
				} else {
					var msg = (haxe_CallStack().default).toString((haxe_CallStack().default).callStack());
					console.log(msg);
				}
			} catch( e21 ) {
				(haxe_CallStack().default).lastException = e21;
				var e22 = ((e21) instanceof (js__$Boot_HaxeError().default)) ? e21.val : e21;
			}
			throw e;
		}
	},
	__onKey: function(type,keyCode,modifier) {
		this.__dispatchPendingMouseEvent();
		(openfl_events_MouseEvent().default).__altKey = (lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_altKey(modifier);
		(openfl_events_MouseEvent().default).__commandKey = (lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_metaKey(modifier);
		(openfl_events_MouseEvent().default).__ctrlKey = (lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_ctrlKey(modifier);
		(openfl_events_MouseEvent().default).__shiftKey = (lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_shiftKey(modifier);
		var stack = [];
		if(this.__focus == null) {
			this.__getInteractive(stack);
		} else {
			this.__focus.__getInteractive(stack);
		}
		if(stack.length > 0) {
			var keyLocation = (openfl_ui_Keyboard().default).__getKeyLocation(keyCode);
			var keyCode1 = (openfl_ui_Keyboard().default).__convertKeyCode(keyCode);
			var charCode = (openfl_ui_Keyboard().default).__getCharCode(keyCode1,(lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_shiftKey(modifier));
			var event = new (openfl_events_KeyboardEvent().default)(type,true,true,charCode,keyCode1,keyLocation,this.__macKeyboard ? (lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_ctrlKey(modifier) || (lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_metaKey(modifier) : (lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_ctrlKey(modifier),(lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_altKey(modifier),(lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_shiftKey(modifier),(lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_ctrlKey(modifier),(lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_metaKey(modifier));
			stack.reverse();
			this.__dispatchStack(event,stack);
			if(event.__preventDefault) {
				if(type == "keyDown") {
					this.window.onKeyDown.cancel();
				} else {
					this.window.onKeyUp.cancel();
				}
			} else if(type == "keyDown" && keyCode1 == 9) {
				var tabStack = [];
				this.__tabTest(tabStack);
				var nextIndex = -1;
				var nextObject = null;
				var nextOffset = (lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_shiftKey(modifier) ? -1 : 1;
				if(tabStack.length > 1) {
					(haxe_ds_ArraySort().default).sort(tabStack,function(a,b) {
						return a.get_tabIndex() - b.get_tabIndex();
					});
					if(tabStack[tabStack.length - 1].get_tabIndex() == -1) {
						if(this.get_focus() != null) {
							nextIndex = 0;
						} else {
							nextIndex = this.__currentTabOrderIndex;
						}
					} else {
						var i = 0;
						while(i < tabStack.length) {
							if(tabStack[i].get_tabIndex() > -1) {
								if(i > 0) {
									tabStack.splice(0,i);
								}
								break;
							}
							++i;
						}
						if(this.get_focus() != null) {
							var index = tabStack.indexOf(this.get_focus());
							if(index < 0) {
								nextIndex = 0;
							} else {
								nextIndex = index + nextOffset;
							}
						} else {
							nextIndex = this.__currentTabOrderIndex;
						}
					}
				} else if(tabStack.length == 1) {
					nextObject = tabStack[0];
					if(this.get_focus() == nextObject) {
						nextObject = null;
					}
				}
				if(tabStack.length == 1 || tabStack.length == 0 && this.get_focus() != null) {
					nextIndex = 0;
				} else if(tabStack.length > 1) {
					if(nextIndex < 0) {
						nextIndex += tabStack.length;
					}
					nextIndex %= tabStack.length;
					nextObject = tabStack[nextIndex];
					if(nextObject == this.get_focus()) {
						nextIndex += nextOffset;
						if(nextIndex < 0) {
							nextIndex += tabStack.length;
						}
						nextIndex %= tabStack.length;
						nextObject = tabStack[nextIndex];
					}
				}
				var focusEvent = null;
				if(this.get_focus() != null) {
					focusEvent = new (openfl_events_FocusEvent().default)("keyFocusChange",true,true,nextObject,(lime_ui__$KeyModifier_KeyModifier_$Impl_$().default).get_shiftKey(modifier),0);
					stack = [];
					this.get_focus().__getInteractive(stack);
					stack.reverse();
					this.__dispatchStack(focusEvent,stack);
				}
				if(focusEvent == null || !focusEvent.isDefaultPrevented()) {
					this.__currentTabOrderIndex = nextIndex;
					if(nextObject != null) {
						this.set_focus(nextObject);
					}
				}
			}
		}
	},
	__onLimeCreateWindow: function($window) {
		if(this.window != $window) {
			return;
		}
		var f = $bind(this,this.__onLimeWindowActivate);
		var window1 = $window;
		var tmp = function() {
			f(window1);
		};
		$window.onActivate.add(tmp);
		var f1 = $bind(this,this.__onLimeWindowClose);
		var window2 = $window;
		var tmp1 = function() {
			f1(window2);
		};
		$window.onClose.add(tmp1,false,-9000);
		var f2 = $bind(this,this.__onLimeWindowDeactivate);
		var window3 = $window;
		var tmp2 = function() {
			f2(window3);
		};
		$window.onDeactivate.add(tmp2);
		var f3 = $bind(this,this.__onLimeWindowDropFile);
		var window4 = $window;
		var tmp3 = function(file) {
			f3(window4,file);
		};
		$window.onDropFile.add(tmp3);
		var f4 = $bind(this,this.__onLimeWindowEnter);
		var window5 = $window;
		var tmp4 = function() {
			f4(window5);
		};
		$window.onEnter.add(tmp4);
		var f5 = $bind(this,this.__onLimeWindowExpose);
		var window6 = $window;
		var tmp5 = function() {
			f5(window6);
		};
		$window.onExpose.add(tmp5);
		var f6 = $bind(this,this.__onLimeWindowFocusIn);
		var window7 = $window;
		var tmp6 = function() {
			f6(window7);
		};
		$window.onFocusIn.add(tmp6);
		var f7 = $bind(this,this.__onLimeWindowFocusOut);
		var window8 = $window;
		var tmp7 = function() {
			f7(window8);
		};
		$window.onFocusOut.add(tmp7);
		var f8 = $bind(this,this.__onLimeWindowFullscreen);
		var window9 = $window;
		var tmp8 = function() {
			f8(window9);
		};
		$window.onFullscreen.add(tmp8);
		var f9 = $bind(this,this.__onLimeKeyDown);
		var window10 = $window;
		var tmp9 = function(keyCode,modifier) {
			f9(window10,keyCode,modifier);
		};
		$window.onKeyDown.add(tmp9);
		var f10 = $bind(this,this.__onLimeKeyUp);
		var window11 = $window;
		var tmp10 = function(keyCode1,modifier1) {
			f10(window11,keyCode1,modifier1);
		};
		$window.onKeyUp.add(tmp10);
		var f11 = $bind(this,this.__onLimeWindowLeave);
		var window12 = $window;
		var tmp11 = function() {
			f11(window12);
		};
		$window.onLeave.add(tmp11);
		var f12 = $bind(this,this.__onLimeWindowMinimize);
		var window13 = $window;
		var tmp12 = function() {
			f12(window13);
		};
		$window.onMinimize.add(tmp12);
		var f13 = $bind(this,this.__onLimeMouseDown);
		var window14 = $window;
		var tmp13 = function(x,y,button) {
			f13(window14,x,y,button);
		};
		$window.onMouseDown.add(tmp13);
		var f14 = $bind(this,this.__onLimeMouseMove);
		var window15 = $window;
		var tmp14 = function(x1,y1) {
			f14(window15,x1,y1);
		};
		$window.onMouseMove.add(tmp14);
		var f15 = $bind(this,this.__onLimeMouseMoveRelative);
		var window16 = $window;
		var tmp15 = function(x2,y2) {
			f15(window16,x2,y2);
		};
		$window.onMouseMoveRelative.add(tmp15);
		var f16 = $bind(this,this.__onLimeMouseUp);
		var window17 = $window;
		var tmp16 = function(x3,y3,button1) {
			f16(window17,x3,y3,button1);
		};
		$window.onMouseUp.add(tmp16);
		var f17 = $bind(this,this.__onLimeMouseWheel);
		var window18 = $window;
		var tmp17 = function(deltaX,deltaY,deltaMode) {
			f17(window18,deltaX,deltaY,deltaMode);
		};
		$window.onMouseWheel.add(tmp17);
		var f18 = $bind(this,this.__onLimeWindowMove);
		var window19 = $window;
		var tmp18 = function(x4,y4) {
			f18(window19,x4,y4);
		};
		$window.onMove.add(tmp18);
		$window.onRender.add($bind(this,this.__onLimeRender));
		$window.onRenderContextLost.add($bind(this,this.__onLimeRenderContextLost));
		$window.onRenderContextRestored.add($bind(this,this.__onLimeRenderContextRestored));
		var f19 = $bind(this,this.__onLimeWindowResize);
		var window20 = $window;
		var tmp19 = function(width,height) {
			f19(window20,width,height);
		};
		$window.onResize.add(tmp19);
		var f20 = $bind(this,this.__onLimeWindowRestore);
		var window21 = $window;
		var tmp20 = function() {
			f20(window21);
		};
		$window.onRestore.add(tmp20);
		var f21 = $bind(this,this.__onLimeTextEdit);
		var window22 = $window;
		var tmp21 = function(text,start,length) {
			f21(window22,text,start,length);
		};
		$window.onTextEdit.add(tmp21);
		var f22 = $bind(this,this.__onLimeTextInput);
		var window23 = $window;
		var tmp22 = function(text1) {
			f22(window23,text1);
		};
		$window.onTextInput.add(tmp22);
		this.__onLimeWindowCreate($window);
	},
	__onLimeGamepadAxisMove: function(gamepad,axis,value) {
		try {
			(openfl_ui_GameInput().default).__onGamepadAxisMove(gamepad,axis,value);
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
		}
	},
	__onLimeGamepadButtonDown: function(gamepad,button) {
		try {
			(openfl_ui_GameInput().default).__onGamepadButtonDown(gamepad,button);
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
		}
	},
	__onLimeGamepadButtonUp: function(gamepad,button) {
		try {
			(openfl_ui_GameInput().default).__onGamepadButtonUp(gamepad,button);
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
		}
	},
	__onLimeGamepadConnect: function(gamepad) {
		try {
			(openfl_ui_GameInput().default).__onGamepadConnect(gamepad);
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
		}
		var f = $bind(this,this.__onLimeGamepadAxisMove);
		var gamepad1 = gamepad;
		var tmp = function(axis,value) {
			f(gamepad1,axis,value);
		};
		gamepad.onAxisMove.add(tmp);
		var f1 = $bind(this,this.__onLimeGamepadButtonDown);
		var gamepad2 = gamepad;
		var tmp1 = function(button) {
			f1(gamepad2,button);
		};
		gamepad.onButtonDown.add(tmp1);
		var f2 = $bind(this,this.__onLimeGamepadButtonUp);
		var gamepad3 = gamepad;
		var tmp2 = function(button1) {
			f2(gamepad3,button1);
		};
		gamepad.onButtonUp.add(tmp2);
		var f3 = $bind(this,this.__onLimeGamepadDisconnect);
		var gamepad4 = gamepad;
		var tmp3 = function() {
			f3(gamepad4);
		};
		gamepad.onDisconnect.add(tmp3);
	},
	__onLimeGamepadDisconnect: function(gamepad) {
		try {
			(openfl_ui_GameInput().default).__onGamepadDisconnect(gamepad);
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			this.__handleError(((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e);
		}
	},
	__onLimeKeyDown: function($window,keyCode,modifier) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__onKey("keyDown",keyCode,modifier);
	},
	__onLimeKeyUp: function($window,keyCode,modifier) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__onKey("keyUp",keyCode,modifier);
	},
	__onLimeModuleExit: function(code) {
		if(this.window != null) {
			var event = null;
			event = new (openfl_events_Event().default)("deactivate");
			this.__broadcastEvent(event);
		}
	},
	__onLimeMouseDown: function($window,x,y,button) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__dispatchPendingMouseEvent();
		var type;
		switch(button) {
		case 1:
			type = "middleMouseDown";
			break;
		case 2:
			type = "rightMouseDown";
			break;
		default:
			type = "mouseDown";
		}
		this.__onMouse(type,(Std().default).int(x * $window.get_scale()),(Std().default).int(y * $window.get_scale()),button);
		if(!this.showDefaultContextMenu && button == 2) {
			$window.onMouseDown.cancel();
		}
	},
	__onLimeMouseMove: function($window,x,y) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__pendingMouseEvent = true;
		this.__pendingMouseX = (Std().default).int(x * $window.get_scale());
		this.__pendingMouseY = (Std().default).int(y * $window.get_scale());
	},
	__onLimeMouseMoveRelative: function($window,x,y) {
	},
	__onLimeMouseUp: function($window,x,y,button) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__dispatchPendingMouseEvent();
		var type;
		switch(button) {
		case 1:
			type = "middleMouseUp";
			break;
		case 2:
			type = "rightMouseUp";
			break;
		default:
			type = "mouseUp";
		}
		this.__onMouse(type,(Std().default).int(x * $window.get_scale()),(Std().default).int(y * $window.get_scale()),button);
		if(!this.showDefaultContextMenu && button == 2) {
			$window.onMouseUp.cancel();
		}
	},
	__onLimeMouseWheel: function($window,deltaX,deltaY,deltaMode) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__dispatchPendingMouseEvent();
		if(deltaMode == (lime_ui_MouseWheelMode().default).PIXELS) {
			this.__onMouseWheel((Std().default).int(deltaX * $window.get_scale()),(Std().default).int(deltaY * $window.get_scale()),deltaMode);
		} else {
			this.__onMouseWheel((Std().default).int(deltaX),(Std().default).int(deltaY),deltaMode);
		}
	},
	__onLimeRender: function(context) {
		if(this.__rendering) {
			return;
		}
		this.__rendering = true;
		var event = null;
		this.__broadcastEvent(new (openfl_events_Event().default)("enterFrame"));
		this.__broadcastEvent(new (openfl_events_Event().default)("frameConstructed"));
		this.__broadcastEvent(new (openfl_events_Event().default)("exitFrame"));
		this.__renderable = true;
		this.__enterFrame(this.__deltaTime);
		this.__deltaTime = 0;
		var shouldRender = this.__renderer != null && (this.__renderDirty || this.__forceRender);
		if(this.__invalidated && shouldRender) {
			this.__invalidated = false;
			event = new (openfl_events_Event().default)("render");
			this.__broadcastEvent(event);
		}
		this.__update(false,true);
		if(this.__renderer != null) {
			if(this.context3D != null) {
				var stage3D = new (openfl__$Vector_VectorIterator().default)(this.stage3Ds);
				while(stage3D.hasNext()) {
					var stage3D1 = stage3D.next();
					this.context3D.__renderStage3D(stage3D1);
				}
				if(this.context3D.__present) {
					shouldRender = true;
				}
			}
			if(shouldRender) {
				var tmp = this.__renderer.__type == "cairo";
				if(this.context3D == null) {
					this.__renderer.__clear();
				}
				this.__renderer.__render(this);
			} else if(this.context3D == null) {
				this.window.onRender.cancel();
			}
			if(this.context3D != null) {
				if(!this.context3D.__present) {
					this.window.onRender.cancel();
				} else {
					if(!this.__renderer.__cleared) {
						this.__renderer.__clear();
					}
					this.context3D.__present = false;
					this.context3D.__cleared = false;
				}
			}
			this.__renderer.__cleared = false;
		}
		this.__rendering = false;
	},
	__onLimeRenderContextLost: function() {
		this.__renderer = null;
		this.context3D = null;
		var stage3D = new (openfl__$Vector_VectorIterator().default)(this.stage3Ds);
		while(stage3D.hasNext()) {
			var stage3D1 = stage3D.next();
			stage3D1.__lostContext();
		}
	},
	__onLimeRenderContextRestored: function(context) {
		this.__createRenderer();
		var stage3D = new (openfl__$Vector_VectorIterator().default)(this.stage3Ds);
		while(stage3D.hasNext()) {
			var stage3D1 = stage3D.next();
			stage3D1.__restoreContext();
		}
	},
	__onLimeTextEdit: function($window,text,start,length) {
	},
	__onLimeTextInput: function($window,text) {
		if(this.window == null || this.window != $window) {
			return;
		}
		var stack = [];
		if(this.__focus == null) {
			this.__getInteractive(stack);
		} else {
			this.__focus.__getInteractive(stack);
		}
		var event = new (openfl_events_TextEvent().default)("textInput",true,true,text);
		if(stack.length > 0) {
			stack.reverse();
			this.__dispatchStack(event,stack);
		} else {
			this.__dispatchEvent(event);
		}
		if(event.isDefaultPrevented()) {
			$window.onTextInput.cancel();
		}
	},
	__onLimeTouchCancel: function(touch) {
		if(this.__primaryTouch == touch) {
			this.__primaryTouch = null;
		}
		this.__onTouch("touchEnd",touch);
	},
	__onLimeTouchMove: function(touch) {
		this.__onTouch("touchMove",touch);
	},
	__onLimeTouchEnd: function(touch) {
		if(this.__primaryTouch == touch) {
			this.__primaryTouch = null;
		}
		this.__onTouch("touchEnd",touch);
	},
	__onLimeTouchStart: function(touch) {
		if(this.__primaryTouch == null) {
			this.__primaryTouch = touch;
		}
		this.__onTouch("touchBegin",touch);
	},
	__onLimeUpdate: function(deltaTime) {
		this.__deltaTime = deltaTime;
		this.__dispatchPendingMouseEvent();
	},
	__onLimeWindowActivate: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
	},
	__onLimeWindowClose: function($window) {
		if(this.window == $window) {
			this.window = null;
		}
		this.__primaryTouch = null;
		var event = null;
		event = new (openfl_events_Event().default)("deactivate");
		this.__broadcastEvent(event);
	},
	__onLimeWindowCreate: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
		if($window.context != null) {
			this.__createRenderer();
		}
	},
	__onLimeWindowDeactivate: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
	},
	__onLimeWindowDropFile: function($window,file) {
	},
	__onLimeWindowEnter: function($window) {
	},
	__onLimeWindowExpose: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__renderDirty = true;
	},
	__onLimeWindowFocusIn: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__renderDirty = true;
		var event = null;
		event = new (openfl_events_Event().default)("activate");
		this.__broadcastEvent(event);
		this.set_focus(this.__cacheFocus);
	},
	__onLimeWindowFocusOut: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__primaryTouch = null;
		var event = null;
		event = new (openfl_events_Event().default)("deactivate");
		this.__broadcastEvent(event);
		var currentFocus = this.get_focus();
		this.set_focus(null);
		this.__cacheFocus = currentFocus;
		(openfl_events_MouseEvent().default).__altKey = false;
		(openfl_events_MouseEvent().default).__commandKey = false;
		(openfl_events_MouseEvent().default).__ctrlKey = false;
		(openfl_events_MouseEvent().default).__shiftKey = false;
	},
	__onLimeWindowFullscreen: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__resize();
		if(!this.__wasFullscreen) {
			this.__wasFullscreen = true;
			if(this.__displayState == "normal") {
				this.__displayState = "fullScreenInteractive";
			}
			this.__dispatchEvent(new (openfl_events_FullScreenEvent().default)("fullScreen",false,false,true,true));
		}
	},
	__onLimeWindowLeave: function($window) {
		if(this.window == null || this.window != $window || (openfl_events_MouseEvent().default).__buttonDown) {
			return;
		}
		this.__dispatchPendingMouseEvent();
		var event = null;
		event = new (openfl_events_Event().default)("mouseLeave");
		this.__dispatchEvent(event);
	},
	__onLimeWindowMinimize: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
	},
	__onLimeWindowMove: function($window,x,y) {
	},
	__onLimeWindowResize: function($window,width,height) {
		if(this.window == null || this.window != $window) {
			return;
		}
		this.__resize();
		if(this.__wasFullscreen && !$window.get_fullscreen()) {
			this.__wasFullscreen = false;
			this.__displayState = "normal";
			this.__dispatchEvent(new (openfl_events_FullScreenEvent().default)("fullScreen",false,false,false,true));
		}
	},
	__onLimeWindowRestore: function($window) {
		if(this.window == null || this.window != $window) {
			return;
		}
		if(this.__wasFullscreen && !$window.get_fullscreen()) {
			this.__wasFullscreen = false;
			this.__displayState = "normal";
			this.__dispatchEvent(new (openfl_events_FullScreenEvent().default)("fullScreen",false,false,false,true));
		}
	},
	__onMouse: function(type,x,y,button) {
		if(button > 2) {
			return;
		}
		var targetPoint = (openfl_geom_Point().default).__pool.get();
		targetPoint.setTo(x,y);
		this.__displayMatrix.__transformInversePoint(targetPoint);
		this.__mouseX = targetPoint.x;
		this.__mouseY = targetPoint.y;
		var stack = [];
		var target = null;
		if(this.__hitTest(this.__mouseX,this.__mouseY,true,stack,true,this)) {
			target = stack[stack.length - 1];
		} else {
			target = this;
			stack = [this];
		}
		if(target == null) {
			target = this;
		}
		var clickType = null;
		switch(type) {
		case "middleMouseDown":
			this.__mouseDownMiddle = target;
			break;
		case "middleMouseUp":
			if(this.__mouseDownMiddle == target) {
				clickType = "middleClick";
			}
			this.__mouseDownMiddle = null;
			break;
		case "mouseDown":
			if(target.__allowMouseFocus()) {
				if(this.get_focus() != null) {
					var focusEvent = new (openfl_events_FocusEvent().default)("mouseFocusChange",true,true,target,false,0);
					this.__dispatchStack(focusEvent,stack);
					if(!focusEvent.isDefaultPrevented()) {
						this.set_focus(target);
					}
				} else {
					this.set_focus(target);
				}
			} else {
				this.set_focus(null);
			}
			this.__mouseDownLeft = target;
			(openfl_events_MouseEvent().default).__buttonDown = true;
			break;
		case "mouseUp":
			if(this.__mouseDownLeft != null) {
				(openfl_events_MouseEvent().default).__buttonDown = false;
				if(this.__mouseDownLeft == target) {
					clickType = "click";
				} else {
					var event = null;
					event = (openfl_events_MouseEvent().default).__create("releaseOutside",1,this.__mouseX,this.__mouseY,new (openfl_geom_Point().default)(this.__mouseX,this.__mouseY),this);
					this.__mouseDownLeft.dispatchEvent(event);
				}
				this.__mouseDownLeft = null;
			}
			break;
		case "rightMouseDown":
			this.__mouseDownRight = target;
			break;
		case "rightMouseUp":
			if(this.__mouseDownRight == target) {
				clickType = "rightClick";
			}
			this.__mouseDownRight = null;
			break;
		default:
		}
		var localPoint = (openfl_geom_Point().default).__pool.get();
		var event1 = null;
		event1 = (openfl_events_MouseEvent().default).__create(type,button,this.__mouseX,this.__mouseY,target.__globalToLocal(targetPoint,localPoint),target);
		this.__dispatchStack(event1,stack);
		if(clickType != null) {
			event1 = (openfl_events_MouseEvent().default).__create(clickType,button,this.__mouseX,this.__mouseY,target.__globalToLocal(targetPoint,localPoint),target);
			this.__dispatchStack(event1,stack);
			if(type == "mouseUp" && ((js_Boot().default).__cast(target , (openfl_display_InteractiveObject().default))).doubleClickEnabled) {
				var currentTime = (openfl_Lib().default).getTimer();
				if(currentTime - this.__lastClickTime < 500) {
					event1 = (openfl_events_MouseEvent().default).__create("doubleClick",button,this.__mouseX,this.__mouseY,target.__globalToLocal(targetPoint,localPoint),target);
					this.__dispatchStack(event1,stack);
					this.__lastClickTime = 0;
				} else {
					this.__lastClickTime = currentTime;
				}
			}
		}
		if((openfl_ui_Mouse().default).__cursor == "auto" && !(openfl_ui_Mouse().default).__hidden) {
			var cursor = null;
			if(this.__mouseDownLeft != null) {
				cursor = this.__mouseDownLeft.__getCursor();
			} else {
				var _g = 0;
				while(_g < stack.length) {
					var target1 = stack[_g];
					++_g;
					cursor = target1.__getCursor();
					if(cursor != null) {
						this.window.set_cursor((openfl_ui__$MouseCursor_MouseCursor_$Impl_$().default).toLimeCursor(cursor));
						break;
					}
				}
			}
			if(cursor == null) {
				this.window.set_cursor((lime_ui_MouseCursor().default).ARROW);
			}
		}
		var event2;
		if(target != this.__mouseOverTarget) {
			if(this.__mouseOverTarget != null) {
				event2 = (openfl_events_MouseEvent().default).__create("mouseOut",button,this.__mouseX,this.__mouseY,this.__mouseOverTarget.__globalToLocal(targetPoint,localPoint),this.__mouseOverTarget);
				this.__dispatchStack(event2,this.__mouseOutStack);
			}
		}
		var item;
		var i = 0;
		while(i < this.__rollOutStack.length) {
			item = this.__rollOutStack[i];
			if(stack.indexOf(item) == -1) {
				(HxOverrides().default).remove(this.__rollOutStack,item);
				event2 = (openfl_events_MouseEvent().default).__create("rollOut",button,this.__mouseX,this.__mouseY,this.__mouseOverTarget.__globalToLocal(targetPoint,localPoint),this.__mouseOverTarget);
				event2.bubbles = false;
				this.__dispatchTarget(item,event2);
			} else {
				++i;
			}
		}
		var _g1 = 0;
		while(_g1 < stack.length) {
			var item1 = stack[_g1];
			++_g1;
			if(this.__rollOutStack.indexOf(item1) == -1 && this.__mouseOverTarget != null) {
				if(item1.hasEventListener("rollOver")) {
					event2 = (openfl_events_MouseEvent().default).__create("rollOver",button,this.__mouseX,this.__mouseY,this.__mouseOverTarget.__globalToLocal(targetPoint,localPoint),item1);
					event2.bubbles = false;
					this.__dispatchTarget(item1,event2);
				}
				if(item1.hasEventListener("rollOut") || item1.hasEventListener("rollOver")) {
					this.__rollOutStack.push(item1);
				}
			}
		}
		if(target != this.__mouseOverTarget) {
			if(target != null) {
				event2 = (openfl_events_MouseEvent().default).__create("mouseOver",button,this.__mouseX,this.__mouseY,target.__globalToLocal(targetPoint,localPoint),target);
				this.__dispatchStack(event2,stack);
			}
			this.__mouseOverTarget = target;
			this.__mouseOutStack = stack;
		}
		if(this.__dragObject != null) {
			this.__drag(targetPoint);
			var dropTarget = null;
			if(this.__mouseOverTarget == this.__dragObject) {
				var cacheMouseEnabled = this.__dragObject.mouseEnabled;
				var cacheMouseChildren = this.__dragObject.mouseChildren;
				this.__dragObject.mouseEnabled = false;
				this.__dragObject.mouseChildren = false;
				var stack1 = [];
				if(this.__hitTest(this.__mouseX,this.__mouseY,true,stack1,true,this)) {
					dropTarget = stack1[stack1.length - 1];
				}
				this.__dragObject.mouseEnabled = cacheMouseEnabled;
				this.__dragObject.mouseChildren = cacheMouseChildren;
			} else if(this.__mouseOverTarget != this) {
				dropTarget = this.__mouseOverTarget;
			}
			this.__dragObject.dropTarget = dropTarget;
		}
		(openfl_geom_Point().default).__pool.release(targetPoint);
		(openfl_geom_Point().default).__pool.release(localPoint);
	},
	__onMouseWheel: function(deltaX,deltaY,deltaMode) {
		var x = this.__mouseX;
		var y = this.__mouseY;
		var stack = [];
		var target = null;
		if(this.__hitTest(this.__mouseX,this.__mouseY,true,stack,true,this)) {
			target = stack[stack.length - 1];
		} else {
			target = this;
			stack = [this];
		}
		if(target == null) {
			target = this;
		}
		var targetPoint = (openfl_geom_Point().default).__pool.get();
		targetPoint.setTo(x,y);
		this.__displayMatrix.__transformInversePoint(targetPoint);
		var delta = (Std().default).int(deltaY);
		var event = (openfl_events_MouseEvent().default).__create("mouseWheel",0,this.__mouseX,this.__mouseY,target.__globalToLocal(targetPoint,targetPoint),target,delta);
		event.cancelable = true;
		this.__dispatchStack(event,stack);
		if(event.isDefaultPrevented()) {
			this.window.onMouseWheel.cancel();
		}
		(openfl_geom_Point().default).__pool.release(targetPoint);
	},
	__onTouch: function(type,touch) {
		var targetPoint = (openfl_geom_Point().default).__pool.get();
		targetPoint.setTo(Math.round(touch.x * this.window.get_width() * this.window.get_scale()),Math.round(touch.y * this.window.get_height() * this.window.get_scale()));
		this.__displayMatrix.__transformInversePoint(targetPoint);
		var touchX = targetPoint.x;
		var touchY = targetPoint.y;
		var stack = [];
		var target = null;
		if(this.__hitTest(touchX,touchY,false,stack,true,this)) {
			target = stack[stack.length - 1];
		} else {
			target = this;
			stack = [this];
		}
		if(target == null) {
			target = this;
		}
		var touchId = touch.id;
		var touchData = null;
		if(this.__touchData.exists(touchId)) {
			touchData = this.__touchData.get(touchId);
		} else {
			touchData = (openfl__$internal_utils_TouchData().default).__pool.get();
			touchData.reset();
			touchData.touch = touch;
			this.__touchData.set(touchId,touchData);
		}
		var touchType = null;
		var releaseTouchData = false;
		switch(type) {
		case "touchBegin":
			touchData.touchDownTarget = target;
			break;
		case "touchEnd":
			if(touchData.touchDownTarget == target) {
				touchType = "touchTap";
			}
			touchData.touchDownTarget = null;
			releaseTouchData = true;
			break;
		default:
		}
		var localPoint = (openfl_geom_Point().default).__pool.get();
		var isPrimaryTouchPoint = this.__primaryTouch == touch;
		var touchEvent = (openfl_events_TouchEvent().default).__create(type,null,touchX,touchY,target.__globalToLocal(targetPoint,localPoint),target);
		touchEvent.touchPointID = touchId;
		touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
		touchEvent.pressure = touch.pressure;
		this.__dispatchStack(touchEvent,stack);
		if(touchType != null) {
			touchEvent = (openfl_events_TouchEvent().default).__create(touchType,null,touchX,touchY,target.__globalToLocal(targetPoint,localPoint),target);
			touchEvent.touchPointID = touchId;
			touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
			touchEvent.pressure = touch.pressure;
			this.__dispatchStack(touchEvent,stack);
		}
		var touchOverTarget = touchData.touchOverTarget;
		if(target != touchOverTarget && touchOverTarget != null) {
			touchEvent = (openfl_events_TouchEvent().default).__create("touchOut",null,touchX,touchY,touchOverTarget.__globalToLocal(targetPoint,localPoint),touchOverTarget);
			touchEvent.touchPointID = touchId;
			touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
			touchEvent.pressure = touch.pressure;
			this.__dispatchTarget(touchOverTarget,touchEvent);
		}
		var touchOutStack = touchData.rollOutStack;
		var item;
		var i = 0;
		while(i < touchOutStack.length) {
			item = touchOutStack[i];
			if(stack.indexOf(item) == -1) {
				(HxOverrides().default).remove(touchOutStack,item);
				touchEvent = (openfl_events_TouchEvent().default).__create("touchRollOut",null,touchX,touchY,touchOverTarget.__globalToLocal(targetPoint,localPoint),touchOverTarget);
				touchEvent.touchPointID = touchId;
				touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
				touchEvent.bubbles = false;
				touchEvent.pressure = touch.pressure;
				this.__dispatchTarget(item,touchEvent);
			} else {
				++i;
			}
		}
		var _g = 0;
		while(_g < stack.length) {
			var item1 = stack[_g];
			++_g;
			if(touchOutStack.indexOf(item1) == -1) {
				if(item1.hasEventListener("touchRollOver")) {
					touchEvent = (openfl_events_TouchEvent().default).__create("touchRollOver",null,touchX,touchY,touchOverTarget.__globalToLocal(targetPoint,localPoint),item1);
					touchEvent.touchPointID = touchId;
					touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
					touchEvent.bubbles = false;
					touchEvent.pressure = touch.pressure;
					this.__dispatchTarget(item1,touchEvent);
				}
				if(item1.hasEventListener("touchRollOut")) {
					touchOutStack.push(item1);
				}
			}
		}
		if(target != touchOverTarget) {
			if(target != null) {
				touchEvent = (openfl_events_TouchEvent().default).__create("touchOver",null,touchX,touchY,target.__globalToLocal(targetPoint,localPoint),target);
				touchEvent.touchPointID = touchId;
				touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
				touchEvent.bubbles = true;
				touchEvent.pressure = touch.pressure;
				this.__dispatchTarget(target,touchEvent);
			}
			touchData.touchOverTarget = target;
		}
		(openfl_geom_Point().default).__pool.release(targetPoint);
		(openfl_geom_Point().default).__pool.release(localPoint);
		if(releaseTouchData) {
			this.__touchData.remove(touchId);
			touchData.reset();
			(openfl__$internal_utils_TouchData().default).__pool.release(touchData);
		}
	},
	__registerLimeModule: function(application) {
		application.onCreateWindow.add($bind(this,this.__onLimeCreateWindow));
		application.onUpdate.add($bind(this,this.__onLimeUpdate));
		application.onExit.add($bind(this,this.__onLimeModuleExit),false,0);
		var gamepad = (lime_ui_Gamepad().default).devices.iterator();
		while(gamepad.hasNext()) {
			var gamepad1 = gamepad.next();
			this.__onLimeGamepadConnect(gamepad1);
		}
		(lime_ui_Gamepad().default).onConnect.add($bind(this,this.__onLimeGamepadConnect));
		(lime_ui_Touch().default).onStart.add($bind(this,this.__onLimeTouchStart));
		(lime_ui_Touch().default).onMove.add($bind(this,this.__onLimeTouchMove));
		(lime_ui_Touch().default).onEnd.add($bind(this,this.__onLimeTouchEnd));
		(lime_ui_Touch().default).onCancel.add($bind(this,this.__onLimeTouchCancel));
	},
	__resize: function() {
		var cacheWidth = this.stageWidth;
		var cacheHeight = this.stageHeight;
		var windowWidth = (Std().default).int(this.window.get_width() * this.window.get_scale());
		var windowHeight = (Std().default).int(this.window.get_height() * this.window.get_scale());
		this.__logicalWidth = windowWidth;
		this.__logicalHeight = windowHeight;
		this.__displayMatrix.identity();
		if(this.get_fullScreenSourceRect() != null && this.window.get_fullscreen()) {
			this.stageWidth = (Std().default).int(this.get_fullScreenSourceRect().width);
			this.stageHeight = (Std().default).int(this.get_fullScreenSourceRect().height);
			var displayScaleX = windowWidth / this.stageWidth;
			var displayScaleY = windowHeight / this.stageHeight;
			this.__displayMatrix.translate(-this.get_fullScreenSourceRect().x,-this.get_fullScreenSourceRect().y);
			this.__displayMatrix.scale(displayScaleX,displayScaleY);
			this.__displayRect.setTo(this.get_fullScreenSourceRect().get_left(),this.get_fullScreenSourceRect().get_right(),this.get_fullScreenSourceRect().get_top(),this.get_fullScreenSourceRect().get_bottom());
		} else {
			if(this.__logicalWidth == 0 && this.__logicalHeight == 0) {
				this.stageWidth = windowWidth;
				this.stageHeight = windowHeight;
			} else {
				this.stageWidth = this.__logicalWidth;
				this.stageHeight = this.__logicalHeight;
				var scaleX = windowWidth / this.stageWidth;
				var scaleY = windowHeight / this.stageHeight;
				var targetScale = Math.min(scaleX,scaleY);
				var offsetX = Math.round((windowWidth - this.stageWidth * targetScale) / 2);
				var offsetY = Math.round((windowHeight - this.stageHeight * targetScale) / 2);
				this.__displayMatrix.scale(targetScale,targetScale);
				this.__displayMatrix.translate(offsetX,offsetY);
			}
			this.__displayRect.setTo(0,0,this.stageWidth,this.stageHeight);
		}
		if(this.context3D != null) {
			this.context3D.configureBackBuffer(windowWidth,windowHeight,0,true,true,true);
		}
		var stage3D = new (openfl__$Vector_VectorIterator().default)(this.stage3Ds);
		while(stage3D.hasNext()) {
			var stage3D1 = stage3D.next();
			stage3D1.__resize(windowWidth,windowHeight);
		}
		if(this.__renderer != null) {
			this.__renderer.__resize(windowWidth,windowHeight);
		}
		if(this.stageWidth != cacheWidth || this.stageHeight != cacheHeight) {
			this.__renderDirty = true;
			this.__setTransformDirty();
			var event = null;
			event = new (openfl_events_Event().default)("resize");
			this.__dispatchEvent(event);
		}
	},
	__setLogicalSize: function(width,height) {
		this.__logicalWidth = width;
		this.__logicalHeight = height;
		this.__resize();
	},
	__startDrag: function(sprite,lockCenter,bounds) {
		if(bounds == null) {
			this.__dragBounds = null;
		} else {
			this.__dragBounds = new (openfl_geom_Rectangle().default)();
			var right = bounds.get_right();
			var bottom = bounds.get_bottom();
			this.__dragBounds.x = right < bounds.x ? right : bounds.x;
			this.__dragBounds.y = bottom < bounds.y ? bottom : bounds.y;
			this.__dragBounds.width = Math.abs(bounds.width);
			this.__dragBounds.height = Math.abs(bounds.height);
		}
		this.__dragObject = sprite;
		if(this.__dragObject != null) {
			if(lockCenter) {
				this.__dragOffsetX = 0;
				this.__dragOffsetY = 0;
			} else {
				var mouse = (openfl_geom_Point().default).__pool.get();
				mouse.setTo(this.get_mouseX(),this.get_mouseY());
				var parent = this.__dragObject.parent;
				if(parent != null) {
					parent.__getWorldTransform().__transformInversePoint(mouse);
				}
				this.__dragOffsetX = this.__dragObject.get_x() - mouse.x;
				this.__dragOffsetY = this.__dragObject.get_y() - mouse.y;
				(openfl_geom_Point().default).__pool.release(mouse);
			}
		}
	},
	__stopDrag: function(sprite) {
		this.__dragBounds = null;
		this.__dragObject = null;
	},
	__unregisterLimeModule: function(application) {
		application.onCreateWindow.remove($bind(this,this.__onLimeCreateWindow));
		application.onUpdate.remove($bind(this,this.__onLimeUpdate));
		application.onExit.remove($bind(this,this.__onLimeModuleExit));
		(lime_ui_Gamepad().default).onConnect.remove($bind(this,this.__onLimeGamepadConnect));
		(lime_ui_Touch().default).onStart.remove($bind(this,this.__onLimeTouchStart));
		(lime_ui_Touch().default).onMove.remove($bind(this,this.__onLimeTouchMove));
		(lime_ui_Touch().default).onEnd.remove($bind(this,this.__onLimeTouchEnd));
		(lime_ui_Touch().default).onCancel.remove($bind(this,this.__onLimeTouchCancel));
	},
	__update: function(transformOnly,updateChildren) {
		if(transformOnly) {
			if(this.__transformDirty) {
				(openfl_display_DisplayObjectContainer().default).prototype.__update.call(this,true,updateChildren);
				if(updateChildren) {
					this.__transformDirty = false;
				}
			}
		} else if(this.__transformDirty || this.__renderDirty) {
			(openfl_display_DisplayObjectContainer().default).prototype.__update.call(this,false,updateChildren);
			if(updateChildren) {
				if((openfl_display_DisplayObject().default).__supportDOM) {
					this.__wasDirty = true;
				}
			}
		} else if(!this.__renderDirty && this.__wasDirty) {
			(openfl_display_DisplayObjectContainer().default).prototype.__update.call(this,false,updateChildren);
			if(updateChildren) {
				this.__wasDirty = false;
			}
		}
	},
	get_color: function() {
		return this.__color;
	},
	set_color: function(value) {
		if(value == null) {
			this.__transparent = true;
			value = 0;
		} else {
			this.__transparent = false;
		}
		if(this.__color != value) {
			var r = (value & 16711680) >>> 16;
			var g = (value & 65280) >>> 8;
			var b = value & 255;
			this.__colorSplit[0] = r / 255;
			this.__colorSplit[1] = g / 255;
			this.__colorSplit[2] = b / 255;
			this.__colorString = "#" + (StringTools().default).hex(value & 16777215,6);
			this.__renderDirty = true;
			this.__color = -16777216 | value & 16777215;
		}
		return value;
	},
	get_contentsScaleFactor: function() {
		return this.__contentsScaleFactor;
	},
	get_displayState: function() {
		return this.__displayState;
	},
	set_displayState: function(value) {
		if(this.window != null) {
			if(value == "normal") {
				if(this.window.get_fullscreen()) {
					this.window.set_fullscreen(false);
				}
			} else if(!this.window.get_fullscreen()) {
				this.window.set_fullscreen(true);
			}
		}
		return this.__displayState = value;
	},
	get_focus: function() {
		return this.__focus;
	},
	set_focus: function(value) {
		if(value != this.__focus) {
			var oldFocus = this.__focus;
			this.__focus = value;
			this.__cacheFocus = value;
			if(oldFocus != null) {
				var event = new (openfl_events_FocusEvent().default)("focusOut",true,false,value,false,0);
				var stack = [];
				oldFocus.__getInteractive(stack);
				stack.reverse();
				this.__dispatchStack(event,stack);
			}
			if(value != null) {
				var event1 = new (openfl_events_FocusEvent().default)("focusIn",true,false,oldFocus,false,0);
				var stack1 = [];
				value.__getInteractive(stack1);
				stack1.reverse();
				this.__dispatchStack(event1,stack1);
			}
		}
		return value;
	},
	get_frameRate: function() {
		if(this.window != null) {
			return this.window.get_frameRate();
		}
		return 0;
	},
	set_frameRate: function(value) {
		if(this.window != null) {
			return this.window.set_frameRate(value);
		}
		return value;
	},
	get_fullScreenHeight: function() {
		return Math.ceil(this.window.get_display().currentMode.height * this.window.get_scale());
	},
	get_fullScreenSourceRect: function() {
		if(this.__fullScreenSourceRect == null) {
			return null;
		} else {
			return this.__fullScreenSourceRect.clone();
		}
	},
	set_fullScreenSourceRect: function(value) {
		if(value == null) {
			if(this.__fullScreenSourceRect != null) {
				this.__fullScreenSourceRect = null;
				this.__resize();
			}
		} else if(!value.equals(this.__fullScreenSourceRect)) {
			this.__fullScreenSourceRect = value.clone();
			this.__resize();
		}
		return value;
	},
	get_fullScreenWidth: function() {
		return Math.ceil(this.window.get_display().currentMode.width * this.window.get_scale());
	},
	set_height: function(value) {
		return this.get_height();
	},
	get_mouseX: function() {
		return this.__mouseX;
	},
	get_mouseY: function() {
		return this.__mouseY;
	},
	get_quality: function() {
		return this.__quality;
	},
	set_quality: function(value) {
		this.__quality = value;
		if(this.__renderer != null) {
			var tmp = this.get_quality();
			this.__renderer.__allowSmoothing = tmp != "low";
		}
		return value;
	},
	set_rotation: function(value) {
		return 0;
	},
	get_scaleMode: function() {
		return this.__scaleMode;
	},
	set_scaleMode: function(value) {
		return this.__scaleMode = value;
	},
	set_scaleX: function(value) {
		return 0;
	},
	set_scaleY: function(value) {
		return 0;
	},
	get_tabEnabled: function() {
		return false;
	},
	set_tabEnabled: function(value) {
		throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Error: The Stage class does not implement this property or method."));
	},
	get_tabIndex: function() {
		return -1;
	},
	set_tabIndex: function(value) {
		throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Error: The Stage class does not implement this property or method."));
	},
	set_transform: function(value) {
		return this.get_transform();
	},
	set_width: function(value) {
		return this.get_width();
	},
	set_x: function(value) {
		return 0;
	},
	set_y: function(value) {
		return 0;
	}
});
Stage.prototype.__class__ = Stage.prototype.constructor = $hxClasses["openfl.display.Stage"] = Stage;

// Init

Object.defineProperties(Stage.prototype,{ color : { get : function () { return this.get_color (); }, set : function (v) { return this.set_color (v); }}, contentsScaleFactor : { get : function () { return this.get_contentsScaleFactor (); }}, displayState : { get : function () { return this.get_displayState (); }, set : function (v) { return this.set_displayState (v); }}, focus : { get : function () { return this.get_focus (); }, set : function (v) { return this.set_focus (v); }}, frameRate : { get : function () { return this.get_frameRate (); }, set : function (v) { return this.set_frameRate (v); }}, fullScreenHeight : { get : function () { return this.get_fullScreenHeight (); }}, fullScreenWidth : { get : function () { return this.get_fullScreenWidth (); }}, quality : { get : function () { return this.get_quality (); }, set : function (v) { return this.set_quality (v); }}, scaleMode : { get : function () { return this.get_scaleMode (); }, set : function (v) { return this.set_scaleMode (v); }}});

// Statics


Stage.__meta__ = { fields : { __broadcastEvent : { SuppressWarnings : ["checkstyle:Dynamic"]}, __dispatchEvent : { SuppressWarnings : [["checkstyle:Dynamic","checkstyle:LeftCurly"]]}, __dispatchStack : { SuppressWarnings : [["checkstyle:Dynamic","checkstyle:LeftCurly"]]}, __dispatchTarget : { SuppressWarnings : ["checkstyle:Dynamic"]}, __handleError : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = Stage;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Stage3D.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Stage3D.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Stage3D

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function haxe_Timer() {return __webpack_require__(/*! ./../../haxe/Timer */ "./node_modules/openfl/lib/_gen/haxe/Timer.js");}
function openfl_display3D_Context3D() {return __webpack_require__(/*! ./../../openfl/display3D/Context3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/Context3D.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function js_html__$CanvasElement_CanvasUtil() {return __webpack_require__(/*! ./../../js/html/_CanvasElement/CanvasUtil */ "./node_modules/openfl/lib/_gen/js/html/_CanvasElement/CanvasUtil.js");}
function openfl_events_ErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/ErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/ErrorEvent.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl_geom_Matrix3D() {return __webpack_require__(/*! ./../../openfl/geom/Matrix3D */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix3D.js");}

// Constructor

var Stage3D = function(stage) {
	(openfl_events_EventDispatcher().default).call(this);
	this.__stage = stage;
	this.__height = 0;
	this.__projectionTransform = new (openfl_geom_Matrix3D().default)();
	this.__renderTransform = new (openfl_geom_Matrix3D().default)();
	this.__width = 0;
	this.__x = 0;
	this.__y = 0;
	this.visible = true;
	if(stage.stageWidth > 0 && stage.stageHeight > 0) {
		this.__resize(stage.stageWidth,stage.stageHeight);
	}
}

// Meta

Stage3D.__name__ = "openfl.display.Stage3D";
Stage3D.__isInterface__ = false;
Stage3D.__super__ = (openfl_events_EventDispatcher().default);
Stage3D.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	requestContext3D: function(context3DRenderMode,profile) {
		if(profile == null) {
			profile = "baseline";
		}
		if(context3DRenderMode == null) {
			context3DRenderMode = "auto";
		}
		if(this.__contextLost) {
			this.__contextRequested = true;
			return;
		}
		if(this.context3D != null) {
			this.__contextRequested = true;
			(haxe_Timer().default).delay($bind(this,this.__dispatchCreate),1);
		} else if(!this.__contextRequested) {
			this.__contextRequested = true;
			(haxe_Timer().default).delay($bind(this,this.__createContext),1);
		}
	},
	requestContext3DMatchingProfiles: function(profiles) {
		this.requestContext3D();
	},
	__createContext: function() {
		var stage = this.__stage;
		var renderer = stage.__renderer;
		if(renderer.__type == "cairo" || renderer.__type == "canvas") {
			this.__dispatchError();
			return;
		}
		if(renderer.__type == "opengl") {
			this.context3D = new (openfl_display3D_Context3D().default)(stage,stage.context3D.__contextState,this);
			this.__dispatchCreate();
		} else if(renderer.__type == "dom") {
			this.__canvas = window.document.createElement("canvas");
			this.__canvas.width = stage.stageWidth;
			this.__canvas.height = stage.stageHeight;
			var $window = stage.window;
			var attributes = renderer.__context.attributes;
			var transparentBackground = (Reflect().default).hasField(attributes,"background") && attributes.background == null;
			var colorDepth = (Reflect().default).hasField(attributes,"colorDepth") ? attributes.colorDepth : 32;
			var options = { alpha : transparentBackground || colorDepth > 16, antialias : (Reflect().default).hasField(attributes,"antialiasing") && attributes.antialiasing > 0, depth : true, premultipliedAlpha : true, stencil : true, preserveDrawingBuffer : false};
			this.__webgl = (js_html__$CanvasElement_CanvasUtil().default).getContextWebGL(this.__canvas,options);
			if(this.__webgl != null) {
				this.__dispatchError();
			} else {
				this.__dispatchError();
			}
		}
	},
	__dispatchError: function() {
		this.__contextRequested = false;
		this.dispatchEvent(new (openfl_events_ErrorEvent().default)("error",false,false,"Context3D not available"));
	},
	__dispatchCreate: function() {
		if(this.__contextRequested) {
			this.__contextRequested = false;
			this.dispatchEvent(new (openfl_events_Event().default)("context3DCreate"));
		}
	},
	__lostContext: function() {
		this.__contextLost = true;
		if(this.context3D != null) {
			this.context3D.__dispose();
			this.__contextRequested = true;
		}
	},
	__resize: function(width,height) {
		if(width != this.__width || height != this.__height) {
			if(this.__canvas != null) {
				this.__canvas.width = width;
				this.__canvas.height = height;
			}
			this.__projectionTransform.copyRawDataFrom((openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[2.0 / (width > 0 ? width : 1),0.0,0.0,0.0,0.0,-2.0 / (height > 0 ? height : 1),0.0,0.0,0.0,0.0,-0.001,0.0,-1.0,1.0,0.0,1.0]));
			this.__renderTransform.identity();
			this.__renderTransform.appendTranslation(this.__x,this.__y,0);
			this.__renderTransform.append(this.__projectionTransform);
			this.__width = width;
			this.__height = height;
		}
	},
	__restoreContext: function() {
		this.__contextLost = false;
		this.__createContext();
	},
	get_x: function() {
		return this.__x;
	},
	set_x: function(value) {
		if(this.__x == value) {
			return value;
		}
		this.__x = value;
		this.__renderTransform.identity();
		this.__renderTransform.appendTranslation(this.__x,this.__y,0);
		this.__renderTransform.append(this.__projectionTransform);
		return value;
	},
	get_y: function() {
		return this.__y;
	},
	set_y: function(value) {
		if(this.__y == value) {
			return value;
		}
		this.__y = value;
		this.__renderTransform.identity();
		this.__renderTransform.appendTranslation(this.__x,this.__y,0);
		this.__renderTransform.append(this.__projectionTransform);
		return value;
	}
});
Stage3D.prototype.__class__ = Stage3D.prototype.constructor = $hxClasses["openfl.display.Stage3D"] = Stage3D;

// Init

Object.defineProperties(Stage3D.prototype,{ x : { get : function () { return this.get_x (); }, set : function (v) { return this.set_x (v); }}, y : { get : function () { return this.get_y (); }, set : function (v) { return this.set_y (v); }}});

// Statics




// Export

exports.default = Stage3D;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/Window.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/Window.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display.Window

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_ui_Window() {return __webpack_require__(/*! ./../../lime/ui/Window */ "./node_modules/openfl/lib/_gen/lime/ui/Window.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function openfl_display_Stage() {return __webpack_require__(/*! ./../../openfl/display/Stage */ "./node_modules/openfl/lib/_gen/openfl/display/Stage.js");}
function haxe_CallStack() {return __webpack_require__(/*! ./../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}

// Constructor

var Window = function(application,attributes) {
	(lime_ui_Window().default).call(this,application,attributes);
	if((Reflect().default).hasField(attributes,"stage")) {
		this.stage = (Reflect().default).field(attributes,"stage");
		this.stage.window = this;
		(Reflect().default).deleteField(attributes,"stage");
	} else {
		this.stage = new (openfl_display_Stage().default)(this,(Reflect().default).hasField(attributes.context,"background") ? attributes.context.background : 16777215);
	}
	if((Reflect().default).hasField(attributes,"parameters")) {
		try {
			this.stage.loaderInfo.parameters = attributes.parameters;
		} catch( e ) {
			(haxe_CallStack().default).lastException = e;
			var e1 = ((e) instanceof (js__$Boot_HaxeError().default)) ? e.val : e;
		}
	}
	if((Reflect().default).hasField(attributes,"resizable") && !attributes.resizable) {
		this.stage.__setLogicalSize(attributes.width,attributes.height);
	}
	application.addModule(this.stage);
}

// Meta

Window.__name__ = "openfl.display.Window";
Window.__isInterface__ = false;
Window.__super__ = (lime_ui_Window().default);
Window.prototype = $extend((lime_ui_Window().default).prototype, {
	
});
Window.prototype.__class__ = Window.prototype.constructor = $hxClasses["openfl.display.Window"] = Window;

// Init



// Statics


Window.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, fields : { _ : { SuppressWarnings : ["checkstyle:Dynamic"]}}}

// Export

exports.default = Window;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/_MovieClip/FrameSymbolInstance.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/_MovieClip/FrameSymbolInstance.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display._MovieClip.FrameSymbolInstance

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var FrameSymbolInstance = function(initFrame,initFrameObjectID,characterID,depth,displayObject,clipDepth) {
	this.initFrame = initFrame;
	this.initFrameObjectID = initFrameObjectID;
	this.characterID = characterID;
	this.depth = depth;
	this.displayObject = displayObject;
	this.clipDepth = clipDepth;
}

// Meta

FrameSymbolInstance.__name__ = "openfl.display._MovieClip.FrameSymbolInstance";
FrameSymbolInstance.__isInterface__ = false;
FrameSymbolInstance.prototype = {
	
};
FrameSymbolInstance.prototype.__class__ = FrameSymbolInstance.prototype.constructor = $hxClasses["openfl.display._MovieClip.FrameSymbolInstance"] = FrameSymbolInstance;

// Init



// Statics




// Export

exports.default = FrameSymbolInstance;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display/_ShaderData/ShaderData_Impl_.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display/_ShaderData/ShaderData_Impl_.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display._ShaderData.ShaderData_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var ShaderData_Impl_ = function(){}

// Meta

ShaderData_Impl_.__name__ = "openfl.display._ShaderData.ShaderData_Impl_";
ShaderData_Impl_.__isInterface__ = false;
ShaderData_Impl_.prototype = {
	
};
ShaderData_Impl_.prototype.__class__ = ShaderData_Impl_.prototype.constructor = $hxClasses["openfl.display._ShaderData.ShaderData_Impl_"] = ShaderData_Impl_;

// Init



// Statics

ShaderData_Impl_._new = function(byteArray) {
	var this1 = { };
	return this1;
}


// Export

exports.default = ShaderData_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/Context3D.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/Context3D.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.Context3D

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl_display3D_textures_CubeTexture() {return __webpack_require__(/*! ./../../openfl/display3D/textures/CubeTexture */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/CubeTexture.js");}
function openfl_display3D_IndexBuffer3D() {return __webpack_require__(/*! ./../../openfl/display3D/IndexBuffer3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/IndexBuffer3D.js");}
function openfl_display3D_Program3D() {return __webpack_require__(/*! ./../../openfl/display3D/Program3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/Program3D.js");}
function openfl_display3D_textures_RectangleTexture() {return __webpack_require__(/*! ./../../openfl/display3D/textures/RectangleTexture */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/RectangleTexture.js");}
function openfl_display3D_textures_Texture() {return __webpack_require__(/*! ./../../openfl/display3D/textures/Texture */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/Texture.js");}
function openfl_display3D_VertexBuffer3D() {return __webpack_require__(/*! ./../../openfl/display3D/VertexBuffer3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/VertexBuffer3D.js");}
function openfl_display3D_textures_VideoTexture() {return __webpack_require__(/*! ./../../openfl/display3D/textures/VideoTexture */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/VideoTexture.js");}
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}
function lime_math_Vector2() {return __webpack_require__(/*! ./../../lime/math/Vector2 */ "./node_modules/openfl/lib/_gen/lime/math/Vector2.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_graphics_Image() {return __webpack_require__(/*! ./../../lime/graphics/Image */ "./node_modules/openfl/lib/_gen/lime/graphics/Image.js");}
function lime_graphics_ImageBuffer() {return __webpack_require__(/*! ./../../lime/graphics/ImageBuffer */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageBuffer.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function openfl__$internal_renderer_SamplerState() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/SamplerState */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/SamplerState.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_IllegalOperationError() {return __webpack_require__(/*! ./../../openfl/errors/IllegalOperationError */ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js");}
function openfl_errors_Error() {return __webpack_require__(/*! ./../../openfl/errors/Error */ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js");}
function openfl_utils_AGALMiniAssembler() {return __webpack_require__(/*! ./../../openfl/utils/AGALMiniAssembler */ "./node_modules/openfl/lib/_gen/openfl/utils/AGALMiniAssembler.js");}
function openfl__$internal_renderer_context3D_Context3DState() {return __webpack_require__(/*! ./../../openfl/_internal/renderer/context3D/Context3DState */ "./node_modules/openfl/lib/_gen/openfl/_internal/renderer/context3D/Context3DState.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var Context3D = function(stage,contextState,stage3D) {
	this.profile = "standard";
	this.driverInfo = "OpenGL (Direct blitting)";
	this.backBufferWidth = 0;
	this.backBufferHeight = 0;
	(openfl_events_EventDispatcher().default).call(this);
	this.__stage = stage;
	this.__contextState = contextState;
	this.__stage3D = stage3D;
	this.__context = stage.window.context;
	this.gl = this.__context.webgl;
	if(this.__contextState == null) {
		this.__contextState = new (openfl__$internal_renderer_context3D_Context3DState().default)();
	}
	this.__state = new (openfl__$internal_renderer_context3D_Context3DState().default)();
	var array = null;
	var view = null;
	var buffer = null;
	var len = null;
	var this1 = new Float32Array(512);
	this.__vertexConstants = this1;
	var array1 = null;
	var view1 = null;
	var buffer1 = null;
	var len1 = null;
	var this2 = new Float32Array(512);
	this.__fragmentConstants = this2;
	var elements = null;
	var array2 = [1.0,1.0,1.0,1.0];
	var view2 = null;
	var buffer2 = null;
	var len2 = null;
	var this3;
	if(elements != null) {
		this3 = new Float32Array(elements);
	} else if(array2 != null) {
		this3 = new Float32Array(array2);
	} else if(view2 != null) {
		this3 = new Float32Array(view2);
	} else if(buffer2 != null) {
		if(len2 == null) {
			this3 = new Float32Array(buffer2,0);
		} else {
			this3 = new Float32Array(buffer2,0,len2);
		}
	} else {
		this3 = null;
	}
	this.__positionScale = this3;
	this.__programs = new (haxe_ds_StringMap().default)();
	if(Context3D.__glMaxViewportDims == -1) {
		Context3D.__glMaxViewportDims = this.gl.getParameter(this.gl.MAX_VIEWPORT_DIMS);
	}
	this.maxBackBufferWidth = Context3D.__glMaxViewportDims;
	this.maxBackBufferHeight = Context3D.__glMaxViewportDims;
	if(Context3D.__glMaxTextureMaxAnisotropy == -1) {
		var extension = this.gl.getExtension("EXT_texture_filter_anisotropic");
		if(extension == null || !(Reflect().default).hasField(extension,"MAX_TEXTURE_MAX_ANISOTROPY_EXT")) {
			extension = this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic");
		}
		if(extension == null || !(Reflect().default).hasField(extension,"MAX_TEXTURE_MAX_ANISOTROPY_EXT")) {
			extension = this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
		}
		if(extension != null) {
			Context3D.__glTextureMaxAnisotropy = extension.TEXTURE_MAX_ANISOTROPY_EXT;
			Context3D.__glMaxTextureMaxAnisotropy = this.gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
		} else {
			Context3D.__glTextureMaxAnisotropy = 0;
			Context3D.__glMaxTextureMaxAnisotropy = 0;
		}
	}
	if(Context3D.__glDepthStencil == -1) {
		Context3D.__glDepthStencil = this.gl.DEPTH_STENCIL;
	}
	if(Context3D.__glMemoryTotalAvailable == -1) {
		var extension1 = this.gl.getExtension("NVX_gpu_memory_info");
		if(extension1 != null) {
			Context3D.__glMemoryTotalAvailable = extension1.GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX;
			Context3D.__glMemoryCurrentAvailable = extension1.GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX;
		}
	}
	if(Context3D.__driverInfo == null) {
		var vendor = this.gl.getParameter(this.gl.VENDOR);
		var version = this.gl.getParameter(this.gl.VERSION);
		var renderer = this.gl.getParameter(this.gl.RENDERER);
		var glslVersion = this.gl.getParameter(this.gl.SHADING_LANGUAGE_VERSION);
		Context3D.__driverInfo = "OpenGL Vendor=" + vendor + " Version=" + version + " Renderer=" + renderer + " GLSL=" + glslVersion;
	}
	this.driverInfo = Context3D.__driverInfo;
	this.__quadIndexBufferElements = 16383;
	this.__quadIndexBufferCount = this.__quadIndexBufferElements * 6;
	var elements1 = this.__quadIndexBufferCount;
	var array3 = null;
	var view3 = null;
	var buffer3 = null;
	var len3 = null;
	var this4;
	if(elements1 != null) {
		this4 = new Uint16Array(elements1);
	} else if(array3 != null) {
		this4 = new Uint16Array(array3);
	} else if(view3 != null) {
		this4 = new Uint16Array(view3);
	} else if(buffer3 != null) {
		if(len3 == null) {
			this4 = new Uint16Array(buffer3,0);
		} else {
			this4 = new Uint16Array(buffer3,0,len3);
		}
	} else {
		this4 = null;
	}
	var data = this4;
	var index = 0;
	var vertex = 0;
	var _g = 0;
	var _g1 = this.__quadIndexBufferElements;
	while(_g < _g1) {
		var i = _g++;
		data[index] = vertex;
		data[index + 1] = vertex + 1;
		data[index + 2] = vertex + 2;
		data[index + 3] = vertex + 2;
		data[index + 4] = vertex + 1;
		data[index + 5] = vertex + 3;
		index = index + 6;
		vertex = vertex + 4;
	}
	this.__quadIndexBuffer = this.createIndexBuffer(this.__quadIndexBufferCount);
	this.__quadIndexBuffer.uploadFromTypedArray(data);
}

// Meta

Context3D.__name__ = "openfl.display3D.Context3D";
Context3D.__isInterface__ = false;
Context3D.__super__ = (openfl_events_EventDispatcher().default);
Context3D.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	clear: function(red,green,blue,alpha,depth,stencil,mask) {
		if(mask == null) {
			mask = 7;
		}
		if(stencil == null) {
			stencil = 0;
		}
		if(depth == null) {
			depth = 1;
		}
		if(alpha == null) {
			alpha = 1;
		}
		if(blue == null) {
			blue = 0;
		}
		if(green == null) {
			green = 0;
		}
		if(red == null) {
			red = 0;
		}
		this.__flushGLFramebuffer();
		this.__flushGLViewport();
		var clearMask = 0;
		if((mask & 1) != 0) {
			if(this.__state.renderToTexture == null) {
				if(this.__stage.context3D == this && !this.__stage.__renderer.__cleared) {
					this.__stage.__renderer.__cleared = true;
				}
				this.__cleared = true;
			}
			clearMask |= this.gl.COLOR_BUFFER_BIT;
			if(this.__contextState.colorMaskRed != true || this.__contextState.colorMaskGreen != true || this.__contextState.colorMaskBlue != true || this.__contextState.colorMaskAlpha != true) {
				this.gl.colorMask(true,true,true,true);
				this.__contextState.colorMaskRed = true;
				this.__contextState.colorMaskGreen = true;
				this.__contextState.colorMaskBlue = true;
				this.__contextState.colorMaskAlpha = true;
			}
			this.gl.clearColor(red,green,blue,alpha);
		}
		if((mask & 2) != 0) {
			clearMask |= this.gl.DEPTH_BUFFER_BIT;
			if(this.__contextState.depthMask != true) {
				this.gl.depthMask(true);
				this.__contextState.depthMask = true;
			}
			this.gl.clearDepth(depth);
		}
		if((mask & 4) != 0) {
			clearMask |= this.gl.STENCIL_BUFFER_BIT;
			if(this.__contextState.stencilWriteMask != 255) {
				this.gl.stencilMask(255);
				this.__contextState.stencilWriteMask = 255;
			}
			this.gl.clearStencil(stencil);
			this.__contextState.stencilWriteMask = 255;
		}
		if(clearMask == 0) {
			return;
		}
		this.__setGLScissorTest(false);
		this.gl.clear(clearMask);
	},
	configureBackBuffer: function(width,height,antiAlias,enableDepthAndStencil,wantsBestResolution,wantsBestResolutionOnBrowserZoom) {
		if(wantsBestResolutionOnBrowserZoom == null) {
			wantsBestResolutionOnBrowserZoom = false;
		}
		if(wantsBestResolution == null) {
			wantsBestResolution = false;
		}
		if(enableDepthAndStencil == null) {
			enableDepthAndStencil = true;
		}
		if(this.__stage3D == null) {
			this.backBufferWidth = width;
			this.backBufferHeight = height;
			this.__backBufferAntiAlias = antiAlias;
			this.__state.backBufferEnableDepthAndStencil = enableDepthAndStencil;
			this.__backBufferWantsBestResolution = wantsBestResolution;
			this.__backBufferWantsBestResolutionOnBrowserZoom = wantsBestResolutionOnBrowserZoom;
		} else {
			if(this.__backBufferTexture == null || this.backBufferWidth != width || this.backBufferHeight != height) {
				if(this.__backBufferTexture != null) {
					this.__backBufferTexture.dispose();
				}
				if(this.__frontBufferTexture != null) {
					this.__frontBufferTexture.dispose();
				}
				this.__backBufferTexture = this.createRectangleTexture(width,height,"bgra",true);
				this.__frontBufferTexture = this.createRectangleTexture(width,height,"bgra",true);
				if(this.__stage3D.__vertexBuffer == null) {
					this.__stage3D.__vertexBuffer = this.createVertexBuffer(4,5);
				}
				var vertexData = (openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[width,height,0,1,1,0,height,0,0,1,width,0,0,1,0,0,0,0,0,0.0]);
				this.__stage3D.__vertexBuffer.uploadFromVector(vertexData,0,20);
				if(this.__stage3D.__indexBuffer == null) {
					this.__stage3D.__indexBuffer = this.createIndexBuffer(6);
					var indexData = (openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[0,1,2,2,1,3]);
					this.__stage3D.__indexBuffer.uploadFromVector(indexData,0,6);
				}
			}
			this.backBufferWidth = width;
			this.backBufferHeight = height;
			this.__backBufferAntiAlias = antiAlias;
			this.__state.backBufferEnableDepthAndStencil = enableDepthAndStencil;
			this.__backBufferWantsBestResolution = wantsBestResolution;
			this.__backBufferWantsBestResolutionOnBrowserZoom = wantsBestResolutionOnBrowserZoom;
			this.__state.__primaryGLFramebuffer = this.__backBufferTexture.__getGLFramebuffer(enableDepthAndStencil,antiAlias,0);
			this.__frontBufferTexture.__getGLFramebuffer(enableDepthAndStencil,antiAlias,0);
		}
	},
	createCubeTexture: function(size,format,optimizeForRenderToTexture,streamingLevels) {
		if(streamingLevels == null) {
			streamingLevels = 0;
		}
		return new (openfl_display3D_textures_CubeTexture().default)(this,size,format,optimizeForRenderToTexture,streamingLevels);
	},
	createIndexBuffer: function(numIndices,bufferUsage) {
		if(bufferUsage == null) {
			bufferUsage = "staticDraw";
		}
		return new (openfl_display3D_IndexBuffer3D().default)(this,numIndices,bufferUsage);
	},
	createProgram: function(format) {
		if(format == null) {
			format = "agal";
		}
		return new (openfl_display3D_Program3D().default)(this,format);
	},
	createRectangleTexture: function(width,height,format,optimizeForRenderToTexture) {
		return new (openfl_display3D_textures_RectangleTexture().default)(this,width,height,format,optimizeForRenderToTexture);
	},
	createTexture: function(width,height,format,optimizeForRenderToTexture,streamingLevels) {
		if(streamingLevels == null) {
			streamingLevels = 0;
		}
		return new (openfl_display3D_textures_Texture().default)(this,width,height,format,optimizeForRenderToTexture,streamingLevels);
	},
	createVertexBuffer: function(numVertices,data32PerVertex,bufferUsage) {
		if(bufferUsage == null) {
			bufferUsage = "staticDraw";
		}
		return new (openfl_display3D_VertexBuffer3D().default)(this,numVertices,data32PerVertex,bufferUsage);
	},
	createVideoTexture: function() {
		return new (openfl_display3D_textures_VideoTexture().default)(this);
	},
	dispose: function(recreate) {
		if(recreate == null) {
			recreate = true;
		}
		this.gl = null;
		this.__dispose();
	},
	drawToBitmapData: function(destination,srcRect,destPoint) {
		if(destination == null) {
			return;
		}
		var sourceRect = srcRect != null ? srcRect.__toLimeRectangle() : new (lime_math_Rectangle().default)(0,0,this.backBufferWidth,this.backBufferHeight);
		var destVector = destPoint != null ? destPoint.__toLimeVector2() : new (lime_math_Vector2().default)();
		if(this.__stage.context3D == this) {
			if(this.__stage.window != null) {
				if(this.__stage3D != null) {
					destVector.setTo((Std().default).int(-this.__stage3D.get_x()),(Std().default).int(-this.__stage3D.get_y()));
				}
				var image = this.__stage.window.readPixels();
				destination.image.copyPixels(image,sourceRect,destVector);
			}
		} else if(this.__backBufferTexture != null) {
			var cacheRenderToTexture = this.__state.renderToTexture;
			this.setRenderToBackBuffer();
			this.__flushGLFramebuffer();
			this.__flushGLViewport();
			var elements = this.backBufferWidth * this.backBufferHeight * 4;
			var array = null;
			var view = null;
			var buffer = null;
			var len = null;
			var this1;
			if(elements != null) {
				this1 = new Uint8Array(elements);
			} else if(array != null) {
				this1 = new Uint8Array(array);
			} else if(view != null) {
				this1 = new Uint8Array(view);
			} else if(buffer != null) {
				if(len == null) {
					this1 = new Uint8Array(buffer,0);
				} else {
					this1 = new Uint8Array(buffer,0,len);
				}
			} else {
				this1 = null;
			}
			var data = this1;
			var this2 = this.gl;
			var width = this.backBufferWidth;
			var height = this.backBufferHeight;
			var format = this.__backBufferTexture.__format;
			var type = this.gl.UNSIGNED_BYTE;
			var pixels = data;
			var dstOffset = null;
			if(dstOffset != null) {
				this2.readPixels(0,0,width,height,format,type,pixels,dstOffset);
			} else {
				this2.readPixels(0,0,width,height,format,type,pixels);
			}
			var image1 = new (lime_graphics_Image().default)(new (lime_graphics_ImageBuffer().default)(data,this.backBufferWidth,this.backBufferHeight,32,2));
			destination.image.copyPixels(image1,sourceRect,destVector);
			if(cacheRenderToTexture != null) {
				this.setRenderToTexture(cacheRenderToTexture,this.__state.renderToTextureDepthStencil,this.__state.renderToTextureAntiAlias,this.__state.renderToTextureSurfaceSelector);
			}
		}
	},
	drawTriangles: function(indexBuffer,firstIndex,numTriangles) {
		if(numTriangles == null) {
			numTriangles = -1;
		}
		if(firstIndex == null) {
			firstIndex = 0;
		}
		if(this.__state.renderToTexture == null) {
			if(this.__stage.context3D == this && !this.__stage.__renderer.__cleared) {
				this.__stage.__renderer.__clear();
			} else if(!this.__cleared) {
				this.clear(0,0,0,0,1,0,1);
			}
		}
		this.__flushGL();
		if(this.__state.program != null) {
			this.__state.program.__flush();
		}
		var count = numTriangles == -1 ? indexBuffer.__numIndices : numTriangles * 3;
		this.__bindGLElementArrayBuffer(indexBuffer.__id);
		this.gl.drawElements(this.gl.TRIANGLES,count,this.gl.UNSIGNED_SHORT,firstIndex * 2);
	},
	present: function() {
		this.setRenderToBackBuffer();
		if(this.__stage3D != null && this.__backBufferTexture != null) {
			if(!this.__cleared) {
				this.clear(0,0,0,0,1,0,1);
			}
			var cacheBuffer = this.__backBufferTexture;
			this.__backBufferTexture = this.__frontBufferTexture;
			this.__frontBufferTexture = cacheBuffer;
			this.__state.__primaryGLFramebuffer = this.__backBufferTexture.__getGLFramebuffer(this.__state.backBufferEnableDepthAndStencil,this.__backBufferAntiAlias,0);
			this.__cleared = false;
		}
		this.__present = true;
	},
	setBlendFactors: function(sourceFactor,destinationFactor) {
		this.setBlendFactorsSeparate(sourceFactor,destinationFactor,sourceFactor,destinationFactor);
	},
	setBlendFactorsSeparate: function(sourceRGBFactor,destinationRGBFactor,sourceAlphaFactor,destinationAlphaFactor) {
		this.__state.blendSourceRGBFactor = sourceRGBFactor;
		this.__state.blendDestinationRGBFactor = destinationRGBFactor;
		this.__state.blendSourceAlphaFactor = sourceAlphaFactor;
		this.__state.blendDestinationAlphaFactor = destinationAlphaFactor;
		this.__setGLBlendEquation(this.gl.FUNC_ADD);
	},
	setColorMask: function(red,green,blue,alpha) {
		this.__state.colorMaskRed = red;
		this.__state.colorMaskGreen = green;
		this.__state.colorMaskBlue = blue;
		this.__state.colorMaskAlpha = alpha;
	},
	setCulling: function(triangleFaceToCull) {
		this.__state.culling = triangleFaceToCull;
	},
	setDepthTest: function(depthMask,passCompareMode) {
		this.__state.depthMask = depthMask;
		this.__state.depthCompareMode = passCompareMode;
	},
	setProgram: function(program) {
		this.__state.program = program;
		this.__state.shader = null;
		if(program != null) {
			var _g = 0;
			var _g1 = program.__samplerStates.length;
			while(_g < _g1) {
				var i = _g++;
				if(this.__state.samplerStates[i] == null) {
					this.__state.samplerStates[i] = program.__samplerStates[i].clone();
				} else {
					this.__state.samplerStates[i].copyFrom(program.__samplerStates[i]);
				}
			}
		}
	},
	setProgramConstantsFromByteArray: function(programType,firstRegister,numRegisters,data,byteArrayOffset) {
		if(numRegisters == 0 || this.__state.program == null) {
			return;
		}
		if(!(this.__state.program != null && this.__state.program.__format == "glsl")) {
			if(numRegisters == -1) {
				numRegisters = ((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(data) >>> 2) - byteArrayOffset;
			}
			var isVertex = programType == "vertex";
			var dest = isVertex ? this.__vertexConstants : this.__fragmentConstants;
			var bytes = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(data);
			var byteOffset = 0;
			var len = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(data);
			if(byteOffset == null) {
				byteOffset = 0;
			}
			var floatData = byteOffset == null ? new Float32Array(bytes.getData()) : len == null ? new Float32Array(bytes.getData(),byteOffset) : new Float32Array(bytes.getData(),byteOffset,len);
			var outOffset = firstRegister * 4;
			var inOffset = (Std().default).int((_$UInt_UInt_$Impl_$().default).toFloat(byteArrayOffset) / (_$UInt_UInt_$Impl_$().default).toFloat(4));
			var _g = 0;
			var _g1 = numRegisters * 4;
			while(_g < _g1) {
				var i = _g++;
				dest[outOffset + i] = floatData[inOffset + i];
			}
			if(this.__state.program != null) {
				this.__state.program.__markDirty(isVertex,firstRegister,numRegisters);
			}
		}
	},
	setProgramConstantsFromMatrix: function(programType,firstRegister,matrix,transposedMatrix) {
		if(transposedMatrix == null) {
			transposedMatrix = false;
		}
		if(this.__state.program != null && this.__state.program.__format == "glsl") {
			this.__flushGLProgram();
			var array = null;
			var view = null;
			var buffer = null;
			var len = null;
			var this1 = new Float32Array(16);
			var data = this1;
			data[0] = matrix.rawData[0];
			data[1] = matrix.rawData[1];
			data[2] = matrix.rawData[2];
			data[3] = matrix.rawData[3];
			data[4] = matrix.rawData[4];
			data[5] = matrix.rawData[5];
			data[6] = matrix.rawData[6];
			data[7] = matrix.rawData[7];
			data[8] = matrix.rawData[8];
			data[9] = matrix.rawData[9];
			data[10] = matrix.rawData[10];
			data[11] = matrix.rawData[11];
			data[12] = matrix.rawData[12];
			data[13] = matrix.rawData[13];
			data[14] = matrix.rawData[14];
			data[15] = matrix.rawData[15];
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix4fv(this.gl,firstRegister,transposedMatrix,data);
		} else {
			var isVertex = programType == "vertex";
			var dest = isVertex ? this.__vertexConstants : this.__fragmentConstants;
			var source = matrix.rawData;
			var i = firstRegister * 4;
			if(transposedMatrix) {
				dest[i++] = source[0];
				dest[i++] = source[4];
				dest[i++] = source[8];
				dest[i++] = source[12];
				dest[i++] = source[1];
				dest[i++] = source[5];
				dest[i++] = source[9];
				dest[i++] = source[13];
				dest[i++] = source[2];
				dest[i++] = source[6];
				dest[i++] = source[10];
				dest[i++] = source[14];
				dest[i++] = source[3];
				dest[i++] = source[7];
				dest[i++] = source[11];
				dest[i++] = source[15];
			} else {
				dest[i++] = source[0];
				dest[i++] = source[1];
				dest[i++] = source[2];
				dest[i++] = source[3];
				dest[i++] = source[4];
				dest[i++] = source[5];
				dest[i++] = source[6];
				dest[i++] = source[7];
				dest[i++] = source[8];
				dest[i++] = source[9];
				dest[i++] = source[10];
				dest[i++] = source[11];
				dest[i++] = source[12];
				dest[i++] = source[13];
				dest[i++] = source[14];
				dest[i++] = source[15];
			}
			if(this.__state.program != null) {
				this.__state.program.__markDirty(isVertex,firstRegister,4);
			}
		}
	},
	setProgramConstantsFromVector: function(programType,firstRegister,data,numRegisters) {
		if(numRegisters == null) {
			numRegisters = -1;
		}
		if(numRegisters == 0) {
			return;
		}
		if(!(this.__state.program != null && this.__state.program.__format == "glsl")) {
			if(numRegisters == -1) {
				numRegisters = data.get_length() >> 2;
			}
			var isVertex = programType == "vertex";
			var dest = isVertex ? this.__vertexConstants : this.__fragmentConstants;
			var source = data;
			var sourceIndex = 0;
			var destIndex = firstRegister * 4;
			var _g = 0;
			var _g1 = numRegisters;
			while(_g < _g1) {
				var i = _g++;
				dest[destIndex++] = source[sourceIndex++];
				dest[destIndex++] = source[sourceIndex++];
				dest[destIndex++] = source[sourceIndex++];
				dest[destIndex++] = source[sourceIndex++];
			}
			if(this.__state.program != null) {
				this.__state.program.__markDirty(isVertex,firstRegister,numRegisters);
			}
		}
	},
	setRenderToBackBuffer: function() {
		this.__state.renderToTexture = null;
	},
	setRenderToTexture: function(texture,enableDepthAndStencil,antiAlias,surfaceSelector) {
		if(surfaceSelector == null) {
			surfaceSelector = 0;
		}
		if(antiAlias == null) {
			antiAlias = 0;
		}
		if(enableDepthAndStencil == null) {
			enableDepthAndStencil = false;
		}
		this.__state.renderToTexture = texture;
		this.__state.renderToTextureDepthStencil = enableDepthAndStencil;
		this.__state.renderToTextureAntiAlias = antiAlias;
		this.__state.renderToTextureSurfaceSelector = surfaceSelector;
	},
	setSamplerStateAt: function(sampler,wrap,filter,mipfilter) {
		if(this.__state.samplerStates[sampler] == null) {
			this.__state.samplerStates[sampler] = new (openfl__$internal_renderer_SamplerState().default)();
		}
		var state = this.__state.samplerStates[sampler];
		state.wrap = wrap;
		state.filter = filter;
		state.mipfilter = mipfilter;
	},
	setScissorRectangle: function(rectangle) {
		if(rectangle != null) {
			this.__state.scissorEnabled = true;
			this.__state.scissorRectangle.copyFrom(rectangle);
		} else {
			this.__state.scissorEnabled = false;
		}
	},
	setStencilActions: function(triangleFace,compareMode,actionOnBothPass,actionOnDepthFail,actionOnDepthPassStencilFail) {
		if(actionOnDepthPassStencilFail == null) {
			actionOnDepthPassStencilFail = "keep";
		}
		if(actionOnDepthFail == null) {
			actionOnDepthFail = "keep";
		}
		if(actionOnBothPass == null) {
			actionOnBothPass = "keep";
		}
		if(compareMode == null) {
			compareMode = "always";
		}
		if(triangleFace == null) {
			triangleFace = "frontAndBack";
		}
		this.__state.stencilTriangleFace = triangleFace;
		this.__state.stencilCompareMode = compareMode;
		this.__state.stencilPass = actionOnBothPass;
		this.__state.stencilDepthFail = actionOnDepthFail;
		this.__state.stencilFail = actionOnDepthPassStencilFail;
	},
	setStencilReferenceValue: function(referenceValue,readMask,writeMask) {
		if(writeMask == null) {
			writeMask = 255;
		}
		if(readMask == null) {
			readMask = 255;
		}
		this.__state.stencilReferenceValue = referenceValue;
		this.__state.stencilReadMask = readMask;
		this.__state.stencilWriteMask = writeMask;
	},
	setTextureAt: function(sampler,texture) {
		this.__state.textures[sampler] = texture;
	},
	setVertexBufferAt: function(index,buffer,bufferOffset,format) {
		if(format == null) {
			format = "float4";
		}
		if(bufferOffset == null) {
			bufferOffset = 0;
		}
		if(buffer == null) {
			this.gl.disableVertexAttribArray(index);
			this.__bindGLArrayBuffer(null);
			return;
		}
		this.__bindGLArrayBuffer(buffer.__id);
		this.gl.enableVertexAttribArray(index);
		var byteOffset = bufferOffset * 4;
		switch(format) {
		case "bytes4":
			this.gl.vertexAttribPointer(index,4,this.gl.UNSIGNED_BYTE,true,buffer.__stride,byteOffset);
			break;
		case "float1":
			this.gl.vertexAttribPointer(index,1,this.gl.FLOAT,false,buffer.__stride,byteOffset);
			break;
		case "float2":
			this.gl.vertexAttribPointer(index,2,this.gl.FLOAT,false,buffer.__stride,byteOffset);
			break;
		case "float3":
			this.gl.vertexAttribPointer(index,3,this.gl.FLOAT,false,buffer.__stride,byteOffset);
			break;
		case "float4":
			this.gl.vertexAttribPointer(index,4,this.gl.FLOAT,false,buffer.__stride,byteOffset);
			break;
		default:
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
		}
	},
	__bindGLArrayBuffer: function(buffer) {
		if(this.__contextState.__currentGLArrayBuffer != buffer) {
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffer);
			this.__contextState.__currentGLArrayBuffer = buffer;
		}
	},
	__bindGLElementArrayBuffer: function(buffer) {
		if(this.__contextState.__currentGLElementArrayBuffer != buffer) {
			this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,buffer);
			this.__contextState.__currentGLElementArrayBuffer = buffer;
		}
	},
	__bindGLFramebuffer: function(framebuffer) {
		if(this.__contextState.__currentGLFramebuffer != framebuffer) {
			this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,framebuffer);
			this.__contextState.__currentGLFramebuffer = framebuffer;
		}
	},
	__bindGLTexture2D: function(texture) {
		this.gl.bindTexture(this.gl.TEXTURE_2D,texture);
		this.__contextState.__currentGLTexture2D = texture;
	},
	__bindGLTextureCubeMap: function(texture) {
		this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP,texture);
		this.__contextState.__currentGLTextureCubeMap = texture;
	},
	__dispose: function() {
		this.driverInfo += " (Disposed)";
		if(this.__stage3D != null) {
			this.__stage3D.__indexBuffer = null;
			this.__stage3D.__vertexBuffer = null;
			this.__stage3D.context3D = null;
			this.__stage3D = null;
		}
		this.__backBufferTexture = null;
		this.__context = null;
		this.__renderStage3DProgram = null;
		this.__fragmentConstants = null;
		this.__frontBufferTexture = null;
		this.__positionScale = null;
		this.__present = false;
		this.__quadIndexBuffer = null;
		this.__stage = null;
		this.__vertexConstants = null;
	},
	__drawTriangles: function(firstIndex,count) {
		if(firstIndex == null) {
			firstIndex = 0;
		}
		if(this.__state.renderToTexture == null) {
			if(this.__stage.context3D == this && !this.__stage.__renderer.__cleared) {
				this.__stage.__renderer.__clear();
			} else if(!this.__cleared) {
				this.clear(0,0,0,0,1,0,1);
			}
		}
		this.__flushGL();
		if(this.__state.program != null) {
			this.__state.program.__flush();
		}
		this.gl.drawArrays(this.gl.TRIANGLES,firstIndex,count);
	},
	__flushGL: function() {
		this.__flushGLProgram();
		this.__flushGLFramebuffer();
		this.__flushGLViewport();
		this.__flushGLBlend();
		this.__flushGLColor();
		this.__flushGLCulling();
		this.__flushGLDepth();
		this.__flushGLScissor();
		this.__flushGLStencil();
		this.__flushGLTextures();
	},
	__flushGLBlend: function() {
		if(this.__contextState.blendDestinationRGBFactor != this.__state.blendDestinationRGBFactor || this.__contextState.blendSourceRGBFactor != this.__state.blendSourceRGBFactor || this.__contextState.blendDestinationAlphaFactor != this.__state.blendDestinationAlphaFactor || this.__contextState.blendSourceAlphaFactor != this.__state.blendSourceAlphaFactor) {
			this.__setGLBlend(true);
			if(this.__state.blendDestinationRGBFactor == this.__state.blendDestinationAlphaFactor && this.__state.blendSourceRGBFactor == this.__state.blendSourceAlphaFactor) {
				this.gl.blendFunc(this.__getGLBlend(this.__state.blendSourceRGBFactor),this.__getGLBlend(this.__state.blendDestinationRGBFactor));
			} else {
				this.gl.blendFuncSeparate(this.__getGLBlend(this.__state.blendSourceRGBFactor),this.__getGLBlend(this.__state.blendDestinationRGBFactor),this.__getGLBlend(this.__state.blendSourceAlphaFactor),this.__getGLBlend(this.__state.blendDestinationAlphaFactor));
			}
			this.__contextState.blendDestinationRGBFactor = this.__state.blendDestinationRGBFactor;
			this.__contextState.blendSourceRGBFactor = this.__state.blendSourceRGBFactor;
			this.__contextState.blendDestinationAlphaFactor = this.__state.blendDestinationAlphaFactor;
			this.__contextState.blendSourceAlphaFactor = this.__state.blendSourceAlphaFactor;
		}
	},
	__flushGLColor: function() {
		if(this.__contextState.colorMaskRed != this.__state.colorMaskRed || this.__contextState.colorMaskGreen != this.__state.colorMaskGreen || this.__contextState.colorMaskBlue != this.__state.colorMaskBlue || this.__contextState.colorMaskAlpha != this.__state.colorMaskAlpha) {
			this.gl.colorMask(this.__state.colorMaskRed,this.__state.colorMaskGreen,this.__state.colorMaskBlue,this.__state.colorMaskAlpha);
			this.__contextState.colorMaskRed = this.__state.colorMaskRed;
			this.__contextState.colorMaskGreen = this.__state.colorMaskGreen;
			this.__contextState.colorMaskBlue = this.__state.colorMaskBlue;
			this.__contextState.colorMaskAlpha = this.__state.colorMaskAlpha;
		}
	},
	__flushGLCulling: function() {
		if(this.__contextState.culling != this.__state.culling) {
			if(this.__state.culling == "none") {
				this.__setGLCullFace(false);
			} else {
				this.__setGLCullFace(true);
				switch(this.__state.culling) {
				case "back":
					this.gl.cullFace(this.gl.BACK);
					break;
				case "front":
					this.gl.cullFace(this.gl.FRONT);
					break;
				case "frontAndBack":
					this.gl.cullFace(this.gl.FRONT_AND_BACK);
					break;
				case "none":
					break;
				default:
					throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
				}
			}
			this.__contextState.culling = this.__state.culling;
		}
	},
	__flushGLDepth: function() {
		var depthMask = this.__state.depthMask && (this.__state.renderToTexture != null ? this.__state.renderToTextureDepthStencil : this.__state.backBufferEnableDepthAndStencil);
		if(this.__contextState.depthMask != depthMask) {
			this.gl.depthMask(depthMask);
			this.__contextState.depthMask = depthMask;
		}
		if(this.__contextState.depthCompareMode != this.__state.depthCompareMode) {
			switch(this.__state.depthCompareMode) {
			case "always":
				this.gl.depthFunc(this.gl.ALWAYS);
				break;
			case "equal":
				this.gl.depthFunc(this.gl.EQUAL);
				break;
			case "greater":
				this.gl.depthFunc(this.gl.GREATER);
				break;
			case "greaterEqual":
				this.gl.depthFunc(this.gl.GEQUAL);
				break;
			case "less":
				this.gl.depthFunc(this.gl.LESS);
				break;
			case "lessEqual":
				this.gl.depthFunc(this.gl.LEQUAL);
				break;
			case "never":
				this.gl.depthFunc(this.gl.NEVER);
				break;
			case "notEqual":
				this.gl.depthFunc(this.gl.NOTEQUAL);
				break;
			default:
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
			}
			this.__contextState.depthCompareMode = this.__state.depthCompareMode;
		}
	},
	__flushGLFramebuffer: function() {
		if(this.__state.renderToTexture != null) {
			if(this.__contextState.renderToTexture != this.__state.renderToTexture || this.__contextState.renderToTextureSurfaceSelector != this.__state.renderToTextureSurfaceSelector) {
				var framebuffer = this.__state.renderToTexture.__getGLFramebuffer(this.__state.renderToTextureDepthStencil,this.__state.renderToTextureAntiAlias,this.__state.renderToTextureSurfaceSelector);
				this.__bindGLFramebuffer(framebuffer);
				this.__contextState.renderToTexture = this.__state.renderToTexture;
				this.__contextState.renderToTextureAntiAlias = this.__state.renderToTextureAntiAlias;
				this.__contextState.renderToTextureDepthStencil = this.__state.renderToTextureDepthStencil;
				this.__contextState.renderToTextureSurfaceSelector = this.__state.renderToTextureSurfaceSelector;
			}
			this.__setGLDepthTest(this.__state.renderToTextureDepthStencil);
			this.__setGLStencilTest(this.__state.renderToTextureDepthStencil);
			this.__setGLFrontFace(true);
		} else {
			if(this.__stage == null && this.backBufferWidth == 0 && this.backBufferHeight == 0) {
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_Error().default)("Context3D backbuffer has not been configured"));
			}
			if(this.__contextState.renderToTexture != null || this.__contextState.__currentGLFramebuffer != this.__state.__primaryGLFramebuffer || this.__contextState.backBufferEnableDepthAndStencil != this.__state.backBufferEnableDepthAndStencil) {
				this.__bindGLFramebuffer(this.__state.__primaryGLFramebuffer);
				this.__contextState.renderToTexture = null;
				this.__contextState.backBufferEnableDepthAndStencil = this.__state.backBufferEnableDepthAndStencil;
			}
			this.__setGLDepthTest(this.__state.backBufferEnableDepthAndStencil);
			this.__setGLStencilTest(this.__state.backBufferEnableDepthAndStencil);
			this.__setGLFrontFace(this.__stage.context3D != this);
		}
	},
	__flushGLProgram: function() {
		var shader = this.__state.shader;
		var program = this.__state.program;
		if(this.__contextState.shader != shader) {
			if(this.__contextState.shader != null) {
				this.__contextState.shader.__disable();
			}
			if(shader != null) {
				shader.__enable();
			}
			this.__contextState.shader = shader;
		}
		if(this.__contextState.program != program) {
			if(this.__contextState.program != null) {
				this.__contextState.program.__disable();
			}
			if(program != null) {
				program.__enable();
			}
			this.__contextState.program = program;
		}
		if(program != null && program.__format == "agal") {
			this.__positionScale[1] = this.__stage.context3D == this && this.__state.renderToTexture == null ? 1.0 : -1.0;
			program.__setPositionScale(this.__positionScale);
		}
	},
	__flushGLScissor: function() {
		if(!this.__state.scissorEnabled) {
			if(this.__contextState.scissorEnabled != this.__state.scissorEnabled) {
				this.__setGLScissorTest(false);
				this.__contextState.scissorEnabled = false;
			}
		} else {
			this.__setGLScissorTest(true);
			this.__contextState.scissorEnabled = true;
			var scissorX = (Std().default).int(this.__state.scissorRectangle.x);
			var scissorY = (Std().default).int(this.__state.scissorRectangle.y);
			var scissorWidth = (Std().default).int(this.__state.scissorRectangle.width);
			var scissorHeight = (Std().default).int(this.__state.scissorRectangle.height);
			if(this.__state.renderToTexture == null && this.__stage3D == null) {
				var contextHeight = (Std().default).int(this.__stage.window.get_height() * this.__stage.window.get_scale());
				scissorY = contextHeight - (Std().default).int(this.__state.scissorRectangle.height) - scissorY;
			}
			if(this.__contextState.scissorRectangle.x != scissorX || this.__contextState.scissorRectangle.y != scissorY || this.__contextState.scissorRectangle.width != scissorWidth || this.__contextState.scissorRectangle.height != scissorHeight) {
				this.gl.scissor(scissorX,scissorY,scissorWidth,scissorHeight);
				this.__contextState.scissorRectangle.setTo(scissorX,scissorY,scissorWidth,scissorHeight);
			}
		}
	},
	__flushGLStencil: function() {
		if(this.__contextState.stencilTriangleFace != this.__state.stencilTriangleFace || this.__contextState.stencilPass != this.__state.stencilPass || this.__contextState.stencilDepthFail != this.__state.stencilDepthFail || this.__contextState.stencilFail != this.__state.stencilFail) {
			this.gl.stencilOpSeparate(this.__getGLTriangleFace(this.__state.stencilTriangleFace),this.__getGLStencilAction(this.__state.stencilFail),this.__getGLStencilAction(this.__state.stencilDepthFail),this.__getGLStencilAction(this.__state.stencilPass));
			this.__contextState.stencilTriangleFace = this.__state.stencilTriangleFace;
			this.__contextState.stencilPass = this.__state.stencilPass;
			this.__contextState.stencilDepthFail = this.__state.stencilDepthFail;
			this.__contextState.stencilFail = this.__state.stencilFail;
		}
		if(this.__contextState.stencilWriteMask != this.__state.stencilWriteMask) {
			this.gl.stencilMask(this.__state.stencilWriteMask);
			this.__contextState.stencilWriteMask = this.__state.stencilWriteMask;
		}
		if(this.__contextState.stencilCompareMode != this.__state.stencilCompareMode || this.__contextState.stencilReferenceValue != this.__state.stencilReferenceValue || this.__contextState.stencilReadMask != this.__state.stencilReadMask) {
			this.gl.stencilFunc(this.__getGLCompareMode(this.__state.stencilCompareMode),this.__state.stencilReferenceValue,this.__state.stencilReadMask);
			this.__contextState.stencilCompareMode = this.__state.stencilCompareMode;
			this.__contextState.stencilReferenceValue = this.__state.stencilReferenceValue;
			this.__contextState.stencilReadMask = this.__state.stencilReadMask;
		}
	},
	__flushGLTextures: function() {
		var sampler = 0;
		var texture;
		var samplerState;
		var _g = 0;
		var _g1 = this.__state.textures.length;
		while(_g < _g1) {
			var i = _g++;
			texture = this.__state.textures[i];
			samplerState = this.__state.samplerStates[i];
			if(samplerState == null) {
				this.__state.samplerStates[i] = new (openfl__$internal_renderer_SamplerState().default)();
				samplerState = this.__state.samplerStates[i];
			}
			this.gl.activeTexture(this.gl.TEXTURE0 + sampler);
			if(texture != null) {
				if(texture.__textureTarget == this.gl.TEXTURE_2D) {
					this.__bindGLTexture2D(texture.__getTexture());
				} else {
					this.__bindGLTextureCubeMap(texture.__getTexture());
				}
				this.__contextState.textures[i] = texture;
				texture.__setSamplerState(samplerState);
			} else {
				this.__bindGLTexture2D(null);
			}
			if(this.__state.program != null && this.__state.program.__format == "agal" && samplerState.textureAlpha) {
				this.gl.activeTexture(this.gl.TEXTURE0 + sampler + 4);
				if(texture != null && texture.__alphaTexture != null) {
					if(texture.__alphaTexture.__textureTarget == this.gl.TEXTURE_2D) {
						this.__bindGLTexture2D(texture.__alphaTexture.__getTexture());
					} else {
						this.__bindGLTextureCubeMap(texture.__alphaTexture.__getTexture());
					}
					texture.__alphaTexture.__setSamplerState(samplerState);
					this.gl.uniform1i(this.__state.program.__agalAlphaSamplerEnabled[sampler].location,1);
				} else {
					this.__bindGLTexture2D(null);
					if(this.__state.program.__agalAlphaSamplerEnabled[sampler] != null) {
						this.gl.uniform1i(this.__state.program.__agalAlphaSamplerEnabled[sampler].location,0);
					}
				}
			}
			++sampler;
		}
	},
	__flushGLViewport: function() {
		if(this.__state.renderToTexture == null) {
			if(this.__stage.context3D == this) {
				var x = this.__stage3D == null ? 0 : (Std().default).int(this.__stage3D.get_x());
				var y = (Std().default).int(this.__stage.window.get_height() * this.__stage.window.get_scale() - this.backBufferHeight - (this.__stage3D == null ? 0 : this.__stage3D.get_y()));
				this.gl.viewport(x,y,this.backBufferWidth,this.backBufferHeight);
			} else {
				this.gl.viewport(0,0,this.backBufferWidth,this.backBufferHeight);
			}
		} else {
			var width = 0;
			var height = 0;
			if(((this.__state.renderToTexture) instanceof (openfl_display3D_textures_Texture().default))) {
				var texture2D = this.__state.renderToTexture;
				width = texture2D.__width;
				height = texture2D.__height;
			} else if(((this.__state.renderToTexture) instanceof (openfl_display3D_textures_RectangleTexture().default))) {
				var rectTexture = this.__state.renderToTexture;
				width = rectTexture.__width;
				height = rectTexture.__height;
			} else if(((this.__state.renderToTexture) instanceof (openfl_display3D_textures_CubeTexture().default))) {
				var cubeTexture = this.__state.renderToTexture;
				width = cubeTexture.__size;
				height = cubeTexture.__size;
			}
			this.gl.viewport(0,0,width,height);
		}
	},
	__getGLBlend: function(blendFactor) {
		switch(blendFactor) {
		case "destinationAlpha":
			return this.gl.DST_ALPHA;
		case "destinationColor":
			return this.gl.DST_COLOR;
		case "one":
			return this.gl.ONE;
		case "oneMinusDestinationAlpha":
			return this.gl.ONE_MINUS_DST_ALPHA;
		case "oneMinusDestinationColor":
			return this.gl.ONE_MINUS_DST_COLOR;
		case "oneMinusSourceAlpha":
			return this.gl.ONE_MINUS_SRC_ALPHA;
		case "oneMinusSourceColor":
			return this.gl.ONE_MINUS_SRC_COLOR;
		case "sourceAlpha":
			return this.gl.SRC_ALPHA;
		case "sourceColor":
			return this.gl.SRC_COLOR;
		case "zero":
			return this.gl.ZERO;
		default:
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
		}
	},
	__getGLCompareMode: function(mode) {
		switch(mode) {
		case "always":
			return this.gl.ALWAYS;
		case "equal":
			return this.gl.EQUAL;
		case "greater":
			return this.gl.GREATER;
		case "greaterEqual":
			return this.gl.GEQUAL;
		case "less":
			return this.gl.LESS;
		case "lessEqual":
			return this.gl.LEQUAL;
		case "never":
			return this.gl.NEVER;
		case "notEqual":
			return this.gl.NOTEQUAL;
		default:
			return this.gl.EQUAL;
		}
	},
	__getGLStencilAction: function(action) {
		switch(action) {
		case "decrementSaturate":
			return this.gl.DECR;
		case "decrementWrap":
			return this.gl.DECR_WRAP;
		case "incrementSaturate":
			return this.gl.INCR;
		case "incrementWrap":
			return this.gl.INCR_WRAP;
		case "invert":
			return this.gl.INVERT;
		case "keep":
			return this.gl.KEEP;
		case "set":
			return this.gl.REPLACE;
		case "zero":
			return this.gl.ZERO;
		default:
			return this.gl.KEEP;
		}
	},
	__getGLTriangleFace: function(face) {
		switch(face) {
		case "back":
			return this.gl.BACK;
		case "front":
			return this.gl.FRONT;
		case "frontAndBack":
			return this.gl.FRONT_AND_BACK;
		case "none":
			return this.gl.NONE;
		default:
			return this.gl.FRONT_AND_BACK;
		}
	},
	__renderStage3D: function(stage3D) {
		var context = stage3D.context3D;
		if(context != null && context != this && context.__frontBufferTexture != null && stage3D.visible && this.backBufferHeight > 0 && this.backBufferWidth > 0) {
			if(this.__renderStage3DProgram == null) {
				var vertexAssembler = new (openfl_utils_AGALMiniAssembler().default)();
				vertexAssembler.assemble("vertex","m44 op, va0, vc0\n" + "mov v0, va1");
				var fragmentAssembler = new (openfl_utils_AGALMiniAssembler().default)();
				fragmentAssembler.assemble("fragment","tex ft1, v0, fs0 <2d,nearest,nomip>\n" + "mov oc, ft1");
				this.__renderStage3DProgram = this.createProgram();
				this.__renderStage3DProgram.upload(vertexAssembler.agalcode,fragmentAssembler.agalcode);
			}
			this.setProgram(this.__renderStage3DProgram);
			this.setBlendFactors("one","zero");
			this.setColorMask(true,true,true,true);
			this.setCulling("none");
			this.setDepthTest(false,"always");
			this.setStencilActions();
			this.setStencilReferenceValue(0,0,0);
			this.setScissorRectangle(null);
			this.setTextureAt(0,context.__frontBufferTexture);
			this.setVertexBufferAt(0,stage3D.__vertexBuffer,0,"float3");
			this.setVertexBufferAt(1,stage3D.__vertexBuffer,3,"float2");
			this.setProgramConstantsFromMatrix("vertex",0,stage3D.__renderTransform,true);
			this.drawTriangles(stage3D.__indexBuffer);
			this.__present = true;
		}
	},
	__setGLBlend: function(enable) {
		if(this.__contextState.__enableGLBlend != enable) {
			if(enable) {
				this.gl.enable(this.gl.BLEND);
			} else {
				this.gl.disable(this.gl.BLEND);
			}
			this.__contextState.__enableGLBlend = enable;
		}
	},
	__setGLBlendEquation: function(value) {
		if(this.__contextState.__glBlendEquation != value) {
			this.gl.blendEquation(value);
			this.__contextState.__glBlendEquation = value;
		}
	},
	__setGLCullFace: function(enable) {
		if(this.__contextState.__enableGLCullFace != enable) {
			if(enable) {
				this.gl.enable(this.gl.CULL_FACE);
			} else {
				this.gl.disable(this.gl.CULL_FACE);
			}
			this.__contextState.__enableGLCullFace = enable;
		}
	},
	__setGLDepthTest: function(enable) {
		if(this.__contextState.__enableGLDepthTest != enable) {
			if(enable) {
				this.gl.enable(this.gl.DEPTH_TEST);
			} else {
				this.gl.disable(this.gl.DEPTH_TEST);
			}
			this.__contextState.__enableGLDepthTest = enable;
		}
	},
	__setGLFrontFace: function(counterClockWise) {
		if(this.__contextState.__frontFaceGLCCW != counterClockWise) {
			this.gl.frontFace(counterClockWise ? this.gl.CCW : this.gl.CW);
			this.__contextState.__frontFaceGLCCW = counterClockWise;
		}
	},
	__setGLScissorTest: function(enable) {
		if(this.__contextState.__enableGLScissorTest != enable) {
			if(enable) {
				this.gl.enable(this.gl.SCISSOR_TEST);
			} else {
				this.gl.disable(this.gl.SCISSOR_TEST);
			}
			this.__contextState.__enableGLScissorTest = enable;
		}
	},
	__setGLStencilTest: function(enable) {
		if(this.__contextState.__enableGLStencilTest != enable) {
			if(enable) {
				this.gl.enable(this.gl.STENCIL_TEST);
			} else {
				this.gl.disable(this.gl.STENCIL_TEST);
			}
			this.__contextState.__enableGLStencilTest = enable;
		}
	},
	get_enableErrorChecking: function() {
		return this.__enableErrorChecking;
	},
	set_enableErrorChecking: function(value) {
		return this.__enableErrorChecking = value;
	},
	get_totalGPUMemory: function() {
		if(Context3D.__glMemoryCurrentAvailable != -1) {
			var current = this.gl.getParameter(Context3D.__glMemoryCurrentAvailable);
			var total = this.gl.getParameter(Context3D.__glMemoryTotalAvailable);
			if(total > 0) {
				return (total - current) * 1024;
			}
		}
		return 0;
	}
});
Context3D.prototype.__class__ = Context3D.prototype.constructor = $hxClasses["openfl.display3D.Context3D"] = Context3D;

// Init



// Statics


Context3D.supportsVideoTexture = true
Context3D.__glDepthStencil = -1
Context3D.__glMaxTextureMaxAnisotropy = -1
Context3D.__glMaxViewportDims = -1
Context3D.__glMemoryCurrentAvailable = -1
Context3D.__glMemoryTotalAvailable = -1
Context3D.__glTextureMaxAnisotropy = -1

// Export

exports.default = Context3D;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/IndexBuffer3D.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/IndexBuffer3D.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.IndexBuffer3D

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}

// Constructor

var IndexBuffer3D = function(context3D,numIndices,bufferUsage) {
	this.__context = context3D;
	this.__numIndices = numIndices;
	var gl = this.__context.gl;
	this.__id = gl.createBuffer();
	this.__usage = bufferUsage == "dynamicDraw" ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
}

// Meta

IndexBuffer3D.__name__ = "openfl.display3D.IndexBuffer3D";
IndexBuffer3D.__isInterface__ = false;
IndexBuffer3D.prototype = {
	dispose: function() {
		var gl = this.__context.gl;
		gl.deleteBuffer(this.__id);
	},
	uploadFromByteArray: function(data,byteArrayOffset,startOffset,count) {
		var offset = byteArrayOffset + startOffset * 2;
		var elements = null;
		var array = null;
		var view = null;
		var buffer = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toArrayBuffer(data);
		var byteoffset = offset;
		if(byteoffset == null) {
			byteoffset = 0;
		}
		var this1;
		if(elements != null) {
			this1 = new Uint16Array(elements);
		} else if(array != null) {
			this1 = new Uint16Array(array);
		} else if(view != null) {
			this1 = new Uint16Array(view);
		} else if(buffer != null) {
			if(count == null) {
				this1 = new Uint16Array(buffer,byteoffset);
			} else {
				this1 = new Uint16Array(buffer,byteoffset,count);
			}
		} else {
			this1 = null;
		}
		this.uploadFromTypedArray(this1);
	},
	uploadFromTypedArray: function(data,byteLength) {
		if(byteLength == null) {
			byteLength = -1;
		}
		if(data == null) {
			return;
		}
		var gl = this.__context.gl;
		this.__context.__bindGLElementArrayBuffer(this.__id);
		(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).bufferData(gl,gl.ELEMENT_ARRAY_BUFFER,data,this.__usage);
	},
	uploadFromVector: function(data,startOffset,count) {
		if(data == null) {
			return;
		}
		var gl = this.__context.gl;
		var length = startOffset + count;
		var existingUInt16Array = this.__tempUInt16Array;
		if(this.__tempUInt16Array == null || this.__tempUInt16Array.length < count) {
			var array = null;
			var view = null;
			var buffer = null;
			var len = null;
			var this1;
			if(count != null) {
				this1 = new Uint16Array(count);
			} else if(array != null) {
				this1 = new Uint16Array(array);
			} else if(view != null) {
				this1 = new Uint16Array(view);
			} else if(buffer != null) {
				if(len == null) {
					this1 = new Uint16Array(buffer,0);
				} else {
					this1 = new Uint16Array(buffer,0,len);
				}
			} else {
				this1 = null;
			}
			this.__tempUInt16Array = this1;
			if(existingUInt16Array != null) {
				this.__tempUInt16Array.set(existingUInt16Array);
			}
		}
		var _g = startOffset;
		var _g1 = length;
		while(_g < _g1) {
			var i = _g++;
			this.__tempUInt16Array[i - startOffset] = data[i];
		}
		this.uploadFromTypedArray(this.__tempUInt16Array);
	}
};
IndexBuffer3D.prototype.__class__ = IndexBuffer3D.prototype.constructor = $hxClasses["openfl.display3D.IndexBuffer3D"] = IndexBuffer3D;

// Init



// Statics




// Export

exports.default = IndexBuffer3D;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/Program3D.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/Program3D.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.Program3D

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl__$internal_formats_agal_AGALConverter() {return __webpack_require__(/*! ./../../openfl/_internal/formats/agal/AGALConverter */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/agal/AGALConverter.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function haxe_ds_List() {return __webpack_require__(/*! ./../../haxe/ds/List */ "./node_modules/openfl/lib/_gen/haxe/ds/List.js");}
function openfl_display3D_Uniform() {return __webpack_require__(/*! ./../../openfl/display3D/Uniform */ "./node_modules/openfl/lib/_gen/openfl/display3D/Uniform.js");}
function openfl_display3D_UniformMap() {return __webpack_require__(/*! ./../../openfl/display3D/UniformMap */ "./node_modules/openfl/lib/_gen/openfl/display3D/UniformMap.js");}
function Lambda() {return __webpack_require__(/*! ./../../Lambda */ "./node_modules/openfl/lib/_gen/Lambda.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_IllegalOperationError() {return __webpack_require__(/*! ./../../openfl/errors/IllegalOperationError */ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js");}
function EReg() {return __webpack_require__(/*! ./../../EReg */ "./node_modules/openfl/lib/_gen/EReg.js");}

// Constructor

var Program3D = function(context3D,format) {
	this.__context = context3D;
	this.__format = format;
	if(this.__format == "agal") {
		this.__agalSamplerUsageMask = 0;
		this.__agalUniforms = new (haxe_ds_List().default)();
		this.__agalSamplerUniforms = new (haxe_ds_List().default)();
		this.__agalAlphaSamplerUniforms = new (haxe_ds_List().default)();
		this.__agalAlphaSamplerEnabled = [];
	} else {
		this.__glslAttribNames = [];
		this.__glslAttribTypes = [];
		this.__glslSamplerNames = [];
		this.__glslUniformLocations = [];
		this.__glslUniformNames = [];
		this.__glslUniformTypes = [];
	}
	this.__samplerStates = [];
}

// Meta

Program3D.__name__ = "openfl.display3D.Program3D";
Program3D.__isInterface__ = false;
Program3D.prototype = {
	dispose: function() {
		this.__deleteShaders();
	},
	getAttributeIndex: function(name) {
		if(this.__format == "agal") {
			if((StringTools().default).startsWith(name,"va")) {
				return (Std().default).parseInt(name.substring(2));
			} else {
				return -1;
			}
		} else {
			var _g = 0;
			var _g1 = this.__glslAttribNames.length;
			while(_g < _g1) {
				var i = _g++;
				if(this.__glslAttribNames[i] == name) {
					return i;
				}
			}
			return -1;
		}
	},
	getConstantIndex: function(name) {
		if(this.__format == "agal") {
			if((StringTools().default).startsWith(name,"vc")) {
				return (Std().default).parseInt(name.substring(2));
			} else if((StringTools().default).startsWith(name,"fc")) {
				return (Std().default).parseInt(name.substring(2));
			} else {
				return -1;
			}
		} else {
			var _g = 0;
			var _g1 = this.__glslUniformNames.length;
			while(_g < _g1) {
				var i = _g++;
				if(this.__glslUniformNames[i] == name) {
					return this.__glslUniformLocations[i];
				}
			}
			return -1;
		}
	},
	upload: function(vertexProgram,fragmentProgram) {
		if(this.__format != "agal") {
			return;
		}
		var samplerStates = [];
		var glslVertex = (openfl__$internal_formats_agal_AGALConverter().default).convertToGLSL(vertexProgram,null);
		var glslFragment = (openfl__$internal_formats_agal_AGALConverter().default).convertToGLSL(fragmentProgram,samplerStates);
		if((lime_utils_Log().default).level == 5) {
			(lime_utils_Log().default).info(glslVertex,{ fileName : "../src/openfl/display3D/Program3D.hx", lineNumber : 399, className : "openfl.display3D.Program3D", methodName : "upload"});
			(lime_utils_Log().default).info(glslFragment,{ fileName : "../src/openfl/display3D/Program3D.hx", lineNumber : 400, className : "openfl.display3D.Program3D", methodName : "upload"});
		}
		this.__deleteShaders();
		this.__uploadFromGLSL(glslVertex,glslFragment);
		this.__buildAGALUniformList();
		var _g = 0;
		var _g1 = samplerStates.length;
		while(_g < _g1) {
			var i = _g++;
			this.__samplerStates[i] = samplerStates[i];
		}
	},
	uploadSources: function(vertexSource,fragmentSource) {
		if(this.__format != "glsl") {
			return;
		}
		var prefix = "#ifdef GL_ES\n\t\t\t#ifdef GL_FRAGMENT_PRECISION_HIGH\n\t\t\tprecision highp float;\n\t\t\t#else\n\t\t\tprecision mediump float;\n\t\t\t#endif\n\t\t\t#endif\n\t\t\t";
		var vertex = prefix + vertexSource;
		var fragment = prefix + fragmentSource;
		if(vertex == this.__glVertexSource && fragment == this.__glFragmentSource) {
			return;
		}
		this.__processGLSLData(vertexSource,"attribute");
		this.__processGLSLData(vertexSource,"uniform");
		this.__processGLSLData(fragmentSource,"uniform");
		this.__deleteShaders();
		this.__uploadFromGLSL(vertex,fragment);
		var samplerNames = this.__glslSamplerNames;
		var attribNames = this.__glslAttribNames;
		var attribTypes = this.__glslAttribTypes;
		var uniformNames = this.__glslUniformNames;
		this.__glslSamplerNames = [];
		this.__glslAttribNames = [];
		this.__glslAttribTypes = [];
		this.__glslUniformLocations = [];
		var gl = this.__context.gl;
		var index;
		var location;
		var _g = 0;
		while(_g < samplerNames.length) {
			var name = samplerNames[_g];
			++_g;
			index = gl.getUniformLocation(this.__glProgram,name);
			this.__glslSamplerNames[index] = name;
		}
		var _g1 = 0;
		var _g2 = attribNames.length;
		while(_g1 < _g2) {
			var i = _g1++;
			index = gl.getAttribLocation(this.__glProgram,attribNames[i]);
			this.__glslAttribNames[index] = attribNames[i];
			this.__glslAttribTypes[index] = attribTypes[i];
		}
		var _g3 = 0;
		var _g4 = uniformNames.length;
		while(_g3 < _g4) {
			var i1 = _g3++;
			location = gl.getUniformLocation(this.__glProgram,uniformNames[i1]);
			this.__glslUniformLocations[i1] = location;
		}
	},
	__buildAGALUniformList: function() {
		if(this.__format == "glsl") {
			return;
		}
		var gl = this.__context.gl;
		this.__agalUniforms.clear();
		this.__agalSamplerUniforms.clear();
		this.__agalAlphaSamplerUniforms.clear();
		this.__agalAlphaSamplerEnabled = [];
		this.__agalSamplerUsageMask = 0;
		var numActive = 0;
		numActive = gl.getProgramParameter(this.__glProgram,gl.ACTIVE_UNIFORMS);
		var vertexUniforms = new (haxe_ds_List().default)();
		var fragmentUniforms = new (haxe_ds_List().default)();
		var _g = 0;
		var _g1 = numActive;
		while(_g < _g1) {
			var i = _g++;
			var info = gl.getActiveUniform(this.__glProgram,i);
			var name = info.name;
			var size = info.size;
			var uniformType = info.type;
			var uniform = new (openfl_display3D_Uniform().default)(this.__context);
			uniform.name = name;
			uniform.size = size;
			uniform.type = uniformType;
			uniform.location = gl.getUniformLocation(this.__glProgram,uniform.name);
			var indexBracket = uniform.name.indexOf("[");
			if(indexBracket >= 0) {
				uniform.name = uniform.name.substring(0,indexBracket);
			}
			switch(uniform.type) {
			case 35674:
				uniform.regCount = 2;
				break;
			case 35675:
				uniform.regCount = 3;
				break;
			case 35676:
				uniform.regCount = 4;
				break;
			default:
				uniform.regCount = 1;
			}
			uniform.regCount *= uniform.size;
			this.__agalUniforms.add(uniform);
			if(uniform.name == "vcPositionScale") {
				this.__agalPositionScale = uniform;
			} else if((StringTools().default).startsWith(uniform.name,"vc")) {
				uniform.regIndex = (Std().default).parseInt(uniform.name.substring(2));
				uniform.regData = this.__context.__vertexConstants;
				vertexUniforms.add(uniform);
			} else if((StringTools().default).startsWith(uniform.name,"fc")) {
				uniform.regIndex = (Std().default).parseInt(uniform.name.substring(2));
				uniform.regData = this.__context.__fragmentConstants;
				fragmentUniforms.add(uniform);
			} else if((StringTools().default).startsWith(uniform.name,"sampler") && uniform.name.indexOf("alpha") == -1) {
				uniform.regIndex = (Std().default).parseInt(uniform.name.substring(7));
				this.__agalSamplerUniforms.add(uniform);
				var _g11 = 0;
				var _g2 = uniform.regCount;
				while(_g11 < _g2) {
					var reg = _g11++;
					this.__agalSamplerUsageMask |= 1 << uniform.regIndex + reg;
				}
			} else if((StringTools().default).startsWith(uniform.name,"sampler") && (StringTools().default).endsWith(uniform.name,"_alpha")) {
				var len = uniform.name.indexOf("_") - 7;
				uniform.regIndex = (Std().default).parseInt(uniform.name.substring(7,7 + len)) + 4;
				this.__agalAlphaSamplerUniforms.add(uniform);
			} else if((StringTools().default).startsWith(uniform.name,"sampler") && (StringTools().default).endsWith(uniform.name,"_alphaEnabled")) {
				uniform.regIndex = (Std().default).parseInt(uniform.name.substring(7));
				this.__agalAlphaSamplerEnabled[uniform.regIndex] = uniform;
			}
			if((lime_utils_Log().default).level == 5) {
				(lime_utils_Log().default).verbose("" + i + " name:" + uniform.name + " type:" + uniform.type + " size:" + uniform.size + " location:" + (Std().default).string(uniform.location),{ fileName : "../src/openfl/display3D/Program3D.hx", lineNumber : 577, className : "openfl.display3D.Program3D", methodName : "__buildAGALUniformList"});
			}
		}
		this.__agalVertexUniformMap = new (openfl_display3D_UniformMap().default)((Lambda().default).array(vertexUniforms));
		this.__agalFragmentUniformMap = new (openfl_display3D_UniformMap().default)((Lambda().default).array(fragmentUniforms));
	},
	__deleteShaders: function() {
		var gl = this.__context.gl;
		if(this.__glProgram != null) {
			this.__glProgram = null;
		}
		if(this.__glVertexShader != null) {
			gl.deleteShader(this.__glVertexShader);
			this.__glVertexShader = null;
		}
		if(this.__glFragmentShader != null) {
			gl.deleteShader(this.__glFragmentShader);
			this.__glFragmentShader = null;
		}
	},
	__disable: function() {
		var tmp = this.__format == "glsl";
	},
	__enable: function() {
		var gl = this.__context.gl;
		gl.useProgram(this.__glProgram);
		if(this.__format == "agal") {
			this.__agalVertexUniformMap.markAllDirty();
			this.__agalFragmentUniformMap.markAllDirty();
			var sampler = this.__agalSamplerUniforms.iterator();
			while(sampler.hasNext()) {
				var sampler1 = sampler.next();
				if(sampler1.regCount == 1) {
					gl.uniform1i(sampler1.location,sampler1.regIndex);
				} else {
					throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("!!! TODO: uniform location on webgl"));
				}
			}
			var sampler2 = this.__agalAlphaSamplerUniforms.iterator();
			while(sampler2.hasNext()) {
				var sampler3 = sampler2.next();
				if(sampler3.regCount == 1) {
					gl.uniform1i(sampler3.location,sampler3.regIndex);
				} else {
					throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("!!! TODO: uniform location on webgl"));
				}
			}
		}
	},
	__flush: function() {
		if(this.__format == "agal") {
			this.__agalVertexUniformMap.flush();
			this.__agalFragmentUniformMap.flush();
		} else {
			return;
		}
	},
	__getSamplerState: function(sampler) {
		return this.__samplerStates[sampler];
	},
	__markDirty: function(isVertex,index,count) {
		if(this.__format == "glsl") {
			return;
		}
		if(isVertex) {
			this.__agalVertexUniformMap.markDirty(index,count);
		} else {
			this.__agalFragmentUniformMap.markDirty(index,count);
		}
	},
	__processGLSLData: function(source,storageType) {
		var lastMatch = 0;
		var position;
		var regex;
		var name;
		var type;
		if(storageType == "uniform") {
			regex = new (EReg().default)("uniform ([A-Za-z0-9]+) ([A-Za-z0-9_]+)","");
		} else {
			regex = new (EReg().default)("attribute ([A-Za-z0-9]+) ([A-Za-z0-9_]+)","");
		}
		while(regex.matchSub(source,lastMatch)) {
			type = regex.matched(1);
			name = regex.matched(2);
			if((StringTools().default).startsWith(name,"gl_")) {
				continue;
			}
			if((StringTools().default).startsWith(type,"sampler")) {
				this.__glslSamplerNames.push(name);
			} else {
				var parameterType;
				switch(type) {
				case "bool":
					parameterType = "bool";
					break;
				case "bvec2":
					parameterType = "bool2";
					break;
				case "bvec3":
					parameterType = "bool3";
					break;
				case "bvec4":
					parameterType = "bool4";
					break;
				case "dvec2":case "vec2":
					parameterType = "float2";
					break;
				case "dvec3":case "vec3":
					parameterType = "float3";
					break;
				case "double":case "float":
					parameterType = "float";
					break;
				case "ivec3":case "uvec3":
					parameterType = "int3";
					break;
				case "ivec4":case "uvec4":
					parameterType = "int4";
					break;
				case "mat2":case "mat2x2":
					parameterType = "matrix2x2";
					break;
				case "mat2x3":
					parameterType = "matrix2x3";
					break;
				case "mat2x4":
					parameterType = "matrix2x4";
					break;
				case "mat3x2":
					parameterType = "matrix3x2";
					break;
				case "mat3":case "mat3x3":
					parameterType = "matrix3x3";
					break;
				case "mat3x4":
					parameterType = "matrix3x4";
					break;
				case "mat4":case "mat4x4":
					parameterType = "matrix4x4";
					break;
				case "mat4x2":
					parameterType = "matrix4x2";
					break;
				case "mat4x3":
					parameterType = "matrix4x3";
					break;
				case "int":case "uint":
					parameterType = "int";
					break;
				case "ivec2":case "uvec2":
					parameterType = "int2";
					break;
				case "dvec4":case "vec4":
					parameterType = "float4";
					break;
				default:
					parameterType = null;
				}
				if(storageType == "uniform") {
					this.__glslUniformNames.push(name);
					this.__glslUniformTypes.push(parameterType);
				} else {
					this.__glslAttribNames.push(name);
					this.__glslAttribTypes.push(parameterType);
				}
			}
			position = regex.matchedPos();
			lastMatch = position.pos + position.len;
		}
	},
	__setPositionScale: function(positionScale) {
		if(this.__format == "glsl") {
			return;
		}
		if(this.__agalPositionScale != null) {
			var gl = this.__context.gl;
			var location = this.__agalPositionScale.location;
			var data = positionScale;
			var srcOffset = null;
			if(srcOffset != null) {
				gl.uniform4fv(location,data,srcOffset,null);
			} else {
				gl.uniform4fv(location,data);
			}
		}
	},
	__setSamplerState: function(sampler,state) {
		this.__samplerStates[sampler] = state;
	},
	__uploadFromGLSL: function(vertexShaderSource,fragmentShaderSource) {
		var gl = this.__context.gl;
		this.__glVertexSource = vertexShaderSource;
		this.__glFragmentSource = fragmentShaderSource;
		this.__glVertexShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(this.__glVertexShader,vertexShaderSource);
		gl.compileShader(this.__glVertexShader);
		if(gl.getShaderParameter(this.__glVertexShader,gl.COMPILE_STATUS) == 0) {
			var message = "Error compiling vertex shader";
			message += "\n" + gl.getShaderInfoLog(this.__glVertexShader);
			message += "\n" + vertexShaderSource;
			(lime_utils_Log().default).error(message,{ fileName : "../src/openfl/display3D/Program3D.hx", lineNumber : 869, className : "openfl.display3D.Program3D", methodName : "__uploadFromGLSL"});
		}
		this.__glFragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(this.__glFragmentShader,fragmentShaderSource);
		gl.compileShader(this.__glFragmentShader);
		if(gl.getShaderParameter(this.__glFragmentShader,gl.COMPILE_STATUS) == 0) {
			var message1 = "Error compiling fragment shader";
			message1 += "\n" + gl.getShaderInfoLog(this.__glFragmentShader);
			message1 += "\n" + fragmentShaderSource;
			(lime_utils_Log().default).error(message1,{ fileName : "../src/openfl/display3D/Program3D.hx", lineNumber : 881, className : "openfl.display3D.Program3D", methodName : "__uploadFromGLSL"});
		}
		this.__glProgram = gl.createProgram();
		if(this.__format == "agal") {
			var _g = 0;
			while(_g < 16) {
				var i = _g++;
				var name = "va" + i;
				if(vertexShaderSource.indexOf(" " + name) != -1) {
					gl.bindAttribLocation(this.__glProgram,i,name);
				}
			}
		} else {
			var _g1 = 0;
			var _g11 = this.__glslAttribNames;
			while(_g1 < _g11.length) {
				var name1 = _g11[_g1];
				++_g1;
				if(name1.indexOf("Position") > -1 && (StringTools().default).startsWith(name1,"openfl_")) {
					gl.bindAttribLocation(this.__glProgram,0,name1);
					break;
				}
			}
		}
		gl.attachShader(this.__glProgram,this.__glVertexShader);
		gl.attachShader(this.__glProgram,this.__glFragmentShader);
		gl.linkProgram(this.__glProgram);
		if(gl.getProgramParameter(this.__glProgram,gl.LINK_STATUS) == 0) {
			var message2 = "Unable to initialize the shader program";
			message2 += "\n" + gl.getProgramInfoLog(this.__glProgram);
			(lime_utils_Log().default).error(message2,{ fileName : "../src/openfl/display3D/Program3D.hx", lineNumber : 922, className : "openfl.display3D.Program3D", methodName : "__uploadFromGLSL"});
		}
	}
};
Program3D.prototype.__class__ = Program3D.prototype.constructor = $hxClasses["openfl.display3D.Program3D"] = Program3D;

// Init



// Statics




// Export

exports.default = Program3D;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/Uniform.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/Uniform.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.Uniform

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_graphics__$WebGL2RenderContext_WebGL2RenderContext_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGL2RenderContext/WebGL2RenderContext_Impl_.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function lime_utils_BytePointerData() {return __webpack_require__(/*! ./../../lime/utils/BytePointerData */ "./node_modules/openfl/lib/_gen/lime/utils/BytePointerData.js");}

// Constructor

var Uniform = function(context) {
	this.context = context;
	this.isDirty = true;
	var this1 = new (lime_utils_BytePointerData().default)(null,0);
	this.regDataPointer = this1;
}

// Meta

Uniform.__name__ = "openfl.display3D.Uniform";
Uniform.__isInterface__ = false;
Uniform.prototype = {
	flush: function() {
		var gl = this.context.gl;
		var index = this.regIndex * 4;
		switch(this.type) {
		case 35664:
			(lime_graphics__$WebGL2RenderContext_WebGL2RenderContext_$Impl_$().default).uniform2fv(gl,this.location,this.__getUniformRegisters(index,this.regCount * 2));
			break;
		case 35665:
			var location = this.location;
			var data = this.__getUniformRegisters(index,this.regCount * 3);
			var srcOffset = null;
			if(srcOffset != null) {
				gl.uniform3fv(location,data,srcOffset,null);
			} else {
				gl.uniform3fv(location,data);
			}
			break;
		case 35666:
			var location1 = this.location;
			var data1 = this.__getUniformRegisters(index,this.regCount * 4);
			var srcOffset1 = null;
			if(srcOffset1 != null) {
				gl.uniform4fv(location1,data1,srcOffset1,null);
			} else {
				gl.uniform4fv(location1,data1);
			}
			break;
		case 35674:
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix2fv(gl,this.location,false,this.__getUniformRegisters(index,this.size * 2 * 2));
			break;
		case 35675:
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix3fv(gl,this.location,false,this.__getUniformRegisters(index,this.size * 3 * 3));
			break;
		case 35676:
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).uniformMatrix4fv(gl,this.location,false,this.__getUniformRegisters(index,this.size * 4 * 4));
			break;
		default:
			var location2 = this.location;
			var data2 = this.__getUniformRegisters(index,this.regCount * 4);
			var srcOffset2 = null;
			if(srcOffset2 != null) {
				gl.uniform4fv(location2,data2,srcOffset2,null);
			} else {
				gl.uniform4fv(location2,data2);
			}
		}
	},
	__getUniformRegisters: function(index,size) {
		return this.regData.subarray(index,index + size);
	}
};
Uniform.prototype.__class__ = Uniform.prototype.constructor = $hxClasses["openfl.display3D.Uniform"] = Uniform;

// Init



// Statics


Uniform.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Uniform;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/UniformMap.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/UniformMap.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.UniformMap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}

// Constructor

var UniformMap = function(list) {
	this.__uniforms = list;
	this.__uniforms.sort(function(a,b) {
		return (Reflect().default).compare(a.regIndex,b.regIndex);
	});
	var total = 0;
	var _g = 0;
	var _g1 = this.__uniforms;
	while(_g < _g1.length) {
		var uniform = _g1[_g];
		++_g;
		if(uniform.regIndex + uniform.regCount > total) {
			total = uniform.regIndex + uniform.regCount;
		}
	}
	this.__registerLookup = (openfl__$Vector_Vector_$Impl_$().default)._new(total);
	var _g2 = 0;
	var _g3 = this.__uniforms;
	while(_g2 < _g3.length) {
		var uniform1 = _g3[_g2];
		++_g2;
		var _g21 = 0;
		var _g31 = uniform1.regCount;
		while(_g21 < _g31) {
			var i = _g21++;
			(openfl__$Vector_Vector_$Impl_$().default).set(this.__registerLookup,uniform1.regIndex + i,uniform1);
		}
	}
	this.__anyDirty = this.__allDirty = true;
}

// Meta

UniformMap.__name__ = "openfl.display3D.UniformMap";
UniformMap.__isInterface__ = false;
UniformMap.prototype = {
	flush: function() {
		if(this.__anyDirty) {
			var _g = 0;
			var _g1 = this.__uniforms;
			while(_g < _g1.length) {
				var uniform = _g1[_g];
				++_g;
				if(this.__allDirty || uniform.isDirty) {
					uniform.flush();
					uniform.isDirty = false;
				}
			}
			this.__anyDirty = this.__allDirty = false;
		}
	},
	markAllDirty: function() {
		this.__allDirty = true;
		this.__anyDirty = true;
	},
	markDirty: function(start,count) {
		if(this.__allDirty) {
			return;
		}
		var end = start + count;
		if(end > this.__registerLookup.get_length()) {
			end = this.__registerLookup.get_length();
		}
		var index = start;
		while(index < end) {
			var uniform = this.__registerLookup[index];
			if(uniform != null) {
				uniform.isDirty = true;
				this.__anyDirty = true;
				index = uniform.regIndex + uniform.regCount;
			} else {
				++index;
			}
		}
	}
};
UniformMap.prototype.__class__ = UniformMap.prototype.constructor = $hxClasses["openfl.display3D.UniformMap"] = UniformMap;

// Init



// Statics


UniformMap.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = UniformMap;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/VertexBuffer3D.js":
/*!*************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/VertexBuffer3D.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.VertexBuffer3D

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}

// Constructor

var VertexBuffer3D = function(context3D,numVertices,dataPerVertex,bufferUsage) {
	this.__context = context3D;
	this.__numVertices = numVertices;
	this.__vertexSize = dataPerVertex;
	var gl = this.__context.gl;
	this.__id = gl.createBuffer();
	this.__stride = this.__vertexSize * 4;
	this.__usage = bufferUsage == "dynamicDraw" ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
}

// Meta

VertexBuffer3D.__name__ = "openfl.display3D.VertexBuffer3D";
VertexBuffer3D.__isInterface__ = false;
VertexBuffer3D.prototype = {
	dispose: function() {
		var gl = this.__context.gl;
		gl.deleteBuffer(this.__id);
	},
	uploadFromByteArray: function(data,byteArrayOffset,startVertex,numVertices) {
		var offset = byteArrayOffset + startVertex * this.__stride;
		var length = numVertices * this.__vertexSize;
		var elements = null;
		var array = null;
		var view = null;
		var buffer = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toArrayBuffer(data);
		var byteoffset = offset;
		if(byteoffset == null) {
			byteoffset = 0;
		}
		var this1;
		if(elements != null) {
			this1 = new Float32Array(elements);
		} else if(array != null) {
			this1 = new Float32Array(array);
		} else if(view != null) {
			this1 = new Float32Array(view);
		} else if(buffer != null) {
			if(length == null) {
				this1 = new Float32Array(buffer,byteoffset);
			} else {
				this1 = new Float32Array(buffer,byteoffset,length);
			}
		} else {
			this1 = null;
		}
		this.uploadFromTypedArray(this1);
	},
	uploadFromTypedArray: function(data,byteLength) {
		if(byteLength == null) {
			byteLength = -1;
		}
		if(data == null) {
			return;
		}
		var gl = this.__context.gl;
		this.__context.__bindGLArrayBuffer(this.__id);
		(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).bufferData(gl,gl.ARRAY_BUFFER,data,this.__usage);
	},
	uploadFromVector: function(data,startVertex,numVertices) {
		if(data == null) {
			return;
		}
		var gl = this.__context.gl;
		var start = startVertex * this.__vertexSize;
		var count = numVertices * this.__vertexSize;
		var length = start + count;
		var existingFloat32Array = this.__tempFloat32Array;
		if(this.__tempFloat32Array == null || this.__tempFloat32Array.length < count) {
			var array = null;
			var view = null;
			var buffer = null;
			var len = null;
			var this1;
			if(count != null) {
				this1 = new Float32Array(count);
			} else if(array != null) {
				this1 = new Float32Array(array);
			} else if(view != null) {
				this1 = new Float32Array(view);
			} else if(buffer != null) {
				if(len == null) {
					this1 = new Float32Array(buffer,0);
				} else {
					this1 = new Float32Array(buffer,0,len);
				}
			} else {
				this1 = null;
			}
			this.__tempFloat32Array = this1;
			if(existingFloat32Array != null) {
				this.__tempFloat32Array.set(existingFloat32Array);
			}
		}
		var _g = start;
		var _g1 = length;
		while(_g < _g1) {
			var i = _g++;
			this.__tempFloat32Array[i - start] = data[i];
		}
		this.uploadFromTypedArray(this.__tempFloat32Array);
	}
};
VertexBuffer3D.prototype.__class__ = VertexBuffer3D.prototype.constructor = $hxClasses["openfl.display3D.VertexBuffer3D"] = VertexBuffer3D;

// Init



// Statics




// Export

exports.default = VertexBuffer3D;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/CubeTexture.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/textures/CubeTexture.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.textures.CubeTexture

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display3D_textures_TextureBase() {return __webpack_require__(/*! ./../../../openfl/display3D/textures/TextureBase */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/TextureBase.js");}
function haxe_Timer() {return __webpack_require__(/*! ./../../../haxe/Timer */ "./node_modules/openfl/lib/_gen/haxe/Timer.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function openfl_display3D_Context3D() {return __webpack_require__(/*! ./../../../openfl/display3D/Context3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/Context3D.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_IllegalOperationError() {return __webpack_require__(/*! ./../../../openfl/errors/IllegalOperationError */ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js");}
function openfl__$internal_formats_atf_ATFReader() {return __webpack_require__(/*! ./../../../openfl/_internal/formats/atf/ATFReader */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/atf/ATFReader.js");}
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var CubeTexture = function(context,size,format,optimizeForRenderToTexture,streamingLevels) {
	(openfl_display3D_textures_TextureBase().default).call(this,context);
	this.__size = size;
	this.__width = this.__height = this.__size;
	this.__optimizeForRenderToTexture = optimizeForRenderToTexture;
	this.__streamingLevels = streamingLevels;
	this.__textureTarget = this.__context.gl.TEXTURE_CUBE_MAP;
	this.__uploadedSides = 0;
}

// Meta

CubeTexture.__name__ = "openfl.display3D.textures.CubeTexture";
CubeTexture.__isInterface__ = false;
CubeTexture.__super__ = (openfl_display3D_textures_TextureBase().default);
CubeTexture.prototype = $extend((openfl_display3D_textures_TextureBase().default).prototype, {
	uploadCompressedTextureFromByteArray: function(data,byteArrayOffset,async) {
		if(async == null) {
			async = false;
		}
		var _gthis = this;
		if(!async) {
			this.__uploadCompressedTextureFromByteArray(data,byteArrayOffset);
		} else {
			(haxe_Timer().default).delay(function() {
				_gthis.__uploadCompressedTextureFromByteArray(data,byteArrayOffset);
				var event = null;
				event = new (openfl_events_Event().default)("textureReady");
				_gthis.dispatchEvent(event);
			},1);
		}
	},
	uploadFromBitmapData: function(source,side,miplevel,generateMipmap) {
		if(generateMipmap == null) {
			generateMipmap = false;
		}
		if(miplevel == null) {
			miplevel = 0;
		}
		if(source == null) {
			return;
		}
		var size = this.__size >> miplevel;
		if(size == 0) {
			return;
		}
		var image = this.__getImage(source);
		if(image == null) {
			return;
		}
		if(miplevel == 0 && image.buffer != null && image.buffer.data == null && image.buffer.get_src() != null) {
			var gl = this.__context.gl;
			var size1 = this.__size >> miplevel;
			if(size1 == 0) {
				return;
			}
			var target = this.__sideToTarget(side);
			this.__context.__bindGLTextureCubeMap(this.__textureID);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,target,miplevel,this.__internalFormat,this.__format,gl.UNSIGNED_BYTE,image.buffer.get_src());
			this.__context.__bindGLTextureCubeMap(null);
			this.__uploadedSides |= 1 << side;
			return;
		}
		this.uploadFromTypedArray(image.get_data(),side,miplevel);
	},
	uploadFromByteArray: function(data,byteArrayOffset,side,miplevel) {
		if(miplevel == null) {
			miplevel = 0;
		}
		if(byteArrayOffset == 0) {
			this.uploadFromTypedArray(data.b,side,miplevel);
			return;
		}
		var elements = null;
		var array = null;
		var view = null;
		var buffer = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toArrayBuffer(data);
		var byteoffset = byteArrayOffset;
		var len = null;
		if(byteoffset == null) {
			byteoffset = 0;
		}
		var this1;
		if(elements != null) {
			this1 = new Uint8Array(elements);
		} else if(array != null) {
			this1 = new Uint8Array(array);
		} else if(view != null) {
			this1 = new Uint8Array(view);
		} else if(buffer != null) {
			if(len == null) {
				this1 = new Uint8Array(buffer,byteoffset);
			} else {
				this1 = new Uint8Array(buffer,byteoffset,len);
			}
		} else {
			this1 = null;
		}
		this.uploadFromTypedArray(this1,side,miplevel);
	},
	uploadFromTypedArray: function(data,side,miplevel) {
		if(miplevel == null) {
			miplevel = 0;
		}
		if(data == null) {
			return;
		}
		var gl = this.__context.gl;
		var size = this.__size >> miplevel;
		if(size == 0) {
			return;
		}
		var target = this.__sideToTarget(side);
		this.__context.__bindGLTextureCubeMap(this.__textureID);
		(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,target,miplevel,this.__internalFormat,size,size,0,this.__format,gl.UNSIGNED_BYTE,data);
		this.__context.__bindGLTextureCubeMap(null);
		this.__uploadedSides |= 1 << side;
	},
	__getGLFramebuffer: function(enableDepthAndStencil,antiAlias,surfaceSelector) {
		var gl = this.__context.gl;
		if(this.__glFramebuffer == null) {
			this.__glFramebuffer = gl.createFramebuffer();
			this.__framebufferSurface = -1;
		}
		if(this.__framebufferSurface != surfaceSelector) {
			this.__framebufferSurface = surfaceSelector;
			this.__context.__bindGLFramebuffer(this.__glFramebuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_CUBE_MAP_POSITIVE_X + surfaceSelector,this.__textureID,0);
			if(this.__context.__enableErrorChecking) {
				var code = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
				if(code != gl.FRAMEBUFFER_COMPLETE) {
					(lime_utils_Log().default).error("Error: Context3D.setRenderToTexture status:" + code + " width:" + this.__width + " height:" + this.__height,{ fileName : "../src/openfl/display3D/textures/CubeTexture.hx", lineNumber : 278, className : "openfl.display3D.textures.CubeTexture", methodName : "__getGLFramebuffer"});
				}
			}
		}
		return (openfl_display3D_textures_TextureBase().default).prototype.__getGLFramebuffer.call(this,enableDepthAndStencil,antiAlias,surfaceSelector);
	},
	__setSamplerState: function(state) {
		if((openfl_display3D_textures_TextureBase().default).prototype.__setSamplerState.call(this,state)) {
			var gl = this.__context.gl;
			if(state.mipfilter != "mipnone" && !this.__samplerState.mipmapGenerated) {
				gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
				this.__samplerState.mipmapGenerated = true;
			}
			if((openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy != 0) {
				var aniso;
				switch(state.filter) {
				case "anisotropic16x":
					aniso = 16;
					break;
				case "anisotropic2x":
					aniso = 2;
					break;
				case "anisotropic4x":
					aniso = 4;
					break;
				case "anisotropic8x":
					aniso = 8;
					break;
				default:
					aniso = 1;
				}
				if(aniso > (openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy) {
					aniso = (openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy;
				}
				gl.texParameterf(gl.TEXTURE_CUBE_MAP,(openfl_display3D_Context3D().default).__glTextureMaxAnisotropy,aniso);
			}
			return true;
		}
		return false;
	},
	__sideToTarget: function(side) {
		var gl = this.__context.gl;
		switch(side) {
		case 0:
			return gl.TEXTURE_CUBE_MAP_POSITIVE_X;
		case 1:
			return gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
		case 2:
			return gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
		case 3:
			return gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
		case 4:
			return gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
		case 5:
			return gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
		default:
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
		}
	},
	__uploadCompressedTextureFromByteArray: function(data,byteArrayOffset) {
		var _gthis = this;
		var reader = new (openfl__$internal_formats_atf_ATFReader().default)(data,byteArrayOffset);
		var alpha = reader.readHeader(this.__size,this.__size,true);
		var gl = this.__context.gl;
		this.__context.__bindGLTextureCubeMap(this.__textureID);
		var hasTexture = false;
		reader.readTextures(function(side,level,gpuFormat,width,height,blockLength,bytes) {
			var format = alpha ? (openfl_display3D_textures_TextureBase().default).__compressedFormatsAlpha.get(gpuFormat) : (openfl_display3D_textures_TextureBase().default).__compressedFormats.get(gpuFormat);
			if(format == 0) {
				return;
			}
			hasTexture = true;
			var target = _gthis.__sideToTarget(side);
			_gthis.__format = format;
			_gthis.__internalFormat = format;
			if(alpha && gpuFormat == 2) {
				var size = (Std().default).int(blockLength / 2);
				var elements = null;
				var array = null;
				var view = null;
				var buffer = bytes.b.buffer;
				var byteoffset = 0;
				if(byteoffset == null) {
					byteoffset = 0;
				}
				var this1;
				if(elements != null) {
					this1 = new Uint8Array(elements);
				} else if(array != null) {
					this1 = new Uint8Array(array);
				} else if(view != null) {
					this1 = new Uint8Array(view);
				} else if(buffer != null) {
					if(size == null) {
						this1 = new Uint8Array(buffer,byteoffset);
					} else {
						this1 = new Uint8Array(buffer,byteoffset,size);
					}
				} else {
					this1 = null;
				}
				(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).compressedTexImage2D(gl,target,level,_gthis.__internalFormat,width,height,0,this1);
				var alphaTexture = new CubeTexture(_gthis.__context,_gthis.__size,"compressed",_gthis.__optimizeForRenderToTexture,_gthis.__streamingLevels);
				alphaTexture.__format = format;
				alphaTexture.__internalFormat = format;
				_gthis.__context.__bindGLTextureCubeMap(alphaTexture.__textureID);
				var elements1 = null;
				var array1 = null;
				var view1 = null;
				var buffer1 = bytes.b.buffer;
				var byteoffset1 = size;
				if(byteoffset1 == null) {
					byteoffset1 = 0;
				}
				var this2;
				if(elements1 != null) {
					this2 = new Uint8Array(elements1);
				} else if(array1 != null) {
					this2 = new Uint8Array(array1);
				} else if(view1 != null) {
					this2 = new Uint8Array(view1);
				} else if(buffer1 != null) {
					if(size == null) {
						this2 = new Uint8Array(buffer1,byteoffset1);
					} else {
						this2 = new Uint8Array(buffer1,byteoffset1,size);
					}
				} else {
					this2 = null;
				}
				(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).compressedTexImage2D(gl,target,level,alphaTexture.__internalFormat,width,height,0,this2);
				_gthis.__alphaTexture = alphaTexture;
			} else {
				var elements2 = null;
				var array2 = null;
				var view2 = null;
				var buffer2 = bytes.b.buffer;
				var byteoffset2 = 0;
				if(byteoffset2 == null) {
					byteoffset2 = 0;
				}
				var this3;
				if(elements2 != null) {
					this3 = new Uint8Array(elements2);
				} else if(array2 != null) {
					this3 = new Uint8Array(array2);
				} else if(view2 != null) {
					this3 = new Uint8Array(view2);
				} else if(buffer2 != null) {
					if(blockLength == null) {
						this3 = new Uint8Array(buffer2,byteoffset2);
					} else {
						this3 = new Uint8Array(buffer2,byteoffset2,blockLength);
					}
				} else {
					this3 = null;
				}
				(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).compressedTexImage2D(gl,target,level,_gthis.__internalFormat,width,height,0,this3);
			}
		});
		if(!hasTexture) {
			var elements3 = this.__size * this.__size * 4;
			var array3 = null;
			var view3 = null;
			var buffer3 = null;
			var len = null;
			var this4;
			if(elements3 != null) {
				this4 = new Uint8Array(elements3);
			} else if(array3 != null) {
				this4 = new Uint8Array(array3);
			} else if(view3 != null) {
				this4 = new Uint8Array(view3);
			} else if(buffer3 != null) {
				if(len == null) {
					this4 = new Uint8Array(buffer3,0);
				} else {
					this4 = new Uint8Array(buffer3,0,len);
				}
			} else {
				this4 = null;
			}
			var data1 = this4;
			var tmp = this.__sideToTarget(0);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,tmp,0,this.__internalFormat,this.__size,this.__size,0,this.__format,gl.UNSIGNED_BYTE,data1);
			var elements4 = this.__size * this.__size * 4;
			var array4 = null;
			var view4 = null;
			var buffer4 = null;
			var len1 = null;
			var this5;
			if(elements4 != null) {
				this5 = new Uint8Array(elements4);
			} else if(array4 != null) {
				this5 = new Uint8Array(array4);
			} else if(view4 != null) {
				this5 = new Uint8Array(view4);
			} else if(buffer4 != null) {
				if(len1 == null) {
					this5 = new Uint8Array(buffer4,0);
				} else {
					this5 = new Uint8Array(buffer4,0,len1);
				}
			} else {
				this5 = null;
			}
			var data2 = this5;
			var tmp1 = this.__sideToTarget(1);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,tmp1,0,this.__internalFormat,this.__size,this.__size,0,this.__format,gl.UNSIGNED_BYTE,data2);
			var elements5 = this.__size * this.__size * 4;
			var array5 = null;
			var view5 = null;
			var buffer5 = null;
			var len2 = null;
			var this6;
			if(elements5 != null) {
				this6 = new Uint8Array(elements5);
			} else if(array5 != null) {
				this6 = new Uint8Array(array5);
			} else if(view5 != null) {
				this6 = new Uint8Array(view5);
			} else if(buffer5 != null) {
				if(len2 == null) {
					this6 = new Uint8Array(buffer5,0);
				} else {
					this6 = new Uint8Array(buffer5,0,len2);
				}
			} else {
				this6 = null;
			}
			var data3 = this6;
			var tmp2 = this.__sideToTarget(2);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,tmp2,0,this.__internalFormat,this.__size,this.__size,0,this.__format,gl.UNSIGNED_BYTE,data3);
			var elements6 = this.__size * this.__size * 4;
			var array6 = null;
			var view6 = null;
			var buffer6 = null;
			var len3 = null;
			var this7;
			if(elements6 != null) {
				this7 = new Uint8Array(elements6);
			} else if(array6 != null) {
				this7 = new Uint8Array(array6);
			} else if(view6 != null) {
				this7 = new Uint8Array(view6);
			} else if(buffer6 != null) {
				if(len3 == null) {
					this7 = new Uint8Array(buffer6,0);
				} else {
					this7 = new Uint8Array(buffer6,0,len3);
				}
			} else {
				this7 = null;
			}
			var data4 = this7;
			var tmp3 = this.__sideToTarget(3);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,tmp3,0,this.__internalFormat,this.__size,this.__size,0,this.__format,gl.UNSIGNED_BYTE,data4);
			var elements7 = this.__size * this.__size * 4;
			var array7 = null;
			var view7 = null;
			var buffer7 = null;
			var len4 = null;
			var this8;
			if(elements7 != null) {
				this8 = new Uint8Array(elements7);
			} else if(array7 != null) {
				this8 = new Uint8Array(array7);
			} else if(view7 != null) {
				this8 = new Uint8Array(view7);
			} else if(buffer7 != null) {
				if(len4 == null) {
					this8 = new Uint8Array(buffer7,0);
				} else {
					this8 = new Uint8Array(buffer7,0,len4);
				}
			} else {
				this8 = null;
			}
			var data5 = this8;
			var tmp4 = this.__sideToTarget(4);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,tmp4,0,this.__internalFormat,this.__size,this.__size,0,this.__format,gl.UNSIGNED_BYTE,data5);
			var elements8 = this.__size * this.__size * 4;
			var array8 = null;
			var view8 = null;
			var buffer8 = null;
			var len5 = null;
			var this9;
			if(elements8 != null) {
				this9 = new Uint8Array(elements8);
			} else if(array8 != null) {
				this9 = new Uint8Array(array8);
			} else if(view8 != null) {
				this9 = new Uint8Array(view8);
			} else if(buffer8 != null) {
				if(len5 == null) {
					this9 = new Uint8Array(buffer8,0);
				} else {
					this9 = new Uint8Array(buffer8,0,len5);
				}
			} else {
				this9 = null;
			}
			var data6 = this9;
			var tmp5 = this.__sideToTarget(5);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,tmp5,0,this.__internalFormat,this.__size,this.__size,0,this.__format,gl.UNSIGNED_BYTE,data6);
		}
		this.__context.__bindGLTextureCubeMap(null);
	}
});
CubeTexture.prototype.__class__ = CubeTexture.prototype.constructor = $hxClasses["openfl.display3D.textures.CubeTexture"] = CubeTexture;

// Init



// Statics




// Export

exports.default = CubeTexture;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/RectangleTexture.js":
/*!************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/textures/RectangleTexture.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.textures.RectangleTexture

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display3D_textures_TextureBase() {return __webpack_require__(/*! ./../../../openfl/display3D/textures/TextureBase */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/TextureBase.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function openfl_display3D_Context3D() {return __webpack_require__(/*! ./../../../openfl/display3D/Context3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/Context3D.js");}

// Constructor

var RectangleTexture = function(context,width,height,format,optimizeForRenderToTexture) {
	(openfl_display3D_textures_TextureBase().default).call(this,context);
	this.__width = width;
	this.__height = height;
	this.__optimizeForRenderToTexture = optimizeForRenderToTexture;
	this.__textureTarget = this.__context.gl.TEXTURE_2D;
	this.uploadFromTypedArray(null);
	if(optimizeForRenderToTexture) {
		this.__getGLFramebuffer(true,0,0);
	}
}

// Meta

RectangleTexture.__name__ = "openfl.display3D.textures.RectangleTexture";
RectangleTexture.__isInterface__ = false;
RectangleTexture.__super__ = (openfl_display3D_textures_TextureBase().default);
RectangleTexture.prototype = $extend((openfl_display3D_textures_TextureBase().default).prototype, {
	uploadFromBitmapData: function(source) {
		if(source == null) {
			return;
		}
		var image = this.__getImage(source);
		if(image == null) {
			return;
		}
		if(image.buffer != null && image.buffer.data == null && image.buffer.get_src() != null) {
			var gl = this.__context.gl;
			this.__context.__bindGLTexture2D(this.__textureID);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,this.__textureTarget,0,this.__internalFormat,this.__format,gl.UNSIGNED_BYTE,image.buffer.get_src());
			this.__context.__bindGLTexture2D(null);
			return;
		}
		this.uploadFromTypedArray(image.get_data());
	},
	uploadFromByteArray: function(data,byteArrayOffset) {
		if(byteArrayOffset == 0) {
			this.uploadFromTypedArray(data.b);
			return;
		}
		var elements = null;
		var array = null;
		var view = null;
		var buffer = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toArrayBuffer(data);
		var byteoffset = byteArrayOffset;
		var len = null;
		if(byteoffset == null) {
			byteoffset = 0;
		}
		var this1;
		if(elements != null) {
			this1 = new Uint8Array(elements);
		} else if(array != null) {
			this1 = new Uint8Array(array);
		} else if(view != null) {
			this1 = new Uint8Array(view);
		} else if(buffer != null) {
			if(len == null) {
				this1 = new Uint8Array(buffer,byteoffset);
			} else {
				this1 = new Uint8Array(buffer,byteoffset,len);
			}
		} else {
			this1 = null;
		}
		this.uploadFromTypedArray(this1);
	},
	uploadFromTypedArray: function(data) {
		var gl = this.__context.gl;
		this.__context.__bindGLTexture2D(this.__textureID);
		(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,this.__textureTarget,0,this.__internalFormat,this.__width,this.__height,0,this.__format,gl.UNSIGNED_BYTE,data);
		this.__context.__bindGLTexture2D(null);
	},
	__setSamplerState: function(state) {
		if((openfl_display3D_textures_TextureBase().default).prototype.__setSamplerState.call(this,state)) {
			var gl = this.__context.gl;
			if((openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy != 0) {
				var aniso;
				switch(state.filter) {
				case "anisotropic16x":
					aniso = 16;
					break;
				case "anisotropic2x":
					aniso = 2;
					break;
				case "anisotropic4x":
					aniso = 4;
					break;
				case "anisotropic8x":
					aniso = 8;
					break;
				default:
					aniso = 1;
				}
				if(aniso > (openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy) {
					aniso = (openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy;
				}
				gl.texParameterf(gl.TEXTURE_2D,(openfl_display3D_Context3D().default).__glTextureMaxAnisotropy,aniso);
			}
			return true;
		}
		return false;
	}
});
RectangleTexture.prototype.__class__ = RectangleTexture.prototype.constructor = $hxClasses["openfl.display3D.textures.RectangleTexture"] = RectangleTexture;

// Init



// Statics




// Export

exports.default = RectangleTexture;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/Texture.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/textures/Texture.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.textures.Texture

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display3D_textures_TextureBase() {return __webpack_require__(/*! ./../../../openfl/display3D/textures/TextureBase */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/TextureBase.js");}
function haxe_Timer() {return __webpack_require__(/*! ./../../../haxe/Timer */ "./node_modules/openfl/lib/_gen/haxe/Timer.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function openfl_display_BitmapData() {return __webpack_require__(/*! ./../../../openfl/display/BitmapData */ "./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function openfl_display3D_Context3D() {return __webpack_require__(/*! ./../../../openfl/display3D/Context3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/Context3D.js");}
function openfl__$internal_formats_atf_ATFReader() {return __webpack_require__(/*! ./../../../openfl/_internal/formats/atf/ATFReader */ "./node_modules/openfl/lib/_gen/openfl/_internal/formats/atf/ATFReader.js");}
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var Texture = function(context,width,height,format,optimizeForRenderToTexture,streamingLevels) {
	(openfl_display3D_textures_TextureBase().default).call(this,context);
	this.__width = width;
	this.__height = height;
	this.__optimizeForRenderToTexture = optimizeForRenderToTexture;
	this.__streamingLevels = streamingLevels;
	var gl = this.__context.gl;
	this.__textureTarget = gl.TEXTURE_2D;
	this.__context.__bindGLTexture2D(this.__textureID);
	(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,this.__textureTarget,0,this.__internalFormat,this.__width,this.__height,0,this.__format,gl.UNSIGNED_BYTE,null);
	this.__context.__bindGLTexture2D(null);
	if(optimizeForRenderToTexture) {
		this.__getGLFramebuffer(true,0,0);
	}
}

// Meta

Texture.__name__ = "openfl.display3D.textures.Texture";
Texture.__isInterface__ = false;
Texture.__super__ = (openfl_display3D_textures_TextureBase().default);
Texture.prototype = $extend((openfl_display3D_textures_TextureBase().default).prototype, {
	uploadCompressedTextureFromByteArray: function(data,byteArrayOffset,async) {
		if(async == null) {
			async = false;
		}
		var _gthis = this;
		if(!async) {
			this.__uploadCompressedTextureFromByteArray(data,byteArrayOffset);
		} else {
			(haxe_Timer().default).delay(function() {
				_gthis.__uploadCompressedTextureFromByteArray(data,byteArrayOffset);
				var event = null;
				event = new (openfl_events_Event().default)("textureReady");
				_gthis.dispatchEvent(event);
			},1);
		}
	},
	uploadFromBitmapData: function(source,miplevel,generateMipmap) {
		if(generateMipmap == null) {
			generateMipmap = false;
		}
		if(miplevel == null) {
			miplevel = 0;
		}
		if(source == null) {
			return;
		}
		var width = this.__width >> miplevel;
		var height = this.__height >> miplevel;
		if(width == 0 && height == 0) {
			return;
		}
		if(width == 0) {
			width = 1;
		}
		if(height == 0) {
			height = 1;
		}
		if(source.width != width || source.height != height) {
			var copy = new (openfl_display_BitmapData().default)(width,height,true,0);
			copy.draw(source);
			source = copy;
		}
		var image = this.__getImage(source);
		if(image == null) {
			return;
		}
		if(miplevel == 0 && image.buffer != null && image.buffer.data == null && image.buffer.get_src() != null) {
			var gl = this.__context.gl;
			var width1 = this.__width >> miplevel;
			var height1 = this.__height >> miplevel;
			if(width1 == 0 && height1 == 0) {
				return;
			}
			if(width1 == 0) {
				width1 = 1;
			}
			if(height1 == 0) {
				height1 = 1;
			}
			this.__context.__bindGLTexture2D(this.__textureID);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,this.__textureTarget,miplevel,this.__internalFormat,this.__format,gl.UNSIGNED_BYTE,image.buffer.get_src());
			this.__context.__bindGLTexture2D(null);
			return;
		}
		this.uploadFromTypedArray(image.get_data(),miplevel);
	},
	uploadFromByteArray: function(data,byteArrayOffset,miplevel) {
		if(miplevel == null) {
			miplevel = 0;
		}
		if(byteArrayOffset == 0) {
			this.uploadFromTypedArray(data.b,miplevel);
			return;
		}
		var elements = null;
		var array = null;
		var view = null;
		var buffer = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toArrayBuffer(data);
		var byteoffset = byteArrayOffset;
		var len = null;
		if(byteoffset == null) {
			byteoffset = 0;
		}
		var this1;
		if(elements != null) {
			this1 = new Uint8Array(elements);
		} else if(array != null) {
			this1 = new Uint8Array(array);
		} else if(view != null) {
			this1 = new Uint8Array(view);
		} else if(buffer != null) {
			if(len == null) {
				this1 = new Uint8Array(buffer,byteoffset);
			} else {
				this1 = new Uint8Array(buffer,byteoffset,len);
			}
		} else {
			this1 = null;
		}
		this.uploadFromTypedArray(this1,miplevel);
	},
	uploadFromTypedArray: function(data,miplevel) {
		if(miplevel == null) {
			miplevel = 0;
		}
		if(data == null) {
			return;
		}
		var gl = this.__context.gl;
		var width = this.__width >> miplevel;
		var height = this.__height >> miplevel;
		if(width == 0 && height == 0) {
			return;
		}
		if(width == 0) {
			width = 1;
		}
		if(height == 0) {
			height = 1;
		}
		this.__context.__bindGLTexture2D(this.__textureID);
		(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,this.__textureTarget,miplevel,this.__internalFormat,width,height,0,this.__format,gl.UNSIGNED_BYTE,data);
		this.__context.__bindGLTexture2D(null);
	},
	__setSamplerState: function(state) {
		if((openfl_display3D_textures_TextureBase().default).prototype.__setSamplerState.call(this,state)) {
			var gl = this.__context.gl;
			if(state.mipfilter != "mipnone" && !this.__samplerState.mipmapGenerated) {
				gl.generateMipmap(gl.TEXTURE_2D);
				this.__samplerState.mipmapGenerated = true;
			}
			if((openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy != 0) {
				var aniso;
				switch(state.filter) {
				case "anisotropic16x":
					aniso = 16;
					break;
				case "anisotropic2x":
					aniso = 2;
					break;
				case "anisotropic4x":
					aniso = 4;
					break;
				case "anisotropic8x":
					aniso = 8;
					break;
				default:
					aniso = 1;
				}
				if(aniso > (openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy) {
					aniso = (openfl_display3D_Context3D().default).__glMaxTextureMaxAnisotropy;
				}
				gl.texParameterf(gl.TEXTURE_2D,(openfl_display3D_Context3D().default).__glTextureMaxAnisotropy,aniso);
			}
			return true;
		}
		return false;
	},
	__uploadCompressedTextureFromByteArray: function(data,byteArrayOffset) {
		var _gthis = this;
		var reader = new (openfl__$internal_formats_atf_ATFReader().default)(data,byteArrayOffset);
		var alpha = reader.readHeader(this.__width,this.__height,false);
		var context = this.__context;
		var gl = context.gl;
		this.__context.__bindGLTexture2D(this.__textureID);
		var hasTexture = false;
		reader.readTextures(function(target,level,gpuFormat,width,height,blockLength,bytes) {
			var format = alpha ? (openfl_display3D_textures_TextureBase().default).__compressedFormatsAlpha.get(gpuFormat) : (openfl_display3D_textures_TextureBase().default).__compressedFormats.get(gpuFormat);
			if(format == 0) {
				return;
			}
			hasTexture = true;
			_gthis.__format = format;
			_gthis.__internalFormat = format;
			if(alpha && gpuFormat == 2) {
				var size = (Std().default).int(blockLength / 2);
				var elements = null;
				var array = null;
				var view = null;
				var buffer = bytes.b.buffer;
				var byteoffset = 0;
				if(byteoffset == null) {
					byteoffset = 0;
				}
				var this1;
				if(elements != null) {
					this1 = new Uint8Array(elements);
				} else if(array != null) {
					this1 = new Uint8Array(array);
				} else if(view != null) {
					this1 = new Uint8Array(view);
				} else if(buffer != null) {
					if(size == null) {
						this1 = new Uint8Array(buffer,byteoffset);
					} else {
						this1 = new Uint8Array(buffer,byteoffset,size);
					}
				} else {
					this1 = null;
				}
				(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).compressedTexImage2D(gl,_gthis.__textureTarget,level,_gthis.__internalFormat,width,height,0,this1);
				var alphaTexture = new Texture(_gthis.__context,_gthis.__width,_gthis.__height,"compressed",_gthis.__optimizeForRenderToTexture,_gthis.__streamingLevels);
				alphaTexture.__format = format;
				alphaTexture.__internalFormat = format;
				_gthis.__context.__bindGLTexture2D(alphaTexture.__textureID);
				var elements1 = null;
				var array1 = null;
				var view1 = null;
				var buffer1 = bytes.b.buffer;
				var byteoffset1 = size;
				if(byteoffset1 == null) {
					byteoffset1 = 0;
				}
				var this2;
				if(elements1 != null) {
					this2 = new Uint8Array(elements1);
				} else if(array1 != null) {
					this2 = new Uint8Array(array1);
				} else if(view1 != null) {
					this2 = new Uint8Array(view1);
				} else if(buffer1 != null) {
					if(size == null) {
						this2 = new Uint8Array(buffer1,byteoffset1);
					} else {
						this2 = new Uint8Array(buffer1,byteoffset1,size);
					}
				} else {
					this2 = null;
				}
				(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).compressedTexImage2D(gl,alphaTexture.__textureTarget,level,alphaTexture.__internalFormat,width,height,0,this2);
				_gthis.__alphaTexture = alphaTexture;
			} else {
				var elements2 = null;
				var array2 = null;
				var view2 = null;
				var buffer2 = bytes.b.buffer;
				var byteoffset2 = 0;
				if(byteoffset2 == null) {
					byteoffset2 = 0;
				}
				var this3;
				if(elements2 != null) {
					this3 = new Uint8Array(elements2);
				} else if(array2 != null) {
					this3 = new Uint8Array(array2);
				} else if(view2 != null) {
					this3 = new Uint8Array(view2);
				} else if(buffer2 != null) {
					if(blockLength == null) {
						this3 = new Uint8Array(buffer2,byteoffset2);
					} else {
						this3 = new Uint8Array(buffer2,byteoffset2,blockLength);
					}
				} else {
					this3 = null;
				}
				(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).compressedTexImage2D(gl,_gthis.__textureTarget,level,_gthis.__internalFormat,width,height,0,this3);
			}
		});
		if(!hasTexture) {
			var elements3 = this.__width * this.__height * 4;
			var array3 = null;
			var view3 = null;
			var buffer3 = null;
			var len = null;
			var this4;
			if(elements3 != null) {
				this4 = new Uint8Array(elements3);
			} else if(array3 != null) {
				this4 = new Uint8Array(array3);
			} else if(view3 != null) {
				this4 = new Uint8Array(view3);
			} else if(buffer3 != null) {
				if(len == null) {
					this4 = new Uint8Array(buffer3,0);
				} else {
					this4 = new Uint8Array(buffer3,0,len);
				}
			} else {
				this4 = null;
			}
			var data1 = this4;
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,this.__textureTarget,0,this.__internalFormat,this.__width,this.__height,0,this.__format,gl.UNSIGNED_BYTE,data1);
		}
		this.__context.__bindGLTexture2D(null);
	}
});
Texture.prototype.__class__ = Texture.prototype.constructor = $hxClasses["openfl.display3D.textures.Texture"] = Texture;

// Init



// Statics


Texture.__lowMemoryMode = false

// Export

exports.default = Texture;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/TextureBase.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/textures/TextureBase.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.textures.TextureBase

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function openfl_display3D_Context3D() {return __webpack_require__(/*! ./../../../openfl/display3D/Context3D */ "./node_modules/openfl/lib/_gen/openfl/display3D/Context3D.js");}
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function lime_graphics_ImageType() {return __webpack_require__(/*! ./../../../lime/graphics/ImageType */ "./node_modules/openfl/lib/_gen/lime/graphics/ImageType.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_Error() {return __webpack_require__(/*! ./../../../openfl/errors/Error */ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}

// Constructor

var TextureBase = function(context) {
	(openfl_events_EventDispatcher().default).call(this);
	this.__context = context;
	var gl = this.__context.gl;
	this.__textureID = gl.createTexture();
	this.__textureContext = this.__context.__context;
	if(TextureBase.__supportsBGRA == null) {
		TextureBase.__textureInternalFormat = gl.RGBA;
		var bgraExtension = null;
		if(bgraExtension != null) {
			TextureBase.__supportsBGRA = true;
			TextureBase.__textureFormat = bgraExtension.BGRA_EXT;
			if(context.__context.type == "opengles") {
				TextureBase.__textureInternalFormat = bgraExtension.BGRA_EXT;
			}
		} else {
			TextureBase.__supportsBGRA = false;
			TextureBase.__textureFormat = gl.RGBA;
		}
		TextureBase.__compressedFormats = new (haxe_ds_IntMap().default)();
		TextureBase.__compressedFormatsAlpha = new (haxe_ds_IntMap().default)();
		var dxtExtension = gl.getExtension("WEBGL_compressed_texture_s3tc");
		var etc1Extension = gl.getExtension("WEBGL_compressed_texture_etc1");
		var pvrtcExtension = gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
		if(dxtExtension != null) {
			var v = dxtExtension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			TextureBase.__compressedFormats.set(0,v);
			var v1 = dxtExtension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
			TextureBase.__compressedFormatsAlpha.set(0,v1);
		}
		if(etc1Extension != null) {
			var v2 = etc1Extension.COMPRESSED_RGB_ETC1_WEBGL;
			TextureBase.__compressedFormats.set(2,v2);
			var v3 = etc1Extension.COMPRESSED_RGB_ETC1_WEBGL;
			TextureBase.__compressedFormatsAlpha.set(2,v3);
		}
		if(pvrtcExtension != null) {
			var v4 = pvrtcExtension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			TextureBase.__compressedFormats.set(1,v4);
			var v5 = pvrtcExtension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			TextureBase.__compressedFormatsAlpha.set(1,v5);
		}
	}
	this.__internalFormat = TextureBase.__textureInternalFormat;
	this.__format = TextureBase.__textureFormat;
}

// Meta

TextureBase.__name__ = "openfl.display3D.textures.TextureBase";
TextureBase.__isInterface__ = false;
TextureBase.__super__ = (openfl_events_EventDispatcher().default);
TextureBase.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	dispose: function() {
		var gl = this.__context.gl;
		if(this.__alphaTexture != null) {
			this.__alphaTexture.dispose();
			this.__alphaTexture = null;
		}
		if(this.__textureID != null) {
			gl.deleteTexture(this.__textureID);
			this.__textureID = null;
		}
		if(this.__glFramebuffer != null) {
			gl.deleteFramebuffer(this.__glFramebuffer);
			this.__glFramebuffer = null;
		}
		if(this.__glDepthRenderbuffer != null) {
			gl.deleteRenderbuffer(this.__glDepthRenderbuffer);
			this.__glDepthRenderbuffer = null;
		}
		if(this.__glStencilRenderbuffer != null) {
			gl.deleteRenderbuffer(this.__glStencilRenderbuffer);
			this.__glStencilRenderbuffer = null;
		}
	},
	__getGLFramebuffer: function(enableDepthAndStencil,antiAlias,surfaceSelector) {
		var gl = this.__context.gl;
		if(this.__glFramebuffer == null) {
			this.__glFramebuffer = gl.createFramebuffer();
			this.__context.__bindGLFramebuffer(this.__glFramebuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,this.__textureID,0);
			if(this.__context.__enableErrorChecking) {
				var code = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
				if(code != gl.FRAMEBUFFER_COMPLETE) {
					(lime_utils_Log().default).warn("Error: Context3D.setRenderToTexture status:" + code + " width:" + this.__width + " height:" + this.__height,{ fileName : "../src/openfl/display3D/textures/TextureBase.hx", lineNumber : 201, className : "openfl.display3D.textures.TextureBase", methodName : "__getGLFramebuffer"});
				}
			}
		}
		if(enableDepthAndStencil && this.__glDepthRenderbuffer == null) {
			this.__context.__bindGLFramebuffer(this.__glFramebuffer);
			if((openfl_display3D_Context3D().default).__glDepthStencil != 0) {
				this.__glDepthRenderbuffer = gl.createRenderbuffer();
				this.__glStencilRenderbuffer = this.__glDepthRenderbuffer;
				gl.bindRenderbuffer(gl.RENDERBUFFER,this.__glDepthRenderbuffer);
				gl.renderbufferStorage(gl.RENDERBUFFER,(openfl_display3D_Context3D().default).__glDepthStencil,this.__width,this.__height);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,gl.RENDERBUFFER,this.__glDepthRenderbuffer);
			} else {
				this.__glDepthRenderbuffer = gl.createRenderbuffer();
				this.__glStencilRenderbuffer = gl.createRenderbuffer();
				gl.bindRenderbuffer(gl.RENDERBUFFER,this.__glDepthRenderbuffer);
				gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT16,this.__width,this.__height);
				gl.bindRenderbuffer(gl.RENDERBUFFER,this.__glStencilRenderbuffer);
				gl.renderbufferStorage(gl.RENDERBUFFER,gl.STENCIL_INDEX8,this.__width,this.__height);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,this.__glDepthRenderbuffer);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.STENCIL_ATTACHMENT,gl.RENDERBUFFER,this.__glStencilRenderbuffer);
			}
			if(this.__context.__enableErrorChecking) {
				var code1 = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
				if(code1 != gl.FRAMEBUFFER_COMPLETE) {
					(lime_utils_Log().default).warn("Error: Context3D.setRenderToTexture status:" + code1 + " width:" + this.__width + " height:" + this.__height,{ fileName : "../src/openfl/display3D/textures/TextureBase.hx", lineNumber : 239, className : "openfl.display3D.textures.TextureBase", methodName : "__getGLFramebuffer"});
				}
			}
			gl.bindRenderbuffer(gl.RENDERBUFFER,null);
		}
		return this.__glFramebuffer;
	},
	__getImage: function(bitmapData) {
		var image = bitmapData.image;
		if(!bitmapData.__isValid || image == null) {
			return null;
		}
		(lime__$internal_graphics_ImageCanvasUtil().default).sync(image,false);
		var gl = this.__context.gl;
		if(image.type != (lime_graphics_ImageType().default).DATA && !image.get_premultiplied()) {
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1);
		} else if(!image.get_premultiplied() && image.get_transparent()) {
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,0);
			image = image.clone();
			image.set_premultiplied(true);
		}
		if(image.get_format() != 0) {
			image = image.clone();
			image.set_format(0);
			image.buffer.premultiplied = true;
		}
		return image;
	},
	__getTexture: function() {
		return this.__textureID;
	},
	__setSamplerState: function(state) {
		if(!state.equals(this.__samplerState)) {
			var gl = this.__context.gl;
			if(this.__textureTarget == this.__context.gl.TEXTURE_CUBE_MAP) {
				this.__context.__bindGLTextureCubeMap(this.__textureID);
			} else {
				this.__context.__bindGLTexture2D(this.__textureID);
			}
			var wrapModeS = 0;
			var wrapModeT = 0;
			switch(state.wrap) {
			case "clamp":
				wrapModeS = gl.CLAMP_TO_EDGE;
				wrapModeT = gl.CLAMP_TO_EDGE;
				break;
			case "clamp_u_repeat_v":
				wrapModeS = gl.CLAMP_TO_EDGE;
				wrapModeT = gl.REPEAT;
				break;
			case "repeat":
				wrapModeS = gl.REPEAT;
				wrapModeT = gl.REPEAT;
				break;
			case "repeat_u_clamp_v":
				wrapModeS = gl.REPEAT;
				wrapModeT = gl.CLAMP_TO_EDGE;
				break;
			default:
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_Error().default)("wrap bad enum"));
			}
			var magFilter = 0;
			var minFilter = 0;
			if(state.filter == "nearest") {
				magFilter = gl.NEAREST;
			} else {
				magFilter = gl.LINEAR;
			}
			switch(state.mipfilter) {
			case "miplinear":
				minFilter = state.filter == "nearest" ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR_MIPMAP_LINEAR;
				break;
			case "mipnearest":
				minFilter = state.filter == "nearest" ? gl.NEAREST_MIPMAP_NEAREST : gl.LINEAR_MIPMAP_NEAREST;
				break;
			case "mipnone":
				minFilter = state.filter == "nearest" ? gl.NEAREST : gl.LINEAR;
				break;
			default:
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_Error().default)("mipfiter bad enum"));
			}
			gl.texParameteri(this.__textureTarget,gl.TEXTURE_MIN_FILTER,minFilter);
			gl.texParameteri(this.__textureTarget,gl.TEXTURE_MAG_FILTER,magFilter);
			gl.texParameteri(this.__textureTarget,gl.TEXTURE_WRAP_S,wrapModeS);
			gl.texParameteri(this.__textureTarget,gl.TEXTURE_WRAP_T,wrapModeT);
			var tmp = state.lodBias != 0.0;
			if(this.__samplerState == null) {
				this.__samplerState = state.clone();
			}
			this.__samplerState.copyFrom(state);
			return true;
		}
		return false;
	},
	__uploadFromImage: function(image) {
		var gl = this.__context.gl;
		var internalFormat;
		var format;
		if(this.__textureTarget != gl.TEXTURE_2D) {
			return;
		}
		if(image.buffer.bitsPerPixel == 1) {
			internalFormat = gl.ALPHA;
			format = gl.ALPHA;
		} else {
			internalFormat = TextureBase.__textureInternalFormat;
			format = TextureBase.__textureFormat;
		}
		this.__context.__bindGLTexture2D(this.__textureID);
		if(image.type != (lime_graphics_ImageType().default).DATA && !image.get_premultiplied()) {
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1);
		} else if(!image.get_premultiplied() && image.get_transparent()) {
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1);
		}
		if(image.type == (lime_graphics_ImageType().default).DATA) {
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,gl.TEXTURE_2D,0,internalFormat,image.buffer.width,image.buffer.height,0,format,gl.UNSIGNED_BYTE,image.get_data());
		} else {
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,gl.TEXTURE_2D,0,internalFormat,format,gl.UNSIGNED_BYTE,image.get_src());
		}
		this.__context.__bindGLTexture2D(null);
	}
});
TextureBase.prototype.__class__ = TextureBase.prototype.constructor = $hxClasses["openfl.display3D.textures.TextureBase"] = TextureBase;

// Init



// Statics


TextureBase.__meta__ = { fields : { __textureContext : { SuppressWarnings : ["checkstyle:Dynamic"]}, __getGLFramebuffer : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
TextureBase.__supportsBGRA = null

// Export

exports.default = TextureBase;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/VideoTexture.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/display3D/textures/VideoTexture.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.display3D.textures.VideoTexture

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display3D_textures_TextureBase() {return __webpack_require__(/*! ./../../../openfl/display3D/textures/TextureBase */ "./node_modules/openfl/lib/_gen/openfl/display3D/textures/TextureBase.js");}
function haxe_Timer() {return __webpack_require__(/*! ./../../../haxe/Timer */ "./node_modules/openfl/lib/_gen/haxe/Timer.js");}
function lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$() {return __webpack_require__(/*! ./../../../lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_ */ "./node_modules/openfl/lib/_gen/lime/graphics/_WebGLRenderContext/WebGLRenderContext_Impl_.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}

// Constructor

var VideoTexture = function(context) {
	(openfl_display3D_textures_TextureBase().default).call(this,context);
	this.__textureTarget = this.__context.gl.TEXTURE_2D;
}

// Meta

VideoTexture.__name__ = "openfl.display3D.textures.VideoTexture";
VideoTexture.__isInterface__ = false;
VideoTexture.__super__ = (openfl_display3D_textures_TextureBase().default);
VideoTexture.prototype = $extend((openfl_display3D_textures_TextureBase().default).prototype, {
	attachNetStream: function(netStream) {
		var _gthis = this;
		if(this.__netStream != null) {
			this.__netStream.__video.removeEventListener("canplay",$bind(this,this.__onCanPlay),false);
		}
		this.__netStream = netStream;
		if(this.__netStream.__video.readyState == 4) {
			(haxe_Timer().default).delay(function() {
				_gthis.__textureReady();
			},0);
		} else {
			this.__netStream.__video.addEventListener("canplay",$bind(this,this.__onCanPlay),false);
		}
	},
	__onCanPlay: function(_) {
		this.__textureReady();
	},
	__getTexture: function() {
		if((!this.__netStream.__video.paused || this.__netStream.get___seeking()) && this.__netStream.__video.readyState > 0) {
			this.__netStream.set___seeking(false);
			var gl = this.__context.gl;
			this.__context.__bindGLTexture2D(this.__textureID);
			(lime_graphics__$WebGLRenderContext_WebGLRenderContext_$Impl_$().default).texImage2D(gl,gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,this.__netStream.__video);
		}
		return this.__textureID;
	},
	__textureReady: function() {
		this.videoWidth = this.__netStream.__video.videoWidth;
		this.videoHeight = this.__netStream.__video.videoHeight;
		var event = null;
		event = new (openfl_events_Event().default)("textureReady");
		this.dispatchEvent(event);
	}
});
VideoTexture.prototype.__class__ = VideoTexture.prototype.constructor = $hxClasses["openfl.display3D.textures.VideoTexture"] = VideoTexture;

// Init



// Statics




// Export

exports.default = VideoTexture;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/errors/ArgumentError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/errors/ArgumentError.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.errors.ArgumentError

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_errors_Error() {return __webpack_require__(/*! ./../../openfl/errors/Error */ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js");}

// Constructor

var ArgumentError = function(message) {
	if(message == null) {
		message = "";
	}
	(openfl_errors_Error().default).call(this,message);
	this.name = "ArgumentError";
}

// Meta

ArgumentError.__name__ = "openfl.errors.ArgumentError";
ArgumentError.__isInterface__ = false;
ArgumentError.__super__ = (openfl_errors_Error().default);
ArgumentError.prototype = $extend((openfl_errors_Error().default).prototype, {
	
});
ArgumentError.prototype.__class__ = ArgumentError.prototype.constructor = $hxClasses["openfl.errors.ArgumentError"] = ArgumentError;

// Init



// Statics




// Export

exports.default = ArgumentError;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/errors/EOFError.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/errors/EOFError.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.errors.EOFError

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_errors_IOError() {return __webpack_require__(/*! ./../../openfl/errors/IOError */ "./node_modules/openfl/lib/_gen/openfl/errors/IOError.js");}

// Constructor

var EOFError = function(message,id) {
	if(id == null) {
		id = 0;
	}
	(openfl_errors_IOError().default).call(this,"End of file was encountered");
	this.name = "EOFError";
	this.errorID = 2030;
}

// Meta

EOFError.__name__ = "openfl.errors.EOFError";
EOFError.__isInterface__ = false;
EOFError.__super__ = (openfl_errors_IOError().default);
EOFError.prototype = $extend((openfl_errors_IOError().default).prototype, {
	
});
EOFError.prototype.__class__ = EOFError.prototype.constructor = $hxClasses["openfl.errors.EOFError"] = EOFError;

// Init



// Statics




// Export

exports.default = EOFError;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/errors/Error.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.errors.Error

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_CallStack() {return __webpack_require__(/*! ./../../haxe/CallStack */ "./node_modules/openfl/lib/_gen/haxe/CallStack.js");}

// Constructor

var Error = function(message,id) {
	if(id == null) {
		id = 0;
	}
	if(message == null) {
		message = "";
	}
	this.message = message;
	this.errorID = id;
	this.name = "Error";
}

// Meta

Error.__name__ = "openfl.errors.Error";
Error.__isInterface__ = false;
Error.prototype = {
	getStackTrace: function() {
		return (haxe_CallStack().default).toString((haxe_CallStack().default).exceptionStack());
	},
	toString: function() {
		if(this.message != null) {
			return this.message;
		} else {
			return "Error";
		}
	}
};
Error.prototype.__class__ = Error.prototype.constructor = $hxClasses["openfl.errors.Error"] = Error;

// Init



// Statics


Error.DEFAULT_TO_STRING = "Error"

// Export

exports.default = Error;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/errors/IOError.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/errors/IOError.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.errors.IOError

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_errors_Error() {return __webpack_require__(/*! ./../../openfl/errors/Error */ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js");}

// Constructor

var IOError = function(message) {
	if(message == null) {
		message = "";
	}
	(openfl_errors_Error().default).call(this,message);
	this.name = "IOError";
}

// Meta

IOError.__name__ = "openfl.errors.IOError";
IOError.__isInterface__ = false;
IOError.__super__ = (openfl_errors_Error().default);
IOError.prototype = $extend((openfl_errors_Error().default).prototype, {
	
});
IOError.prototype.__class__ = IOError.prototype.constructor = $hxClasses["openfl.errors.IOError"] = IOError;

// Init



// Statics




// Export

exports.default = IOError;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/errors/IllegalOperationError.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.errors.IllegalOperationError

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_errors_Error() {return __webpack_require__(/*! ./../../openfl/errors/Error */ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js");}

// Constructor

var IllegalOperationError = function(message) {
	if(message == null) {
		message = "";
	}
	(openfl_errors_Error().default).call(this,message,0);
	this.name = "IllegalOperationError";
}

// Meta

IllegalOperationError.__name__ = "openfl.errors.IllegalOperationError";
IllegalOperationError.__isInterface__ = false;
IllegalOperationError.__super__ = (openfl_errors_Error().default);
IllegalOperationError.prototype = $extend((openfl_errors_Error().default).prototype, {
	
});
IllegalOperationError.prototype.__class__ = IllegalOperationError.prototype.constructor = $hxClasses["openfl.errors.IllegalOperationError"] = IllegalOperationError;

// Init



// Statics




// Export

exports.default = IllegalOperationError;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/errors/RangeError.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/errors/RangeError.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.errors.RangeError

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_errors_Error() {return __webpack_require__(/*! ./../../openfl/errors/Error */ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js");}

// Constructor

var RangeError = function(message) {
	if(message == null) {
		message = "";
	}
	(openfl_errors_Error().default).call(this,message,0);
	this.name = "RangeError";
}

// Meta

RangeError.__name__ = "openfl.errors.RangeError";
RangeError.__isInterface__ = false;
RangeError.__super__ = (openfl_errors_Error().default);
RangeError.prototype = $extend((openfl_errors_Error().default).prototype, {
	
});
RangeError.prototype.__class__ = RangeError.prototype.constructor = $hxClasses["openfl.errors.RangeError"] = RangeError;

// Init



// Statics




// Export

exports.default = RangeError;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/errors/TypeError.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/errors/TypeError.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.errors.TypeError

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_errors_Error() {return __webpack_require__(/*! ./../../openfl/errors/Error */ "./node_modules/openfl/lib/_gen/openfl/errors/Error.js");}

// Constructor

var TypeError = function(message) {
	if(message == null) {
		message = "";
	}
	(openfl_errors_Error().default).call(this,message,0);
	this.name = "TypeError";
}

// Meta

TypeError.__name__ = "openfl.errors.TypeError";
TypeError.__isInterface__ = false;
TypeError.__super__ = (openfl_errors_Error().default);
TypeError.prototype = $extend((openfl_errors_Error().default).prototype, {
	
});
TypeError.prototype.__class__ = TypeError.prototype.constructor = $hxClasses["openfl.errors.TypeError"] = TypeError;

// Init



// Statics




// Export

exports.default = TypeError;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/ActivityEvent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/ActivityEvent.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.ActivityEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var ActivityEvent = function(type,bubbles,cancelable,activating) {
	if(activating == null) {
		activating = false;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.activating = activating;
}

// Meta

ActivityEvent.__name__ = "openfl.events.ActivityEvent";
ActivityEvent.__isInterface__ = false;
ActivityEvent.__super__ = (openfl_events_Event().default);
ActivityEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new ActivityEvent(this.type,this.bubbles,this.cancelable,this.activating);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("ActivityEvent",["type","bubbles","cancelable","activating"]);
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.activating = false;
	}
});
ActivityEvent.prototype.__class__ = ActivityEvent.prototype.constructor = $hxClasses["openfl.events.ActivityEvent"] = ActivityEvent;

// Init



// Statics


ActivityEvent.ACTIVITY = "activity"
ActivityEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new ActivityEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = ActivityEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/ErrorEvent.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/ErrorEvent.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.ErrorEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_TextEvent() {return __webpack_require__(/*! ./../../openfl/events/TextEvent */ "./node_modules/openfl/lib/_gen/openfl/events/TextEvent.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var ErrorEvent = function(type,bubbles,cancelable,text,id) {
	if(id == null) {
		id = 0;
	}
	if(text == null) {
		text = "";
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_TextEvent().default).call(this,type,bubbles,cancelable,text);
	this.errorID = id;
}

// Meta

ErrorEvent.__name__ = "openfl.events.ErrorEvent";
ErrorEvent.__isInterface__ = false;
ErrorEvent.__super__ = (openfl_events_TextEvent().default);
ErrorEvent.prototype = $extend((openfl_events_TextEvent().default).prototype, {
	clone: function() {
		var event = new ErrorEvent(this.type,this.bubbles,this.cancelable,this.text,this.errorID);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("ErrorEvent",["type","bubbles","cancelable","text","errorID"]);
	},
	__init: function() {
		(openfl_events_TextEvent().default).prototype.__init.call(this);
		this.errorID = 0;
	}
});
ErrorEvent.prototype.__class__ = ErrorEvent.prototype.constructor = $hxClasses["openfl.events.ErrorEvent"] = ErrorEvent;

// Init



// Statics


ErrorEvent.ERROR = "error"
ErrorEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new ErrorEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = ErrorEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/Event.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/Event.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.Event

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var Event = function(type,bubbles,cancelable) {
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	this.type = type;
	this.bubbles = bubbles;
	this.cancelable = cancelable;
	this.eventPhase = 2;
}

// Meta

Event.__name__ = "openfl.events.Event";
Event.__isInterface__ = false;
Event.prototype = {
	clone: function() {
		var event = new Event(this.type,this.bubbles,this.cancelable);
		event.eventPhase = this.eventPhase;
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		return event;
	},
	formatToString: function(className,p1,p2,p3,p4,p5) {
		var parameters = [];
		if(p1 != null) {
			parameters.push(p1);
		}
		if(p2 != null) {
			parameters.push(p2);
		}
		if(p3 != null) {
			parameters.push(p3);
		}
		if(p4 != null) {
			parameters.push(p4);
		}
		if(p5 != null) {
			parameters.push(p5);
		}
		return (Reflect().default).callMethod(this,$bind(this,this.__formatToString),[className,parameters]);
	},
	isDefaultPrevented: function() {
		return this.__preventDefault;
	},
	preventDefault: function() {
		if(this.cancelable) {
			this.__preventDefault = true;
		}
	},
	stopImmediatePropagation: function() {
		this.__isCanceled = true;
		this.__isCanceledNow = true;
	},
	stopPropagation: function() {
		this.__isCanceled = true;
	},
	toString: function() {
		return this.__formatToString("Event",["type","bubbles","cancelable"]);
	},
	__formatToString: function(className,parameters) {
		var output = "[" + className;
		var arg = null;
		var _g = 0;
		while(_g < parameters.length) {
			var param = parameters[_g];
			++_g;
			arg = (Reflect().default).field(this,param);
			if(typeof(arg) == "string") {
				output += " " + param + "=\"" + (Std().default).string(arg) + "\"";
			} else {
				output += " " + param + "=" + (Std().default).string(arg);
			}
		}
		output += "]";
		return output;
	},
	__init: function() {
		this.target = null;
		this.currentTarget = null;
		this.bubbles = false;
		this.cancelable = false;
		this.eventPhase = 2;
		this.__isCanceled = false;
		this.__isCanceledNow = false;
		this.__preventDefault = false;
	}
};
Event.prototype.__class__ = Event.prototype.constructor = $hxClasses["openfl.events.Event"] = Event;

// Init



// Statics


Event.ACTIVATE = "activate"
Event.ADDED = "added"
Event.ADDED_TO_STAGE = "addedToStage"
Event.CANCEL = "cancel"
Event.CHANGE = "change"
Event.CLEAR = "clear"
Event.CLOSE = "close"
Event.COMPLETE = "complete"
Event.CONNECT = "connect"
Event.CONTEXT3D_CREATE = "context3DCreate"
Event.COPY = "copy"
Event.CUT = "cut"
Event.DEACTIVATE = "deactivate"
Event.ENTER_FRAME = "enterFrame"
Event.EXIT_FRAME = "exitFrame"
Event.FRAME_CONSTRUCTED = "frameConstructed"
Event.FRAME_LABEL = "frameLabel"
Event.FULLSCREEN = "fullScreen"
Event.ID3 = "id3"
Event.INIT = "init"
Event.MOUSE_LEAVE = "mouseLeave"
Event.OPEN = "open"
Event.PASTE = "paste"
Event.REMOVED = "removed"
Event.REMOVED_FROM_STAGE = "removedFromStage"
Event.RENDER = "render"
Event.RESIZE = "resize"
Event.SCROLL = "scroll"
Event.SELECT = "select"
Event.SELECT_ALL = "selectAll"
Event.SOUND_COMPLETE = "soundComplete"
Event.TAB_CHILDREN_CHANGE = "tabChildrenChange"
Event.TAB_ENABLED_CHANGE = "tabEnabledChange"
Event.TAB_INDEX_CHANGE = "tabIndexChange"
Event.TEXTURE_READY = "textureReady"
Event.UNLOAD = "unload"
Event.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new Event(null);
},function(event) {
	event.__init();
})

// Export

exports.default = Event;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.EventDispatcher

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_events_IEventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/IEventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/IEventDispatcher.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function openfl_events__$EventDispatcher_Listener() {return __webpack_require__(/*! ./../../openfl/events/_EventDispatcher/Listener */ "./node_modules/openfl/lib/_gen/openfl/events/_EventDispatcher/Listener.js");}
function openfl_events__$EventDispatcher_DispatchIterator() {return __webpack_require__(/*! ./../../openfl/events/_EventDispatcher/DispatchIterator */ "./node_modules/openfl/lib/_gen/openfl/events/_EventDispatcher/DispatchIterator.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var EventDispatcher = function(target) {
	if(target != null) {
		this.__targetDispatcher = target;
	}
}

// Meta

EventDispatcher.__name__ = "openfl.events.EventDispatcher";
EventDispatcher.__isInterface__ = false;
EventDispatcher.__interfaces__ = [(openfl_events_IEventDispatcher().default)];
EventDispatcher.prototype = {
	addEventListener: function(type,listener,useCapture,priority,useWeakReference) {
		if(useWeakReference == null) {
			useWeakReference = false;
		}
		if(priority == null) {
			priority = 0;
		}
		if(useCapture == null) {
			useCapture = false;
		}
		if(listener == null) {
			return;
		}
		if(this.__eventMap == null) {
			this.__eventMap = new (haxe_ds_StringMap().default)();
			this.__iterators = new (haxe_ds_StringMap().default)();
		}
		if(!this.__eventMap.exists(type)) {
			var list = [];
			list.push(new (openfl_events__$EventDispatcher_Listener().default)(listener,useCapture,priority));
			var iterator = new (openfl_events__$EventDispatcher_DispatchIterator().default)(list);
			this.__eventMap.set(type,list);
			this.__iterators.set(type,[iterator]);
		} else {
			var list1 = this.__eventMap.get(type);
			var _g = 0;
			var _g1 = list1.length;
			while(_g < _g1) {
				var i = _g++;
				if(list1[i].match(listener,useCapture)) {
					return;
				}
			}
			var iterators = this.__iterators.get(type);
			var _g2 = 0;
			while(_g2 < iterators.length) {
				var iterator1 = iterators[_g2];
				++_g2;
				if(iterator1.active) {
					iterator1.copy();
				}
			}
			this.__addListenerByPriority(list1,new (openfl_events__$EventDispatcher_Listener().default)(listener,useCapture,priority));
		}
	},
	dispatchEvent: function(event) {
		if(this.__targetDispatcher != null) {
			event.target = this.__targetDispatcher;
		} else {
			event.target = this;
		}
		return this.__dispatchEvent(event);
	},
	hasEventListener: function(type) {
		if(this.__eventMap == null) {
			return false;
		}
		return this.__eventMap.exists(type);
	},
	removeEventListener: function(type,listener,useCapture) {
		if(useCapture == null) {
			useCapture = false;
		}
		if(this.__eventMap == null || listener == null) {
			return;
		}
		var list = this.__eventMap.get(type);
		if(list == null) {
			return;
		}
		var iterators = this.__iterators.get(type);
		var _g = 0;
		var _g1 = list.length;
		while(_g < _g1) {
			var i = _g++;
			if(list[i].match(listener,useCapture)) {
				var _g2 = 0;
				while(_g2 < iterators.length) {
					var iterator = iterators[_g2];
					++_g2;
					iterator.remove(list[i],i);
				}
				list.splice(i,1);
				break;
			}
		}
		if(list.length == 0) {
			this.__eventMap.remove(type);
			this.__iterators.remove(type);
		}
		if(!this.__eventMap.iterator().hasNext()) {
			this.__eventMap = null;
			this.__iterators = null;
		}
	},
	toString: function() {
		var full = (Type().default).getClassName((Type().default).getClass(this));
		var short = full.split(".").pop();
		return "[object " + short + "]";
	},
	willTrigger: function(type) {
		return this.hasEventListener(type);
	},
	__dispatchEvent: function(event) {
		if(this.__eventMap == null || event == null) {
			return true;
		}
		var type = event.type;
		var list = this.__eventMap.get(type);
		if(list == null) {
			return true;
		}
		if(event.target == null) {
			if(this.__targetDispatcher != null) {
				event.target = this.__targetDispatcher;
			} else {
				event.target = this;
			}
		}
		event.currentTarget = this;
		var capture = event.eventPhase == 1;
		var iterators = this.__iterators.get(type);
		var iterator = iterators[0];
		if(iterator.active) {
			iterator = new (openfl_events__$EventDispatcher_DispatchIterator().default)(list);
			iterators.push(iterator);
		}
		iterator.start();
		var listener = iterator;
		while(listener.hasNext()) {
			var listener1 = listener.next();
			if(listener1 == null) {
				continue;
			}
			if(listener1.useCapture == capture) {
				listener1.callback(event);
				if(event.__isCanceledNow) {
					break;
				}
			}
		}
		iterator.stop();
		if(iterator != iterators[0]) {
			(HxOverrides().default).remove(iterators,iterator);
		} else {
			iterator.reset(list);
		}
		return !event.isDefaultPrevented();
	},
	__removeAllListeners: function() {
		this.__eventMap = null;
		this.__iterators = null;
	},
	__addListenerByPriority: function(list,listener) {
		var numElements = list.length;
		var addAtPosition = numElements;
		var _g = 0;
		var _g1 = numElements;
		while(_g < _g1) {
			var i = _g++;
			if(list[i].priority < listener.priority) {
				addAtPosition = i;
				break;
			}
		}
		list.splice(addAtPosition,0,listener);
	}
};
EventDispatcher.prototype.__class__ = EventDispatcher.prototype.constructor = $hxClasses["openfl.events.EventDispatcher"] = EventDispatcher;

// Init



// Statics




// Export

exports.default = EventDispatcher;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/FocusEvent.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/FocusEvent.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.FocusEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var FocusEvent = function(type,bubbles,cancelable,relatedObject,shiftKey,keyCode) {
	if(keyCode == null) {
		keyCode = 0;
	}
	if(shiftKey == null) {
		shiftKey = false;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.keyCode = keyCode;
	this.shiftKey = shiftKey;
	this.relatedObject = relatedObject;
}

// Meta

FocusEvent.__name__ = "openfl.events.FocusEvent";
FocusEvent.__isInterface__ = false;
FocusEvent.__super__ = (openfl_events_Event().default);
FocusEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new FocusEvent(this.type,this.bubbles,this.cancelable,this.relatedObject,this.shiftKey,this.keyCode);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("FocusEvent",["type","bubbles","cancelable","relatedObject","shiftKey","keyCode"]);
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.keyCode = 0;
		this.shiftKey = false;
		this.relatedObject = null;
	}
});
FocusEvent.prototype.__class__ = FocusEvent.prototype.constructor = $hxClasses["openfl.events.FocusEvent"] = FocusEvent;

// Init



// Statics


FocusEvent.FOCUS_IN = "focusIn"
FocusEvent.FOCUS_OUT = "focusOut"
FocusEvent.KEY_FOCUS_CHANGE = "keyFocusChange"
FocusEvent.MOUSE_FOCUS_CHANGE = "mouseFocusChange"
FocusEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new FocusEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = FocusEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/FullScreenEvent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/FullScreenEvent.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.FullScreenEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_ActivityEvent() {return __webpack_require__(/*! ./../../openfl/events/ActivityEvent */ "./node_modules/openfl/lib/_gen/openfl/events/ActivityEvent.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var FullScreenEvent = function(type,bubbles,cancelable,fullScreen,interactive) {
	if(interactive == null) {
		interactive = false;
	}
	if(fullScreen == null) {
		fullScreen = false;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_ActivityEvent().default).call(this,type,bubbles,cancelable);
	this.fullScreen = fullScreen;
	this.interactive = interactive;
}

// Meta

FullScreenEvent.__name__ = "openfl.events.FullScreenEvent";
FullScreenEvent.__isInterface__ = false;
FullScreenEvent.__super__ = (openfl_events_ActivityEvent().default);
FullScreenEvent.prototype = $extend((openfl_events_ActivityEvent().default).prototype, {
	clone: function() {
		var event = new FullScreenEvent(this.type,this.bubbles,this.cancelable,this.fullScreen,this.interactive);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("FullscreenEvent",["type","bubbles","cancelable","fullscreen","interactive"]);
	},
	__init: function() {
		(openfl_events_ActivityEvent().default).prototype.__init.call(this);
		this.fullScreen = false;
		this.interactive = false;
	}
});
FullScreenEvent.prototype.__class__ = FullScreenEvent.prototype.constructor = $hxClasses["openfl.events.FullScreenEvent"] = FullScreenEvent;

// Init



// Statics


FullScreenEvent.FULL_SCREEN = "fullScreen"
FullScreenEvent.FULL_SCREEN_INTERACTIVE_ACCEPTED = "fullScreenInteractiveAccepted"
FullScreenEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new FullScreenEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = FullScreenEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/GameInputEvent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/GameInputEvent.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.GameInputEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var GameInputEvent = function(type,bubbles,cancelable,device) {
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = true;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.device = device;
}

// Meta

GameInputEvent.__name__ = "openfl.events.GameInputEvent";
GameInputEvent.__isInterface__ = false;
GameInputEvent.__super__ = (openfl_events_Event().default);
GameInputEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new GameInputEvent(this.type,this.bubbles,this.cancelable,this.device);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("GameInputEvent",["type","bubbles","cancelable","device"]);
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.device = null;
	}
});
GameInputEvent.prototype.__class__ = GameInputEvent.prototype.constructor = $hxClasses["openfl.events.GameInputEvent"] = GameInputEvent;

// Init



// Statics


GameInputEvent.DEVICE_ADDED = "deviceAdded"
GameInputEvent.DEVICE_REMOVED = "deviceRemoved"
GameInputEvent.DEVICE_UNUSABLE = "deviceUnusable"
GameInputEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new GameInputEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = GameInputEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/HTTPStatusEvent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/HTTPStatusEvent.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.HTTPStatusEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var HTTPStatusEvent = function(type,bubbles,cancelable,status,redirected) {
	if(redirected == null) {
		redirected = false;
	}
	if(status == null) {
		status = 0;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	this.status = status;
	this.redirected = redirected;
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
}

// Meta

HTTPStatusEvent.__name__ = "openfl.events.HTTPStatusEvent";
HTTPStatusEvent.__isInterface__ = false;
HTTPStatusEvent.__super__ = (openfl_events_Event().default);
HTTPStatusEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new HTTPStatusEvent(this.type,this.bubbles,this.cancelable,this.status,this.redirected);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("HTTPStatusEvent",["type","bubbles","cancelable","status","redirected"]);
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.status = 0;
		this.redirected = false;
	}
});
HTTPStatusEvent.prototype.__class__ = HTTPStatusEvent.prototype.constructor = $hxClasses["openfl.events.HTTPStatusEvent"] = HTTPStatusEvent;

// Init



// Statics


HTTPStatusEvent.HTTP_RESPONSE_STATUS = "httpResponseStatus"
HTTPStatusEvent.HTTP_STATUS = "httpStatus"
HTTPStatusEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new HTTPStatusEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = HTTPStatusEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/IEventDispatcher.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/IEventDispatcher.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.IEventDispatcher

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IEventDispatcher = function() {}

// Meta

IEventDispatcher.__name__ = "openfl.events.IEventDispatcher";
IEventDispatcher.__isInterface__ = true;
IEventDispatcher.prototype = {
	
};
IEventDispatcher.prototype.__class__ = IEventDispatcher.prototype.constructor = $hxClasses["openfl.events.IEventDispatcher"] = IEventDispatcher;

// Init



// Statics




// Export

exports.default = IEventDispatcher;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/IOErrorEvent.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/IOErrorEvent.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.IOErrorEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_ErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/ErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/ErrorEvent.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var IOErrorEvent = function(type,bubbles,cancelable,text,id) {
	if(id == null) {
		id = 0;
	}
	if(text == null) {
		text = "";
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = true;
	}
	(openfl_events_ErrorEvent().default).call(this,type,bubbles,cancelable,text,id);
}

// Meta

IOErrorEvent.__name__ = "openfl.events.IOErrorEvent";
IOErrorEvent.__isInterface__ = false;
IOErrorEvent.__super__ = (openfl_events_ErrorEvent().default);
IOErrorEvent.prototype = $extend((openfl_events_ErrorEvent().default).prototype, {
	clone: function() {
		var event = new IOErrorEvent(this.type,this.bubbles,this.cancelable,this.text,this.errorID);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("IOErrorEvent",["type","bubbles","cancelable","text","errorID"]);
	}
});
IOErrorEvent.prototype.__class__ = IOErrorEvent.prototype.constructor = $hxClasses["openfl.events.IOErrorEvent"] = IOErrorEvent;

// Init



// Statics


IOErrorEvent.IO_ERROR = "ioError"
IOErrorEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new IOErrorEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = IOErrorEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/KeyboardEvent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/KeyboardEvent.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.KeyboardEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var KeyboardEvent = function(type,bubbles,cancelable,charCodeValue,keyCodeValue,keyLocationValue,ctrlKeyValue,altKeyValue,shiftKeyValue,controlKeyValue,commandKeyValue) {
	if(commandKeyValue == null) {
		commandKeyValue = false;
	}
	if(controlKeyValue == null) {
		controlKeyValue = false;
	}
	if(shiftKeyValue == null) {
		shiftKeyValue = false;
	}
	if(altKeyValue == null) {
		altKeyValue = false;
	}
	if(ctrlKeyValue == null) {
		ctrlKeyValue = false;
	}
	if(keyCodeValue == null) {
		keyCodeValue = 0;
	}
	if(charCodeValue == null) {
		charCodeValue = 0;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.charCode = charCodeValue;
	this.keyCode = keyCodeValue;
	this.keyLocation = keyLocationValue != null ? keyLocationValue : 0;
	this.ctrlKey = ctrlKeyValue;
	this.altKey = altKeyValue;
	this.shiftKey = shiftKeyValue;
	this.controlKey = controlKeyValue;
	this.commandKey = commandKeyValue;
}

// Meta

KeyboardEvent.__name__ = "openfl.events.KeyboardEvent";
KeyboardEvent.__isInterface__ = false;
KeyboardEvent.__super__ = (openfl_events_Event().default);
KeyboardEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new KeyboardEvent(this.type,this.bubbles,this.cancelable,this.charCode,this.keyCode,this.keyLocation,this.ctrlKey,this.altKey,this.shiftKey,this.controlKey,this.commandKey);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("KeyboardEvent",["type","bubbles","cancelable","charCode","keyCode","keyLocation","ctrlKey","altKey","shiftKey"]);
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.charCode = 0;
		this.keyCode = 0;
		this.keyLocation = 0;
		this.ctrlKey = false;
		this.altKey = false;
		this.shiftKey = false;
		this.controlKey = false;
		this.commandKey = false;
	}
});
KeyboardEvent.prototype.__class__ = KeyboardEvent.prototype.constructor = $hxClasses["openfl.events.KeyboardEvent"] = KeyboardEvent;

// Init



// Statics


KeyboardEvent.KEY_DOWN = "keyDown"
KeyboardEvent.KEY_UP = "keyUp"
KeyboardEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new KeyboardEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = KeyboardEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/MouseEvent.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/MouseEvent.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.MouseEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var MouseEvent = function(type,bubbles,cancelable,localX,localY,relatedObject,ctrlKey,altKey,shiftKey,buttonDown,delta,commandKey,clickCount) {
	if(clickCount == null) {
		clickCount = 0;
	}
	if(commandKey == null) {
		commandKey = false;
	}
	if(delta == null) {
		delta = 0;
	}
	if(buttonDown == null) {
		buttonDown = false;
	}
	if(shiftKey == null) {
		shiftKey = false;
	}
	if(altKey == null) {
		altKey = false;
	}
	if(ctrlKey == null) {
		ctrlKey = false;
	}
	if(localY == null) {
		localY = 0;
	}
	if(localX == null) {
		localX = 0;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = true;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.shiftKey = shiftKey;
	this.altKey = altKey;
	this.ctrlKey = ctrlKey;
	this.bubbles = bubbles;
	this.relatedObject = relatedObject;
	this.delta = delta;
	this.localX = localX;
	this.localY = localY;
	this.buttonDown = buttonDown;
	this.commandKey = commandKey;
	this.clickCount = clickCount;
	this.isRelatedObjectInaccessible = false;
	this.stageX = NaN;
	this.stageY = NaN;
}

// Meta

MouseEvent.__name__ = "openfl.events.MouseEvent";
MouseEvent.__isInterface__ = false;
MouseEvent.__super__ = (openfl_events_Event().default);
MouseEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new MouseEvent(this.type,this.bubbles,this.cancelable,this.localX,this.localY,this.relatedObject,this.ctrlKey,this.altKey,this.shiftKey,this.buttonDown,this.delta,this.commandKey,this.clickCount);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("MouseEvent",["type","bubbles","cancelable","localX","localY","relatedObject","ctrlKey","altKey","shiftKey","buttonDown","delta"]);
	},
	updateAfterEvent: function() {
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.shiftKey = false;
		this.altKey = false;
		this.ctrlKey = false;
		this.bubbles = false;
		this.relatedObject = null;
		this.delta = 0;
		this.localX = 0;
		this.localY = 0;
		this.buttonDown = false;
		this.commandKey = false;
		this.clickCount = 0;
		this.isRelatedObjectInaccessible = false;
		this.stageX = NaN;
		this.stageY = NaN;
	}
});
MouseEvent.prototype.__class__ = MouseEvent.prototype.constructor = $hxClasses["openfl.events.MouseEvent"] = MouseEvent;

// Init



// Statics

MouseEvent.__create = function(type,button,stageX,stageY,local,target,delta) {
	if(delta == null) {
		delta = 0;
	}
	var event = new MouseEvent(type,true,false,local.x,local.y,null,MouseEvent.__ctrlKey,MouseEvent.__altKey,MouseEvent.__shiftKey,MouseEvent.__buttonDown,delta,MouseEvent.__commandKey);
	event.stageX = stageX;
	event.stageY = stageY;
	event.target = target;
	return event;
}
MouseEvent.CLICK = "click"
MouseEvent.DOUBLE_CLICK = "doubleClick"
MouseEvent.MIDDLE_CLICK = "middleClick"
MouseEvent.MIDDLE_MOUSE_DOWN = "middleMouseDown"
MouseEvent.MIDDLE_MOUSE_UP = "middleMouseUp"
MouseEvent.MOUSE_DOWN = "mouseDown"
MouseEvent.MOUSE_MOVE = "mouseMove"
MouseEvent.MOUSE_OUT = "mouseOut"
MouseEvent.MOUSE_OVER = "mouseOver"
MouseEvent.MOUSE_UP = "mouseUp"
MouseEvent.MOUSE_WHEEL = "mouseWheel"
MouseEvent.RELEASE_OUTSIDE = "releaseOutside"
MouseEvent.RIGHT_CLICK = "rightClick"
MouseEvent.RIGHT_MOUSE_DOWN = "rightMouseDown"
MouseEvent.RIGHT_MOUSE_UP = "rightMouseUp"
MouseEvent.ROLL_OUT = "rollOut"
MouseEvent.ROLL_OVER = "rollOver"
MouseEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new MouseEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = MouseEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/ProgressEvent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/ProgressEvent.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.ProgressEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var ProgressEvent = function(type,bubbles,cancelable,bytesLoaded,bytesTotal) {
	if(bytesTotal == null) {
		bytesTotal = 0;
	}
	if(bytesLoaded == null) {
		bytesLoaded = 0;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.bytesLoaded = bytesLoaded;
	this.bytesTotal = bytesTotal;
}

// Meta

ProgressEvent.__name__ = "openfl.events.ProgressEvent";
ProgressEvent.__isInterface__ = false;
ProgressEvent.__super__ = (openfl_events_Event().default);
ProgressEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new ProgressEvent(this.type,this.bubbles,this.cancelable,this.bytesLoaded,this.bytesTotal);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("ProgressEvent",["type","bubbles","cancelable","bytesLoaded","bytesTotal"]);
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.bytesLoaded = 0;
		this.bytesTotal = 0;
	}
});
ProgressEvent.prototype.__class__ = ProgressEvent.prototype.constructor = $hxClasses["openfl.events.ProgressEvent"] = ProgressEvent;

// Init



// Statics


ProgressEvent.PROGRESS = "progress"
ProgressEvent.SOCKET_DATA = "socketData"
ProgressEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new ProgressEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = ProgressEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/RenderEvent.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/RenderEvent.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.RenderEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var RenderEvent = function(type,bubbles,cancelable,objectMatrix,objectColorTransform,allowSmoothing) {
	if(allowSmoothing == null) {
		allowSmoothing = true;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.objectMatrix = objectMatrix;
	this.objectColorTransform = objectColorTransform;
	this.allowSmoothing = allowSmoothing;
}

// Meta

RenderEvent.__name__ = "openfl.events.RenderEvent";
RenderEvent.__isInterface__ = false;
RenderEvent.__super__ = (openfl_events_Event().default);
RenderEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new RenderEvent(this.type,this.bubbles,this.cancelable,this.objectMatrix.clone(),this.objectColorTransform.__clone(),this.allowSmoothing);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("RenderEvent",["type","bubbles","cancelable"]);
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.objectMatrix = null;
		this.objectColorTransform = null;
		this.allowSmoothing = false;
		this.renderer = null;
	}
});
RenderEvent.prototype.__class__ = RenderEvent.prototype.constructor = $hxClasses["openfl.events.RenderEvent"] = RenderEvent;

// Init



// Statics


RenderEvent.CLEAR_DOM = "clearDOM"
RenderEvent.RENDER_CAIRO = "renderCairo"
RenderEvent.RENDER_CANVAS = "renderCanvas"
RenderEvent.RENDER_DOM = "renderDOM"
RenderEvent.RENDER_OPENGL = "renderOpenGL"
RenderEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new RenderEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = RenderEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/SecurityErrorEvent.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/SecurityErrorEvent.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.SecurityErrorEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_ErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/ErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/ErrorEvent.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var SecurityErrorEvent = function(type,bubbles,cancelable,text,id) {
	if(id == null) {
		id = 0;
	}
	if(text == null) {
		text = "";
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_ErrorEvent().default).call(this,type,bubbles,cancelable,text,id);
}

// Meta

SecurityErrorEvent.__name__ = "openfl.events.SecurityErrorEvent";
SecurityErrorEvent.__isInterface__ = false;
SecurityErrorEvent.__super__ = (openfl_events_ErrorEvent().default);
SecurityErrorEvent.prototype = $extend((openfl_events_ErrorEvent().default).prototype, {
	clone: function() {
		var event = new SecurityErrorEvent(this.type,this.bubbles,this.cancelable,this.text,this.errorID);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("SecurityErrorEvent",["type","bubbles","cancelable","text","errorID"]);
	}
});
SecurityErrorEvent.prototype.__class__ = SecurityErrorEvent.prototype.constructor = $hxClasses["openfl.events.SecurityErrorEvent"] = SecurityErrorEvent;

// Init



// Statics


SecurityErrorEvent.SECURITY_ERROR = "securityError"
SecurityErrorEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new SecurityErrorEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = SecurityErrorEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/TextEvent.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/TextEvent.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.TextEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var TextEvent = function(type,bubbles,cancelable,text) {
	if(text == null) {
		text = "";
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = false;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.text = text;
}

// Meta

TextEvent.__name__ = "openfl.events.TextEvent";
TextEvent.__isInterface__ = false;
TextEvent.__super__ = (openfl_events_Event().default);
TextEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new TextEvent(this.type,this.bubbles,this.cancelable,this.text);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("TextEvent",["type","bubbles","cancelable","text"]);
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.text = "";
	}
});
TextEvent.prototype.__class__ = TextEvent.prototype.constructor = $hxClasses["openfl.events.TextEvent"] = TextEvent;

// Init



// Statics


TextEvent.LINK = "link"
TextEvent.TEXT_INPUT = "textInput"
TextEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new TextEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = TextEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/TouchEvent.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/TouchEvent.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.TouchEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var TouchEvent = function(type,bubbles,cancelable,touchPointID,isPrimaryTouchPoint,localX,localY,sizeX,sizeY,pressure,relatedObject,ctrlKey,altKey,shiftKey,commandKey,controlKey,timestamp,touchIntent,samples,isTouchPointCanceled) {
	if(isTouchPointCanceled == null) {
		isTouchPointCanceled = false;
	}
	if(timestamp == null) {
		timestamp = 0;
	}
	if(controlKey == null) {
		controlKey = false;
	}
	if(commandKey == null) {
		commandKey = false;
	}
	if(shiftKey == null) {
		shiftKey = false;
	}
	if(altKey == null) {
		altKey = false;
	}
	if(ctrlKey == null) {
		ctrlKey = false;
	}
	if(pressure == null) {
		pressure = 0;
	}
	if(sizeY == null) {
		sizeY = 0;
	}
	if(sizeX == null) {
		sizeX = 0;
	}
	if(localY == null) {
		localY = 0;
	}
	if(localX == null) {
		localX = 0;
	}
	if(isPrimaryTouchPoint == null) {
		isPrimaryTouchPoint = false;
	}
	if(touchPointID == null) {
		touchPointID = 0;
	}
	if(cancelable == null) {
		cancelable = false;
	}
	if(bubbles == null) {
		bubbles = true;
	}
	(openfl_events_Event().default).call(this,type,bubbles,cancelable);
	this.touchPointID = touchPointID;
	this.isPrimaryTouchPoint = isPrimaryTouchPoint;
	this.localX = localX;
	this.localY = localY;
	this.sizeX = sizeX;
	this.sizeY = sizeY;
	this.pressure = pressure;
	this.relatedObject = relatedObject;
	this.ctrlKey = ctrlKey;
	this.altKey = altKey;
	this.shiftKey = shiftKey;
	this.commandKey = commandKey;
	this.controlKey = controlKey;
	this.stageX = NaN;
	this.stageY = NaN;
}

// Meta

TouchEvent.__name__ = "openfl.events.TouchEvent";
TouchEvent.__isInterface__ = false;
TouchEvent.__super__ = (openfl_events_Event().default);
TouchEvent.prototype = $extend((openfl_events_Event().default).prototype, {
	clone: function() {
		var event = new TouchEvent(this.type,this.bubbles,this.cancelable,this.touchPointID,this.isPrimaryTouchPoint,this.localX,this.localY,this.sizeX,this.sizeY,this.pressure,this.relatedObject,this.ctrlKey,this.altKey,this.shiftKey,this.commandKey,this.controlKey);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("TouchEvent",["type","bubbles","cancelable","touchPointID","isPrimaryTouchPoint","localX","localY","sizeX","sizeY","pressure","relatedObject","ctrlKey","altKey","shiftKey","commandKey","controlKey"]);
	},
	updateAfterEvent: function() {
	},
	__init: function() {
		(openfl_events_Event().default).prototype.__init.call(this);
		this.touchPointID = 0;
		this.isPrimaryTouchPoint = false;
		this.localX = 0;
		this.localY = 0;
		this.sizeX = 0;
		this.sizeY = 0;
		this.pressure = 0;
		this.relatedObject = null;
		this.ctrlKey = false;
		this.altKey = false;
		this.shiftKey = false;
		this.commandKey = false;
		this.controlKey = false;
		this.stageX = NaN;
		this.stageY = NaN;
	}
});
TouchEvent.prototype.__class__ = TouchEvent.prototype.constructor = $hxClasses["openfl.events.TouchEvent"] = TouchEvent;

// Init



// Statics

TouchEvent.__create = function(type,touch,stageX,stageY,local,target) {
	var evt = new TouchEvent(type,true,false,0,true,local.x,local.y,1,1,1);
	evt.stageX = stageX;
	evt.stageY = stageY;
	evt.target = target;
	return evt;
}
TouchEvent.__meta__ = { fields : { delta : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}}
TouchEvent.TOUCH_BEGIN = "touchBegin"
TouchEvent.TOUCH_END = "touchEnd"
TouchEvent.TOUCH_MOVE = "touchMove"
TouchEvent.TOUCH_OUT = "touchOut"
TouchEvent.TOUCH_OVER = "touchOver"
TouchEvent.TOUCH_ROLL_OUT = "touchRollOut"
TouchEvent.TOUCH_ROLL_OVER = "touchRollOver"
TouchEvent.TOUCH_TAP = "touchTap"
TouchEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new TouchEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = TouchEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/UncaughtErrorEvent.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/UncaughtErrorEvent.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.UncaughtErrorEvent

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_ErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/ErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/ErrorEvent.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var UncaughtErrorEvent = function(type,bubbles,cancelable,error) {
	if(cancelable == null) {
		cancelable = true;
	}
	if(bubbles == null) {
		bubbles = true;
	}
	(openfl_events_ErrorEvent().default).call(this,type,bubbles,cancelable);
	this.error = error;
}

// Meta

UncaughtErrorEvent.__name__ = "openfl.events.UncaughtErrorEvent";
UncaughtErrorEvent.__isInterface__ = false;
UncaughtErrorEvent.__super__ = (openfl_events_ErrorEvent().default);
UncaughtErrorEvent.prototype = $extend((openfl_events_ErrorEvent().default).prototype, {
	clone: function() {
		var event = new UncaughtErrorEvent(this.type,this.bubbles,this.cancelable,this.error);
		event.target = this.target;
		event.currentTarget = this.currentTarget;
		event.eventPhase = this.eventPhase;
		return event;
	},
	toString: function() {
		return this.__formatToString("UncaughtErrorEvent",["type","bubbles","cancelable","error"]);
	},
	__init: function() {
		(openfl_events_ErrorEvent().default).prototype.__init.call(this);
		this.error = null;
	}
});
UncaughtErrorEvent.prototype.__class__ = UncaughtErrorEvent.prototype.constructor = $hxClasses["openfl.events.UncaughtErrorEvent"] = UncaughtErrorEvent;

// Init



// Statics


UncaughtErrorEvent.UNCAUGHT_ERROR = "uncaughtError"
UncaughtErrorEvent.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new UncaughtErrorEvent(null);
},function(event) {
	event.__init();
})

// Export

exports.default = UncaughtErrorEvent;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/UncaughtErrorEvents.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/UncaughtErrorEvents.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events.UncaughtErrorEvents

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}

// Constructor

var UncaughtErrorEvents = function() {
	(openfl_events_EventDispatcher().default).call(this);
}

// Meta

UncaughtErrorEvents.__name__ = "openfl.events.UncaughtErrorEvents";
UncaughtErrorEvents.__isInterface__ = false;
UncaughtErrorEvents.__super__ = (openfl_events_EventDispatcher().default);
UncaughtErrorEvents.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	
});
UncaughtErrorEvents.prototype.__class__ = UncaughtErrorEvents.prototype.constructor = $hxClasses["openfl.events.UncaughtErrorEvents"] = UncaughtErrorEvents;

// Init



// Statics




// Export

exports.default = UncaughtErrorEvents;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/_EventDispatcher/DispatchIterator.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/_EventDispatcher/DispatchIterator.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events._EventDispatcher.DispatchIterator

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var DispatchIterator = function(list) {
	this.active = false;
	this.reset(list);
}

// Meta

DispatchIterator.__name__ = "openfl.events._EventDispatcher.DispatchIterator";
DispatchIterator.__isInterface__ = false;
DispatchIterator.prototype = {
	copy: function() {
		if(!this.isCopy) {
			this.list = this.list.slice();
			this.isCopy = true;
		}
	},
	hasNext: function() {
		return this.index < this.list.length;
	},
	next: function() {
		return this.list[this.index++];
	},
	remove: function(listener,listIndex) {
		if(this.active) {
			if(!this.isCopy) {
				if(listIndex < this.index) {
					this.index--;
				}
			} else {
				var _g = this.index;
				var _g1 = this.list.length;
				while(_g < _g1) {
					var i = _g++;
					if(this.list[i] == listener) {
						this.list.splice(i,1);
						break;
					}
				}
			}
		}
	},
	reset: function(list) {
		this.list = list;
		this.isCopy = false;
		this.index = 0;
	},
	start: function() {
		this.active = true;
	},
	stop: function() {
		this.active = false;
	}
};
DispatchIterator.prototype.__class__ = DispatchIterator.prototype.constructor = $hxClasses["openfl.events._EventDispatcher.DispatchIterator"] = DispatchIterator;

// Init



// Statics


DispatchIterator.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = DispatchIterator;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/events/_EventDispatcher/Listener.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/events/_EventDispatcher/Listener.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.events._EventDispatcher.Listener

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Reflect() {return __webpack_require__(/*! ./../../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}

// Constructor

var Listener = function(callback,useCapture,priority) {
	this.callback = callback;
	this.useCapture = useCapture;
	this.priority = priority;
}

// Meta

Listener.__name__ = "openfl.events._EventDispatcher.Listener";
Listener.__isInterface__ = false;
Listener.prototype = {
	match: function(callback,useCapture) {
		if((Reflect().default).compareMethods(this.callback,callback)) {
			return this.useCapture == useCapture;
		} else {
			return false;
		}
	}
};
Listener.prototype.__class__ = Listener.prototype.constructor = $hxClasses["openfl.events._EventDispatcher.Listener"] = Listener;

// Init



// Statics


Listener.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Listener;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilter.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters.BitmapFilter

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var BitmapFilter = function() {
	this.__bottomExtension = 0;
	this.__leftExtension = 0;
	this.__needSecondBitmapData = true;
	this.__numShaderPasses = 0;
	this.__preserveObject = false;
	this.__rightExtension = 0;
	this.__shaderBlendMode = "normal";
	this.__topExtension = 0;
	this.__smooth = true;
}

// Meta

BitmapFilter.__name__ = "openfl.filters.BitmapFilter";
BitmapFilter.__isInterface__ = false;
BitmapFilter.prototype = {
	clone: function() {
		return new BitmapFilter();
	},
	__applyFilter: function(bitmapData,sourceBitmapData,sourceRect,destPoint) {
		return sourceBitmapData;
	},
	__initShader: function(renderer,pass) {
		return null;
	}
};
BitmapFilter.prototype.__class__ = BitmapFilter.prototype.constructor = $hxClasses["openfl.filters.BitmapFilter"] = BitmapFilter;

// Init



// Statics




// Export

exports.default = BitmapFilter;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilterShader.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilterShader.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters.BitmapFilterShader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_display_Shader() {return __webpack_require__(/*! ./../../openfl/display/Shader */ "./node_modules/openfl/lib/_gen/openfl/display/Shader.js");}

// Constructor

var BitmapFilterShader = function(code) {
	if(this.__glFragmentSource == null) {
		this.__glFragmentSource = "varying vec2 openfl_TextureCoordv;\n\n\t\tuniform sampler2D openfl_Texture;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\tvoid main(void) {\n\n\t\t\tgl_FragColor = texture2D (openfl_Texture, openfl_TextureCoordv);\n\n\t\t}";
	}
	if(this.__glVertexSource == null) {
		this.__glVertexSource = "attribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\tvoid main(void) {\n\n\t\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\n\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\t\t}";
	}
	(openfl_display_Shader().default).call(this,code);
	this.__isGenerated = true;
	this.__initGL();
}

// Meta

BitmapFilterShader.__name__ = "openfl.filters.BitmapFilterShader";
BitmapFilterShader.__isInterface__ = false;
BitmapFilterShader.__super__ = (openfl_display_Shader().default);
BitmapFilterShader.prototype = $extend((openfl_display_Shader().default).prototype, {
	
});
BitmapFilterShader.prototype.__class__ = BitmapFilterShader.prototype.constructor = $hxClasses["openfl.filters.BitmapFilterShader"] = BitmapFilterShader;

// Init



// Statics




// Export

exports.default = BitmapFilterShader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/BlurFilter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/BlurFilter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters.BlurFilter

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_filters_BitmapFilter() {return __webpack_require__(/*! ./../../openfl/filters/BitmapFilter */ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilter.js");}
function haxe_Timer() {return __webpack_require__(/*! ./../../haxe/Timer */ "./node_modules/openfl/lib/_gen/haxe/Timer.js");}
function lime__$internal_graphics_ImageDataUtil() {return __webpack_require__(/*! ./../../lime/_internal/graphics/ImageDataUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageDataUtil.js");}
function openfl_filters__$BlurFilter_BlurShader() {return __webpack_require__(/*! ./../../openfl/filters/_BlurFilter/BlurShader */ "./node_modules/openfl/lib/_gen/openfl/filters/_BlurFilter/BlurShader.js");}

// Constructor

var BlurFilter = function(blurX,blurY,quality) {
	if(quality == null) {
		quality = 1;
	}
	if(blurY == null) {
		blurY = 4;
	}
	if(blurX == null) {
		blurX = 4;
	}
	(openfl_filters_BitmapFilter().default).call(this);
	this.set_blurX(blurX);
	this.set_blurY(blurY);
	this.set_quality(quality);
	this.__needSecondBitmapData = true;
	this.__preserveObject = false;
	this.__renderDirty = true;
}

// Meta

BlurFilter.__name__ = "openfl.filters.BlurFilter";
BlurFilter.__isInterface__ = false;
BlurFilter.__super__ = (openfl_filters_BitmapFilter().default);
BlurFilter.prototype = $extend((openfl_filters_BitmapFilter().default).prototype, {
	clone: function() {
		return new BlurFilter(this.__blurX,this.__blurY,this.__quality);
	},
	__applyFilter: function(bitmapData,sourceBitmapData,sourceRect,destPoint) {
		var time = (haxe_Timer().default).stamp();
		var finalImage = (lime__$internal_graphics_ImageDataUtil().default).gaussianBlur(bitmapData.image,sourceBitmapData.image,sourceRect.__toLimeRectangle(),destPoint.__toLimeVector2(),this.__blurX,this.__blurY,this.__quality);
		var elapsed = (haxe_Timer().default).stamp() - time;
		if(finalImage == bitmapData.image) {
			return bitmapData;
		}
		return sourceBitmapData;
	},
	__initShader: function(renderer,pass) {
		if(pass <= this.__horizontalPasses) {
			var scale = Math.pow(0.5,pass >> 1);
			BlurFilter.__blurShader.uRadius.value[0] = this.get_blurX() * scale;
			BlurFilter.__blurShader.uRadius.value[1] = 0;
		} else {
			var scale1 = Math.pow(0.5,pass - this.__horizontalPasses >> 1);
			BlurFilter.__blurShader.uRadius.value[0] = 0;
			BlurFilter.__blurShader.uRadius.value[1] = this.get_blurY() * scale1;
		}
		return BlurFilter.__blurShader;
	},
	get_blurX: function() {
		return this.__blurX;
	},
	set_blurX: function(value) {
		if(value != this.__blurX) {
			this.__blurX = value;
			this.__renderDirty = true;
			this.__leftExtension = value > 0 ? Math.ceil(value) : 0;
			this.__rightExtension = this.__leftExtension;
		}
		return value;
	},
	get_blurY: function() {
		return this.__blurY;
	},
	set_blurY: function(value) {
		if(value != this.__blurY) {
			this.__blurY = value;
			this.__renderDirty = true;
			this.__topExtension = value > 0 ? Math.ceil(value) : 0;
			this.__bottomExtension = this.__topExtension;
		}
		return value;
	},
	get_quality: function() {
		return this.__quality;
	},
	set_quality: function(value) {
		this.__horizontalPasses = this.__blurX <= 0 ? 0 : Math.round(this.__blurX * (value / 4)) + 1;
		this.__verticalPasses = this.__blurY <= 0 ? 0 : Math.round(this.__blurY * (value / 4)) + 1;
		this.__numShaderPasses = this.__horizontalPasses + this.__verticalPasses;
		if(value != this.__quality) {
			this.__renderDirty = true;
		}
		return this.__quality = value;
	}
});
BlurFilter.prototype.__class__ = BlurFilter.prototype.constructor = $hxClasses["openfl.filters.BlurFilter"] = BlurFilter;

// Init

Object.defineProperties(BlurFilter.prototype,{ blurX : { get : function () { return this.get_blurX (); }, set : function (v) { return this.set_blurX (v); }}, blurY : { get : function () { return this.get_blurY (); }, set : function (v) { return this.set_blurY (v); }}, quality : { get : function () { return this.get_quality (); }, set : function (v) { return this.set_quality (v); }}});

// Statics


BlurFilter.__blurShader = new (openfl_filters__$BlurFilter_BlurShader().default)()

// Export

exports.default = BlurFilter;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/ColorMatrixFilter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/ColorMatrixFilter.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters.ColorMatrixFilter

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_filters_BitmapFilter() {return __webpack_require__(/*! ./../../openfl/filters/BitmapFilter */ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilter.js");}
function lime__$internal_graphics_ImageCanvasUtil() {return __webpack_require__(/*! ./../../lime/_internal/graphics/ImageCanvasUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageCanvasUtil.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_math__$RGBA_RGBA_$Impl_$() {return __webpack_require__(/*! ./../../lime/math/_RGBA/RGBA_Impl_ */ "./node_modules/openfl/lib/_gen/lime/math/_RGBA/RGBA_Impl_.js");}
function openfl_filters__$ColorMatrixFilter_ColorMatrixShader() {return __webpack_require__(/*! ./../../openfl/filters/_ColorMatrixFilter/ColorMatrixShader */ "./node_modules/openfl/lib/_gen/openfl/filters/_ColorMatrixFilter/ColorMatrixShader.js");}

// Constructor

var ColorMatrixFilter = function(matrix) {
	(openfl_filters_BitmapFilter().default).call(this);
	this.set_matrix(matrix);
	this.__numShaderPasses = 1;
	this.__needSecondBitmapData = false;
}

// Meta

ColorMatrixFilter.__name__ = "openfl.filters.ColorMatrixFilter";
ColorMatrixFilter.__isInterface__ = false;
ColorMatrixFilter.__super__ = (openfl_filters_BitmapFilter().default);
ColorMatrixFilter.prototype = $extend((openfl_filters_BitmapFilter().default).prototype, {
	clone: function() {
		return new ColorMatrixFilter(this.__matrix);
	},
	__applyFilter: function(destBitmapData,sourceBitmapData,sourceRect,destPoint) {
		var sourceImage = sourceBitmapData.image;
		var image = destBitmapData.image;
		(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(sourceImage);
		(lime__$internal_graphics_ImageCanvasUtil().default).convertToData(image);
		var sourceData = sourceImage.get_data();
		var destData = image.get_data();
		var offsetX = (Std().default).int(destPoint.x - sourceRect.x);
		var offsetY = (Std().default).int(destPoint.y - sourceRect.y);
		var sourceStride = sourceBitmapData.width * 4;
		var destStride = destBitmapData.width * 4;
		var sourceFormat = sourceImage.buffer.format;
		var destFormat = image.buffer.format;
		var sourcePremultiplied = sourceImage.buffer.premultiplied;
		var destPremultiplied = image.buffer.premultiplied;
		var sourcePixel;
		var destPixel = 0;
		var sourceOffset;
		var destOffset;
		var _g = (Std().default).int(sourceRect.y);
		var _g1 = (Std().default).int(sourceRect.height);
		while(_g < _g1) {
			var row = _g++;
			var _g2 = (Std().default).int(sourceRect.x);
			var _g11 = (Std().default).int(sourceRect.width);
			while(_g2 < _g11) {
				var column = _g2++;
				sourceOffset = row * sourceStride + column * 4;
				destOffset = (row + offsetX) * destStride + (column + offsetY) * 4;
				var format = sourceFormat;
				var premultiplied = sourcePremultiplied;
				if(premultiplied == null) {
					premultiplied = false;
				}
				if(format == null) {
					format = 0;
				}
				switch(format) {
				case 0:
					sourcePixel = (sourceData[sourceOffset] & 255) << 24 | (sourceData[sourceOffset + 1] & 255) << 16 | (sourceData[sourceOffset + 2] & 255) << 8 | sourceData[sourceOffset + 3] & 255;
					break;
				case 1:
					sourcePixel = (sourceData[sourceOffset + 1] & 255) << 24 | (sourceData[sourceOffset + 2] & 255) << 16 | (sourceData[sourceOffset + 3] & 255) << 8 | sourceData[sourceOffset] & 255;
					break;
				case 2:
					sourcePixel = (sourceData[sourceOffset + 2] & 255) << 24 | (sourceData[sourceOffset + 1] & 255) << 16 | (sourceData[sourceOffset] & 255) << 8 | sourceData[sourceOffset + 3] & 255;
					break;
				}
				if(premultiplied) {
					if((sourcePixel & 255) != 0 && (sourcePixel & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).unmult = 255.0 / (sourcePixel & 255);
						sourcePixel = ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 24 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 16 | ((lime_math__$RGBA_RGBA_$Impl_$().default).__clamp[Math.round((sourcePixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).unmult)] & 255) << 8 | sourcePixel & 255 & 255;
					}
				}
				if((sourcePixel & 255) == 0) {
					destPixel = 0;
				} else {
					var value = (Std().default).int(Math.max(0,Math.min(this.__matrix[0] * (sourcePixel >>> 24 & 255) + this.__matrix[1] * (sourcePixel >>> 16 & 255) + this.__matrix[2] * (sourcePixel >>> 8 & 255) + this.__matrix[3] * (sourcePixel & 255) + this.__matrix[4],255)));
					destPixel = (value & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
					var value1 = (Std().default).int(Math.max(0,Math.min(this.__matrix[5] * (sourcePixel >>> 24 & 255) + this.__matrix[6] * (sourcePixel >>> 16 & 255) + this.__matrix[7] * (sourcePixel >>> 8 & 255) + this.__matrix[8] * (sourcePixel & 255) + this.__matrix[9],255)));
					destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (value1 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | destPixel & 255 & 255;
					var value2 = (Std().default).int(Math.max(0,Math.min(this.__matrix[10] * (sourcePixel >>> 24 & 255) + this.__matrix[11] * (sourcePixel >>> 16 & 255) + this.__matrix[12] * (sourcePixel >>> 8 & 255) + this.__matrix[13] * (sourcePixel & 255) + this.__matrix[14],255)));
					destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (value2 & 255) << 8 | destPixel & 255 & 255;
					var value3 = (Std().default).int(Math.max(0,Math.min(this.__matrix[15] * (sourcePixel >>> 24 & 255) + this.__matrix[16] * (sourcePixel >>> 16 & 255) + this.__matrix[17] * (sourcePixel >>> 8 & 255) + this.__matrix[18] * (sourcePixel & 255) + this.__matrix[19],255)));
					destPixel = (destPixel >>> 24 & 255 & 255) << 24 | (destPixel >>> 16 & 255 & 255) << 16 | (destPixel >>> 8 & 255 & 255) << 8 | value3 & 255;
				}
				var format1 = destFormat;
				var premultiplied1 = destPremultiplied;
				if(premultiplied1 == null) {
					premultiplied1 = false;
				}
				if(format1 == null) {
					format1 = 0;
				}
				if(premultiplied1) {
					if((destPixel & 255) == 0) {
						if(destPixel != 0) {
							destPixel = 0;
						}
					} else if((destPixel & 255) != 255) {
						(lime_math__$RGBA_RGBA_$Impl_$().default).a16 = (lime_math__$RGBA_RGBA_$Impl_$().default).__alpha16[destPixel & 255];
						destPixel = ((destPixel >>> 24 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 24 | ((destPixel >>> 16 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 16 | ((destPixel >>> 8 & 255) * (lime_math__$RGBA_RGBA_$Impl_$().default).a16 >> 16 & 255) << 8 | destPixel & 255 & 255;
					}
				}
				switch(format1) {
				case 0:
					destData[destOffset] = destPixel >>> 24 & 255;
					destData[destOffset + 1] = destPixel >>> 16 & 255;
					destData[destOffset + 2] = destPixel >>> 8 & 255;
					destData[destOffset + 3] = destPixel & 255;
					break;
				case 1:
					destData[destOffset] = destPixel & 255;
					destData[destOffset + 1] = destPixel >>> 24 & 255;
					destData[destOffset + 2] = destPixel >>> 16 & 255;
					destData[destOffset + 3] = destPixel >>> 8 & 255;
					break;
				case 2:
					destData[destOffset] = destPixel >>> 8 & 255;
					destData[destOffset + 1] = destPixel >>> 16 & 255;
					destData[destOffset + 2] = destPixel >>> 24 & 255;
					destData[destOffset + 3] = destPixel & 255;
					break;
				}
			}
		}
		destBitmapData.image.dirty = true;
		return destBitmapData;
	},
	__initShader: function(renderer,pass) {
		ColorMatrixFilter.__colorMatrixShader.init(this.get_matrix());
		return ColorMatrixFilter.__colorMatrixShader;
	},
	get_matrix: function() {
		return this.__matrix;
	},
	set_matrix: function(value) {
		if(value == null) {
			value = [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];
		}
		return this.__matrix = value;
	}
});
ColorMatrixFilter.prototype.__class__ = ColorMatrixFilter.prototype.constructor = $hxClasses["openfl.filters.ColorMatrixFilter"] = ColorMatrixFilter;

// Init

Object.defineProperties(ColorMatrixFilter.prototype,{ matrix : { get : function () { return this.get_matrix (); }, set : function (v) { return this.set_matrix (v); }}});

// Statics


ColorMatrixFilter.__colorMatrixShader = new (openfl_filters__$ColorMatrixFilter_ColorMatrixShader().default)()

// Export

exports.default = ColorMatrixFilter;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/DropShadowFilter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/DropShadowFilter.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters.DropShadowFilter

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_filters_BitmapFilter() {return __webpack_require__(/*! ./../../openfl/filters/BitmapFilter */ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilter.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function lime__$internal_graphics_ImageDataUtil() {return __webpack_require__(/*! ./../../lime/_internal/graphics/ImageDataUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageDataUtil.js");}
function openfl_geom_ColorTransform() {return __webpack_require__(/*! ./../../openfl/geom/ColorTransform */ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}

// Constructor

var DropShadowFilter = function(distance,angle,color,alpha,blurX,blurY,strength,quality,inner,knockout,hideObject) {
	if(hideObject == null) {
		hideObject = false;
	}
	if(knockout == null) {
		knockout = false;
	}
	if(inner == null) {
		inner = false;
	}
	if(quality == null) {
		quality = 1;
	}
	if(strength == null) {
		strength = 1;
	}
	if(blurY == null) {
		blurY = 4;
	}
	if(blurX == null) {
		blurX = 4;
	}
	if(alpha == null) {
		alpha = 1;
	}
	if(color == null) {
		color = 0;
	}
	if(angle == null) {
		angle = 45;
	}
	if(distance == null) {
		distance = 4;
	}
	(openfl_filters_BitmapFilter().default).call(this);
	this.__offsetX = 0;
	this.__offsetY = 0;
	this.__distance = distance;
	this.__angle = angle;
	this.__color = color;
	this.__alpha = alpha;
	this.__blurX = blurX;
	this.__blurY = blurY;
	this.__strength = strength;
	this.__quality = quality;
	this.__inner = inner;
	this.__knockout = knockout;
	this.__hideObject = hideObject;
	this.__updateSize();
	this.__needSecondBitmapData = true;
	this.__preserveObject = !this.__hideObject;
	this.__renderDirty = true;
}

// Meta

DropShadowFilter.__name__ = "openfl.filters.DropShadowFilter";
DropShadowFilter.__isInterface__ = false;
DropShadowFilter.__super__ = (openfl_filters_BitmapFilter().default);
DropShadowFilter.prototype = $extend((openfl_filters_BitmapFilter().default).prototype, {
	clone: function() {
		return new DropShadowFilter(this.__distance,this.__angle,this.__color,this.__alpha,this.__blurX,this.__blurY,this.__strength,this.__quality,this.__inner,this.__knockout,this.__hideObject);
	},
	__applyFilter: function(bitmapData,sourceBitmapData,sourceRect,destPoint) {
		var r = this.__color >> 16 & 255;
		var g = this.__color >> 8 & 255;
		var b = this.__color & 255;
		var point = new (openfl_geom_Point().default)(destPoint.x + this.__offsetX,destPoint.y + this.__offsetY);
		var finalImage = (lime__$internal_graphics_ImageDataUtil().default).gaussianBlur(bitmapData.image,sourceBitmapData.image,sourceRect.__toLimeRectangle(),point.__toLimeVector2(),this.__blurX,this.__blurY,this.__quality,this.__strength);
		finalImage.colorTransform(finalImage.get_rect(),new (openfl_geom_ColorTransform().default)(0,0,0,this.__alpha,r,g,b,0).__toLimeColorMatrix());
		if(finalImage == bitmapData.image) {
			return bitmapData;
		}
		return sourceBitmapData;
	},
	__updateSize: function() {
		this.__offsetX = (Std().default).int(this.__distance * Math.cos(this.__angle * Math.PI / 180));
		this.__offsetY = (Std().default).int(this.__distance * Math.sin(this.__angle * Math.PI / 180));
		this.__topExtension = Math.ceil((this.__offsetY < 0 ? -this.__offsetY : 0) + this.__blurY);
		this.__bottomExtension = Math.ceil((this.__offsetY > 0 ? this.__offsetY : 0) + this.__blurY);
		this.__leftExtension = Math.ceil((this.__offsetX < 0 ? -this.__offsetX : 0) + this.__blurX);
		this.__rightExtension = Math.ceil((this.__offsetX > 0 ? this.__offsetX : 0) + this.__blurX);
	},
	get_alpha: function() {
		return this.__alpha;
	},
	set_alpha: function(value) {
		if(value != this.__alpha) {
			this.__renderDirty = true;
		}
		return this.__alpha = value;
	},
	get_angle: function() {
		return this.__angle;
	},
	set_angle: function(value) {
		if(value != this.__angle) {
			this.__angle = value;
			this.__renderDirty = true;
			this.__updateSize();
		}
		return value;
	},
	get_blurX: function() {
		return this.__blurX;
	},
	set_blurX: function(value) {
		if(value != this.__blurX) {
			this.__blurX = value;
			this.__renderDirty = true;
			this.__updateSize();
		}
		return value;
	},
	get_blurY: function() {
		return this.__blurY;
	},
	set_blurY: function(value) {
		if(value != this.__blurY) {
			this.__blurY = value;
			this.__renderDirty = true;
			this.__updateSize();
		}
		return value;
	},
	get_color: function() {
		return this.__color;
	},
	set_color: function(value) {
		if(value != this.__color) {
			this.__renderDirty = true;
		}
		return this.__color = value;
	},
	get_distance: function() {
		return this.__distance;
	},
	set_distance: function(value) {
		if(value != this.__distance) {
			this.__distance = value;
			this.__renderDirty = true;
			this.__updateSize();
		}
		return value;
	},
	get_hideObject: function() {
		return this.__hideObject;
	},
	set_hideObject: function(value) {
		if(value != this.__hideObject) {
			this.__renderDirty = true;
			this.__preserveObject = !value;
		}
		return this.__hideObject = value;
	},
	get_inner: function() {
		return this.__inner;
	},
	set_inner: function(value) {
		if(value != this.__inner) {
			this.__renderDirty = true;
		}
		return this.__inner = value;
	},
	get_knockout: function() {
		return this.__knockout;
	},
	set_knockout: function(value) {
		if(value != this.__knockout) {
			this.__renderDirty = true;
		}
		return this.__knockout = value;
	},
	get_quality: function() {
		return this.__quality;
	},
	set_quality: function(value) {
		if(value != this.__quality) {
			this.__renderDirty = true;
		}
		return this.__quality = value;
	},
	get_strength: function() {
		return this.__strength;
	},
	set_strength: function(value) {
		if(value != this.__strength) {
			this.__renderDirty = true;
		}
		return this.__strength = value;
	}
});
DropShadowFilter.prototype.__class__ = DropShadowFilter.prototype.constructor = $hxClasses["openfl.filters.DropShadowFilter"] = DropShadowFilter;

// Init

Object.defineProperties(DropShadowFilter.prototype,{ alpha : { get : function () { return this.get_alpha (); }, set : function (v) { return this.set_alpha (v); }}, angle : { get : function () { return this.get_angle (); }, set : function (v) { return this.set_angle (v); }}, blurX : { get : function () { return this.get_blurX (); }, set : function (v) { return this.set_blurX (v); }}, blurY : { get : function () { return this.get_blurY (); }, set : function (v) { return this.set_blurY (v); }}, color : { get : function () { return this.get_color (); }, set : function (v) { return this.set_color (v); }}, distance : { get : function () { return this.get_distance (); }, set : function (v) { return this.set_distance (v); }}, hideObject : { get : function () { return this.get_hideObject (); }, set : function (v) { return this.set_hideObject (v); }}, inner : { get : function () { return this.get_inner (); }, set : function (v) { return this.set_inner (v); }}, knockout : { get : function () { return this.get_knockout (); }, set : function (v) { return this.set_knockout (v); }}, quality : { get : function () { return this.get_quality (); }, set : function (v) { return this.set_quality (v); }}, strength : { get : function () { return this.get_strength (); }, set : function (v) { return this.set_strength (v); }}});

// Statics




// Export

exports.default = DropShadowFilter;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/GlowFilter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/GlowFilter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters.GlowFilter

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_filters_BitmapFilter() {return __webpack_require__(/*! ./../../openfl/filters/BitmapFilter */ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilter.js");}
function lime__$internal_graphics_ImageDataUtil() {return __webpack_require__(/*! ./../../lime/_internal/graphics/ImageDataUtil */ "./node_modules/openfl/lib/_gen/lime/_internal/graphics/ImageDataUtil.js");}
function openfl_geom_ColorTransform() {return __webpack_require__(/*! ./../../openfl/geom/ColorTransform */ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js");}
function openfl_filters__$GlowFilter_GlowShader() {return __webpack_require__(/*! ./../../openfl/filters/_GlowFilter/GlowShader */ "./node_modules/openfl/lib/_gen/openfl/filters/_GlowFilter/GlowShader.js");}

// Constructor

var GlowFilter = function(color,alpha,blurX,blurY,strength,quality,inner,knockout) {
	if(knockout == null) {
		knockout = false;
	}
	if(inner == null) {
		inner = false;
	}
	if(quality == null) {
		quality = 1;
	}
	if(strength == null) {
		strength = 2;
	}
	if(blurY == null) {
		blurY = 6;
	}
	if(blurX == null) {
		blurX = 6;
	}
	if(alpha == null) {
		alpha = 1;
	}
	if(color == null) {
		color = 16711680;
	}
	(openfl_filters_BitmapFilter().default).call(this);
	this.__color = color;
	this.__alpha = alpha;
	this.set_blurX(blurX);
	this.set_blurY(blurY);
	this.__strength = strength;
	this.set_quality(quality);
	this.__inner = inner;
	this.__knockout = knockout;
	this.__needSecondBitmapData = true;
	this.__preserveObject = true;
	this.__renderDirty = true;
}

// Meta

GlowFilter.__name__ = "openfl.filters.GlowFilter";
GlowFilter.__isInterface__ = false;
GlowFilter.__super__ = (openfl_filters_BitmapFilter().default);
GlowFilter.prototype = $extend((openfl_filters_BitmapFilter().default).prototype, {
	clone: function() {
		return new GlowFilter(this.__color,this.__alpha,this.__blurX,this.__blurY,this.__strength,this.__quality,this.__inner,this.__knockout);
	},
	__applyFilter: function(bitmapData,sourceBitmapData,sourceRect,destPoint) {
		var r = this.__color >> 16 & 255;
		var g = this.__color >> 8 & 255;
		var b = this.__color & 255;
		var finalImage = (lime__$internal_graphics_ImageDataUtil().default).gaussianBlur(bitmapData.image,sourceBitmapData.image,sourceRect.__toLimeRectangle(),destPoint.__toLimeVector2(),this.__blurX,this.__blurY,this.__quality,this.__strength);
		finalImage.colorTransform(finalImage.get_rect(),new (openfl_geom_ColorTransform().default)(0,0,0,this.__alpha,r,g,b,0).__toLimeColorMatrix());
		if(finalImage == bitmapData.image) {
			return bitmapData;
		}
		return sourceBitmapData;
	},
	__initShader: function(renderer,pass) {
		if(pass <= this.__horizontalPasses) {
			var scale = Math.pow(0.5,pass >> 1);
			GlowFilter.__glowShader.uRadius.value[0] = this.get_blurX() * scale;
			GlowFilter.__glowShader.uRadius.value[1] = 0;
		} else {
			var scale1 = Math.pow(0.5,pass - this.__horizontalPasses >> 1);
			GlowFilter.__glowShader.uRadius.value[0] = 0;
			GlowFilter.__glowShader.uRadius.value[1] = this.get_blurY() * scale1;
		}
		GlowFilter.__glowShader.uColor.value[0] = (this.get_color() >> 16 & 255) / 255;
		GlowFilter.__glowShader.uColor.value[1] = (this.get_color() >> 8 & 255) / 255;
		GlowFilter.__glowShader.uColor.value[2] = (this.get_color() & 255) / 255;
		GlowFilter.__glowShader.uColor.value[3] = this.get_alpha() * (this.__strength / this.__numShaderPasses);
		return GlowFilter.__glowShader;
	},
	get_alpha: function() {
		return this.__alpha;
	},
	set_alpha: function(value) {
		if(value != this.__alpha) {
			this.__renderDirty = true;
		}
		return this.__alpha = value;
	},
	get_blurX: function() {
		return this.__blurX;
	},
	set_blurX: function(value) {
		if(value != this.__blurX) {
			this.__blurX = value;
			this.__renderDirty = true;
			this.__leftExtension = value > 0 ? Math.ceil(value * 1.5) : 0;
			this.__rightExtension = this.__leftExtension;
		}
		return value;
	},
	get_blurY: function() {
		return this.__blurY;
	},
	set_blurY: function(value) {
		if(value != this.__blurY) {
			this.__blurY = value;
			this.__renderDirty = true;
			this.__topExtension = value > 0 ? Math.ceil(value * 1.5) : 0;
			this.__bottomExtension = this.__topExtension;
		}
		return value;
	},
	get_color: function() {
		return this.__color;
	},
	set_color: function(value) {
		if(value != this.__color) {
			this.__renderDirty = true;
		}
		return this.__color = value;
	},
	get_inner: function() {
		return this.__inner;
	},
	set_inner: function(value) {
		if(value != this.__inner) {
			this.__renderDirty = true;
		}
		return this.__inner = value;
	},
	get_knockout: function() {
		return this.__knockout;
	},
	set_knockout: function(value) {
		if(value != this.__knockout) {
			this.__renderDirty = true;
		}
		return this.__knockout = value;
	},
	get_quality: function() {
		return this.__quality;
	},
	set_quality: function(value) {
		this.__horizontalPasses = this.__blurX <= 0 ? 0 : Math.round(this.__blurX * (value / 4)) + 1;
		this.__verticalPasses = this.__blurY <= 0 ? 0 : Math.round(this.__blurY * (value / 4)) + 1;
		this.__numShaderPasses = this.__horizontalPasses + this.__verticalPasses;
		if(value != this.__quality) {
			this.__renderDirty = true;
		}
		return this.__quality = value;
	},
	get_strength: function() {
		return this.__strength;
	},
	set_strength: function(value) {
		if(value != this.__strength) {
			this.__renderDirty = true;
		}
		return this.__strength = value;
	}
});
GlowFilter.prototype.__class__ = GlowFilter.prototype.constructor = $hxClasses["openfl.filters.GlowFilter"] = GlowFilter;

// Init

Object.defineProperties(GlowFilter.prototype,{ alpha : { get : function () { return this.get_alpha (); }, set : function (v) { return this.set_alpha (v); }}, blurX : { get : function () { return this.get_blurX (); }, set : function (v) { return this.set_blurX (v); }}, blurY : { get : function () { return this.get_blurY (); }, set : function (v) { return this.set_blurY (v); }}, color : { get : function () { return this.get_color (); }, set : function (v) { return this.set_color (v); }}, inner : { get : function () { return this.get_inner (); }, set : function (v) { return this.set_inner (v); }}, knockout : { get : function () { return this.get_knockout (); }, set : function (v) { return this.set_knockout (v); }}, quality : { get : function () { return this.get_quality (); }, set : function (v) { return this.set_quality (v); }}, strength : { get : function () { return this.get_strength (); }, set : function (v) { return this.set_strength (v); }}});

// Statics


GlowFilter.__glowShader = new (openfl_filters__$GlowFilter_GlowShader().default)()

// Export

exports.default = GlowFilter;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/_BlurFilter/BlurShader.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/_BlurFilter/BlurShader.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters._BlurFilter.BlurShader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_filters_BitmapFilterShader() {return __webpack_require__(/*! ./../../../openfl/filters/BitmapFilterShader */ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilterShader.js");}

// Constructor

var BlurShader = function() {
	if(this.__glFragmentSource == null) {
		this.__glFragmentSource = "uniform sampler2D openfl_Texture;\n\n\t\tvarying vec2 vBlurCoords[7];\n\n\t\tvoid main(void) {\n\n\t\t\tvec4 sum = vec4(0.0);\n\t\t\tsum += texture2D(openfl_Texture, vBlurCoords[0]) * 0.00443;\n\t\t\tsum += texture2D(openfl_Texture, vBlurCoords[1]) * 0.05399;\n\t\t\tsum += texture2D(openfl_Texture, vBlurCoords[2]) * 0.24197;\n\t\t\tsum += texture2D(openfl_Texture, vBlurCoords[3]) * 0.39894;\n\t\t\tsum += texture2D(openfl_Texture, vBlurCoords[4]) * 0.24197;\n\t\t\tsum += texture2D(openfl_Texture, vBlurCoords[5]) * 0.05399;\n\t\t\tsum += texture2D(openfl_Texture, vBlurCoords[6]) * 0.00443;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}";
	}
	if(this.__glVertexSource == null) {
		this.__glVertexSource = "attribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tuniform mat4 openfl_Matrix;\n\n\t\tuniform vec2 uRadius;\n\t\tvarying vec2 vBlurCoords[7];\n\t\tuniform vec2 uTextureSize;\n\n\t\tvoid main(void) {\n\n\t\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\t\t\tvec2 r = uRadius / uTextureSize;\n\t\t\tvBlurCoords[0] = openfl_TextureCoord - r * 1.0;\n\t\t\tvBlurCoords[1] = openfl_TextureCoord - r * 0.75;\n\t\t\tvBlurCoords[2] = openfl_TextureCoord - r * 0.5;\n\t\t\tvBlurCoords[3] = openfl_TextureCoord;\n\t\t\tvBlurCoords[4] = openfl_TextureCoord + r * 0.5;\n\t\t\tvBlurCoords[5] = openfl_TextureCoord + r * 0.75;\n\t\t\tvBlurCoords[6] = openfl_TextureCoord + r * 1.0;\n\n\t\t}";
	}
	(openfl_filters_BitmapFilterShader().default).call(this);
	this.uRadius.value = [0,0];
	this.__isGenerated = true;
	this.__initGL();
}

// Meta

BlurShader.__name__ = "openfl.filters._BlurFilter.BlurShader";
BlurShader.__isInterface__ = false;
BlurShader.__super__ = (openfl_filters_BitmapFilterShader().default);
BlurShader.prototype = $extend((openfl_filters_BitmapFilterShader().default).prototype, {
	__update: function() {
		this.uTextureSize.value = [this.__texture.input.width,this.__texture.input.height];
		(openfl_filters_BitmapFilterShader().default).prototype.__update.call(this);
	}
});
BlurShader.prototype.__class__ = BlurShader.prototype.constructor = $hxClasses["openfl.filters._BlurFilter.BlurShader"] = BlurShader;

// Init



// Statics




// Export

exports.default = BlurShader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/_ColorMatrixFilter/ColorMatrixShader.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/_ColorMatrixFilter/ColorMatrixShader.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters._ColorMatrixFilter.ColorMatrixShader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_filters_BitmapFilterShader() {return __webpack_require__(/*! ./../../../openfl/filters/BitmapFilterShader */ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilterShader.js");}

// Constructor

var ColorMatrixShader = function() {
	if(this.__glFragmentSource == null) {
		this.__glFragmentSource = "varying vec2 openfl_TextureCoordv;\n\t\tuniform sampler2D openfl_Texture;\n\n\t\tuniform mat4 uMultipliers;\n\t\tuniform vec4 uOffsets;\n\n\t\tvoid main(void) {\n\n\t\t\tvec4 color = texture2D (openfl_Texture, openfl_TextureCoordv);\n\n\t\t\tif (color.a == 0.0) {\n\n\t\t\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\n\n\t\t\t} else {\n\n\t\t\t\tcolor = vec4 (color.rgb / color.a, color.a);\n\t\t\t\tcolor = uOffsets + color * uMultipliers;\n\n\t\t\t\tgl_FragColor = vec4 (color.rgb * color.a, color.a);\n\n\t\t\t}\n\n\t\t}";
	}
	if(this.__glVertexSource == null) {
		this.__glVertexSource = "attribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform vec2 openfl_TextureSize;\n\n\n\t\tvoid main(void) {\n\n\t\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\n\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\n\t\t}";
	}
	(openfl_filters_BitmapFilterShader().default).call(this);
	this.uMultipliers.value = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
	this.uOffsets.value = [0,0,0,0];
	this.__isGenerated = true;
	this.__initGL();
}

// Meta

ColorMatrixShader.__name__ = "openfl.filters._ColorMatrixFilter.ColorMatrixShader";
ColorMatrixShader.__isInterface__ = false;
ColorMatrixShader.__super__ = (openfl_filters_BitmapFilterShader().default);
ColorMatrixShader.prototype = $extend((openfl_filters_BitmapFilterShader().default).prototype, {
	init: function(matrix) {
		var multipliers = this.uMultipliers.value;
		var offsets = this.uOffsets.value;
		multipliers[0] = matrix[0];
		multipliers[1] = matrix[1];
		multipliers[2] = matrix[2];
		multipliers[3] = matrix[3];
		multipliers[4] = matrix[5];
		multipliers[5] = matrix[6];
		multipliers[6] = matrix[7];
		multipliers[7] = matrix[8];
		multipliers[8] = matrix[10];
		multipliers[9] = matrix[11];
		multipliers[10] = matrix[12];
		multipliers[11] = matrix[13];
		multipliers[12] = matrix[15];
		multipliers[13] = matrix[16];
		multipliers[14] = matrix[17];
		multipliers[15] = matrix[18];
		offsets[0] = matrix[4] / 255.0;
		offsets[1] = matrix[9] / 255.0;
		offsets[2] = matrix[14] / 255.0;
		offsets[3] = matrix[19] / 255.0;
	}
});
ColorMatrixShader.prototype.__class__ = ColorMatrixShader.prototype.constructor = $hxClasses["openfl.filters._ColorMatrixFilter.ColorMatrixShader"] = ColorMatrixShader;

// Init



// Statics


ColorMatrixShader.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = ColorMatrixShader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/filters/_GlowFilter/GlowShader.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/filters/_GlowFilter/GlowShader.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.filters._GlowFilter.GlowShader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_filters_BitmapFilterShader() {return __webpack_require__(/*! ./../../../openfl/filters/BitmapFilterShader */ "./node_modules/openfl/lib/_gen/openfl/filters/BitmapFilterShader.js");}

// Constructor

var GlowShader = function() {
	if(this.__glFragmentSource == null) {
		this.__glFragmentSource = "uniform sampler2D openfl_Texture;\n\t\t\n\t\tuniform vec4 uColor;\n\t\t\n\t\tvarying vec2 vBlurCoords[7];\n\t\t\n\t\tvoid main(void) {\n\t\t\t\n\t\t\tfloat a = 0.0;\n\t\t\ta += texture2D(openfl_Texture, vBlurCoords[0]).a * 0.00443;\n\t\t\ta += texture2D(openfl_Texture, vBlurCoords[1]).a * 0.05399;\n\t\t\ta += texture2D(openfl_Texture, vBlurCoords[2]).a * 0.24197;\n\t\t\ta += texture2D(openfl_Texture, vBlurCoords[3]).a * 0.39894;\n\t\t\ta += texture2D(openfl_Texture, vBlurCoords[4]).a * 0.24197;\n\t\t\ta += texture2D(openfl_Texture, vBlurCoords[5]).a * 0.05399;\n\t\t\ta += texture2D(openfl_Texture, vBlurCoords[6]).a * 0.00443;\n\t\t\ta *= uColor.a;\n\t\t\t\n\t\t\tgl_FragColor = vec4(uColor.rgb * a, a);\n\t\t\t\n\t\t}";
	}
	if(this.__glVertexSource == null) {
		this.__glVertexSource = "attribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\t\t\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform vec2 openfl_TextureSize;\n\t\t\n\t\tuniform vec2 uRadius;\n\t\tvarying vec2 vBlurCoords[7];\n\t\t\n\t\tvoid main(void) {\n\t\t\t\n\t\t\tgl_Position = openfl_Matrix * openfl_Position;\n\t\t\t\n\t\t\tvec2 r = uRadius / openfl_TextureSize;\n\t\t\tvBlurCoords[0] = openfl_TextureCoord - r * 1.0;\n\t\t\tvBlurCoords[1] = openfl_TextureCoord - r * 0.75;\n\t\t\tvBlurCoords[2] = openfl_TextureCoord - r * 0.5;\n\t\t\tvBlurCoords[3] = openfl_TextureCoord;\n\t\t\tvBlurCoords[4] = openfl_TextureCoord + r * 0.5;\n\t\t\tvBlurCoords[5] = openfl_TextureCoord + r * 0.75;\n\t\t\tvBlurCoords[6] = openfl_TextureCoord + r * 1.0;\n\t\t\t\n\t\t}";
	}
	(openfl_filters_BitmapFilterShader().default).call(this);
	this.uRadius.value = [0,0];
	this.uColor.value = [0,0,0,0];
	this.__isGenerated = true;
	this.__initGL();
}

// Meta

GlowShader.__name__ = "openfl.filters._GlowFilter.GlowShader";
GlowShader.__isInterface__ = false;
GlowShader.__super__ = (openfl_filters_BitmapFilterShader().default);
GlowShader.prototype = $extend((openfl_filters_BitmapFilterShader().default).prototype, {
	
});
GlowShader.prototype.__class__ = GlowShader.prototype.constructor = $hxClasses["openfl.filters._GlowFilter.GlowShader"] = GlowShader;

// Init



// Statics




// Export

exports.default = GlowShader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.geom.ColorTransform

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var ColorTransform = function(redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset) {
	if(alphaOffset == null) {
		alphaOffset = 0;
	}
	if(blueOffset == null) {
		blueOffset = 0;
	}
	if(greenOffset == null) {
		greenOffset = 0;
	}
	if(redOffset == null) {
		redOffset = 0;
	}
	if(alphaMultiplier == null) {
		alphaMultiplier = 1;
	}
	if(blueMultiplier == null) {
		blueMultiplier = 1;
	}
	if(greenMultiplier == null) {
		greenMultiplier = 1;
	}
	if(redMultiplier == null) {
		redMultiplier = 1;
	}
	this.redMultiplier = redMultiplier;
	this.greenMultiplier = greenMultiplier;
	this.blueMultiplier = blueMultiplier;
	this.alphaMultiplier = alphaMultiplier;
	this.redOffset = redOffset;
	this.greenOffset = greenOffset;
	this.blueOffset = blueOffset;
	this.alphaOffset = alphaOffset;
}

// Meta

ColorTransform.__name__ = "openfl.geom.ColorTransform";
ColorTransform.__isInterface__ = false;
ColorTransform.prototype = {
	concat: function(second) {
		this.redOffset = second.redOffset * this.redMultiplier + this.redOffset;
		this.greenOffset = second.greenOffset * this.greenMultiplier + this.greenOffset;
		this.blueOffset = second.blueOffset * this.blueMultiplier + this.blueOffset;
		this.alphaOffset = second.alphaOffset * this.alphaMultiplier + this.alphaOffset;
		this.redMultiplier *= second.redMultiplier;
		this.greenMultiplier *= second.greenMultiplier;
		this.blueMultiplier *= second.blueMultiplier;
		this.alphaMultiplier *= second.alphaMultiplier;
	},
	toString: function() {
		return "(redMultiplier=" + this.redMultiplier + ", greenMultiplier=" + this.greenMultiplier + ", blueMultiplier=" + this.blueMultiplier + ", alphaMultiplier=" + this.alphaMultiplier + ", redOffset=" + this.redOffset + ", greenOffset=" + this.greenOffset + ", blueOffset=" + this.blueOffset + ", alphaOffset=" + this.alphaOffset + ")";
	},
	__clone: function() {
		return new ColorTransform(this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaMultiplier,this.redOffset,this.greenOffset,this.blueOffset,this.alphaOffset);
	},
	__copyFrom: function(ct) {
		this.redMultiplier = ct.redMultiplier;
		this.greenMultiplier = ct.greenMultiplier;
		this.blueMultiplier = ct.blueMultiplier;
		this.alphaMultiplier = ct.alphaMultiplier;
		this.redOffset = ct.redOffset;
		this.greenOffset = ct.greenOffset;
		this.blueOffset = ct.blueOffset;
		this.alphaOffset = ct.alphaOffset;
	},
	__combine: function(ct) {
		this.redMultiplier *= ct.redMultiplier;
		this.greenMultiplier *= ct.greenMultiplier;
		this.blueMultiplier *= ct.blueMultiplier;
		this.alphaMultiplier *= ct.alphaMultiplier;
		this.redOffset += ct.redOffset;
		this.greenOffset += ct.greenOffset;
		this.blueOffset += ct.blueOffset;
		this.alphaOffset += ct.alphaOffset;
	},
	__identity: function() {
		this.redMultiplier = 1;
		this.greenMultiplier = 1;
		this.blueMultiplier = 1;
		this.alphaMultiplier = 1;
		this.redOffset = 0;
		this.greenOffset = 0;
		this.blueOffset = 0;
		this.alphaOffset = 0;
	},
	__invert: function() {
		this.redMultiplier = this.redMultiplier != 0 ? 1 / this.redMultiplier : 1;
		this.greenMultiplier = this.greenMultiplier != 0 ? 1 / this.greenMultiplier : 1;
		this.blueMultiplier = this.blueMultiplier != 0 ? 1 / this.blueMultiplier : 1;
		this.alphaMultiplier = this.alphaMultiplier != 0 ? 1 / this.alphaMultiplier : 1;
		this.redOffset = -this.redOffset;
		this.greenOffset = -this.greenOffset;
		this.blueOffset = -this.blueOffset;
		this.alphaOffset = -this.alphaOffset;
	},
	__equals: function(ct,ignoreAlphaMultiplier) {
		if(ct != null && this.redMultiplier == ct.redMultiplier && this.greenMultiplier == ct.greenMultiplier && this.blueMultiplier == ct.blueMultiplier && (ignoreAlphaMultiplier || this.alphaMultiplier == ct.alphaMultiplier) && this.redOffset == ct.redOffset && this.greenOffset == ct.greenOffset && this.blueOffset == ct.blueOffset) {
			return this.alphaOffset == ct.alphaOffset;
		} else {
			return false;
		}
	},
	__isDefault: function(ignoreAlphaMultiplier) {
		if(ignoreAlphaMultiplier) {
			if(this.redMultiplier == 1 && this.greenMultiplier == 1 && this.blueMultiplier == 1 && this.redOffset == 0 && this.greenOffset == 0 && this.blueOffset == 0) {
				return this.alphaOffset == 0;
			} else {
				return false;
			}
		} else if(this.redMultiplier == 1 && this.greenMultiplier == 1 && this.blueMultiplier == 1 && this.alphaMultiplier == 1 && this.redOffset == 0 && this.greenOffset == 0 && this.blueOffset == 0) {
			return this.alphaOffset == 0;
		} else {
			return false;
		}
	},
	__setArrays: function(colorMultipliers,colorOffsets) {
		colorMultipliers[0] = this.redMultiplier;
		colorMultipliers[1] = this.greenMultiplier;
		colorMultipliers[2] = this.blueMultiplier;
		colorMultipliers[3] = this.alphaMultiplier;
		colorOffsets[0] = this.redOffset;
		colorOffsets[1] = this.greenOffset;
		colorOffsets[2] = this.blueOffset;
		colorOffsets[3] = this.alphaOffset;
	},
	get_color: function() {
		return (Std().default).int(this.redOffset) << 16 | (Std().default).int(this.greenOffset) << 8 | (Std().default).int(this.blueOffset);
	},
	set_color: function(value) {
		this.redOffset = value >> 16 & 255;
		this.greenOffset = value >> 8 & 255;
		this.blueOffset = value & 255;
		this.redMultiplier = 0;
		this.greenMultiplier = 0;
		this.blueMultiplier = 0;
		return this.get_color();
	},
	__toLimeColorMatrix: function() {
		if(ColorTransform.__limeColorMatrix == null) {
			var array = null;
			var view = null;
			var buffer = null;
			var len = null;
			var this1 = new Float32Array(20);
			ColorTransform.__limeColorMatrix = this1;
		}
		ColorTransform.__limeColorMatrix[0] = this.redMultiplier;
		ColorTransform.__limeColorMatrix[4] = this.redOffset / 255;
		ColorTransform.__limeColorMatrix[6] = this.greenMultiplier;
		ColorTransform.__limeColorMatrix[9] = this.greenOffset / 255;
		ColorTransform.__limeColorMatrix[12] = this.blueMultiplier;
		ColorTransform.__limeColorMatrix[14] = this.blueOffset / 255;
		ColorTransform.__limeColorMatrix[18] = this.alphaMultiplier;
		ColorTransform.__limeColorMatrix[19] = this.alphaOffset / 255;
		return ColorTransform.__limeColorMatrix;
	}
};
ColorTransform.prototype.__class__ = ColorTransform.prototype.constructor = $hxClasses["openfl.geom.ColorTransform"] = ColorTransform;

// Init

Object.defineProperty(ColorTransform.prototype,"color",{ get : function () { return this.get_color (); }, set : function (v) { return this.set_color (v); }});

// Statics


ColorTransform.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new ColorTransform();
},function(ct) {
	ct.__identity();
})

// Export

exports.default = ColorTransform;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/geom/Matrix.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.geom.Matrix

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}
function lime_math_Matrix3() {return __webpack_require__(/*! ./../../lime/math/Matrix3 */ "./node_modules/openfl/lib/_gen/lime/math/Matrix3.js");}

// Constructor

var Matrix = function(a,b,c,d,tx,ty) {
	if(ty == null) {
		ty = 0;
	}
	if(tx == null) {
		tx = 0;
	}
	if(d == null) {
		d = 1;
	}
	if(c == null) {
		c = 0;
	}
	if(b == null) {
		b = 0;
	}
	if(a == null) {
		a = 1;
	}
	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;
	this.tx = tx;
	this.ty = ty;
}

// Meta

Matrix.__name__ = "openfl.geom.Matrix";
Matrix.__isInterface__ = false;
Matrix.prototype = {
	clone: function() {
		return new Matrix(this.a,this.b,this.c,this.d,this.tx,this.ty);
	},
	concat: function(m) {
		var a1 = this.a * m.a + this.b * m.c;
		this.b = this.a * m.b + this.b * m.d;
		this.a = a1;
		var c1 = this.c * m.a + this.d * m.c;
		this.d = this.c * m.b + this.d * m.d;
		this.c = c1;
		var tx1 = this.tx * m.a + this.ty * m.c + m.tx;
		this.ty = this.tx * m.b + this.ty * m.d + m.ty;
		this.tx = tx1;
	},
	copyColumnFrom: function(column,vector3D) {
		if(column > 2) {
			throw new (js__$Boot_HaxeError().default)("Column " + column + " out of bounds (2)");
		} else if(column == 0) {
			this.a = vector3D.x;
			this.b = vector3D.y;
		} else if(column == 1) {
			this.c = vector3D.x;
			this.d = vector3D.y;
		} else {
			this.tx = vector3D.x;
			this.ty = vector3D.y;
		}
	},
	copyColumnTo: function(column,vector3D) {
		if(column > 2) {
			throw new (js__$Boot_HaxeError().default)("Column " + column + " out of bounds (2)");
		} else if(column == 0) {
			vector3D.x = this.a;
			vector3D.y = this.b;
			vector3D.z = 0;
		} else if(column == 1) {
			vector3D.x = this.c;
			vector3D.y = this.d;
			vector3D.z = 0;
		} else {
			vector3D.x = this.tx;
			vector3D.y = this.ty;
			vector3D.z = 1;
		}
	},
	copyFrom: function(sourceMatrix) {
		this.a = sourceMatrix.a;
		this.b = sourceMatrix.b;
		this.c = sourceMatrix.c;
		this.d = sourceMatrix.d;
		this.tx = sourceMatrix.tx;
		this.ty = sourceMatrix.ty;
	},
	copyRowFrom: function(row,vector3D) {
		if(row > 2) {
			throw new (js__$Boot_HaxeError().default)("Row " + row + " out of bounds (2)");
		} else if(row == 0) {
			this.a = vector3D.x;
			this.c = vector3D.y;
			this.tx = vector3D.z;
		} else if(row == 1) {
			this.b = vector3D.x;
			this.d = vector3D.y;
			this.ty = vector3D.z;
		}
	},
	copyRowTo: function(row,vector3D) {
		if(row > 2) {
			throw new (js__$Boot_HaxeError().default)("Row " + row + " out of bounds (2)");
		} else if(row == 0) {
			vector3D.x = this.a;
			vector3D.y = this.c;
			vector3D.z = this.tx;
		} else if(row == 1) {
			vector3D.x = this.b;
			vector3D.y = this.d;
			vector3D.z = this.ty;
		} else {
			vector3D.setTo(0,0,1);
		}
	},
	createBox: function(scaleX,scaleY,rotation,tx,ty) {
		if(ty == null) {
			ty = 0;
		}
		if(tx == null) {
			tx = 0;
		}
		if(rotation == null) {
			rotation = 0;
		}
		if(rotation != 0) {
			var cos = Math.cos(rotation);
			var sin = Math.sin(rotation);
			this.a = cos * scaleX;
			this.b = sin * scaleY;
			this.c = -sin * scaleX;
			this.d = cos * scaleY;
		} else {
			this.a = scaleX;
			this.b = 0;
			this.c = 0;
			this.d = scaleY;
		}
		this.tx = tx;
		this.ty = ty;
	},
	createGradientBox: function(width,height,rotation,tx,ty) {
		if(ty == null) {
			ty = 0;
		}
		if(tx == null) {
			tx = 0;
		}
		if(rotation == null) {
			rotation = 0;
		}
		this.a = width / 1638.4;
		this.d = height / 1638.4;
		if(rotation != 0) {
			var cos = Math.cos(rotation);
			var sin = Math.sin(rotation);
			this.b = sin * this.d;
			this.c = -sin * this.a;
			this.a *= cos;
			this.d *= cos;
		} else {
			this.b = 0;
			this.c = 0;
		}
		this.tx = tx + width / 2;
		this.ty = ty + height / 2;
	},
	deltaTransformPoint: function(point) {
		return new (openfl_geom_Point().default)(point.x * this.a + point.y * this.c,point.x * this.b + point.y * this.d);
	},
	equals: function(matrix) {
		if(matrix != null && this.tx == matrix.tx && this.ty == matrix.ty && this.a == matrix.a && this.b == matrix.b && this.c == matrix.c) {
			return this.d == matrix.d;
		} else {
			return false;
		}
	},
	identity: function() {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.tx = 0;
		this.ty = 0;
	},
	invert: function() {
		var norm = this.a * this.d - this.b * this.c;
		if(norm == 0) {
			this.a = this.b = this.c = this.d = 0;
			this.tx = -this.tx;
			this.ty = -this.ty;
		} else {
			norm = 1.0 / norm;
			var a1 = this.d * norm;
			this.d = this.a * norm;
			this.a = a1;
			this.b *= -norm;
			this.c *= -norm;
			var tx1 = -this.a * this.tx - this.c * this.ty;
			this.ty = -this.b * this.tx - this.d * this.ty;
			this.tx = tx1;
		}
		return this;
	},
	rotate: function(theta) {
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);
		var a1 = this.a * cos - this.b * sin;
		this.b = this.a * sin + this.b * cos;
		this.a = a1;
		var c1 = this.c * cos - this.d * sin;
		this.d = this.c * sin + this.d * cos;
		this.c = c1;
		var tx1 = this.tx * cos - this.ty * sin;
		this.ty = this.tx * sin + this.ty * cos;
		this.tx = tx1;
	},
	scale: function(sx,sy) {
		this.a *= sx;
		this.b *= sy;
		this.c *= sx;
		this.d *= sy;
		this.tx *= sx;
		this.ty *= sy;
	},
	setRotation: function(theta,scale) {
		if(scale == null) {
			scale = 1;
		}
		this.a = Math.cos(theta) * scale;
		this.c = Math.sin(theta) * scale;
		this.b = -this.c;
		this.d = this.a;
	},
	setTo: function(a,b,c,d,tx,ty) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
		this.tx = tx;
		this.ty = ty;
	},
	to3DString: function(roundPixels) {
		if(roundPixels == null) {
			roundPixels = false;
		}
		if(roundPixels) {
			return "matrix3d(" + this.a + ", " + this.b + ", 0, 0, " + this.c + ", " + this.d + ", 0, 0, 0, 0, 1, 0, " + (Std().default).int(this.tx) + ", " + (Std().default).int(this.ty) + ", 0, 1)";
		} else {
			return "matrix3d(" + this.a + ", " + this.b + ", 0, 0, " + this.c + ", " + this.d + ", 0, 0, 0, 0, 1, 0, " + this.tx + ", " + this.ty + ", 0, 1)";
		}
	},
	toMozString: function() {
		return "matrix(" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.tx + "px, " + this.ty + "px)";
	},
	toString: function() {
		return "matrix(" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.tx + ", " + this.ty + ")";
	},
	transformPoint: function(pos) {
		return new (openfl_geom_Point().default)(this.__transformX(pos.x,pos.y),this.__transformY(pos.x,pos.y));
	},
	translate: function(dx,dy) {
		this.tx += dx;
		this.ty += dy;
	},
	toArray: function(transpose) {
		if(transpose == null) {
			transpose = false;
		}
		if(this.__array == null) {
			var array = null;
			var view = null;
			var buffer = null;
			var len = null;
			var this1 = new Float32Array(9);
			this.__array = this1;
		}
		if(transpose) {
			this.__array[0] = this.a;
			this.__array[1] = this.b;
			this.__array[2] = 0;
			this.__array[3] = this.c;
			this.__array[4] = this.d;
			this.__array[5] = 0;
			this.__array[6] = this.tx;
			this.__array[7] = this.ty;
			this.__array[8] = 1;
		} else {
			this.__array[0] = this.a;
			this.__array[1] = this.c;
			this.__array[2] = this.tx;
			this.__array[3] = this.b;
			this.__array[4] = this.d;
			this.__array[5] = this.ty;
			this.__array[6] = 0;
			this.__array[7] = 0;
			this.__array[8] = 1;
		}
		return this.__array;
	},
	__cleanValues: function() {
		this.a = Math.round(this.a * 1000) / 1000;
		this.b = Math.round(this.b * 1000) / 1000;
		this.c = Math.round(this.c * 1000) / 1000;
		this.d = Math.round(this.d * 1000) / 1000;
		this.tx = Math.round(this.tx * 10) / 10;
		this.ty = Math.round(this.ty * 10) / 10;
	},
	__toMatrix3: function() {
		Matrix.__matrix3.setTo(this.a,this.b,this.c,this.d,this.tx,this.ty);
		return Matrix.__matrix3;
	},
	__transformInversePoint: function(point) {
		var norm = this.a * this.d - this.b * this.c;
		if(norm == 0) {
			point.x = -this.tx;
			point.y = -this.ty;
		} else {
			var px = 1.0 / norm * (this.c * (this.ty - point.y) + this.d * (point.x - this.tx));
			point.y = 1.0 / norm * (this.a * (point.y - this.ty) + this.b * (this.tx - point.x));
			point.x = px;
		}
	},
	__transformInverseX: function(px,py) {
		var norm = this.a * this.d - this.b * this.c;
		if(norm == 0) {
			return -this.tx;
		} else {
			return 1.0 / norm * (this.c * (this.ty - py) + this.d * (px - this.tx));
		}
	},
	__transformInverseY: function(px,py) {
		var norm = this.a * this.d - this.b * this.c;
		if(norm == 0) {
			return -this.ty;
		} else {
			return 1.0 / norm * (this.a * (py - this.ty) + this.b * (this.tx - px));
		}
	},
	__transformPoint: function(point) {
		var px = point.x;
		var py = point.y;
		point.x = this.__transformX(px,py);
		point.y = this.__transformY(px,py);
	},
	__transformX: function(px,py) {
		return px * this.a + py * this.c + this.tx;
	},
	__transformY: function(px,py) {
		return px * this.b + py * this.d + this.ty;
	},
	__translateTransformed: function(px,py) {
		this.tx = this.__transformX(px,py);
		this.ty = this.__transformY(px,py);
	}
};
Matrix.prototype.__class__ = Matrix.prototype.constructor = $hxClasses["openfl.geom.Matrix"] = Matrix;

// Init



// Statics


Matrix.__meta__ = { fields : { equals : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, to3DString : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, toMozString : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}}
Matrix.__identity = new Matrix()
Matrix.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new Matrix();
},function(m) {
	m.identity();
})
Matrix.__matrix3 = new (lime_math_Matrix3().default)()

// Export

exports.default = Matrix;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix3D.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/geom/Matrix3D.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.geom.Matrix3D

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl_VectorData() {return __webpack_require__(/*! ./../../openfl/VectorData */ "./node_modules/openfl/lib/_gen/openfl/VectorData.js");}
function openfl_geom_Vector3D() {return __webpack_require__(/*! ./../../openfl/geom/Vector3D */ "./node_modules/openfl/lib/_gen/openfl/geom/Vector3D.js");}

// Constructor

var Matrix3D = function(v) {
	if(v != null && v.get_length() == 16) {
		this.rawData = (openfl_VectorData().default).ofArray(Array.prototype.concat.call(v,null));
	} else {
		this.rawData = (openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0]);
	}
}

// Meta

Matrix3D.__name__ = "openfl.geom.Matrix3D";
Matrix3D.__isInterface__ = false;
Matrix3D.prototype = {
	append: function(lhs) {
		var m111 = this.rawData[0];
		var m121 = this.rawData[4];
		var m131 = this.rawData[8];
		var m141 = this.rawData[12];
		var m112 = this.rawData[1];
		var m122 = this.rawData[5];
		var m132 = this.rawData[9];
		var m142 = this.rawData[13];
		var m113 = this.rawData[2];
		var m123 = this.rawData[6];
		var m133 = this.rawData[10];
		var m143 = this.rawData[14];
		var m114 = this.rawData[3];
		var m124 = this.rawData[7];
		var m134 = this.rawData[11];
		var m144 = this.rawData[15];
		var m211 = lhs.rawData[0];
		var m221 = lhs.rawData[4];
		var m231 = lhs.rawData[8];
		var m241 = lhs.rawData[12];
		var m212 = lhs.rawData[1];
		var m222 = lhs.rawData[5];
		var m232 = lhs.rawData[9];
		var m242 = lhs.rawData[13];
		var m213 = lhs.rawData[2];
		var m223 = lhs.rawData[6];
		var m233 = lhs.rawData[10];
		var m243 = lhs.rawData[14];
		var m214 = lhs.rawData[3];
		var m224 = lhs.rawData[7];
		var m234 = lhs.rawData[11];
		var m244 = lhs.rawData[15];
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,15,m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244);
	},
	appendRotation: function(degrees,axis,pivotPoint) {
		var tz = 0;
		var ty = tz;
		var tx = ty;
		if(pivotPoint != null) {
			tx = pivotPoint.x;
			ty = pivotPoint.y;
			tz = pivotPoint.z;
		}
		var radian = degrees * Math.PI / 180;
		var cos = Math.cos(radian);
		var sin = Math.sin(radian);
		var x = axis.x;
		var y = axis.y;
		var z = axis.z;
		var x2 = x * x;
		var y2 = y * y;
		var z2 = z * z;
		var ls = x2 + y2 + z2;
		if(ls != 0) {
			var l = Math.sqrt(ls);
			x /= l;
			y /= l;
			z /= l;
			x2 /= ls;
			y2 /= ls;
			z2 /= ls;
		}
		var ccos = 1 - cos;
		var m = new Matrix3D();
		var d = m.rawData;
		(openfl__$Vector_Vector_$Impl_$().default).set(d,0,x2 + (y2 + z2) * cos);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,1,x * y * ccos + z * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,2,x * z * ccos - y * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,4,x * y * ccos - z * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,5,y2 + (x2 + z2) * cos);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,6,y * z * ccos + x * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,8,x * z * ccos + y * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,9,y * z * ccos - x * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,10,z2 + (x2 + y2) * cos);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,12,(tx * (y2 + z2) - x * (ty * y + tz * z)) * ccos + (ty * z - tz * y) * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,13,(ty * (x2 + z2) - y * (tx * x + tz * z)) * ccos + (tz * x - tx * z) * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,14,(tz * (x2 + y2) - z * (tx * x + ty * y)) * ccos + (tx * y - ty * x) * sin);
		this.append(m);
	},
	appendScale: function(xScale,yScale,zScale) {
		this.append(new Matrix3D((openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[xScale,0.0,0.0,0.0,0.0,yScale,0.0,0.0,0.0,0.0,zScale,0.0,0.0,0.0,0.0,1.0])));
	},
	appendTranslation: function(x,y,z) {
		var _g = this.rawData;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g,12,_g[12] + x);
		var _g1 = this.rawData;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g1,13,_g1[13] + y);
		var _g2 = this.rawData;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g2,14,_g2[14] + z);
	},
	clone: function() {
		return new Matrix3D((openfl_VectorData().default).ofArray(this.rawData));
	},
	copyColumnFrom: function(column,vector3D) {
		switch(column) {
		case 0:
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,vector3D.x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,vector3D.y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,vector3D.z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,vector3D.w);
			break;
		case 1:
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,vector3D.x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,vector3D.y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,vector3D.z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,vector3D.w);
			break;
		case 2:
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,vector3D.x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,vector3D.y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,vector3D.z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,vector3D.w);
			break;
		case 3:
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,vector3D.x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,vector3D.y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,vector3D.z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,15,vector3D.w);
			break;
		default:
		}
	},
	copyColumnTo: function(column,vector3D) {
		switch(column) {
		case 0:
			vector3D.x = this.rawData[0];
			vector3D.y = this.rawData[1];
			vector3D.z = this.rawData[2];
			vector3D.w = this.rawData[3];
			break;
		case 1:
			vector3D.x = this.rawData[4];
			vector3D.y = this.rawData[5];
			vector3D.z = this.rawData[6];
			vector3D.w = this.rawData[7];
			break;
		case 2:
			vector3D.x = this.rawData[8];
			vector3D.y = this.rawData[9];
			vector3D.z = this.rawData[10];
			vector3D.w = this.rawData[11];
			break;
		case 3:
			vector3D.x = this.rawData[12];
			vector3D.y = this.rawData[13];
			vector3D.z = this.rawData[14];
			vector3D.w = this.rawData[15];
			break;
		default:
		}
	},
	copyFrom: function(other) {
		this.rawData = (openfl_VectorData().default).ofArray(other.rawData);
	},
	copyRawDataFrom: function(vector,index,transpose) {
		if(transpose == null) {
			transpose = false;
		}
		if(index == null) {
			index = 0;
		}
		if(transpose) {
			this.transpose();
		}
		var length = vector.get_length() - index;
		var _g = 0;
		var _g1 = length;
		while(_g < _g1) {
			var i = _g++;
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,i,vector[i + index]);
		}
		if(transpose) {
			this.transpose();
		}
	},
	copyRawDataTo: function(vector,index,transpose) {
		if(transpose == null) {
			transpose = false;
		}
		if(index == null) {
			index = 0;
		}
		if(transpose) {
			this.transpose();
		}
		var _g = 0;
		var _g1 = this.rawData.get_length();
		while(_g < _g1) {
			var i = _g++;
			(openfl__$Vector_Vector_$Impl_$().default).set(vector,i + index,this.rawData[i]);
		}
		if(transpose) {
			this.transpose();
		}
	},
	copyRowFrom: function(row,vector3D) {
		switch(row) {
		case 0:
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,vector3D.x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,vector3D.y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,vector3D.z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,vector3D.w);
			break;
		case 1:
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,vector3D.x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,vector3D.y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,vector3D.z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,vector3D.w);
			break;
		case 2:
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,vector3D.x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,vector3D.y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,vector3D.z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,vector3D.w);
			break;
		case 3:
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,vector3D.x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,vector3D.y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,vector3D.z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,15,vector3D.w);
			break;
		default:
		}
	},
	copyRowTo: function(row,vector3D) {
		switch(row) {
		case 0:
			vector3D.x = this.rawData[0];
			vector3D.y = this.rawData[4];
			vector3D.z = this.rawData[8];
			vector3D.w = this.rawData[12];
			break;
		case 1:
			vector3D.x = this.rawData[1];
			vector3D.y = this.rawData[5];
			vector3D.z = this.rawData[9];
			vector3D.w = this.rawData[13];
			break;
		case 2:
			vector3D.x = this.rawData[2];
			vector3D.y = this.rawData[6];
			vector3D.z = this.rawData[10];
			vector3D.w = this.rawData[14];
			break;
		case 3:
			vector3D.x = this.rawData[3];
			vector3D.y = this.rawData[7];
			vector3D.z = this.rawData[11];
			vector3D.w = this.rawData[15];
			break;
		default:
		}
	},
	copyToMatrix3D: function(other) {
		other.rawData = (openfl_VectorData().default).ofArray(this.rawData);
	},
	decompose: function(orientationStyle) {
		if(orientationStyle == null) {
			orientationStyle = "eulerAngles";
		}
		var vec = (openfl__$Vector_Vector_$Impl_$().default)._new();
		var m = this.clone();
		var mr = (openfl_VectorData().default).ofArray(m.rawData);
		var pos = new (openfl_geom_Vector3D().default)(mr[12],mr[13],mr[14]);
		(openfl__$Vector_Vector_$Impl_$().default).set(mr,12,0);
		(openfl__$Vector_Vector_$Impl_$().default).set(mr,13,0);
		(openfl__$Vector_Vector_$Impl_$().default).set(mr,14,0);
		var scale = new (openfl_geom_Vector3D().default)();
		scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
		scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
		scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);
		if(mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0) {
			scale.z = -scale.z;
		}
		var _g = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g,0,_g[0] / scale.x);
		var _g1 = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g1,1,_g1[1] / scale.x);
		var _g2 = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g2,2,_g2[2] / scale.x);
		var _g3 = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g3,4,_g3[4] / scale.y);
		var _g4 = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g4,5,_g4[5] / scale.y);
		var _g5 = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g5,6,_g5[6] / scale.y);
		var _g6 = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g6,8,_g6[8] / scale.z);
		var _g7 = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g7,9,_g7[9] / scale.z);
		var _g8 = mr;
		(openfl__$Vector_Vector_$Impl_$().default).set(_g8,10,_g8[10] / scale.z);
		var rot = new (openfl_geom_Vector3D().default)();
		switch(orientationStyle) {
		case "axisAngle":
			rot.w = Math.acos((mr[0] + mr[5] + mr[10] - 1) / 2);
			var len = Math.sqrt((mr[6] - mr[9]) * (mr[6] - mr[9]) + (mr[8] - mr[2]) * (mr[8] - mr[2]) + (mr[1] - mr[4]) * (mr[1] - mr[4]));
			if(len != 0) {
				rot.x = (mr[6] - mr[9]) / len;
				rot.y = (mr[8] - mr[2]) / len;
				rot.z = (mr[1] - mr[4]) / len;
			} else {
				rot.x = rot.y = rot.z = 0;
			}
			break;
		case "eulerAngles":
			rot.y = Math.asin(-mr[2]);
			if(mr[2] != 1 && mr[2] != -1) {
				rot.x = Math.atan2(mr[6],mr[10]);
				rot.z = Math.atan2(mr[1],mr[0]);
			} else {
				rot.z = 0;
				rot.x = Math.atan2(mr[4],mr[5]);
			}
			break;
		case "quaternion":
			var tr = mr[0] + mr[5] + mr[10];
			if(tr > 0) {
				rot.w = Math.sqrt(1 + tr) / 2;
				rot.x = (mr[6] - mr[9]) / (4 * rot.w);
				rot.y = (mr[8] - mr[2]) / (4 * rot.w);
				rot.z = (mr[1] - mr[4]) / (4 * rot.w);
			} else if(mr[0] > mr[5] && mr[0] > mr[10]) {
				rot.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
				rot.w = (mr[6] - mr[9]) / (4 * rot.x);
				rot.y = (mr[1] + mr[4]) / (4 * rot.x);
				rot.z = (mr[8] + mr[2]) / (4 * rot.x);
			} else if(mr[5] > mr[10]) {
				rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
				rot.x = (mr[1] + mr[4]) / (4 * rot.y);
				rot.w = (mr[8] - mr[2]) / (4 * rot.y);
				rot.z = (mr[6] + mr[9]) / (4 * rot.y);
			} else {
				rot.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
				rot.x = (mr[8] + mr[2]) / (4 * rot.z);
				rot.y = (mr[6] + mr[9]) / (4 * rot.z);
				rot.w = (mr[1] - mr[4]) / (4 * rot.z);
			}
			break;
		}
		(openfl__$Vector_Vector_$Impl_$().default).push(vec,pos);
		(openfl__$Vector_Vector_$Impl_$().default).push(vec,rot);
		(openfl__$Vector_Vector_$Impl_$().default).push(vec,scale);
		return vec;
	},
	deltaTransformVector: function(v) {
		var x = v.x;
		var y = v.y;
		var z = v.z;
		return new (openfl_geom_Vector3D().default)(x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8],x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9],x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10],x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11]);
	},
	identity: function() {
		this.rawData = (openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0]);
	},
	interpolateTo: function(toMat,percent) {
		var _g = 0;
		while(_g < 16) {
			var i = _g++;
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,i,this.rawData[i] + (toMat.rawData[i] - this.rawData[i]) * percent);
		}
	},
	invert: function() {
		var d = this.get_determinant();
		var invertable = Math.abs(d) > 0.00000000001;
		if(invertable) {
			d = 1 / d;
			var m11 = this.rawData[0];
			var m21 = this.rawData[4];
			var m31 = this.rawData[8];
			var m41 = this.rawData[12];
			var m12 = this.rawData[1];
			var m22 = this.rawData[5];
			var m32 = this.rawData[9];
			var m42 = this.rawData[13];
			var m13 = this.rawData[2];
			var m23 = this.rawData[6];
			var m33 = this.rawData[10];
			var m43 = this.rawData[14];
			var m14 = this.rawData[3];
			var m24 = this.rawData[7];
			var m34 = this.rawData[11];
			var m44 = this.rawData[15];
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,-d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,-d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,-d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,-d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,-d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,-d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,-d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,-d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13)));
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,15,d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13)));
		}
		return invertable;
	},
	pointAt: function(pos,at,up) {
		if(at == null) {
			at = new (openfl_geom_Vector3D().default)(0,0,-1);
		}
		if(up == null) {
			up = new (openfl_geom_Vector3D().default)(0,-1,0);
		}
		var dir = at.subtract(pos);
		var vup = up.clone();
		dir.normalize();
		vup.normalize();
		var dir2 = dir.clone();
		dir2.scaleBy(vup.dotProduct(dir));
		vup = vup.subtract(dir2);
		if(vup.get_length() > 0) {
			vup.normalize();
		} else if(dir.x != 0) {
			vup = new (openfl_geom_Vector3D().default)(-dir.y,dir.x,0);
		} else {
			vup = new (openfl_geom_Vector3D().default)(1,0,0);
		}
		var right = vup.crossProduct(dir);
		right.normalize();
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,right.x);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,right.y);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,right.z);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,0.0);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,vup.x);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,vup.y);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,vup.z);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,0.0);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,dir.x);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,dir.y);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,dir.z);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,0.0);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,pos.x);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,pos.y);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,pos.z);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,15,1.0);
	},
	prepend: function(rhs) {
		var m111 = rhs.rawData[0];
		var m121 = rhs.rawData[4];
		var m131 = rhs.rawData[8];
		var m141 = rhs.rawData[12];
		var m112 = rhs.rawData[1];
		var m122 = rhs.rawData[5];
		var m132 = rhs.rawData[9];
		var m142 = rhs.rawData[13];
		var m113 = rhs.rawData[2];
		var m123 = rhs.rawData[6];
		var m133 = rhs.rawData[10];
		var m143 = rhs.rawData[14];
		var m114 = rhs.rawData[3];
		var m124 = rhs.rawData[7];
		var m134 = rhs.rawData[11];
		var m144 = rhs.rawData[15];
		var m211 = this.rawData[0];
		var m221 = this.rawData[4];
		var m231 = this.rawData[8];
		var m241 = this.rawData[12];
		var m212 = this.rawData[1];
		var m222 = this.rawData[5];
		var m232 = this.rawData[9];
		var m242 = this.rawData[13];
		var m213 = this.rawData[2];
		var m223 = this.rawData[6];
		var m233 = this.rawData[10];
		var m243 = this.rawData[14];
		var m214 = this.rawData[3];
		var m224 = this.rawData[7];
		var m234 = this.rawData[11];
		var m244 = this.rawData[15];
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,15,m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244);
	},
	prependRotation: function(degrees,axis,pivotPoint) {
		var tz = 0;
		var ty = tz;
		var tx = ty;
		if(pivotPoint != null) {
			tx = pivotPoint.x;
			ty = pivotPoint.y;
			tz = pivotPoint.z;
		}
		var radian = degrees * Math.PI / 180;
		var cos = Math.cos(radian);
		var sin = Math.sin(radian);
		var x = axis.x;
		var y = axis.y;
		var z = axis.z;
		var x2 = x * x;
		var y2 = y * y;
		var z2 = z * z;
		var ls = x2 + y2 + z2;
		if(ls != 0) {
			var l = Math.sqrt(ls);
			x /= l;
			y /= l;
			z /= l;
			x2 /= ls;
			y2 /= ls;
			z2 /= ls;
		}
		var ccos = 1 - cos;
		var m = new Matrix3D();
		var d = m.rawData;
		(openfl__$Vector_Vector_$Impl_$().default).set(d,0,x2 + (y2 + z2) * cos);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,1,x * y * ccos + z * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,2,x * z * ccos - y * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,4,x * y * ccos - z * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,5,y2 + (x2 + z2) * cos);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,6,y * z * ccos + x * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,8,x * z * ccos + y * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,9,y * z * ccos - x * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,10,z2 + (x2 + y2) * cos);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,12,(tx * (y2 + z2) - x * (ty * y + tz * z)) * ccos + (ty * z - tz * y) * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,13,(ty * (x2 + z2) - y * (tx * x + tz * z)) * ccos + (tz * x - tx * z) * sin);
		(openfl__$Vector_Vector_$Impl_$().default).set(d,14,(tz * (x2 + y2) - z * (tx * x + ty * y)) * ccos + (tx * y - ty * x) * sin);
		this.prepend(m);
	},
	prependScale: function(xScale,yScale,zScale) {
		this.prepend(new Matrix3D((openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[xScale,0.0,0.0,0.0,0.0,yScale,0.0,0.0,0.0,0.0,zScale,0.0,0.0,0.0,0.0,1.0])));
	},
	prependTranslation: function(x,y,z) {
		var m = new Matrix3D();
		m.set_position(new (openfl_geom_Vector3D().default)(x,y,z));
		this.prepend(m);
	},
	recompose: function(components,orientationStyle) {
		if(orientationStyle == null) {
			orientationStyle = "eulerAngles";
		}
		if(components.get_length() < 3 || components[2].x == 0 || components[2].y == 0 || components[2].z == 0) {
			return false;
		}
		this.identity();
		var scale = [];
		scale[0] = scale[1] = scale[2] = components[2].x;
		scale[4] = scale[5] = scale[6] = components[2].y;
		scale[8] = scale[9] = scale[10] = components[2].z;
		if(orientationStyle == "eulerAngles") {
			var cx = Math.cos(components[1].x);
			var cy = Math.cos(components[1].y);
			var cz = Math.cos(components[1].z);
			var sx = Math.sin(components[1].x);
			var sy = Math.sin(components[1].y);
			var sz = Math.sin(components[1].z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,cy * cz * scale[0]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,cy * sz * scale[1]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,-sy * scale[2]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,0);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,(sx * sy * cz - cx * sz) * scale[4]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,(sx * sy * sz + cx * cz) * scale[5]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,sx * cy * scale[6]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,0);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,(cx * sy * cz + sx * sz) * scale[8]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,(cx * sy * sz - sx * cz) * scale[9]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,cx * cy * scale[10]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,0);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,components[0].x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,components[0].y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,components[0].z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,15,1);
		} else {
			var x = components[1].x;
			var y = components[1].y;
			var z = components[1].z;
			var w = components[1].w;
			if(orientationStyle == "axisAngle") {
				x *= Math.sin(w / 2);
				y *= Math.sin(w / 2);
				z *= Math.sin(w / 2);
				w = Math.cos(w / 2);
			}
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,(1 - 2 * y * y - 2 * z * z) * scale[0]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,(2 * x * y + 2 * w * z) * scale[1]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,(2 * x * z - 2 * w * y) * scale[2]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,0);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,(2 * x * y - 2 * w * z) * scale[4]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,(1 - 2 * x * x - 2 * z * z) * scale[5]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,(2 * y * z + 2 * w * x) * scale[6]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,0);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,(2 * x * z + 2 * w * y) * scale[8]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,(2 * y * z - 2 * w * x) * scale[9]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,(1 - 2 * x * x - 2 * y * y) * scale[10]);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,0);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,components[0].x);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,components[0].y);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,components[0].z);
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,15,1);
		}
		if(components[2].x == 0) {
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,0,1e-15);
		}
		if(components[2].y == 0) {
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,5,1e-15);
		}
		if(components[2].z == 0) {
			(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,10,1e-15);
		}
		return !(components[2].x == 0 || components[2].y == 0 || components[2].y == 0);
	},
	transformVector: function(v) {
		var x = v.x;
		var y = v.y;
		var z = v.z;
		return new (openfl_geom_Vector3D().default)(x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12],x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13],x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14],x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15]);
	},
	transformVectors: function(vin,vout) {
		var i = 0;
		var x;
		var y;
		var z;
		while(i + 3 <= vin.get_length()) {
			x = vin[i];
			y = vin[i + 1];
			z = vin[i + 2];
			(openfl__$Vector_Vector_$Impl_$().default).set(vout,i,x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12]);
			(openfl__$Vector_Vector_$Impl_$().default).set(vout,i + 1,x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13]);
			(openfl__$Vector_Vector_$Impl_$().default).set(vout,i + 2,x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14]);
			i += 3;
		}
	},
	transpose: function() {
		var oRawData = (openfl_VectorData().default).ofArray(this.rawData);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,1,oRawData[4]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,2,oRawData[8]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,3,oRawData[12]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,4,oRawData[1]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,6,oRawData[9]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,7,oRawData[13]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,8,oRawData[2]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,9,oRawData[6]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,11,oRawData[14]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,oRawData[3]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,oRawData[7]);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,oRawData[11]);
	},
	get_determinant: function() {
		return (this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]);
	},
	get_position: function() {
		return new (openfl_geom_Vector3D().default)(this.rawData[12],this.rawData[13],this.rawData[14]);
	},
	set_position: function(val) {
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,12,val.x);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,13,val.y);
		(openfl__$Vector_Vector_$Impl_$().default).set(this.rawData,14,val.z);
		return val;
	}
};
Matrix3D.prototype.__class__ = Matrix3D.prototype.constructor = $hxClasses["openfl.geom.Matrix3D"] = Matrix3D;

// Init

Object.defineProperties(Matrix3D.prototype,{ determinant : { get : function () { return this.get_determinant (); }, set : function (v) { return this.set_determinant (v); }}, position : { get : function () { return this.get_position (); }, set : function (v) { return this.set_position (v); }}});

// Statics

Matrix3D.create2D = function(x,y,scale,rotation) {
	if(rotation == null) {
		rotation = 0;
	}
	if(scale == null) {
		scale = 1;
	}
	var theta = rotation * Math.PI / 180.0;
	var c = Math.cos(theta);
	var s = Math.sin(theta);
	return new Matrix3D((openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[c * scale,-s * scale,0,0,s * scale,c * scale,0,0,0,0,1,0,x,y,0,1]));
}
Matrix3D.createABCD = function(a,b,c,d,tx,ty) {
	return new Matrix3D((openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[a,b,0,0,c,d,0,0,0,0,1,0,tx,ty,0,1]));
}
Matrix3D.createOrtho = function(x0,x1,y0,y1,zNear,zFar) {
	var sx = 1.0 / (x1 - x0);
	var sy = 1.0 / (y1 - y0);
	var sz = 1.0 / (zFar - zNear);
	return new Matrix3D((openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[2.0 * sx,0,0,0,0,2.0 * sy,0,0,0,0,-2.0 * sz,0,-(x0 + x1) * sx,-(y0 + y1) * sy,-(zNear + zFar) * sz,1]));
}
Matrix3D.interpolate = function(thisMat,toMat,percent) {
	var m = new Matrix3D();
	var _g = 0;
	while(_g < 16) {
		var i = _g++;
		(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,i,thisMat.rawData[i] + (toMat.rawData[i] - thisMat.rawData[i]) * percent);
	}
	return m;
}
Matrix3D.__getAxisRotation = function(x,y,z,degrees) {
	var m = new Matrix3D();
	var a1 = new (openfl_geom_Vector3D().default)(x,y,z);
	var rad = -degrees * (Math.PI / 180);
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var t = 1.0 - c;
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,0,c + a1.x * a1.x * t);
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,5,c + a1.y * a1.y * t);
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,10,c + a1.z * a1.z * t);
	var tmp1 = a1.x * a1.y * t;
	var tmp2 = a1.z * s;
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,4,tmp1 + tmp2);
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,1,tmp1 - tmp2);
	tmp1 = a1.x * a1.z * t;
	tmp2 = a1.y * s;
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,8,tmp1 - tmp2);
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,2,tmp1 + tmp2);
	tmp1 = a1.y * a1.z * t;
	tmp2 = a1.x * s;
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,9,tmp1 + tmp2);
	(openfl__$Vector_Vector_$Impl_$().default).set(m.rawData,6,tmp1 - tmp2);
	return m;
}
Matrix3D.__meta__ = { statics : { create2D : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, createABCD : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, createOrtho : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}}

// Export

exports.default = Matrix3D;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/geom/Point.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.geom.Point

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_math_Vector2() {return __webpack_require__(/*! ./../../lime/math/Vector2 */ "./node_modules/openfl/lib/_gen/lime/math/Vector2.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var Point = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
}

// Meta

Point.__name__ = "openfl.geom.Point";
Point.__isInterface__ = false;
Point.prototype = {
	add: function(v) {
		return new Point(v.x + this.x,v.y + this.y);
	},
	clone: function() {
		return new Point(this.x,this.y);
	},
	copyFrom: function(sourcePoint) {
		this.x = sourcePoint.x;
		this.y = sourcePoint.y;
	},
	equals: function(toCompare) {
		if(toCompare != null && toCompare.x == this.x) {
			return toCompare.y == this.y;
		} else {
			return false;
		}
	},
	normalize: function(thickness) {
		if(this.x == 0 && this.y == 0) {
			return;
		} else {
			var norm = thickness / Math.sqrt(this.x * this.x + this.y * this.y);
			this.x *= norm;
			this.y *= norm;
		}
	},
	offset: function(dx,dy) {
		this.x += dx;
		this.y += dy;
	},
	setTo: function(xa,ya) {
		this.x = xa;
		this.y = ya;
	},
	subtract: function(v) {
		return new Point(this.x - v.x,this.y - v.y);
	},
	toString: function() {
		return "(x=" + this.x + ", y=" + this.y + ")";
	},
	__toLimeVector2: function() {
		if(Point.__limeVector2 == null) {
			Point.__limeVector2 = new (lime_math_Vector2().default)();
		}
		Point.__limeVector2.setTo(this.x,this.y);
		return Point.__limeVector2;
	},
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
};
Point.prototype.__class__ = Point.prototype.constructor = $hxClasses["openfl.geom.Point"] = Point;

// Init

Object.defineProperty(Point.prototype,"length",{ get : function () { return this.get_length (); }});

// Statics

Point.distance = function(pt1,pt2) {
	var dx = pt1.x - pt2.x;
	var dy = pt1.y - pt2.y;
	return Math.sqrt(dx * dx + dy * dy);
}
Point.interpolate = function(pt1,pt2,f) {
	return new Point(pt2.x + f * (pt1.x - pt2.x),pt2.y + f * (pt1.y - pt2.y));
}
Point.polar = function(len,angle) {
	return new Point(len * Math.cos(angle),len * Math.sin(angle));
}
Point.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new Point();
},function(p) {
	p.setTo(0,0);
})

// Export

exports.default = Point;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.geom.Rectangle

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_math_Rectangle() {return __webpack_require__(/*! ./../../lime/math/Rectangle */ "./node_modules/openfl/lib/_gen/lime/math/Rectangle.js");}
function openfl_geom_Point() {return __webpack_require__(/*! ./../../openfl/geom/Point */ "./node_modules/openfl/lib/_gen/openfl/geom/Point.js");}
function lime_utils_ObjectPool() {return __webpack_require__(/*! ./../../lime/utils/ObjectPool */ "./node_modules/openfl/lib/_gen/lime/utils/ObjectPool.js");}

// Constructor

var Rectangle = function(x,y,width,height) {
	if(height == null) {
		height = 0;
	}
	if(width == null) {
		width = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
}

// Meta

Rectangle.__name__ = "openfl.geom.Rectangle";
Rectangle.__isInterface__ = false;
Rectangle.prototype = {
	clone: function() {
		return new Rectangle(this.x,this.y,this.width,this.height);
	},
	contains: function(x,y) {
		if(x >= this.x && y >= this.y && x < this.get_right()) {
			return y < this.get_bottom();
		} else {
			return false;
		}
	},
	containsPoint: function(point) {
		return this.contains(point.x,point.y);
	},
	containsRect: function(rect) {
		if(rect.width <= 0 || rect.height <= 0) {
			if(rect.x > this.x && rect.y > this.y && rect.get_right() < this.get_right()) {
				return rect.get_bottom() < this.get_bottom();
			} else {
				return false;
			}
		} else if(rect.x >= this.x && rect.y >= this.y && rect.get_right() <= this.get_right()) {
			return rect.get_bottom() <= this.get_bottom();
		} else {
			return false;
		}
	},
	copyFrom: function(sourceRect) {
		this.x = sourceRect.x;
		this.y = sourceRect.y;
		this.width = sourceRect.width;
		this.height = sourceRect.height;
	},
	equals: function(toCompare) {
		if(toCompare == this) {
			return true;
		} else if(toCompare != null && this.x == toCompare.x && this.y == toCompare.y && this.width == toCompare.width) {
			return this.height == toCompare.height;
		} else {
			return false;
		}
	},
	inflate: function(dx,dy) {
		this.x -= dx;
		this.width += dx * 2;
		this.y -= dy;
		this.height += dy * 2;
	},
	inflatePoint: function(point) {
		this.inflate(point.x,point.y);
	},
	intersection: function(toIntersect) {
		var x0 = this.x < toIntersect.x ? toIntersect.x : this.x;
		var x1 = this.get_right() > toIntersect.get_right() ? toIntersect.get_right() : this.get_right();
		if(x1 <= x0) {
			return new Rectangle();
		}
		var y0 = this.y < toIntersect.y ? toIntersect.y : this.y;
		var y1 = this.get_bottom() > toIntersect.get_bottom() ? toIntersect.get_bottom() : this.get_bottom();
		if(y1 <= y0) {
			return new Rectangle();
		}
		return new Rectangle(x0,y0,x1 - x0,y1 - y0);
	},
	intersects: function(toIntersect) {
		var x0 = this.x < toIntersect.x ? toIntersect.x : this.x;
		var x1 = this.get_right() > toIntersect.get_right() ? toIntersect.get_right() : this.get_right();
		if(x1 <= x0) {
			return false;
		}
		var y0 = this.y < toIntersect.y ? toIntersect.y : this.y;
		var y1 = this.get_bottom() > toIntersect.get_bottom() ? toIntersect.get_bottom() : this.get_bottom();
		return y1 > y0;
	},
	isEmpty: function() {
		if(!(this.width <= 0)) {
			return this.height <= 0;
		} else {
			return true;
		}
	},
	offset: function(dx,dy) {
		this.x += dx;
		this.y += dy;
	},
	offsetPoint: function(point) {
		this.x += point.x;
		this.y += point.y;
	},
	setEmpty: function() {
		this.x = this.y = this.width = this.height = 0;
	},
	setTo: function(xa,ya,widtha,heighta) {
		this.x = xa;
		this.y = ya;
		this.width = widtha;
		this.height = heighta;
	},
	toString: function() {
		return "(x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
	},
	union: function(toUnion) {
		if(this.width == 0 || this.height == 0) {
			return toUnion.clone();
		} else if(toUnion.width == 0 || toUnion.height == 0) {
			return this.clone();
		}
		var x0 = this.x > toUnion.x ? toUnion.x : this.x;
		var x1 = this.get_right() < toUnion.get_right() ? toUnion.get_right() : this.get_right();
		var y0 = this.y > toUnion.y ? toUnion.y : this.y;
		var y1 = this.get_bottom() < toUnion.get_bottom() ? toUnion.get_bottom() : this.get_bottom();
		return new Rectangle(x0,y0,x1 - x0,y1 - y0);
	},
	__contract: function(x,y,width,height) {
		if(this.width == 0 && this.height == 0) {
			return;
		}
		var offsetX = 0.0;
		var offsetY = 0.0;
		var offsetRight = 0.0;
		var offsetBottom = 0.0;
		if(this.x < x) {
			offsetX = x - this.x;
		}
		if(this.y < y) {
			offsetY = y - this.y;
		}
		if(this.get_right() > x + width) {
			offsetRight = x + width - this.get_right();
		}
		if(this.get_bottom() > y + height) {
			offsetBottom = y + height - this.get_bottom();
		}
		this.x += offsetX;
		this.y += offsetY;
		this.width += offsetRight - offsetX;
		this.height += offsetBottom - offsetY;
	},
	__expand: function(x,y,width,height) {
		if(this.width == 0 && this.height == 0) {
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			return;
		}
		var cacheRight = this.get_right();
		var cacheBottom = this.get_bottom();
		if(this.x > x) {
			this.x = x;
			this.width = cacheRight - x;
		}
		if(this.y > y) {
			this.y = y;
			this.height = cacheBottom - y;
		}
		if(cacheRight < x + width) {
			this.width = x + width - this.x;
		}
		if(cacheBottom < y + height) {
			this.height = y + height - this.y;
		}
	},
	__toLimeRectangle: function() {
		if(Rectangle.__limeRectangle == null) {
			Rectangle.__limeRectangle = new (lime_math_Rectangle().default)();
		}
		Rectangle.__limeRectangle.setTo(this.x,this.y,this.width,this.height);
		return Rectangle.__limeRectangle;
	},
	__transform: function(rect,m) {
		var tx0 = m.a * this.x + m.c * this.y;
		var tx1 = tx0;
		var ty0 = m.b * this.x + m.d * this.y;
		var ty1 = ty0;
		var tx = m.a * (this.x + this.width) + m.c * this.y;
		var ty = m.b * (this.x + this.width) + m.d * this.y;
		if(tx < tx0) {
			tx0 = tx;
		}
		if(ty < ty0) {
			ty0 = ty;
		}
		if(tx > tx1) {
			tx1 = tx;
		}
		if(ty > ty1) {
			ty1 = ty;
		}
		tx = m.a * (this.x + this.width) + m.c * (this.y + this.height);
		ty = m.b * (this.x + this.width) + m.d * (this.y + this.height);
		if(tx < tx0) {
			tx0 = tx;
		}
		if(ty < ty0) {
			ty0 = ty;
		}
		if(tx > tx1) {
			tx1 = tx;
		}
		if(ty > ty1) {
			ty1 = ty;
		}
		tx = m.a * this.x + m.c * (this.y + this.height);
		ty = m.b * this.x + m.d * (this.y + this.height);
		if(tx < tx0) {
			tx0 = tx;
		}
		if(ty < ty0) {
			ty0 = ty;
		}
		if(tx > tx1) {
			tx1 = tx;
		}
		if(ty > ty1) {
			ty1 = ty;
		}
		rect.setTo(tx0 + m.tx,ty0 + m.ty,tx1 - tx0,ty1 - ty0);
	},
	get_bottom: function() {
		return this.y + this.height;
	},
	set_bottom: function(b) {
		this.height = b - this.y;
		return b;
	},
	get_bottomRight: function() {
		return new (openfl_geom_Point().default)(this.x + this.width,this.y + this.height);
	},
	set_bottomRight: function(p) {
		this.width = p.x - this.x;
		this.height = p.y - this.y;
		return p.clone();
	},
	get_left: function() {
		return this.x;
	},
	set_left: function(l) {
		this.width -= l - this.x;
		this.x = l;
		return l;
	},
	get_right: function() {
		return this.x + this.width;
	},
	set_right: function(r) {
		this.width = r - this.x;
		return r;
	},
	get_size: function() {
		return new (openfl_geom_Point().default)(this.width,this.height);
	},
	set_size: function(p) {
		this.width = p.x;
		this.height = p.y;
		return p.clone();
	},
	get_top: function() {
		return this.y;
	},
	set_top: function(t) {
		this.height -= t - this.y;
		this.y = t;
		return t;
	},
	get_topLeft: function() {
		return new (openfl_geom_Point().default)(this.x,this.y);
	},
	set_topLeft: function(p) {
		this.x = p.x;
		this.y = p.y;
		return p.clone();
	}
};
Rectangle.prototype.__class__ = Rectangle.prototype.constructor = $hxClasses["openfl.geom.Rectangle"] = Rectangle;

// Init

Object.defineProperties(Rectangle.prototype,{ bottom : { get : function () { return this.get_bottom (); }, set : function (v) { return this.set_bottom (v); }}, bottomRight : { get : function () { return this.get_bottomRight (); }, set : function (v) { return this.set_bottomRight (v); }}, left : { get : function () { return this.get_left (); }, set : function (v) { return this.set_left (v); }}, right : { get : function () { return this.get_right (); }, set : function (v) { return this.set_right (v); }}, size : { get : function () { return this.get_size (); }, set : function (v) { return this.set_size (v); }}, top : { get : function () { return this.get_top (); }, set : function (v) { return this.set_top (v); }}, topLeft : { get : function () { return this.get_topLeft (); }, set : function (v) { return this.set_topLeft (v); }}});

// Statics


Rectangle.__pool = new (lime_utils_ObjectPool().default)(function() {
	return new Rectangle();
},function(r) {
	r.setTo(0,0,0,0);
})

// Export

exports.default = Rectangle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/geom/Transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/geom/Transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.geom.Transform

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_geom_Matrix3D() {return __webpack_require__(/*! ./../../openfl/geom/Matrix3D */ "./node_modules/openfl/lib/_gen/openfl/geom/Matrix3D.js");}
function openfl__$Vector_Vector_$Impl_$() {return __webpack_require__(/*! ./../../openfl/_Vector/Vector_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/_Vector/Vector_Impl_.js");}
function openfl_geom_ColorTransform() {return __webpack_require__(/*! ./../../openfl/geom/ColorTransform */ "./node_modules/openfl/lib/_gen/openfl/geom/ColorTransform.js");}
function openfl_geom_Rectangle() {return __webpack_require__(/*! ./../../openfl/geom/Rectangle */ "./node_modules/openfl/lib/_gen/openfl/geom/Rectangle.js");}

// Constructor

var Transform = function(displayObject) {
	this.__colorTransform = new (openfl_geom_ColorTransform().default)();
	this.concatenatedColorTransform = new (openfl_geom_ColorTransform().default)();
	this.pixelBounds = new (openfl_geom_Rectangle().default)();
	this.__displayObject = displayObject;
	this.__hasMatrix = true;
}

// Meta

Transform.__name__ = "openfl.geom.Transform";
Transform.__isInterface__ = false;
Transform.prototype = {
	get_colorTransform: function() {
		return this.__colorTransform;
	},
	set_colorTransform: function(value) {
		if(!this.__colorTransform.__equals(value,false)) {
			this.__colorTransform.__copyFrom(value);
			if(value != null) {
				this.__displayObject.set_alpha(value.alphaMultiplier);
			}
			this.__displayObject.__setRenderDirty();
		}
		return this.__colorTransform;
	},
	get_concatenatedMatrix: function() {
		if(this.__hasMatrix) {
			return this.__displayObject.__getWorldTransform().clone();
		}
		return null;
	},
	get_matrix: function() {
		if(this.__hasMatrix) {
			return this.__displayObject.__transform.clone();
		}
		return null;
	},
	set_matrix: function(value) {
		if(value == null) {
			this.__hasMatrix = false;
			return null;
		}
		this.__hasMatrix = true;
		this.__hasMatrix3D = false;
		if(this.__displayObject != null) {
			this.__setTransform(value.a,value.b,value.c,value.d,value.tx,value.ty);
		}
		return value;
	},
	get_matrix3D: function() {
		if(this.__hasMatrix3D) {
			var matrix = this.__displayObject.__transform;
			return new (openfl_geom_Matrix3D().default)((openfl__$Vector_Vector_$Impl_$().default)._new(null,null,[matrix.a,matrix.b,0.0,0.0,matrix.c,matrix.d,0.0,0.0,0.0,0.0,1.0,0.0,matrix.tx,matrix.ty,0.0,1.0]));
		}
		return null;
	},
	set_matrix3D: function(value) {
		if(value == null) {
			this.__hasMatrix3D = false;
			return null;
		}
		this.__hasMatrix = false;
		this.__hasMatrix3D = true;
		this.__setTransform(value.rawData[0],value.rawData[1],value.rawData[5],value.rawData[6],value.rawData[12],value.rawData[13]);
		return value;
	},
	__setTransform: function(a,b,c,d,tx,ty) {
		if(this.__displayObject != null) {
			var transform = this.__displayObject.__transform;
			if(transform.a == a && transform.b == b && transform.c == c && transform.d == d && transform.tx == tx && transform.ty == ty) {
				return;
			}
			var scaleX = 0.0;
			var scaleY = 0.0;
			if(b == 0) {
				scaleX = a;
			} else {
				scaleX = Math.sqrt(a * a + b * b);
			}
			if(c == 0) {
				scaleY = d;
			} else {
				scaleY = Math.sqrt(c * c + d * d);
			}
			this.__displayObject.__scaleX = scaleX;
			this.__displayObject.__scaleY = scaleY;
			var rotation = 180 / Math.PI * Math.atan2(d,c) - 90;
			if(rotation != this.__displayObject.__rotation) {
				this.__displayObject.__rotation = rotation;
				var radians = rotation * (Math.PI / 180);
				this.__displayObject.__rotationSine = Math.sin(radians);
				this.__displayObject.__rotationCosine = Math.cos(radians);
			}
			transform.a = a;
			transform.b = b;
			transform.c = c;
			transform.d = d;
			transform.tx = tx;
			transform.ty = ty;
			this.__displayObject.__setTransformDirty();
		}
	}
};
Transform.prototype.__class__ = Transform.prototype.constructor = $hxClasses["openfl.geom.Transform"] = Transform;

// Init

Object.defineProperties(Transform.prototype,{ colorTransform : { get : function () { return this.get_colorTransform (); }, set : function (v) { return this.set_colorTransform (v); }}, concatenatedMatrix : { get : function () { return this.get_concatenatedMatrix (); }, set : function (v) { return this.set_concatenatedMatrix (v); }}, matrix : { get : function () { return this.get_matrix (); }, set : function (v) { return this.set_matrix (v); }}, matrix3D : { get : function () { return this.get_matrix3D (); }, set : function (v) { return this.set_matrix3D (v); }}});

// Statics




// Export

exports.default = Transform;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/geom/Vector3D.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/geom/Vector3D.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.geom.Vector3D

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var Vector3D = function(x,y,z,w) {
	if(w == null) {
		w = 0;
	}
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.w = w;
	this.x = x;
	this.y = y;
	this.z = z;
}

// Meta

Vector3D.__name__ = "openfl.geom.Vector3D";
Vector3D.__isInterface__ = false;
Vector3D.prototype = {
	add: function(a) {
		return new Vector3D(this.x + a.x,this.y + a.y,this.z + a.z);
	},
	clone: function() {
		return new Vector3D(this.x,this.y,this.z,this.w);
	},
	copyFrom: function(sourceVector3D) {
		this.x = sourceVector3D.x;
		this.y = sourceVector3D.y;
		this.z = sourceVector3D.z;
	},
	crossProduct: function(a) {
		return new Vector3D(this.y * a.z - this.z * a.y,this.z * a.x - this.x * a.z,this.x * a.y - this.y * a.x,1);
	},
	decrementBy: function(a) {
		this.x -= a.x;
		this.y -= a.y;
		this.z -= a.z;
	},
	dotProduct: function(a) {
		return this.x * a.x + this.y * a.y + this.z * a.z;
	},
	equals: function(toCompare,allFour) {
		if(allFour == null) {
			allFour = false;
		}
		if(this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z) {
			if(!(!allFour)) {
				return this.w == toCompare.w;
			} else {
				return true;
			}
		} else {
			return false;
		}
	},
	incrementBy: function(a) {
		this.x += a.x;
		this.y += a.y;
		this.z += a.z;
	},
	nearEquals: function(toCompare,tolerance,allFour) {
		if(allFour == null) {
			allFour = false;
		}
		if(Math.abs(this.x - toCompare.x) < tolerance && Math.abs(this.y - toCompare.y) < tolerance && Math.abs(this.z - toCompare.z) < tolerance) {
			if(!(!allFour)) {
				return Math.abs(this.w - toCompare.w) < tolerance;
			} else {
				return true;
			}
		} else {
			return false;
		}
	},
	negate: function() {
		this.x *= -1;
		this.y *= -1;
		this.z *= -1;
	},
	normalize: function() {
		var l = this.get_length();
		if(l != 0) {
			this.x /= l;
			this.y /= l;
			this.z /= l;
		}
		return l;
	},
	project: function() {
		this.x /= this.w;
		this.y /= this.w;
		this.z /= this.w;
	},
	scaleBy: function(s) {
		this.x *= s;
		this.y *= s;
		this.z *= s;
	},
	setTo: function(xa,ya,za) {
		this.x = xa;
		this.y = ya;
		this.z = za;
	},
	subtract: function(a) {
		return new Vector3D(this.x - a.x,this.y - a.y,this.z - a.z);
	},
	toString: function() {
		return "Vector3D(" + this.x + ", " + this.y + ", " + this.z + ")";
	},
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	},
	get_lengthSquared: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
};
Vector3D.prototype.__class__ = Vector3D.prototype.constructor = $hxClasses["openfl.geom.Vector3D"] = Vector3D;

// Init

{
	Object.defineProperties(Vector3D,{ X_AXIS : { get : function() {
		return Vector3D.get_X_AXIS();
	}}, Y_AXIS : { get : function() {
		return Vector3D.get_Y_AXIS();
	}}, Z_AXIS : { get : function() {
		return Vector3D.get_Z_AXIS();
	}}});
	Object.defineProperties(Vector3D.prototype,{ length : { get : function () { return this.get_length (); }}, lengthSquared : { get : function () { return this.get_lengthSquared (); }}});
};

// Statics

Vector3D.angleBetween = function(a,b) {
	var la = a.get_length();
	var lb = b.get_length();
	var dot = a.dotProduct(b);
	if(la != 0) {
		dot /= la;
	}
	if(lb != 0) {
		dot /= lb;
	}
	return Math.acos(dot);
}
Vector3D.distance = function(pt1,pt2) {
	var x = pt2.x - pt1.x;
	var y = pt2.y - pt1.y;
	var z = pt2.z - pt1.z;
	return Math.sqrt(x * x + y * y + z * z);
}
Vector3D.get_X_AXIS = function() {
	return new Vector3D(1,0,0);
}
Vector3D.get_Y_AXIS = function() {
	return new Vector3D(0,1,0);
}
Vector3D.get_Z_AXIS = function() {
	return new Vector3D(0,0,1);
}


// Export

exports.default = Vector3D;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/media/ID3Info.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/media/ID3Info.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.media.ID3Info

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var ID3Info = function() {
}

// Meta

ID3Info.__name__ = "openfl.media.ID3Info";
ID3Info.__isInterface__ = false;
ID3Info.prototype = {
	
};
ID3Info.prototype.__class__ = ID3Info.prototype.constructor = $hxClasses["openfl.media.ID3Info"] = ID3Info;

// Init



// Statics




// Export

exports.default = ID3Info;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/media/Sound.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/media/Sound.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.media.Sound

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function lime_utils_Assets() {return __webpack_require__(/*! ./../../lime/utils/Assets */ "./node_modules/openfl/lib/_gen/lime/utils/Assets.js");}
function lime_media_AudioBuffer() {return __webpack_require__(/*! ./../../lime/media/AudioBuffer */ "./node_modules/openfl/lib/_gen/lime/media/AudioBuffer.js");}
function openfl_events_IOErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/IOErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/IOErrorEvent.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function openfl_utils_ByteArrayData() {return __webpack_require__(/*! ./../../openfl/utils/ByteArrayData */ "./node_modules/openfl/lib/_gen/openfl/utils/ByteArrayData.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl_media_SoundMixer() {return __webpack_require__(/*! ./../../openfl/media/SoundMixer */ "./node_modules/openfl/lib/_gen/openfl/media/SoundMixer.js");}
function openfl_media_SoundTransform() {return __webpack_require__(/*! ./../../openfl/media/SoundTransform */ "./node_modules/openfl/lib/_gen/openfl/media/SoundTransform.js");}
function lime_media_AudioSource() {return __webpack_require__(/*! ./../../lime/media/AudioSource */ "./node_modules/openfl/lib/_gen/lime/media/AudioSource.js");}
function openfl_media_SoundChannel() {return __webpack_require__(/*! ./../../openfl/media/SoundChannel */ "./node_modules/openfl/lib/_gen/openfl/media/SoundChannel.js");}
function openfl_media_ID3Info() {return __webpack_require__(/*! ./../../openfl/media/ID3Info */ "./node_modules/openfl/lib/_gen/openfl/media/ID3Info.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}

// Constructor

var Sound = function(stream,context) {
	(openfl_events_EventDispatcher().default).call(this,this);
	this.bytesLoaded = 0;
	this.bytesTotal = 0;
	this.isBuffering = false;
	this.url = null;
	if(stream != null) {
		this.load(stream,context);
	}
}

// Meta

Sound.__name__ = "openfl.media.Sound";
Sound.__isInterface__ = false;
Sound.__super__ = (openfl_events_EventDispatcher().default);
Sound.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	close: function() {
		if(this.__buffer != null) {
			this.__buffer.dispose();
			this.__buffer = null;
		}
	},
	load: function(stream,context) {
		var _gthis = this;
		this.url = stream.url;
		var defaultLibrary = (lime_utils_Assets().default).getLibrary("default");
		if(defaultLibrary != null && defaultLibrary.cachedAudioBuffers.exists(this.url)) {
			this.AudioBuffer_onURLLoad(defaultLibrary.cachedAudioBuffers.get(this.url));
		} else {
			(lime_media_AudioBuffer().default).loadFromFile(this.url).onComplete($bind(this,this.AudioBuffer_onURLLoad)).onError(function(_) {
				_gthis.AudioBuffer_onURLLoad(null);
			});
		}
	},
	loadCompressedDataFromByteArray: function(bytes,bytesLength) {
		if(bytes == null || bytesLength <= 0) {
			this.dispatchEvent(new (openfl_events_IOErrorEvent().default)("ioError"));
			return;
		}
		if((_$UInt_UInt_$Impl_$().default).gt(bytes.position,0) || (_$UInt_UInt_$Impl_$().default).gt((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(bytes),bytesLength)) {
			var length = bytesLength;
			if(length == null) {
				length = 0;
			}
			var this1 = new (openfl_utils_ByteArrayData().default)(length);
			var copy = this1;
			var offset = bytes.position;
			var length1 = bytesLength;
			if(length1 == null) {
				length1 = 0;
			}
			if(offset == null) {
				offset = 0;
			}
			copy.writeBytes(bytes,offset,length1);
			bytes = copy;
		}
		this.__buffer = (lime_media_AudioBuffer().default).fromBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(bytes));
		if(this.__buffer == null) {
			this.dispatchEvent(new (openfl_events_IOErrorEvent().default)("ioError"));
		} else {
			this.dispatchEvent(new (openfl_events_Event().default)("complete"));
		}
	},
	loadPCMFromByteArray: function(bytes,samples,format,stereo,sampleRate) {
		if(sampleRate == null) {
			sampleRate = 44100;
		}
		if(stereo == null) {
			stereo = true;
		}
		if(format == null) {
			format = "float";
		}
		if(bytes == null) {
			this.dispatchEvent(new (openfl_events_IOErrorEvent().default)("ioError"));
			return;
		}
		var bitsPerSample = format == "float" ? 32 : 16;
		var channels = stereo ? 2 : 1;
		var bytesLength = (Std().default).int(samples * channels * (bitsPerSample / 8));
		if((_$UInt_UInt_$Impl_$().default).gt(bytes.position,0) || (_$UInt_UInt_$Impl_$().default).gt((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(bytes),bytesLength)) {
			var length = bytesLength;
			if(length == null) {
				length = 0;
			}
			var this1 = new (openfl_utils_ByteArrayData().default)(length);
			var copy = this1;
			var offset = bytes.position;
			var length1 = bytesLength;
			if(length1 == null) {
				length1 = 0;
			}
			if(offset == null) {
				offset = 0;
			}
			copy.writeBytes(bytes,offset,length1);
			bytes = copy;
		}
		var audioBuffer = new (lime_media_AudioBuffer().default)();
		audioBuffer.bitsPerSample = bitsPerSample;
		audioBuffer.channels = channels;
		var elements = null;
		var array = null;
		var view = null;
		var buffer = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toArrayBuffer(bytes);
		var len = null;
		var this2;
		if(elements != null) {
			this2 = new Uint8Array(elements);
		} else if(array != null) {
			this2 = new Uint8Array(array);
		} else if(view != null) {
			this2 = new Uint8Array(view);
		} else if(buffer != null) {
			if(len == null) {
				this2 = new Uint8Array(buffer,0);
			} else {
				this2 = new Uint8Array(buffer,0,len);
			}
		} else {
			this2 = null;
		}
		audioBuffer.data = this2;
		audioBuffer.sampleRate = (Std().default).int(sampleRate);
		this.__buffer = audioBuffer;
		this.dispatchEvent(new (openfl_events_Event().default)("complete"));
	},
	play: function(startTime,loops,sndTransform) {
		if(loops == null) {
			loops = 0;
		}
		if(startTime == null) {
			startTime = 0.0;
		}
		if(this.__buffer == null || (openfl_media_SoundMixer().default).__soundChannels.length >= 32) {
			return null;
		}
		if(sndTransform == null) {
			sndTransform = new (openfl_media_SoundTransform().default)();
		} else {
			sndTransform = sndTransform.clone();
		}
		var pan = (openfl_media_SoundMixer().default).__soundTransform.pan + sndTransform.pan;
		if(pan > 1) {
			pan = 1;
		}
		if(pan < -1) {
			pan = -1;
		}
		var volume = (openfl_media_SoundMixer().default).__soundTransform.volume * sndTransform.volume;
		var source = new (lime_media_AudioSource().default)(this.__buffer);
		source.offset = (Std().default).int(startTime);
		if(loops > 1) {
			source.set_loops(loops - 1);
		}
		source.set_gain(volume);
		var position = source.get_position();
		position.x = pan;
		position.z = -1 * Math.sqrt(1 - Math.pow(pan,2));
		source.set_position(position);
		return new (openfl_media_SoundChannel().default)(source,sndTransform);
	},
	get_id3: function() {
		return new (openfl_media_ID3Info().default)();
	},
	get_length: function() {
		if(this.__buffer != null) {
			return (Std().default).int(this.__buffer.get_src().duration() * 1000);
		}
		return 0;
	},
	AudioBuffer_onURLLoad: function(buffer) {
		if(buffer == null) {
			this.dispatchEvent(new (openfl_events_IOErrorEvent().default)("ioError"));
		} else {
			this.__buffer = buffer;
			this.dispatchEvent(new (openfl_events_Event().default)("complete"));
		}
	}
});
Sound.prototype.__class__ = Sound.prototype.constructor = $hxClasses["openfl.media.Sound"] = Sound;

// Init

Object.defineProperties(Sound.prototype,{ id3 : { get : function () { return this.get_id3 (); }}, length : { get : function () { return this.get_length (); }}});

// Statics

Sound.fromAudioBuffer = function(buffer) {
	var sound = new Sound();
	sound.__buffer = buffer;
	return sound;
}
Sound.fromFile = function(path) {
	return Sound.fromAudioBuffer((lime_media_AudioBuffer().default).fromFile(path));
}
Sound.loadFromFile = function(path) {
	return (lime_media_AudioBuffer().default).loadFromFile(path).then(function(audioBuffer) {
		return (lime_app_Future().default).withValue(Sound.fromAudioBuffer(audioBuffer));
	});
}
Sound.loadFromFiles = function(paths) {
	return (lime_media_AudioBuffer().default).loadFromFiles(paths).then(function(audioBuffer) {
		return (lime_app_Future().default).withValue(Sound.fromAudioBuffer(audioBuffer));
	});
}


// Export

exports.default = Sound;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/media/SoundChannel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/media/SoundChannel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.media.SoundChannel

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function openfl_media_SoundMixer() {return __webpack_require__(/*! ./../../openfl/media/SoundMixer */ "./node_modules/openfl/lib/_gen/openfl/media/SoundMixer.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function openfl_media_SoundTransform() {return __webpack_require__(/*! ./../../openfl/media/SoundTransform */ "./node_modules/openfl/lib/_gen/openfl/media/SoundTransform.js");}

// Constructor

var SoundChannel = function(source,soundTransform) {
	(openfl_events_EventDispatcher().default).call(this,this);
	this.leftPeak = 1;
	this.rightPeak = 1;
	if(soundTransform != null) {
		this.__soundTransform = soundTransform;
	} else {
		this.__soundTransform = new (openfl_media_SoundTransform().default)();
	}
	if(source != null) {
		this.__source = source;
		this.__source.onComplete.add($bind(this,this.source_onComplete));
		this.__isValid = true;
		this.__source.play();
	}
	(openfl_media_SoundMixer().default).__registerSoundChannel(this);
}

// Meta

SoundChannel.__name__ = "openfl.media.SoundChannel";
SoundChannel.__isInterface__ = false;
SoundChannel.__super__ = (openfl_events_EventDispatcher().default);
SoundChannel.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	stop: function() {
		(openfl_media_SoundMixer().default).__unregisterSoundChannel(this);
		if(!this.__isValid) {
			return;
		}
		this.__source.stop();
		this.__dispose();
	},
	__dispose: function() {
		if(!this.__isValid) {
			return;
		}
		this.__source.onComplete.remove($bind(this,this.source_onComplete));
		this.__source.dispose();
		this.__source = null;
		this.__isValid = false;
	},
	__updateTransform: function() {
		this.set_soundTransform(this.get_soundTransform());
	},
	get_position: function() {
		if(!this.__isValid) {
			return 0;
		}
		return this.__source.get_currentTime() + this.__source.offset;
	},
	set_position: function(value) {
		if(!this.__isValid) {
			return 0;
		}
		this.__source.set_currentTime((Std().default).int(value) - this.__source.offset);
		return value;
	},
	get_soundTransform: function() {
		return this.__soundTransform.clone();
	},
	set_soundTransform: function(value) {
		if(value != null) {
			this.__soundTransform.pan = value.pan;
			this.__soundTransform.volume = value.volume;
			var pan = (openfl_media_SoundMixer().default).__soundTransform.pan + this.__soundTransform.pan;
			if(pan < -1) {
				pan = -1;
			}
			if(pan > 1) {
				pan = 1;
			}
			var volume = (openfl_media_SoundMixer().default).__soundTransform.volume * this.__soundTransform.volume;
			if(this.__isValid) {
				this.__source.set_gain(volume);
				var position = this.__source.get_position();
				position.x = pan;
				position.z = -1 * Math.sqrt(1 - Math.pow(pan,2));
				this.__source.set_position(position);
				return value;
			}
		}
		return value;
	},
	source_onComplete: function() {
		(openfl_media_SoundMixer().default).__unregisterSoundChannel(this);
		this.__dispose();
		this.dispatchEvent(new (openfl_events_Event().default)("soundComplete"));
	}
});
SoundChannel.prototype.__class__ = SoundChannel.prototype.constructor = $hxClasses["openfl.media.SoundChannel"] = SoundChannel;

// Init

Object.defineProperties(SoundChannel.prototype,{ position : { get : function () { return this.get_position (); }, set : function (v) { return this.set_position (v); }}, soundTransform : { get : function () { return this.get_soundTransform (); }, set : function (v) { return this.set_soundTransform (v); }}});

// Statics




// Export

exports.default = SoundChannel;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/media/SoundMixer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/media/SoundMixer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.media.SoundMixer

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_media_SoundTransform() {return __webpack_require__(/*! ./../../openfl/media/SoundTransform */ "./node_modules/openfl/lib/_gen/openfl/media/SoundTransform.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var SoundMixer = function(){}

// Meta

SoundMixer.__name__ = "openfl.media.SoundMixer";
SoundMixer.__isInterface__ = false;
SoundMixer.prototype = {
	
};
SoundMixer.prototype.__class__ = SoundMixer.prototype.constructor = $hxClasses["openfl.media.SoundMixer"] = SoundMixer;

// Init

Object.defineProperty(SoundMixer,"soundTransform",{ get : function() {
	return SoundMixer.get_soundTransform();
}, set : function(value) {
	return SoundMixer.set_soundTransform(value);
}});

// Statics

SoundMixer.areSoundsInaccessible = function() {
	return false;
}
SoundMixer.stopAll = function() {
	var _g = 0;
	var _g1 = SoundMixer.__soundChannels;
	while(_g < _g1.length) {
		var channel = _g1[_g];
		++_g;
		channel.stop();
	}
}
SoundMixer.__registerSoundChannel = function(soundChannel) {
	SoundMixer.__soundChannels.push(soundChannel);
}
SoundMixer.__unregisterSoundChannel = function(soundChannel) {
	(HxOverrides().default).remove(SoundMixer.__soundChannels,soundChannel);
}
SoundMixer.get_soundTransform = function() {
	return SoundMixer.__soundTransform;
}
SoundMixer.set_soundTransform = function(value) {
	SoundMixer.__soundTransform = value.clone();
	var _g = 0;
	var _g1 = SoundMixer.__soundChannels;
	while(_g < _g1.length) {
		var channel = _g1[_g];
		++_g;
		channel.__updateTransform();
	}
	return value;
}
SoundMixer.MAX_ACTIVE_CHANNELS = 32
SoundMixer.__soundChannels = []
SoundMixer.__soundTransform = new (openfl_media_SoundTransform().default)()

// Export

exports.default = SoundMixer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/media/SoundTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/media/SoundTransform.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.media.SoundTransform

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;

// Constructor

var SoundTransform = function(vol,panning) {
	if(panning == null) {
		panning = 0;
	}
	if(vol == null) {
		vol = 1;
	}
	this.volume = vol;
	this.pan = panning;
	this.leftToLeft = 0;
	this.leftToRight = 0;
	this.rightToLeft = 0;
	this.rightToRight = 0;
}

// Meta

SoundTransform.__name__ = "openfl.media.SoundTransform";
SoundTransform.__isInterface__ = false;
SoundTransform.prototype = {
	clone: function() {
		return new SoundTransform(this.volume,this.pan);
	}
};
SoundTransform.prototype.__class__ = SoundTransform.prototype.constructor = $hxClasses["openfl.media.SoundTransform"] = SoundTransform;

// Init



// Statics


SoundTransform.__meta__ = { fields : { clone : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}}

// Export

exports.default = SoundTransform;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/net/URLLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/net/URLLoader.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.net.URLLoader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function lime_net__$HTTPRequest_$openfl_$utils_$ByteArray() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest_openfl_utils_ByteArray */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_openfl_utils_ByteArray.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function lime_net__$HTTPRequest_$String() {return __webpack_require__(/*! ./../../lime/net/_HTTPRequest_String */ "./node_modules/openfl/lib/_gen/lime/net/_HTTPRequest_String.js");}
function openfl_events_HTTPStatusEvent() {return __webpack_require__(/*! ./../../openfl/events/HTTPStatusEvent */ "./node_modules/openfl/lib/_gen/openfl/events/HTTPStatusEvent.js");}
function openfl_net_URLRequestHeader() {return __webpack_require__(/*! ./../../openfl/net/URLRequestHeader */ "./node_modules/openfl/lib/_gen/openfl/net/URLRequestHeader.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function ValueType() {return __webpack_require__(/*! ./../../ValueType */ "./node_modules/openfl/lib/_gen/ValueType.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function lime_net_HTTPRequestHeader() {return __webpack_require__(/*! ./../../lime/net/HTTPRequestHeader */ "./node_modules/openfl/lib/_gen/lime/net/HTTPRequestHeader.js");}
function openfl_events_SecurityErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/SecurityErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/SecurityErrorEvent.js");}
function openfl_events_IOErrorEvent() {return __webpack_require__(/*! ./../../openfl/events/IOErrorEvent */ "./node_modules/openfl/lib/_gen/openfl/events/IOErrorEvent.js");}
function openfl_events_ProgressEvent() {return __webpack_require__(/*! ./../../openfl/events/ProgressEvent */ "./node_modules/openfl/lib/_gen/openfl/events/ProgressEvent.js");}

// Constructor

var URLLoader = function(request) {
	(openfl_events_EventDispatcher().default).call(this);
	this.bytesLoaded = 0;
	this.bytesTotal = 0;
	this.dataFormat = "text";
	if(request != null) {
		this.load(request);
	}
}

// Meta

URLLoader.__name__ = "openfl.net.URLLoader";
URLLoader.__isInterface__ = false;
URLLoader.__super__ = (openfl_events_EventDispatcher().default);
URLLoader.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	close: function() {
		if(this.__httpRequest != null) {
			this.__httpRequest.cancel();
		}
	},
	load: function(request) {
		var _gthis = this;
		if(this.dataFormat == "binary") {
			var httpRequest = new (lime_net__$HTTPRequest_$openfl_$utils_$ByteArray().default)();
			this.__prepareRequest(httpRequest,request);
			httpRequest.load().onProgress($bind(this,this.httpRequest_onProgress)).onError($bind(this,this.httpRequest_onError)).onComplete(function(data) {
				_gthis.__dispatchStatus();
				_gthis.data = data;
				var event = new (openfl_events_Event().default)("complete");
				_gthis.dispatchEvent(event);
			});
		} else {
			var httpRequest1 = new (lime_net__$HTTPRequest_$String().default)();
			this.__prepareRequest(httpRequest1,request);
			httpRequest1.load().onProgress($bind(this,this.httpRequest_onProgress)).onError($bind(this,this.httpRequest_onError)).onComplete(function(data1) {
				_gthis.__dispatchStatus();
				_gthis.data = data1;
				var event1 = new (openfl_events_Event().default)("complete");
				_gthis.dispatchEvent(event1);
			});
		}
	},
	__dispatchStatus: function() {
		var event = new (openfl_events_HTTPStatusEvent().default)("httpStatus",false,false,this.__httpRequest.responseStatus);
		event.responseURL = this.__httpRequest.uri;
		var headers = [];
		if(this.__httpRequest.enableResponseHeaders && this.__httpRequest.responseHeaders != null) {
			var _g = 0;
			var _g1 = this.__httpRequest.responseHeaders;
			while(_g < _g1.length) {
				var header = _g1[_g];
				++_g;
				headers.push(new (openfl_net_URLRequestHeader().default)(header.name,header.value));
			}
		}
		event.responseHeaders = headers;
		this.dispatchEvent(event);
	},
	__prepareRequest: function(httpRequest,request) {
		this.__httpRequest = httpRequest;
		this.__httpRequest.uri = request.url;
		this.__httpRequest.method = request.method;
		if(request.data != null) {
			if((Type().default).typeof(request.data) == (ValueType().default).TObject) {
				var fields = (Reflect().default).fields(request.data);
				var _g = 0;
				while(_g < fields.length) {
					var field = fields[_g];
					++_g;
					this.__httpRequest.formData.set(field,(Reflect().default).field(request.data,field));
				}
			} else if(((request.data) instanceof (haxe_io_Bytes().default))) {
				this.__httpRequest.data = request.data;
			} else {
				this.__httpRequest.data = (haxe_io_Bytes().default).ofString((Std().default).string(request.data));
			}
		}
		this.__httpRequest.contentType = request.contentType;
		if(request.requestHeaders != null) {
			var _g1 = 0;
			var _g11 = request.requestHeaders;
			while(_g1 < _g11.length) {
				var header = _g11[_g1];
				++_g1;
				this.__httpRequest.headers.push(new (lime_net_HTTPRequestHeader().default)(header.name,header.value));
			}
		}
		this.__httpRequest.followRedirects = request.followRedirects;
		this.__httpRequest.timeout = (Std().default).int(request.idleTimeout);
		this.__httpRequest.withCredentials = request.manageCookies;
		var userAgent = request.userAgent;
		if(userAgent == null) {
			userAgent = "Mozilla/5.0 (Windows; U; en) AppleWebKit/420+ (KHTML, like Gecko) OpenFL/1.0";
		}
		this.__httpRequest.userAgent = request.userAgent;
		this.__httpRequest.enableResponseHeaders = true;
	},
	httpRequest_onError: function(error) {
		this.__dispatchStatus();
		if(error == 403) {
			var event = new (openfl_events_SecurityErrorEvent().default)("securityError");
			event.text = (Std().default).string(error);
			this.dispatchEvent(event);
		} else {
			var event1 = new (openfl_events_IOErrorEvent().default)("ioError");
			event1.text = (Std().default).string(error);
			this.dispatchEvent(event1);
		}
	},
	httpRequest_onProgress: function(bytesLoaded,bytesTotal) {
		var event = new (openfl_events_ProgressEvent().default)("progress");
		event.bytesLoaded = bytesLoaded;
		event.bytesTotal = bytesTotal;
		this.dispatchEvent(event);
	}
});
URLLoader.prototype.__class__ = URLLoader.prototype.constructor = $hxClasses["openfl.net.URLLoader"] = URLLoader;

// Init



// Statics




// Export

exports.default = URLLoader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/net/URLRequest.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/net/URLRequest.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.net.URLRequest

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_net_URLRequestDefaults() {return __webpack_require__(/*! ./../../openfl/net/URLRequestDefaults */ "./node_modules/openfl/lib/_gen/openfl/net/URLRequestDefaults.js");}

// Constructor

var URLRequest = function(url) {
	if(url != null) {
		this.url = url;
	}
	this.contentType = null;
	this.followRedirects = (openfl_net_URLRequestDefaults().default).followRedirects;
	if((openfl_net_URLRequestDefaults().default).idleTimeout > 0) {
		this.idleTimeout = (openfl_net_URLRequestDefaults().default).idleTimeout;
	} else {
		this.idleTimeout = 30000;
	}
	this.manageCookies = (openfl_net_URLRequestDefaults().default).manageCookies;
	this.method = "GET";
	this.requestHeaders = [];
	this.userAgent = (openfl_net_URLRequestDefaults().default).userAgent;
}

// Meta

URLRequest.__name__ = "openfl.net.URLRequest";
URLRequest.__isInterface__ = false;
URLRequest.prototype = {
	
};
URLRequest.prototype.__class__ = URLRequest.prototype.constructor = $hxClasses["openfl.net.URLRequest"] = URLRequest;

// Init



// Statics




// Export

exports.default = URLRequest;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/net/URLRequestDefaults.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/net/URLRequestDefaults.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.net.URLRequestDefaults

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var URLRequestDefaults = function(){}

// Meta

URLRequestDefaults.__name__ = "openfl.net.URLRequestDefaults";
URLRequestDefaults.__isInterface__ = false;
URLRequestDefaults.prototype = {
	
};
URLRequestDefaults.prototype.__class__ = URLRequestDefaults.prototype.constructor = $hxClasses["openfl.net.URLRequestDefaults"] = URLRequestDefaults;

// Init



// Statics


URLRequestDefaults.followRedirects = true
URLRequestDefaults.idleTimeout = 0
URLRequestDefaults.manageCookies = false

// Export

exports.default = URLRequestDefaults;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/net/URLRequestHeader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/net/URLRequestHeader.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.net.URLRequestHeader

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var URLRequestHeader = function(name,value) {
	if(value == null) {
		value = "";
	}
	if(name == null) {
		name = "";
	}
	this.name = name;
	this.value = value;
}

// Meta

URLRequestHeader.__name__ = "openfl.net.URLRequestHeader";
URLRequestHeader.__isInterface__ = false;
URLRequestHeader.prototype = {
	
};
URLRequestHeader.prototype.__class__ = URLRequestHeader.prototype.constructor = $hxClasses["openfl.net.URLRequestHeader"] = URLRequestHeader;

// Init



// Statics




// Export

exports.default = URLRequestHeader;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/system/ApplicationDomain.js":
/*!*************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/system/ApplicationDomain.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.system.ApplicationDomain

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}

// Constructor

var ApplicationDomain = function(parentDomain) {
	if(parentDomain != null) {
		this.parentDomain = parentDomain;
	} else {
		this.parentDomain = ApplicationDomain.currentDomain;
	}
}

// Meta

ApplicationDomain.__name__ = "openfl.system.ApplicationDomain";
ApplicationDomain.__isInterface__ = false;
ApplicationDomain.prototype = {
	getDefinition: function(name) {
		return (Type().default).resolveClass(name);
	},
	hasDefinition: function(name) {
		return (Type().default).resolveClass(name) != null;
	}
};
ApplicationDomain.prototype.__class__ = ApplicationDomain.prototype.constructor = $hxClasses["openfl.system.ApplicationDomain"] = ApplicationDomain;

// Init



// Statics


ApplicationDomain.currentDomain = new ApplicationDomain(null)

// Export

exports.default = ApplicationDomain;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/text/Font.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/text/Font.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.text.Font

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_text_Font() {return __webpack_require__(/*! ./../../lime/text/Font */ "./node_modules/openfl/lib/_gen/lime/text/Font.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function js_Boot() {return __webpack_require__(/*! ./../../js/Boot */ "./node_modules/openfl/lib/_gen/js/Boot.js");}

// Constructor

var Font = function(name) {
	(lime_text_Font().default).call(this,name);
}

// Meta

Font.__name__ = "openfl.text.Font";
Font.__isInterface__ = false;
Font.__super__ = (lime_text_Font().default);
Font.prototype = $extend((lime_text_Font().default).prototype, {
	__fromLimeFont: function(font) {
		this.__copyFrom(font);
	},
	__initialize: function() {
		return this.__initialized;
	},
	get_fontName: function() {
		return this.name;
	},
	set_fontName: function(value) {
		return this.name = value;
	}
});
Font.prototype.__class__ = Font.prototype.constructor = $hxClasses["openfl.text.Font"] = Font;

// Init

Object.defineProperty(Font.prototype,"fontName",{ get : function () { return this.get_fontName (); }, set : function (v) { return this.set_fontName (v); }});

// Statics

Font.enumerateFonts = function(enumerateDeviceFonts) {
	if(enumerateDeviceFonts == null) {
		enumerateDeviceFonts = false;
	}
	return Font.__registeredFonts;
}
Font.fromBytes = function(bytes) {
	var font = new Font();
	font.__fromBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(bytes));
	return font;
}
Font.fromFile = function(path) {
	var font = new Font();
	font.__fromFile(path);
	return font;
}
Font.loadFromBytes = function(bytes) {
	return (lime_text_Font().default).loadFromBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(bytes)).then(function(limeFont) {
		var font = new Font();
		font.__fromLimeFont(limeFont);
		return (lime_app_Future().default).withValue(font);
	});
}
Font.loadFromFile = function(path) {
	return (lime_text_Font().default).loadFromFile(path).then(function(limeFont) {
		var font = new Font();
		font.__fromLimeFont(limeFont);
		return (lime_app_Future().default).withValue(font);
	});
}
Font.loadFromName = function(path) {
	return (lime_text_Font().default).loadFromName(path).then(function(limeFont) {
		var font = new Font();
		font.__fromLimeFont(limeFont);
		return (lime_app_Future().default).withValue(font);
	});
}
Font.registerFont = function(font) {
	var instance = null;
	if((Type().default).getClass(font) == null) {
		instance = (js_Boot().default).__cast((Type().default).createInstance(font,[]) , Font);
	} else {
		instance = (js_Boot().default).__cast(font , Font);
	}
	if(instance != null) {
		Font.__registeredFonts.push(instance);
		Font.__fontByName.set(instance.get_fontName(),instance);
	}
}
Font.__fontByName = new (haxe_ds_StringMap().default)()
Font.__registeredFonts = []

// Export

exports.default = Font;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/ui/GameInput.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/ui/GameInput.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.ui.GameInput

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function openfl_events_GameInputEvent() {return __webpack_require__(/*! ./../../openfl/events/GameInputEvent */ "./node_modules/openfl/lib/_gen/openfl/events/GameInputEvent.js");}
function haxe_ds_ObjectMap() {return __webpack_require__(/*! ./../../haxe/ds/ObjectMap */ "./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js");}
function openfl_ui_GameInputDevice() {return __webpack_require__(/*! ./../../openfl/ui/GameInputDevice */ "./node_modules/openfl/lib/_gen/openfl/ui/GameInputDevice.js");}
function openfl_ui_GameInputControl() {return __webpack_require__(/*! ./../../openfl/ui/GameInputControl */ "./node_modules/openfl/lib/_gen/openfl/ui/GameInputControl.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}

// Constructor

var GameInput = function() {
	(openfl_events_EventDispatcher().default).call(this);
	GameInput.__instances.push(this);
}

// Meta

GameInput.__name__ = "openfl.ui.GameInput";
GameInput.__isInterface__ = false;
GameInput.__super__ = (openfl_events_EventDispatcher().default);
GameInput.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	addEventListener: function(type,listener,useCapture,priority,useWeakReference) {
		if(useWeakReference == null) {
			useWeakReference = false;
		}
		if(priority == null) {
			priority = 0;
		}
		if(useCapture == null) {
			useCapture = false;
		}
		(openfl_events_EventDispatcher().default).prototype.addEventListener.call(this,type,listener,useCapture,priority,useWeakReference);
		if(type == "deviceAdded") {
			var _g = 0;
			var _g1 = GameInput.__deviceList;
			while(_g < _g1.length) {
				var device = _g1[_g];
				++_g;
				this.dispatchEvent(new (openfl_events_GameInputEvent().default)("deviceAdded",true,false,device));
			}
		}
	}
});
GameInput.prototype.__class__ = GameInput.prototype.constructor = $hxClasses["openfl.ui.GameInput"] = GameInput;

// Init



// Statics

GameInput.getDeviceAt = function(index) {
	if(index >= 0 && index < GameInput.__deviceList.length) {
		return GameInput.__deviceList[index];
	}
	return null;
}
GameInput.__getDevice = function(gamepad) {
	if(gamepad == null) {
		return null;
	}
	if(!GameInput.__devices.exists(gamepad)) {
		var device = new (openfl_ui_GameInputDevice().default)(gamepad.get_guid(),gamepad.get_name());
		GameInput.__deviceList.push(device);
		GameInput.__devices.set(gamepad,device);
		GameInput.numDevices = GameInput.__deviceList.length;
	}
	return GameInput.__devices.get(gamepad);
}
GameInput.__onGamepadAxisMove = function(gamepad,axis,value) {
	var device = GameInput.__getDevice(gamepad);
	if(device == null) {
		return;
	}
	if(device.enabled) {
		if(!device.__axis.exists(axis)) {
			var control;
			switch(axis) {
			case 0:
				control = "LEFT_X";
				break;
			case 1:
				control = "LEFT_Y";
				break;
			case 2:
				control = "RIGHT_X";
				break;
			case 3:
				control = "RIGHT_Y";
				break;
			case 4:
				control = "TRIGGER_LEFT";
				break;
			case 5:
				control = "TRIGGER_RIGHT";
				break;
			default:
				control = "UNKNOWN (" + axis + ")";
			}
			var control1 = new (openfl_ui_GameInputControl().default)(device,"AXIS_" + control,-1,1);
			device.__axis.set(axis,control1);
			device.__controls.push(control1);
		}
		var control2 = device.__axis.get(axis);
		control2.value = value;
		control2.dispatchEvent(new (openfl_events_Event().default)("change"));
	}
}
GameInput.__onGamepadButtonDown = function(gamepad,button) {
	var device = GameInput.__getDevice(gamepad);
	if(device == null) {
		return;
	}
	if(device.enabled) {
		if(!device.__button.exists(button)) {
			var control;
			switch(button) {
			case 0:
				control = "A";
				break;
			case 1:
				control = "B";
				break;
			case 2:
				control = "X";
				break;
			case 3:
				control = "Y";
				break;
			case 4:
				control = "BACK";
				break;
			case 5:
				control = "GUIDE";
				break;
			case 6:
				control = "START";
				break;
			case 7:
				control = "LEFT_STICK";
				break;
			case 8:
				control = "RIGHT_STICK";
				break;
			case 9:
				control = "LEFT_SHOULDER";
				break;
			case 10:
				control = "RIGHT_SHOULDER";
				break;
			case 11:
				control = "DPAD_UP";
				break;
			case 12:
				control = "DPAD_DOWN";
				break;
			case 13:
				control = "DPAD_LEFT";
				break;
			case 14:
				control = "DPAD_RIGHT";
				break;
			default:
				control = "UNKNOWN (" + button + ")";
			}
			var control1 = new (openfl_ui_GameInputControl().default)(device,"BUTTON_" + control,0,1);
			device.__button.set(button,control1);
			device.__controls.push(control1);
		}
		var control2 = device.__button.get(button);
		control2.value = 1;
		control2.dispatchEvent(new (openfl_events_Event().default)("change"));
	}
}
GameInput.__onGamepadButtonUp = function(gamepad,button) {
	var device = GameInput.__getDevice(gamepad);
	if(device == null) {
		return;
	}
	if(device.enabled) {
		if(!device.__button.exists(button)) {
			var control;
			switch(button) {
			case 0:
				control = "A";
				break;
			case 1:
				control = "B";
				break;
			case 2:
				control = "X";
				break;
			case 3:
				control = "Y";
				break;
			case 4:
				control = "BACK";
				break;
			case 5:
				control = "GUIDE";
				break;
			case 6:
				control = "START";
				break;
			case 7:
				control = "LEFT_STICK";
				break;
			case 8:
				control = "RIGHT_STICK";
				break;
			case 9:
				control = "LEFT_SHOULDER";
				break;
			case 10:
				control = "RIGHT_SHOULDER";
				break;
			case 11:
				control = "DPAD_UP";
				break;
			case 12:
				control = "DPAD_DOWN";
				break;
			case 13:
				control = "DPAD_LEFT";
				break;
			case 14:
				control = "DPAD_RIGHT";
				break;
			default:
				control = "UNKNOWN (" + button + ")";
			}
			var control1 = new (openfl_ui_GameInputControl().default)(device,"BUTTON_" + control,0,1);
			device.__button.set(button,control1);
			device.__controls.push(control1);
		}
		var control2 = device.__button.get(button);
		control2.value = 0;
		control2.dispatchEvent(new (openfl_events_Event().default)("change"));
	}
}
GameInput.__onGamepadConnect = function(gamepad) {
	var device = GameInput.__getDevice(gamepad);
	if(device == null) {
		return;
	}
	var _g = 0;
	var _g1 = GameInput.__instances;
	while(_g < _g1.length) {
		var instance = _g1[_g];
		++_g;
		instance.dispatchEvent(new (openfl_events_GameInputEvent().default)("deviceAdded",true,false,device));
	}
}
GameInput.__onGamepadDisconnect = function(gamepad) {
	var device = GameInput.__devices.get(gamepad);
	if(device != null) {
		if(GameInput.__devices.exists(gamepad)) {
			(HxOverrides().default).remove(GameInput.__deviceList,GameInput.__devices.get(gamepad));
			GameInput.__devices.remove(gamepad);
		}
		GameInput.numDevices = GameInput.__deviceList.length;
		var _g = 0;
		var _g1 = GameInput.__instances;
		while(_g < _g1.length) {
			var instance = _g1[_g];
			++_g;
			instance.dispatchEvent(new (openfl_events_GameInputEvent().default)("deviceRemoved",true,false,device));
		}
	}
}
GameInput.__meta__ = { fields : { addEventListener : { SuppressWarnings : ["checkstyle:Dynamic"]}}}
GameInput.isSupported = true
GameInput.numDevices = 0
GameInput.__deviceList = []
GameInput.__instances = []
GameInput.__devices = new (haxe_ds_ObjectMap().default)()

// Export

exports.default = GameInput;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/ui/GameInputControl.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/ui/GameInputControl.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.ui.GameInputControl

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}

// Constructor

var GameInputControl = function(device,id,minValue,maxValue,value) {
	if(value == null) {
		value = 0;
	}
	(openfl_events_EventDispatcher().default).call(this);
	this.device = device;
	this.id = id;
	this.minValue = minValue;
	this.maxValue = maxValue;
	this.value = value;
}

// Meta

GameInputControl.__name__ = "openfl.ui.GameInputControl";
GameInputControl.__isInterface__ = false;
GameInputControl.__super__ = (openfl_events_EventDispatcher().default);
GameInputControl.prototype = $extend((openfl_events_EventDispatcher().default).prototype, {
	
});
GameInputControl.prototype.__class__ = GameInputControl.prototype.constructor = $hxClasses["openfl.ui.GameInputControl"] = GameInputControl;

// Init



// Statics




// Export

exports.default = GameInputControl;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/ui/GameInputDevice.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/ui/GameInputDevice.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.ui.GameInputDevice

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function openfl_ui_GameInputControl() {return __webpack_require__(/*! ./../../openfl/ui/GameInputControl */ "./node_modules/openfl/lib/_gen/openfl/ui/GameInputControl.js");}

// Constructor

var GameInputDevice = function(id,name) {
	this.__controls = [];
	this.__button = new (haxe_ds_IntMap().default)();
	this.__axis = new (haxe_ds_IntMap().default)();
	this.id = id;
	this.name = name;
	var control;
	control = new (openfl_ui_GameInputControl().default)(this,"AXIS_" + 0,-1,1);
	this.__axis.set(0,control);
	this.__controls.push(control);
	control = new (openfl_ui_GameInputControl().default)(this,"AXIS_" + 1,-1,1);
	this.__axis.set(1,control);
	this.__controls.push(control);
	control = new (openfl_ui_GameInputControl().default)(this,"AXIS_" + 2,-1,1);
	this.__axis.set(2,control);
	this.__controls.push(control);
	control = new (openfl_ui_GameInputControl().default)(this,"AXIS_" + 3,-1,1);
	this.__axis.set(3,control);
	this.__controls.push(control);
	control = new (openfl_ui_GameInputControl().default)(this,"AXIS_" + 4,-1,1);
	this.__axis.set(4,control);
	this.__controls.push(control);
	control = new (openfl_ui_GameInputControl().default)(this,"AXIS_" + 5,-1,1);
	this.__axis.set(5,control);
	this.__controls.push(control);
	var _g = 0;
	while(_g < 15) {
		var i = _g++;
		control = new (openfl_ui_GameInputControl().default)(this,"BUTTON_" + i,0,1);
		this.__button.set(i,control);
		this.__controls.push(control);
	}
}

// Meta

GameInputDevice.__name__ = "openfl.ui.GameInputDevice";
GameInputDevice.__isInterface__ = false;
GameInputDevice.prototype = {
	getCachedSamples: function(data,append) {
		if(append == null) {
			append = false;
		}
		return 0;
	},
	getControlAt: function(i) {
		if(i >= 0 && i < this.__controls.length) {
			return this.__controls[i];
		}
		return null;
	},
	startCachingSamples: function(numSamples,controls) {
	},
	stopCachingSamples: function() {
	},
	get_numControls: function() {
		return this.__controls.length;
	}
};
GameInputDevice.prototype.__class__ = GameInputDevice.prototype.constructor = $hxClasses["openfl.ui.GameInputDevice"] = GameInputDevice;

// Init

Object.defineProperties(GameInputDevice.prototype,{ numControls : { get : function () { return this.get_numControls (); }}});

// Statics


GameInputDevice.MAX_BUFFER_SIZE = 32000

// Export

exports.default = GameInputDevice;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/ui/Keyboard.js":
/*!************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/ui/Keyboard.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.ui.Keyboard

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var Keyboard = function(){}

// Meta

Keyboard.__name__ = "openfl.ui.Keyboard";
Keyboard.__isInterface__ = false;
Keyboard.prototype = {
	
};
Keyboard.prototype.__class__ = Keyboard.prototype.constructor = $hxClasses["openfl.ui.Keyboard"] = Keyboard;

// Init



// Statics

Keyboard.isAccessible = function() {
	return false;
}
Keyboard.__convertKeyCode = function(key) {
	switch(key) {
	case 8:
		return 8;
	case 9:
		return 9;
	case 13:
		return 13;
	case 27:
		return 27;
	case 32:
		return 32;
	case 33:
		return 49;
	case 34:
		return 222;
	case 35:
		return 51;
	case 36:
		return 52;
	case 37:
		return 53;
	case 38:
		return 55;
	case 39:
		return 222;
	case 40:
		return 57;
	case 41:
		return 48;
	case 42:
		return 56;
	case 44:
		return 188;
	case 45:
		return 189;
	case 46:
		return 190;
	case 47:
		return 191;
	case 48:
		return 48;
	case 49:
		return 49;
	case 50:
		return 50;
	case 51:
		return 51;
	case 52:
		return 52;
	case 53:
		return 53;
	case 54:
		return 54;
	case 55:
		return 55;
	case 56:
		return 56;
	case 57:
		return 57;
	case 58:
		return 186;
	case 59:
		return 186;
	case 60:
		return 60;
	case 61:
		return 187;
	case 62:
		return 190;
	case 63:
		return 191;
	case 64:
		return 50;
	case 91:
		return 219;
	case 92:
		return 220;
	case 93:
		return 221;
	case 94:
		return 54;
	case 95:
		return 189;
	case 96:
		return 192;
	case 97:
		return 65;
	case 98:
		return 66;
	case 99:
		return 67;
	case 100:
		return 68;
	case 101:
		return 69;
	case 102:
		return 70;
	case 103:
		return 71;
	case 104:
		return 72;
	case 105:
		return 73;
	case 106:
		return 74;
	case 107:
		return 75;
	case 108:
		return 76;
	case 109:
		return 77;
	case 110:
		return 78;
	case 111:
		return 79;
	case 112:
		return 80;
	case 113:
		return 81;
	case 114:
		return 82;
	case 115:
		return 83;
	case 116:
		return 84;
	case 117:
		return 85;
	case 118:
		return 86;
	case 119:
		return 87;
	case 120:
		return 88;
	case 121:
		return 89;
	case 122:
		return 90;
	case 127:
		return 46;
	case 1073741881:
		return 20;
	case 1073741882:
		return 112;
	case 1073741883:
		return 113;
	case 1073741884:
		return 114;
	case 1073741885:
		return 115;
	case 1073741886:
		return 116;
	case 1073741887:
		return 117;
	case 1073741888:
		return 118;
	case 1073741889:
		return 119;
	case 1073741890:
		return 120;
	case 1073741891:
		return 121;
	case 1073741892:
		return 122;
	case 1073741893:
		return 123;
	case 1073741894:
		return 301;
	case 1073741895:
		return 145;
	case 1073741896:
		return 19;
	case 1073741897:
		return 45;
	case 1073741898:
		return 36;
	case 1073741899:
		return 33;
	case 1073741901:
		return 35;
	case 1073741902:
		return 34;
	case 1073741903:
		return 39;
	case 1073741904:
		return 37;
	case 1073741905:
		return 40;
	case 1073741906:
		return 38;
	case 1073741907:
		return 144;
	case 1073741908:
		return 111;
	case 1073741909:
		return 106;
	case 1073741910:
		return 109;
	case 1073741911:
		return 107;
	case 1073741912:
		return 13;
	case 1073741913:
		return 97;
	case 1073741914:
		return 98;
	case 1073741915:
		return 99;
	case 1073741916:
		return 100;
	case 1073741917:
		return 101;
	case 1073741918:
		return 102;
	case 1073741919:
		return 103;
	case 1073741920:
		return 104;
	case 1073741921:
		return 105;
	case 1073741922:
		return 96;
	case 1073741923:
		return 110;
	case 1073741925:
		return 302;
	case 1073741928:
		return 124;
	case 1073741929:
		return 125;
	case 1073741930:
		return 126;
	case 1073741982:
		return 13;
	case 1073742044:
		return 110;
	case 1073742048:
		return 17;
	case 1073742049:
		return 16;
	case 1073742050:
		return 18;
	case 1073742051:
		return 15;
	case 1073742052:
		return 17;
	case 1073742053:
		return 16;
	case 1073742054:
		return 18;
	case 1073742055:
		return 15;
	default:
		return key;
	}
}
Keyboard.__getCharCode = function(key,shift) {
	if(shift == null) {
		shift = false;
	}
	if(!shift) {
		switch(key) {
		case 8:
			return 8;
		case 9:
			return 9;
		case 13:
			return 13;
		case 27:
			return 27;
		case 32:
			return 32;
		case 186:
			return 59;
		case 187:
			return 61;
		case 188:
			return 44;
		case 189:
			return 45;
		case 190:
			return 46;
		case 191:
			return 47;
		case 192:
			return 96;
		case 219:
			return 91;
		case 220:
			return 92;
		case 221:
			return 93;
		case 222:
			return 39;
		}
		if(key >= 48 && key <= 57) {
			return key - 48 + 48;
		}
		if(key >= 65 && key <= 90) {
			return key - 65 + 97;
		}
	} else {
		switch(key) {
		case 48:
			return 41;
		case 49:
			return 33;
		case 50:
			return 64;
		case 51:
			return 35;
		case 52:
			return 36;
		case 53:
			return 37;
		case 54:
			return 94;
		case 55:
			return 38;
		case 56:
			return 42;
		case 57:
			return 40;
		case 186:
			return 58;
		case 187:
			return 43;
		case 188:
			return 60;
		case 189:
			return 95;
		case 190:
			return 62;
		case 191:
			return 63;
		case 192:
			return 126;
		case 219:
			return 123;
		case 220:
			return 124;
		case 221:
			return 125;
		case 222:
			return 34;
		}
		if(key >= 65 && key <= 90) {
			return key - 65 + 65;
		}
	}
	if(key >= 96 && key <= 105) {
		return key - 96 + 48;
	}
	switch(key) {
	case 8:
		return 8;
	case 13:
		return 13;
	case 46:
		return 127;
	case 106:
		return 42;
	case 107:
		return 43;
	case 108:
		return 44;
	case 110:
		return 45;
	case 111:
		return 46;
	}
	return 0;
}
Keyboard.__getKeyLocation = function(key) {
	switch(key) {
	case 1073741908:case 1073741909:case 1073741910:case 1073741911:case 1073741912:case 1073741913:case 1073741914:case 1073741915:case 1073741916:case 1073741917:case 1073741918:case 1073741919:case 1073741920:case 1073741921:case 1073741922:case 1073741923:case 1073742044:
		return 3;
	case 1073742048:case 1073742049:case 1073742050:case 1073742051:
		return 1;
	case 1073742052:case 1073742053:case 1073742054:case 1073742055:
		return 2;
	default:
		return 0;
	}
}
Keyboard.__meta__ = { statics : { BREAK : { SuppressWarnings : ["checkstyle:FieldDocComment"]}, NUMLOCK : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}}
Keyboard.NUMBER_0 = 48
Keyboard.NUMBER_1 = 49
Keyboard.NUMBER_2 = 50
Keyboard.NUMBER_3 = 51
Keyboard.NUMBER_4 = 52
Keyboard.NUMBER_5 = 53
Keyboard.NUMBER_6 = 54
Keyboard.NUMBER_7 = 55
Keyboard.NUMBER_8 = 56
Keyboard.NUMBER_9 = 57
Keyboard.A = 65
Keyboard.B = 66
Keyboard.C = 67
Keyboard.D = 68
Keyboard.E = 69
Keyboard.F = 70
Keyboard.G = 71
Keyboard.H = 72
Keyboard.I = 73
Keyboard.J = 74
Keyboard.K = 75
Keyboard.L = 76
Keyboard.M = 77
Keyboard.N = 78
Keyboard.O = 79
Keyboard.P = 80
Keyboard.Q = 81
Keyboard.R = 82
Keyboard.S = 83
Keyboard.T = 84
Keyboard.U = 85
Keyboard.V = 86
Keyboard.W = 87
Keyboard.X = 88
Keyboard.Y = 89
Keyboard.Z = 90
Keyboard.NUMPAD_0 = 96
Keyboard.NUMPAD_1 = 97
Keyboard.NUMPAD_2 = 98
Keyboard.NUMPAD_3 = 99
Keyboard.NUMPAD_4 = 100
Keyboard.NUMPAD_5 = 101
Keyboard.NUMPAD_6 = 102
Keyboard.NUMPAD_7 = 103
Keyboard.NUMPAD_8 = 104
Keyboard.NUMPAD_9 = 105
Keyboard.NUMPAD_MULTIPLY = 106
Keyboard.NUMPAD_ADD = 107
Keyboard.NUMPAD_ENTER = 108
Keyboard.NUMPAD_SUBTRACT = 109
Keyboard.NUMPAD_DECIMAL = 110
Keyboard.NUMPAD_DIVIDE = 111
Keyboard.F1 = 112
Keyboard.F2 = 113
Keyboard.F3 = 114
Keyboard.F4 = 115
Keyboard.F5 = 116
Keyboard.F6 = 117
Keyboard.F7 = 118
Keyboard.F8 = 119
Keyboard.F9 = 120
Keyboard.F10 = 121
Keyboard.F11 = 122
Keyboard.F12 = 123
Keyboard.F13 = 124
Keyboard.F14 = 125
Keyboard.F15 = 126
Keyboard.BACKSPACE = 8
Keyboard.TAB = 9
Keyboard.ALTERNATE = 18
Keyboard.ENTER = 13
Keyboard.COMMAND = 15
Keyboard.SHIFT = 16
Keyboard.CONTROL = 17
Keyboard.BREAK = 19
Keyboard.CAPS_LOCK = 20
Keyboard.NUMPAD = 21
Keyboard.ESCAPE = 27
Keyboard.SPACE = 32
Keyboard.PAGE_UP = 33
Keyboard.PAGE_DOWN = 34
Keyboard.END = 35
Keyboard.HOME = 36
Keyboard.LEFT = 37
Keyboard.RIGHT = 39
Keyboard.UP = 38
Keyboard.DOWN = 40
Keyboard.INSERT = 45
Keyboard.DELETE = 46
Keyboard.NUMLOCK = 144
Keyboard.SEMICOLON = 186
Keyboard.EQUAL = 187
Keyboard.COMMA = 188
Keyboard.MINUS = 189
Keyboard.PERIOD = 190
Keyboard.SLASH = 191
Keyboard.BACKQUOTE = 192
Keyboard.LEFTBRACKET = 219
Keyboard.BACKSLASH = 220
Keyboard.RIGHTBRACKET = 221
Keyboard.QUOTE = 222

// Export

exports.default = Keyboard;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/ui/Mouse.js":
/*!*********************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/ui/Mouse.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.ui.Mouse

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_app_Application() {return __webpack_require__(/*! ./../../lime/app/Application */ "./node_modules/openfl/lib/_gen/lime/app/Application.js");}
function lime_ui_MouseCursor() {return __webpack_require__(/*! ./../../lime/ui/MouseCursor */ "./node_modules/openfl/lib/_gen/lime/ui/MouseCursor.js");}

// Constructor

var Mouse = function(){}

// Meta

Mouse.__name__ = "openfl.ui.Mouse";
Mouse.__isInterface__ = false;
Mouse.prototype = {
	
};
Mouse.prototype.__class__ = Mouse.prototype.constructor = $hxClasses["openfl.ui.Mouse"] = Mouse;

// Init

Object.defineProperty(Mouse,"cursor",{ get : function() {
	return Mouse.get_cursor();
}, set : function(value) {
	return Mouse.set_cursor(value);
}});

// Statics

Mouse.hide = function() {
	Mouse.__hidden = true;
	var _g = 0;
	var _g1 = (lime_app_Application().default).current.get_windows();
	while(_g < _g1.length) {
		var $window = _g1[_g];
		++_g;
		$window.set_cursor(null);
	}
}
Mouse.show = function() {
	Mouse.__hidden = false;
	var cacheCursor = Mouse.__cursor;
	Mouse.__cursor = null;
	Mouse.set_cursor(cacheCursor);
}
Mouse.get_cursor = function() {
	return Mouse.__cursor;
}
Mouse.set_cursor = function(value) {
	if(value == null) {
		value = "auto";
	}
	var setCursor = null;
	switch(value) {
	case "arrow":
		setCursor = (lime_ui_MouseCursor().default).ARROW;
		break;
	case "button":
		setCursor = (lime_ui_MouseCursor().default).POINTER;
		break;
	case "crosshair":
		setCursor = (lime_ui_MouseCursor().default).CROSSHAIR;
		break;
	case "custom":
		setCursor = (lime_ui_MouseCursor().default).CUSTOM;
		break;
	case "hand":
		setCursor = (lime_ui_MouseCursor().default).MOVE;
		break;
	case "ibeam":
		setCursor = (lime_ui_MouseCursor().default).TEXT;
		break;
	case "resize_nesw":
		setCursor = (lime_ui_MouseCursor().default).RESIZE_NESW;
		break;
	case "resize_ns":
		setCursor = (lime_ui_MouseCursor().default).RESIZE_NS;
		break;
	case "resize_nwse":
		setCursor = (lime_ui_MouseCursor().default).RESIZE_NWSE;
		break;
	case "resize_we":
		setCursor = (lime_ui_MouseCursor().default).RESIZE_WE;
		break;
	case "wait":
		setCursor = (lime_ui_MouseCursor().default).WAIT;
		break;
	case "waitarrow":
		setCursor = (lime_ui_MouseCursor().default).WAIT_ARROW;
		break;
	default:
	}
	if(setCursor != null && !Mouse.__hidden) {
		var _g = 0;
		var _g1 = (lime_app_Application().default).current.get_windows();
		while(_g < _g1.length) {
			var $window = _g1[_g];
			++_g;
			$window.set_cursor(setCursor);
		}
	}
	return Mouse.__cursor = value;
}
Mouse.supportsCursor = true
Mouse.supportsNativeCursor = true
Mouse.__cursor = "auto"

// Export

exports.default = Mouse;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/ui/_MouseCursor/MouseCursor_Impl_.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/ui/_MouseCursor/MouseCursor_Impl_.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.ui._MouseCursor.MouseCursor_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_ui_MouseCursor() {return __webpack_require__(/*! ./../../../lime/ui/MouseCursor */ "./node_modules/openfl/lib/_gen/lime/ui/MouseCursor.js");}

// Constructor

var MouseCursor_Impl_ = function(){}

// Meta

MouseCursor_Impl_.__name__ = "openfl.ui._MouseCursor.MouseCursor_Impl_";
MouseCursor_Impl_.__isInterface__ = false;
MouseCursor_Impl_.prototype = {
	
};
MouseCursor_Impl_.prototype.__class__ = MouseCursor_Impl_.prototype.constructor = $hxClasses["openfl.ui._MouseCursor.MouseCursor_Impl_"] = MouseCursor_Impl_;

// Init



// Statics

MouseCursor_Impl_.fromLimeCursor = function(cursor) {
	switch(cursor._hx_index) {
	case 0:
		return "arrow";
	case 1:
		return "crosshair";
	case 2:
		return "auto";
	case 3:
		return "hand";
	case 4:
		return "button";
	case 5:
		return "resize_nesw";
	case 6:
		return "resize_ns";
	case 7:
		return "resize_nwse";
	case 8:
		return "resize_we";
	case 9:
		return "ibeam";
	case 10:
		return "wait";
	case 11:
		return "waitarrow";
	case 12:
		return "custom";
	}
}
MouseCursor_Impl_.toLimeCursor = function(this1) {
	switch(this1) {
	case "arrow":
		return (lime_ui_MouseCursor().default).ARROW;
	case "auto":
		return (lime_ui_MouseCursor().default).DEFAULT;
	case "button":
		return (lime_ui_MouseCursor().default).POINTER;
	case "crosshair":
		return (lime_ui_MouseCursor().default).CROSSHAIR;
	case "custom":
		return (lime_ui_MouseCursor().default).CUSTOM;
	case "hand":
		return (lime_ui_MouseCursor().default).MOVE;
	case "ibeam":
		return (lime_ui_MouseCursor().default).TEXT;
	case "resize_nesw":
		return (lime_ui_MouseCursor().default).RESIZE_NESW;
	case "resize_ns":
		return (lime_ui_MouseCursor().default).RESIZE_NS;
	case "resize_nwse":
		return (lime_ui_MouseCursor().default).RESIZE_NWSE;
	case "resize_we":
		return (lime_ui_MouseCursor().default).RESIZE_WE;
	case "wait":
		return (lime_ui_MouseCursor().default).WAIT;
	case "waitarrow":
		return (lime_ui_MouseCursor().default).WAIT_ARROW;
	default:
		return (lime_ui_MouseCursor().default).DEFAULT;
	}
}
MouseCursor_Impl_.ARROW = "arrow"
MouseCursor_Impl_.AUTO = "auto"
MouseCursor_Impl_.BUTTON = "button"
MouseCursor_Impl_.HAND = "hand"
MouseCursor_Impl_.IBEAM = "ibeam"
MouseCursor_Impl_.__CROSSHAIR = "crosshair"
MouseCursor_Impl_.__CUSTOM = "custom"
MouseCursor_Impl_.__MOVE = "move"
MouseCursor_Impl_.__RESIZE_NESW = "resize_nesw"
MouseCursor_Impl_.__RESIZE_NS = "resize_ns"
MouseCursor_Impl_.__RESIZE_NWSE = "resize_nwse"
MouseCursor_Impl_.__RESIZE_WE = "resize_we"
MouseCursor_Impl_.__WAIT = "wait"
MouseCursor_Impl_.__WAIT_ARROW = "waitarrow"

// Export

exports.default = MouseCursor_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/AGALMiniAssembler.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/AGALMiniAssembler.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils.AGALMiniAssembler

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_Lib() {return __webpack_require__(/*! ./../../openfl/Lib */ "./node_modules/openfl/lib/_gen/openfl/Lib.js");}
function openfl_utils_ByteArrayData() {return __webpack_require__(/*! ./../../openfl/utils/ByteArrayData */ "./node_modules/openfl/lib/_gen/openfl/utils/ByteArrayData.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function EReg() {return __webpack_require__(/*! ./../../EReg */ "./node_modules/openfl/lib/_gen/EReg.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function Std() {return __webpack_require__(/*! ./../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function openfl_utils__$AGALMiniAssembler_Register() {return __webpack_require__(/*! ./../../openfl/utils/_AGALMiniAssembler/Register */ "./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/Register.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function openfl_utils__$AGALMiniAssembler_OpCode() {return __webpack_require__(/*! ./../../openfl/utils/_AGALMiniAssembler/OpCode */ "./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/OpCode.js");}
function openfl_utils__$AGALMiniAssembler_Sampler() {return __webpack_require__(/*! ./../../openfl/utils/_AGALMiniAssembler/Sampler */ "./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/Sampler.js");}

// Constructor

var AGALMiniAssembler = function(debugging) {
	if(debugging == null) {
		debugging = false;
	}
	this.debugEnabled = false;
	this.debugEnabled = debugging;
	if(!AGALMiniAssembler.initialized) {
		AGALMiniAssembler.init();
	}
}

// Meta

AGALMiniAssembler.__name__ = "openfl.utils.AGALMiniAssembler";
AGALMiniAssembler.__isInterface__ = false;
AGALMiniAssembler.prototype = {
	assemble2: function(context3D,version,vertexSource,fragmentSource) {
		var agalVertex = this.assemble("vertex",vertexSource,version);
		var agalFragment = this.assemble("fragment",fragmentSource,version);
		var program = context3D.createProgram();
		program.upload(agalVertex,agalFragment);
		return program;
	},
	assemble: function(mode,source,version,ignoreLimits) {
		if(ignoreLimits == null) {
			ignoreLimits = false;
		}
		if(version == null) {
			version = 1;
		}
		var start = (openfl_Lib().default).getTimer();
		var this1 = new (openfl_utils_ByteArrayData().default)(0);
		this.agalcode = this1;
		this.error = "";
		var isFrag = false;
		if(mode == "fragment") {
			isFrag = true;
		} else if(mode != "vertex") {
			this.error = "ERROR: mode needs to be \"" + "fragment" + "\" or \"" + "vertex" + "\" but is \"" + mode + "\".";
		}
		this.agalcode.set_endian("littleEndian");
		this.agalcode.writeByte(160);
		this.agalcode.writeUnsignedInt(version);
		this.agalcode.writeByte(161);
		this.agalcode.writeByte(isFrag ? 1 : 0);
		this.initregmap(version,ignoreLimits);
		var lines = (StringTools().default).replace(source,"\r","\n").split("\n");
		var nops = 0;
		var lng = lines.length;
		var reg1 = new (EReg().default)("<.*>","g");
		var reg2 = new (EReg().default)("([\\w\\.\\-\\+]+)","gi");
		var reg3 = new (EReg().default)("^\\w{3}","ig");
		var reg4 = new (EReg().default)("vc\\[([vofi][acostdip]?[d]?)(\\d*)?(\\.[xyzw](\\+\\d{1,3})?)?\\](\\.[xyzw]{1,4})?|([vofi][acostdip]?[d]?)(\\d*)?(\\.[xyzw]{1,4})?","gi");
		var reg5 = new (EReg().default)("\\[.*\\]","ig");
		var reg6 = new (EReg().default)("^\\b[A-Za-z]{1,3}","ig");
		var reg7 = new (EReg().default)("\\d+","");
		var reg8 = new (EReg().default)("(\\.[xyzw]{1,4})","");
		var reg9 = new (EReg().default)("[A-Za-z]{1,3}","ig");
		var reg10 = new (EReg().default)("(\\.[xyzw]{1,1})","");
		var reg11 = new (EReg().default)("\\+\\d{1,3}","ig");
		var i = 0;
		while(i < lng && this.error == "") {
			var line = (StringTools().default).trim(lines[i]);
			var startcomment = line.indexOf("//");
			if(startcomment != -1) {
				line = (HxOverrides().default).substr(line,0,startcomment);
			}
			var optsi = reg1.match(line) ? reg1.matchedPos().pos : -1;
			var opts = null;
			if(optsi != -1) {
				opts = this.match((HxOverrides().default).substr(line,optsi,null),reg2);
				line = (HxOverrides().default).substr(line,0,optsi);
			}
			var opCode = null;
			var opFound = null;
			if(reg3.match(line)) {
				opCode = reg3.matched(0);
				opFound = AGALMiniAssembler.OPMAP.get(opCode);
			}
			if(opFound == null) {
				if(line.length >= 3) {
					(lime_utils_Log().default).warn("warning: bad line " + i + ": " + lines[i],{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 262, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
				}
				++i;
				continue;
			}
			if(this.debugEnabled) {
				(lime_utils_Log().default).info(opFound,{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 272, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
			}
			if(opFound == null) {
				if(line.length >= 3) {
					(lime_utils_Log().default).warn("warning: bad line " + i + ": " + lines[i],{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 279, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
				}
				++i;
				continue;
			}
			line = (HxOverrides().default).substr(line,line.indexOf(opFound.name) + opFound.name.length,null);
			if((opFound.flags & 256) != 0 && version < 2) {
				this.error = "error: opcode requires version 2.";
				break;
			}
			if((opFound.flags & 64) != 0 && isFrag) {
				this.error = "error: opcode is only allowed in vertex programs.";
				break;
			}
			if((opFound.flags & 32) != 0 && !isFrag) {
				this.error = "error: opcode is only allowed in fragment programs.";
				break;
			}
			if(this.verbose) {
				(lime_utils_Log().default).info("emit opcode=" + (Std().default).string(opFound),{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 308, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
			}
			this.agalcode.writeUnsignedInt(opFound.emitCode);
			++nops;
			if(nops > 4096) {
				this.error = "error: too many opcodes. maximum is " + 4096 + ".";
				break;
			}
			var regs = this.match(line,reg4);
			if(regs.length != opFound.numRegister) {
				this.error = "error: wrong number of operands. found " + regs.length + " but expected " + opFound.numRegister + ".";
				break;
			}
			var badreg = false;
			var pad = 160;
			var regLength = regs.length;
			var _g = 0;
			var _g1 = regLength;
			while(_g < _g1) {
				var j = _g++;
				var isRelative = false;
				var relreg = this.match(regs[j],reg5);
				if(relreg.length > 0) {
					regs[j] = (StringTools().default).replace(regs[j],relreg[0],"0");
					if(this.verbose) {
						(lime_utils_Log().default).info("IS REL",{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 344, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
					}
					isRelative = true;
				}
				var res = this.match(regs[j],reg6);
				if(res.length == 0) {
					this.error = "error: could not parse operand " + j + " (" + regs[j] + ").";
					badreg = true;
					break;
				}
				var regFound = AGALMiniAssembler.REGMAP.get(res[0]);
				if(this.debugEnabled) {
					(lime_utils_Log().default).info(regFound,{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 363, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
				}
				if(regFound == null) {
					this.error = "error: could not find register name for operand " + j + " (" + regs[j] + ").";
					badreg = true;
					break;
				}
				if(isFrag) {
					if((regFound.flags & 32) == 0) {
						this.error = "error: register operand " + j + " (" + regs[j] + ") only allowed in vertex programs.";
						badreg = true;
						break;
					}
					if(isRelative) {
						this.error = "error: register operand " + j + " (" + regs[j] + ") relative adressing not allowed in fragment programs.";
						badreg = true;
						break;
					}
				} else if((regFound.flags & 64) == 0) {
					this.error = "error: register operand " + j + " (" + regs[j] + ") only allowed in fragment programs.";
					badreg = true;
					break;
				}
				regs[j] = (HxOverrides().default).substr(regs[j],regs[j].indexOf(regFound.name) + regFound.name.length,null);
				var idxmatch = isRelative ? this.match(relreg[0],reg7) : this.match(regs[j],reg7);
				var regidx = 0;
				if(idxmatch.length > 0) {
					regidx = (Std().default).parseInt(idxmatch[0]);
				}
				if((_$UInt_UInt_$Impl_$().default).gt(regidx,regFound.range)) {
					var this2 = regFound.range + 1;
					this.error = "error: register operand " + j + " (" + regs[j] + ") index exceeds limit of " + (Std().default).string(this2 == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(this2)) + ".";
					badreg = true;
					break;
				}
				var regmask = 0;
				var maskmatch = this.match(regs[j],reg8);
				var isDest = j == 0 && (opFound.flags & 128) == 0;
				var isSampler = j == 2 && (opFound.flags & 8) != 0;
				var reltype = 0;
				var relsel = 0;
				var reloffset = 0;
				if(isDest && isRelative) {
					this.error = "error: relative can not be destination";
					badreg = true;
					break;
				}
				if(maskmatch.length > 0) {
					regmask = 0;
					var cv = 0;
					var maskLength = maskmatch[0].length;
					var k = 1;
					while(k < maskLength) {
						cv = (HxOverrides().default).cca(maskmatch[0],k) - 120;
						if((_$UInt_UInt_$Impl_$().default).gt(cv,2)) {
							cv = 3;
						}
						if(isDest) {
							regmask |= 1 << cv;
						} else {
							regmask = regmask | cv << (k - 1 << 1);
						}
						++k;
					}
					if(!isDest) {
						while(k <= 4) {
							regmask = regmask | cv << (k - 1 << 1);
							++k;
						}
					}
				} else {
					regmask = isDest ? 15 : 228;
				}
				if(isRelative) {
					var relname = this.match(relreg[0],reg9);
					var regFoundRel = AGALMiniAssembler.REGMAP.get(relname[0]);
					if(regFoundRel == null) {
						this.error = "error: bad index register";
						badreg = true;
						break;
					}
					reltype = regFoundRel.emitCode;
					var selmatch = this.match(relreg[0],reg10);
					if(selmatch.length == 0) {
						this.error = "error: bad index register select";
						badreg = true;
						break;
					}
					relsel = (HxOverrides().default).cca(selmatch[0],1) - 120;
					if((_$UInt_UInt_$Impl_$().default).gt(relsel,2)) {
						relsel = 3;
					}
					var relofs = this.match(relreg[0],reg11);
					if(relofs.length > 0) {
						reloffset = (Std().default).parseInt(relofs[0]);
					}
					if(reloffset < 0 || reloffset > 255) {
						this.error = "error: index offset " + reloffset + " out of bounds. [0..255]";
						badreg = true;
						break;
					}
					if(this.verbose) {
						(lime_utils_Log().default).info("RELATIVE: type=" + reltype + "==" + relname[0] + " sel=" + (Std().default).string(relsel == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(relsel)) + "==" + selmatch[0] + " idx=" + (Std().default).string(regidx == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(regidx)) + " offset=" + reloffset,{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 518, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
					}
				}
				if(this.verbose) {
					(lime_utils_Log().default).info("  emit argcode=" + (Std().default).string(regFound) + "[" + (Std().default).string(regidx == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(regidx)) + "][" + regmask + "]",{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 525, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
				}
				if(isDest) {
					this.agalcode.writeShort(regidx);
					this.agalcode.writeByte(regmask);
					this.agalcode.writeByte(regFound.emitCode);
					pad -= 32;
				} else if(isSampler) {
					if(this.verbose) {
						(lime_utils_Log().default).info("  emit sampler",{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 541, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
					}
					var samplerbits = 5;
					var optsLength = opts == null ? 0 : opts.length;
					var bias = 0.0;
					var _g2 = 0;
					var _g11 = optsLength;
					while(_g2 < _g11) {
						var k1 = _g2++;
						if(this.verbose) {
							(lime_utils_Log().default).info("    opt: " + opts[k1],{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 552, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
						}
						var optfound = AGALMiniAssembler.SAMPLEMAP.get(opts[k1]);
						if(optfound == null) {
							bias = (Std().default).parseFloat(opts[k1]);
							if(this.verbose) {
								(lime_utils_Log().default).info("    bias: " + bias,{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 565, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
							}
						} else {
							if(optfound.flag != 16) {
								samplerbits &= ~(15 << optfound.flag);
							}
							samplerbits = samplerbits | optfound.mask << optfound.flag;
						}
					}
					this.agalcode.writeShort(regidx);
					this.agalcode.writeByte((Std().default).int(bias * 8.0));
					this.agalcode.writeByte(0);
					this.agalcode.writeUnsignedInt(samplerbits);
					if(this.verbose) {
						(lime_utils_Log().default).info("    bits: " + (samplerbits - 5),{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 586, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
					}
					pad -= 64;
				} else {
					if(j == 0) {
						this.agalcode.writeUnsignedInt(0);
						pad -= 32;
					}
					this.agalcode.writeShort(regidx);
					this.agalcode.writeByte(reloffset);
					this.agalcode.writeByte(regmask);
					this.agalcode.writeByte(regFound.emitCode);
					this.agalcode.writeByte(reltype);
					this.agalcode.writeShort(isRelative ? relsel | 32768 : 0);
					pad -= 64;
				}
			}
			var j1 = 0;
			while(j1 < pad) {
				this.agalcode.writeByte(0);
				j1 += 8;
			}
			if(badreg) {
				break;
			}
			++i;
		}
		if(this.error != "") {
			this.error += "\n  at line " + i + " " + lines[i];
			(openfl_utils__$ByteArray_ByteArray_$Impl_$().default).set_length(this.agalcode,0);
			(lime_utils_Log().default).info(this.error,{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 631, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
		}
		if(this.debugEnabled) {
			var dbgLine = "generated bytecode:";
			var agalLength = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(this.agalcode);
			var _g3 = 0;
			var _g12 = agalLength;
			while(_g3 < _g12) {
				var index = _g3++;
				if(index % 16 == 0) {
					dbgLine += "\n";
				}
				if(index % 4 == 0) {
					dbgLine += " ";
				}
				var byteStr = (StringTools().default).hex(this.agalcode.get(index),2);
				if(byteStr.length < 2) {
					byteStr = "0" + byteStr;
				}
				dbgLine += byteStr;
			}
			(lime_utils_Log().default).info(dbgLine,{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 662, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
		}
		if(this.verbose) {
			(lime_utils_Log().default).info("AGALMiniAssembler.assemble time: " + ((openfl_Lib().default).getTimer() - start) / 1000 + "s",{ fileName : "../src/openfl/utils/AGALMiniAssembler.hx", lineNumber : 667, className : "openfl.utils.AGALMiniAssembler", methodName : "assemble"});
		}
		return this.agalcode;
	},
	initregmap: function(version,ignorelimits) {
		var this1 = AGALMiniAssembler.REGMAP;
		var v = new (openfl_utils__$AGALMiniAssembler_Register().default)("va","vertex attribute",0,ignorelimits ? 1024 : version == 1 || version == 2 ? 7 : 15,66);
		this1.set("va",v);
		var this2 = AGALMiniAssembler.REGMAP;
		var v1 = new (openfl_utils__$AGALMiniAssembler_Register().default)("vc","vertex constant",1,ignorelimits ? 1024 : version == 1 ? 127 : 249,66);
		this2.set("vc",v1);
		var this3 = AGALMiniAssembler.REGMAP;
		var v2 = new (openfl_utils__$AGALMiniAssembler_Register().default)("vt","vertex temporary",2,ignorelimits ? 1024 : version == 1 ? 7 : 25,67);
		this3.set("vt",v2);
		var this4 = AGALMiniAssembler.REGMAP;
		var v3 = new (openfl_utils__$AGALMiniAssembler_Register().default)("vo","vertex output",3,ignorelimits ? 1024 : 0,65);
		this4.set("vo",v3);
		var this5 = AGALMiniAssembler.REGMAP;
		var v4 = new (openfl_utils__$AGALMiniAssembler_Register().default)("vi","varying",4,ignorelimits ? 1024 : version == 1 ? 7 : 9,99);
		this5.set("vi",v4);
		var this6 = AGALMiniAssembler.REGMAP;
		var v5 = new (openfl_utils__$AGALMiniAssembler_Register().default)("fc","fragment constant",1,ignorelimits ? 1024 : version == 1 ? 27 : version == 2 ? 63 : 199,34);
		this6.set("fc",v5);
		var this7 = AGALMiniAssembler.REGMAP;
		var v6 = new (openfl_utils__$AGALMiniAssembler_Register().default)("ft","fragment temporary",2,ignorelimits ? 1024 : version == 1 ? 7 : 25,35);
		this7.set("ft",v6);
		var this8 = AGALMiniAssembler.REGMAP;
		var v7 = new (openfl_utils__$AGALMiniAssembler_Register().default)("fs","texture sampler",5,ignorelimits ? 1024 : 7,34);
		this8.set("fs",v7);
		var this9 = AGALMiniAssembler.REGMAP;
		var v8 = new (openfl_utils__$AGALMiniAssembler_Register().default)("fo","fragment output",3,ignorelimits ? 1024 : version == 1 ? 0 : 3,33);
		this9.set("fo",v8);
		var this10 = AGALMiniAssembler.REGMAP;
		var v9 = new (openfl_utils__$AGALMiniAssembler_Register().default)("fd","fragment depth output",6,ignorelimits ? 1024 : version == 1 ? -1 : 0,33);
		this10.set("fd",v9);
		var this11 = AGALMiniAssembler.REGMAP;
		var v10 = new (openfl_utils__$AGALMiniAssembler_Register().default)("iid","instance id",7,ignorelimits ? 1024 : 0,66);
		this11.set("iid",v10);
		var this12 = AGALMiniAssembler.REGMAP;
		var v11 = AGALMiniAssembler.REGMAP.get("vo");
		this12.set("op",v11);
		var this13 = AGALMiniAssembler.REGMAP;
		var v12 = AGALMiniAssembler.REGMAP.get("vi");
		this13.set("i",v12);
		var this14 = AGALMiniAssembler.REGMAP;
		var v13 = AGALMiniAssembler.REGMAP.get("vi");
		this14.set("v",v13);
		var this15 = AGALMiniAssembler.REGMAP;
		var v14 = AGALMiniAssembler.REGMAP.get("fo");
		this15.set("oc",v14);
		var this16 = AGALMiniAssembler.REGMAP;
		var v15 = AGALMiniAssembler.REGMAP.get("fd");
		this16.set("od",v15);
		var this17 = AGALMiniAssembler.REGMAP;
		var v16 = AGALMiniAssembler.REGMAP.get("vi");
		this17.set("fi",v16);
	},
	match: function(value,reg) {
		var matches = [];
		var index = 0;
		var match;
		while(reg.matchSub(value,index)) {
			match = reg.matched(0);
			matches.push(match);
			index = reg.matchedPos().pos + match.length;
		}
		return matches;
	}
};
AGALMiniAssembler.prototype.__class__ = AGALMiniAssembler.prototype.constructor = $hxClasses["openfl.utils.AGALMiniAssembler"] = AGALMiniAssembler;

// Init



// Statics

AGALMiniAssembler.init = function() {
	AGALMiniAssembler.initialized = true;
	var this1 = AGALMiniAssembler.OPMAP;
	var v = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("mov",2,0,0);
	this1.set("mov",v);
	var this2 = AGALMiniAssembler.OPMAP;
	var v1 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("add",3,1,0);
	this2.set("add",v1);
	var this3 = AGALMiniAssembler.OPMAP;
	var v2 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("sub",3,2,0);
	this3.set("sub",v2);
	var this4 = AGALMiniAssembler.OPMAP;
	var v3 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("mul",3,3,0);
	this4.set("mul",v3);
	var this5 = AGALMiniAssembler.OPMAP;
	var v4 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("div",3,4,0);
	this5.set("div",v4);
	var this6 = AGALMiniAssembler.OPMAP;
	var v5 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("rcp",2,5,0);
	this6.set("rcp",v5);
	var this7 = AGALMiniAssembler.OPMAP;
	var v6 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("min",3,6,0);
	this7.set("min",v6);
	var this8 = AGALMiniAssembler.OPMAP;
	var v7 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("max",3,7,0);
	this8.set("max",v7);
	var this9 = AGALMiniAssembler.OPMAP;
	var v8 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("frc",2,8,0);
	this9.set("frc",v8);
	var this10 = AGALMiniAssembler.OPMAP;
	var v9 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("sqt",2,9,0);
	this10.set("sqt",v9);
	var this11 = AGALMiniAssembler.OPMAP;
	var v10 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("rsq",2,10,0);
	this11.set("rsq",v10);
	var this12 = AGALMiniAssembler.OPMAP;
	var v11 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("pow",3,11,0);
	this12.set("pow",v11);
	var this13 = AGALMiniAssembler.OPMAP;
	var v12 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("log",2,12,0);
	this13.set("log",v12);
	var this14 = AGALMiniAssembler.OPMAP;
	var v13 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("exp",2,13,0);
	this14.set("exp",v13);
	var this15 = AGALMiniAssembler.OPMAP;
	var v14 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("nrm",2,14,0);
	this15.set("nrm",v14);
	var this16 = AGALMiniAssembler.OPMAP;
	var v15 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("sin",2,15,0);
	this16.set("sin",v15);
	var this17 = AGALMiniAssembler.OPMAP;
	var v16 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("cos",2,16,0);
	this17.set("cos",v16);
	var this18 = AGALMiniAssembler.OPMAP;
	var v17 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("crs",3,17,0);
	this18.set("crs",v17);
	var this19 = AGALMiniAssembler.OPMAP;
	var v18 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("dp3",3,18,0);
	this19.set("dp3",v18);
	var this20 = AGALMiniAssembler.OPMAP;
	var v19 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("dp4",3,19,0);
	this20.set("dp4",v19);
	var this21 = AGALMiniAssembler.OPMAP;
	var v20 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("abs",2,20,0);
	this21.set("abs",v20);
	var this22 = AGALMiniAssembler.OPMAP;
	var v21 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("neg",2,21,0);
	this22.set("neg",v21);
	var this23 = AGALMiniAssembler.OPMAP;
	var v22 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("sat",2,22,0);
	this23.set("sat",v22);
	var this24 = AGALMiniAssembler.OPMAP;
	var v23 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("m33",3,23,16);
	this24.set("m33",v23);
	var this25 = AGALMiniAssembler.OPMAP;
	var v24 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("m44",3,24,16);
	this25.set("m44",v24);
	var this26 = AGALMiniAssembler.OPMAP;
	var v25 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("m34",3,25,16);
	this26.set("m34",v25);
	var this27 = AGALMiniAssembler.OPMAP;
	var v26 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("ddx",2,26,288);
	this27.set("ddx",v26);
	var this28 = AGALMiniAssembler.OPMAP;
	var v27 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("ddy",2,27,288);
	this28.set("ddy",v27);
	var this29 = AGALMiniAssembler.OPMAP;
	var v28 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("ife",2,28,897);
	this29.set("ife",v28);
	var this30 = AGALMiniAssembler.OPMAP;
	var v29 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("ine",2,29,897);
	this30.set("ine",v29);
	var this31 = AGALMiniAssembler.OPMAP;
	var v30 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("ifg",2,30,897);
	this31.set("ifg",v30);
	var this32 = AGALMiniAssembler.OPMAP;
	var v31 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("ifl",2,31,897);
	this32.set("ifl",v31);
	var this33 = AGALMiniAssembler.OPMAP;
	var v32 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("els",0,32,1921);
	this33.set("els",v32);
	var this34 = AGALMiniAssembler.OPMAP;
	var v33 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("eif",0,33,1409);
	this34.set("eif",v33);
	var this35 = AGALMiniAssembler.OPMAP;
	var v34 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("kil",1,39,160);
	this35.set("kil",v34);
	var this36 = AGALMiniAssembler.OPMAP;
	var v35 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("tex",3,40,40);
	this36.set("tex",v35);
	var this37 = AGALMiniAssembler.OPMAP;
	var v36 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("sge",3,41,0);
	this37.set("sge",v36);
	var this38 = AGALMiniAssembler.OPMAP;
	var v37 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("slt",3,42,0);
	this38.set("slt",v37);
	var this39 = AGALMiniAssembler.OPMAP;
	var v38 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("sgn",2,43,0);
	this39.set("sgn",v38);
	var this40 = AGALMiniAssembler.OPMAP;
	var v39 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("seq",3,44,0);
	this40.set("seq",v39);
	var this41 = AGALMiniAssembler.OPMAP;
	var v40 = new (openfl_utils__$AGALMiniAssembler_OpCode().default)("sne",3,45,0);
	this41.set("sne",v40);
	var this42 = AGALMiniAssembler.SAMPLEMAP;
	var v41 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("rgba",8,0);
	this42.set("rgba",v41);
	var this43 = AGALMiniAssembler.SAMPLEMAP;
	var v42 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("compressed",8,1);
	this43.set("compressed",v42);
	var this44 = AGALMiniAssembler.SAMPLEMAP;
	var v43 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("compressedalpha",8,2);
	this44.set("compressedalpha",v43);
	var this45 = AGALMiniAssembler.SAMPLEMAP;
	var v44 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("dxt1",8,1);
	this45.set("dxt1",v44);
	var this46 = AGALMiniAssembler.SAMPLEMAP;
	var v45 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("dxt5",8,2);
	this46.set("dxt5",v45);
	var this47 = AGALMiniAssembler.SAMPLEMAP;
	var v46 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("video",8,3);
	this47.set("video",v46);
	var this48 = AGALMiniAssembler.SAMPLEMAP;
	var v47 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("2d",12,0);
	this48.set("2d",v47);
	var this49 = AGALMiniAssembler.SAMPLEMAP;
	var v48 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("3d",12,2);
	this49.set("3d",v48);
	var this50 = AGALMiniAssembler.SAMPLEMAP;
	var v49 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("cube",12,1);
	this50.set("cube",v49);
	var this51 = AGALMiniAssembler.SAMPLEMAP;
	var v50 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("mipnearest",24,1);
	this51.set("mipnearest",v50);
	var this52 = AGALMiniAssembler.SAMPLEMAP;
	var v51 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("miplinear",24,2);
	this52.set("miplinear",v51);
	var this53 = AGALMiniAssembler.SAMPLEMAP;
	var v52 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("mipnone",24,0);
	this53.set("mipnone",v52);
	var this54 = AGALMiniAssembler.SAMPLEMAP;
	var v53 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("nomip",24,0);
	this54.set("nomip",v53);
	var this55 = AGALMiniAssembler.SAMPLEMAP;
	var v54 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("nearest",28,0);
	this55.set("nearest",v54);
	var this56 = AGALMiniAssembler.SAMPLEMAP;
	var v55 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("linear",28,1);
	this56.set("linear",v55);
	var this57 = AGALMiniAssembler.SAMPLEMAP;
	var v56 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("anisotropic2x",28,2);
	this57.set("anisotropic2x",v56);
	var this58 = AGALMiniAssembler.SAMPLEMAP;
	var v57 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("anisotropic4x",28,3);
	this58.set("anisotropic4x",v57);
	var this59 = AGALMiniAssembler.SAMPLEMAP;
	var v58 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("anisotropic8x",28,4);
	this59.set("anisotropic8x",v58);
	var this60 = AGALMiniAssembler.SAMPLEMAP;
	var v59 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("anisotropic16x",28,5);
	this60.set("anisotropic16x",v59);
	var this61 = AGALMiniAssembler.SAMPLEMAP;
	var v60 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("centroid",16,1);
	this61.set("centroid",v60);
	var this62 = AGALMiniAssembler.SAMPLEMAP;
	var v61 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("single",16,2);
	this62.set("single",v61);
	var this63 = AGALMiniAssembler.SAMPLEMAP;
	var v62 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("ignoresampler",16,4);
	this63.set("ignoresampler",v62);
	var this64 = AGALMiniAssembler.SAMPLEMAP;
	var v63 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("repeat",20,1);
	this64.set("repeat",v63);
	var this65 = AGALMiniAssembler.SAMPLEMAP;
	var v64 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("wrap",20,1);
	this65.set("wrap",v64);
	var this66 = AGALMiniAssembler.SAMPLEMAP;
	var v65 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("clamp",20,0);
	this66.set("clamp",v65);
	var this67 = AGALMiniAssembler.SAMPLEMAP;
	var v66 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("clamp_u_repeat_v",20,2);
	this67.set("clamp_u_repeat_v",v66);
	var this68 = AGALMiniAssembler.SAMPLEMAP;
	var v67 = new (openfl_utils__$AGALMiniAssembler_Sampler().default)("repeat_u_clamp_v",20,3);
	this68.set("repeat_u_clamp_v",v67);
}
AGALMiniAssembler.__meta__ = { obj : { SuppressWarnings : [["checkstyle:ConstantName","checkstyle:FieldDocComment"]]}}
AGALMiniAssembler.OPMAP = new (haxe_ds_StringMap().default)()
AGALMiniAssembler.REGMAP = new (haxe_ds_StringMap().default)()
AGALMiniAssembler.SAMPLEMAP = new (haxe_ds_StringMap().default)()
AGALMiniAssembler.MAX_NESTING = 4
AGALMiniAssembler.MAX_OPCODES = 4096
AGALMiniAssembler.FRAGMENT = "fragment"
AGALMiniAssembler.VERTEX = "vertex"
AGALMiniAssembler.SAMPLER_TYPE_SHIFT = 8
AGALMiniAssembler.SAMPLER_DIM_SHIFT = 12
AGALMiniAssembler.SAMPLER_SPECIAL_SHIFT = 16
AGALMiniAssembler.SAMPLER_REPEAT_SHIFT = 20
AGALMiniAssembler.SAMPLER_MIPMAP_SHIFT = 24
AGALMiniAssembler.SAMPLER_FILTER_SHIFT = 28
AGALMiniAssembler.REG_WRITE = 1
AGALMiniAssembler.REG_READ = 2
AGALMiniAssembler.REG_FRAG = 32
AGALMiniAssembler.REG_VERT = 64
AGALMiniAssembler.OP_SCALAR = 1
AGALMiniAssembler.OP_SPECIAL_TEX = 8
AGALMiniAssembler.OP_SPECIAL_MATRIX = 16
AGALMiniAssembler.OP_FRAG_ONLY = 32
AGALMiniAssembler.OP_VERT_ONLY = 64
AGALMiniAssembler.OP_NO_DEST = 128
AGALMiniAssembler.OP_VERSION2 = 256
AGALMiniAssembler.OP_INCNEST = 512
AGALMiniAssembler.OP_DECNEST = 1024
AGALMiniAssembler.MOV = "mov"
AGALMiniAssembler.ADD = "add"
AGALMiniAssembler.SUB = "sub"
AGALMiniAssembler.MUL = "mul"
AGALMiniAssembler.DIV = "div"
AGALMiniAssembler.RCP = "rcp"
AGALMiniAssembler.MIN = "min"
AGALMiniAssembler.MAX = "max"
AGALMiniAssembler.FRC = "frc"
AGALMiniAssembler.SQT = "sqt"
AGALMiniAssembler.RSQ = "rsq"
AGALMiniAssembler.POW = "pow"
AGALMiniAssembler.LOG = "log"
AGALMiniAssembler.EXP = "exp"
AGALMiniAssembler.NRM = "nrm"
AGALMiniAssembler.SIN = "sin"
AGALMiniAssembler.COS = "cos"
AGALMiniAssembler.CRS = "crs"
AGALMiniAssembler.DP3 = "dp3"
AGALMiniAssembler.DP4 = "dp4"
AGALMiniAssembler.ABS = "abs"
AGALMiniAssembler.NEG = "neg"
AGALMiniAssembler.SAT = "sat"
AGALMiniAssembler.M33 = "m33"
AGALMiniAssembler.M44 = "m44"
AGALMiniAssembler.M34 = "m34"
AGALMiniAssembler.DDX = "ddx"
AGALMiniAssembler.DDY = "ddy"
AGALMiniAssembler.IFE = "ife"
AGALMiniAssembler.INE = "ine"
AGALMiniAssembler.IFG = "ifg"
AGALMiniAssembler.IFL = "ifl"
AGALMiniAssembler.IEG = "ieg"
AGALMiniAssembler.IEL = "iel"
AGALMiniAssembler.ELS = "els"
AGALMiniAssembler.EIF = "eif"
AGALMiniAssembler.TED = "ted"
AGALMiniAssembler.KIL = "kil"
AGALMiniAssembler.TEX = "tex"
AGALMiniAssembler.SGE = "sge"
AGALMiniAssembler.SLT = "slt"
AGALMiniAssembler.SGN = "sgn"
AGALMiniAssembler.SEQ = "seq"
AGALMiniAssembler.SNE = "sne"
AGALMiniAssembler.VA = "va"
AGALMiniAssembler.VC = "vc"
AGALMiniAssembler.VT = "vt"
AGALMiniAssembler.VO = "vo"
AGALMiniAssembler.VI = "vi"
AGALMiniAssembler.FC = "fc"
AGALMiniAssembler.FT = "ft"
AGALMiniAssembler.FS = "fs"
AGALMiniAssembler.FO = "fo"
AGALMiniAssembler.FD = "fd"
AGALMiniAssembler.IID = "iid"
AGALMiniAssembler.D2 = "2d"
AGALMiniAssembler.D3 = "3d"
AGALMiniAssembler.CUBE = "cube"
AGALMiniAssembler.MIPNEAREST = "mipnearest"
AGALMiniAssembler.MIPLINEAR = "miplinear"
AGALMiniAssembler.MIPNONE = "mipnone"
AGALMiniAssembler.NOMIP = "nomip"
AGALMiniAssembler.NEAREST = "nearest"
AGALMiniAssembler.LINEAR = "linear"
AGALMiniAssembler.ANISOTROPIC2X = "anisotropic2x"
AGALMiniAssembler.ANISOTROPIC4X = "anisotropic4x"
AGALMiniAssembler.ANISOTROPIC8X = "anisotropic8x"
AGALMiniAssembler.ANISOTROPIC16X = "anisotropic16x"
AGALMiniAssembler.CENTROID = "centroid"
AGALMiniAssembler.SINGLE = "single"
AGALMiniAssembler.IGNORESAMPLER = "ignoresampler"
AGALMiniAssembler.REPEAT = "repeat"
AGALMiniAssembler.WRAP = "wrap"
AGALMiniAssembler.CLAMP = "clamp"
AGALMiniAssembler.REPEAT_U_CLAMP_V = "repeat_u_clamp_v"
AGALMiniAssembler.CLAMP_U_REPEAT_V = "clamp_u_repeat_v"
AGALMiniAssembler.RGBA = "rgba"
AGALMiniAssembler.COMPRESSED = "compressed"
AGALMiniAssembler.COMPRESSEDALPHA = "compressedalpha"
AGALMiniAssembler.DXT1 = "dxt1"
AGALMiniAssembler.DXT5 = "dxt5"
AGALMiniAssembler.VIDEO = "video"
AGALMiniAssembler.initialized = false

// Export

exports.default = AGALMiniAssembler;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/AssetCache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/AssetCache.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils.AssetCache

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function openfl_utils_IAssetCache() {return __webpack_require__(/*! ./../../openfl/utils/IAssetCache */ "./node_modules/openfl/lib/_gen/openfl/utils/IAssetCache.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function StringTools() {return __webpack_require__(/*! ./../../StringTools */ "./node_modules/openfl/lib/_gen/StringTools.js");}
function lime_utils_Assets() {return __webpack_require__(/*! ./../../lime/utils/Assets */ "./node_modules/openfl/lib/_gen/lime/utils/Assets.js");}

// Constructor

var AssetCache = function() {
	this.__enabled = true;
	this.bitmapData = new (haxe_ds_StringMap().default)();
	this.font = new (haxe_ds_StringMap().default)();
	this.sound = new (haxe_ds_StringMap().default)();
}

// Meta

AssetCache.__name__ = "openfl.utils.AssetCache";
AssetCache.__isInterface__ = false;
AssetCache.__interfaces__ = [(openfl_utils_IAssetCache().default)];
AssetCache.prototype = {
	clear: function(prefix) {
		if(prefix == null) {
			this.bitmapData = new (haxe_ds_StringMap().default)();
			this.font = new (haxe_ds_StringMap().default)();
			this.sound = new (haxe_ds_StringMap().default)();
		} else {
			var keys = this.bitmapData.keys();
			var key = keys;
			while(key.hasNext()) {
				var key1 = key.next();
				if((StringTools().default).startsWith(key1,prefix)) {
					this.removeBitmapData(key1);
				}
			}
			var keys1 = this.font.keys();
			var key2 = keys1;
			while(key2.hasNext()) {
				var key3 = key2.next();
				if((StringTools().default).startsWith(key3,prefix)) {
					this.removeFont(key3);
				}
			}
			var keys2 = this.sound.keys();
			var key4 = keys2;
			while(key4.hasNext()) {
				var key5 = key4.next();
				if((StringTools().default).startsWith(key5,prefix)) {
					this.removeSound(key5);
				}
			}
		}
	},
	getBitmapData: function(id) {
		return this.bitmapData.get(id);
	},
	getFont: function(id) {
		return this.font.get(id);
	},
	getSound: function(id) {
		return this.sound.get(id);
	},
	hasBitmapData: function(id) {
		return this.bitmapData.exists(id);
	},
	hasFont: function(id) {
		return this.font.exists(id);
	},
	hasSound: function(id) {
		return this.sound.exists(id);
	},
	removeBitmapData: function(id) {
		(lime_utils_Assets().default).cache.image.remove(id);
		return this.bitmapData.remove(id);
	},
	removeFont: function(id) {
		(lime_utils_Assets().default).cache.font.remove(id);
		return this.font.remove(id);
	},
	removeSound: function(id) {
		(lime_utils_Assets().default).cache.audio.remove(id);
		return this.sound.remove(id);
	},
	setBitmapData: function(id,bitmapData) {
		this.bitmapData.set(id,bitmapData);
	},
	setFont: function(id,font) {
		this.font.set(id,font);
	},
	setSound: function(id,sound) {
		this.sound.set(id,sound);
	},
	get_enabled: function() {
		return this.__enabled;
	},
	set_enabled: function(value) {
		return this.__enabled = value;
	}
};
AssetCache.prototype.__class__ = AssetCache.prototype.constructor = $hxClasses["openfl.utils.AssetCache"] = AssetCache;

// Init

{
	var tmp = AssetCache.prototype;
	var tmp1 = function () { return this.get_enabled (); }
	var tmp2 = function (v) { return this.set_enabled (v); }
	global.Object.defineProperty(tmp,"enabled",{ get : tmp1, set : tmp2});
};

// Statics




// Export

exports.default = AssetCache;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/AssetLibrary.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/AssetLibrary.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils.AssetLibrary

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function lime_utils_AssetLibrary() {return __webpack_require__(/*! ./../../lime/utils/AssetLibrary */ "./node_modules/openfl/lib/_gen/lime/utils/AssetLibrary.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function lime_utils_AssetManifest() {return __webpack_require__(/*! ./../../lime/utils/AssetManifest */ "./node_modules/openfl/lib/_gen/lime/utils/AssetManifest.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}

// Constructor

var AssetLibrary = function() {
	(lime_utils_AssetLibrary().default).call(this);
}

// Meta

AssetLibrary.__name__ = "openfl.utils.AssetLibrary";
AssetLibrary.__isInterface__ = false;
AssetLibrary.__super__ = (lime_utils_AssetLibrary().default);
AssetLibrary.prototype = $extend((lime_utils_AssetLibrary().default).prototype, {
	exists: function(id,type) {
		if(this.__proxy != null) {
			return this.__proxy.exists(id,type);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.exists.call(this,id,type);
		}
	},
	getAsset: function(id,type) {
		if(this.__proxy != null) {
			return this.__proxy.getAsset(id,type);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.getAsset.call(this,id,type);
		}
	},
	getAudioBuffer: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.getAudioBuffer(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.getAudioBuffer.call(this,id);
		}
	},
	getBytes: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.getBytes(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.getBytes.call(this,id);
		}
	},
	getFont: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.getFont(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.getFont.call(this,id);
		}
	},
	getImage: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.getImage(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.getImage.call(this,id);
		}
	},
	getMovieClip: function(id) {
		return null;
	},
	getPath: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.getPath(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.getPath.call(this,id);
		}
	},
	getText: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.getText(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.getText.call(this,id);
		}
	},
	isLocal: function(id,type) {
		if(this.__proxy != null) {
			return this.__proxy.isLocal(id,type);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.isLocal.call(this,id,type);
		}
	},
	list: function(type) {
		if(this.__proxy != null) {
			return this.__proxy.list(type);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.list.call(this,type);
		}
	},
	loadAsset: function(id,type) {
		if(this.__proxy != null) {
			return this.__proxy.loadAsset(id,type);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.loadAsset.call(this,id,type);
		}
	},
	load: function() {
		if(this.__proxy != null) {
			return this.__proxy.load();
		} else {
			return (lime_utils_AssetLibrary().default).prototype.load.call(this);
		}
	},
	loadAudioBuffer: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.loadAudioBuffer(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.loadAudioBuffer.call(this,id);
		}
	},
	loadBytes: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.loadBytes(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.loadBytes.call(this,id);
		}
	},
	loadFont: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.loadFont(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.loadFont.call(this,id);
		}
	},
	loadImage: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.loadImage(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.loadImage.call(this,id);
		}
	},
	loadMovieClip: function(id) {
		return (lime_app_Future().default).withValue(this.getMovieClip(id));
	},
	loadText: function(id) {
		if(this.__proxy != null) {
			return this.__proxy.loadText(id);
		} else {
			return (lime_utils_AssetLibrary().default).prototype.loadText.call(this,id);
		}
	},
	unload: function() {
		if(this.__proxy != null) {
			this.__proxy.unload();
			return;
		} else {
			(lime_utils_AssetLibrary().default).prototype.unload.call(this);
			return;
		}
	}
});
AssetLibrary.prototype.__class__ = AssetLibrary.prototype.constructor = $hxClasses["openfl.utils.AssetLibrary"] = AssetLibrary;

// Init



// Statics

AssetLibrary.fromBytes = function(bytes,rootPath) {
	return AssetLibrary.fromManifest((lime_utils_AssetManifest().default).fromBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(bytes),rootPath));
}
AssetLibrary.fromFile = function(path,rootPath) {
	return AssetLibrary.fromManifest((lime_utils_AssetManifest().default).fromFile(path,rootPath));
}
AssetLibrary.fromManifest = function(manifest) {
	var library = (lime_utils_AssetLibrary().default).fromManifest(manifest);
	if(library != null) {
		if(((library) instanceof AssetLibrary)) {
			return library;
		} else {
			var _library = new AssetLibrary();
			_library.__proxy = library;
			return _library;
		}
	} else {
		return null;
	}
}
AssetLibrary.loadFromBytes = function(bytes,rootPath) {
	return (lime_utils_AssetManifest().default).loadFromBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toBytes(bytes),rootPath).then(function(manifest) {
		return AssetLibrary.loadFromManifest(manifest);
	});
}
AssetLibrary.loadFromFile = function(path,rootPath) {
	return (lime_utils_AssetManifest().default).loadFromFile(path,rootPath).then(function(manifest) {
		return AssetLibrary.loadFromManifest(manifest);
	});
}
AssetLibrary.loadFromManifest = function(manifest) {
	var library = AssetLibrary.fromManifest(manifest);
	if(library != null) {
		return library.load().then(function(library1) {
			return (lime_app_Future().default).withValue(library1);
		});
	} else {
		return (lime_app_Future().default).withError("Could not load asset manifest");
	}
}


// Export

exports.default = AssetLibrary;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/Assets.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/Assets.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils.Assets

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $bind = __webpack_require__(/*! ./../../bind_stub */ "./node_modules/openfl/lib/_gen/bind_stub.js").default;
function openfl_utils_AssetCache() {return __webpack_require__(/*! ./../../openfl/utils/AssetCache */ "./node_modules/openfl/lib/_gen/openfl/utils/AssetCache.js");}
function openfl_events_EventDispatcher() {return __webpack_require__(/*! ./../../openfl/events/EventDispatcher */ "./node_modules/openfl/lib/_gen/openfl/events/EventDispatcher.js");}
function lime_utils_Assets() {return __webpack_require__(/*! ./../../lime/utils/Assets */ "./node_modules/openfl/lib/_gen/lime/utils/Assets.js");}
function openfl_display_BitmapData() {return __webpack_require__(/*! ./../../openfl/display/BitmapData */ "./node_modules/openfl/lib/_gen/openfl/display/BitmapData.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function openfl_text_Font() {return __webpack_require__(/*! ./../../openfl/text/Font */ "./node_modules/openfl/lib/_gen/openfl/text/Font.js");}
function HxOverrides() {return __webpack_require__(/*! ./../../HxOverrides */ "./node_modules/openfl/lib/_gen/HxOverrides.js");}
function openfl_utils_AssetLibrary() {return __webpack_require__(/*! ./../../openfl/utils/AssetLibrary */ "./node_modules/openfl/lib/_gen/openfl/utils/AssetLibrary.js");}
function lime_utils_Log() {return __webpack_require__(/*! ./../../lime/utils/Log */ "./node_modules/openfl/lib/_gen/lime/utils/Log.js");}
function openfl_media_Sound() {return __webpack_require__(/*! ./../../openfl/media/Sound */ "./node_modules/openfl/lib/_gen/openfl/media/Sound.js");}
function lime_app_Promise() {return __webpack_require__(/*! ./../../lime/app/Promise */ "./node_modules/openfl/lib/_gen/lime/app/Promise.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function Type() {return __webpack_require__(/*! ./../../Type */ "./node_modules/openfl/lib/_gen/Type.js");}
function openfl_events_Event() {return __webpack_require__(/*! ./../../openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");}

// Constructor

var Assets = function(){}

// Meta

Assets.__name__ = "openfl.utils.Assets";
Assets.__isInterface__ = false;
Assets.prototype = {
	
};
Assets.prototype.__class__ = Assets.prototype.constructor = $hxClasses["openfl.utils.Assets"] = Assets;

// Init



// Statics

Assets.addEventListener = function(type,listener,useCapture,priority,useWeakReference) {
	if(useWeakReference == null) {
		useWeakReference = false;
	}
	if(priority == null) {
		priority = 0;
	}
	if(useCapture == null) {
		useCapture = false;
	}
	if(!(lime_utils_Assets().default).onChange.has(Assets.LimeAssets_onChange)) {
		(lime_utils_Assets().default).onChange.add(Assets.LimeAssets_onChange);
	}
	Assets.dispatcher.addEventListener(type,listener,useCapture,priority,useWeakReference);
}
Assets.dispatchEvent = function(event) {
	return Assets.dispatcher.dispatchEvent(event);
}
Assets.exists = function(id,type) {
	return (lime_utils_Assets().default).exists(id,type);
}
Assets.getBitmapData = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache && Assets.cache.get_enabled() && Assets.cache.hasBitmapData(id)) {
		var bitmapData = Assets.cache.getBitmapData(id);
		if(Assets.isValidBitmapData(bitmapData)) {
			return bitmapData;
		}
	}
	var image = (lime_utils_Assets().default).getImage(id,false);
	if(image != null) {
		var bitmapData1 = (openfl_display_BitmapData().default).fromImage(image);
		if(useCache && Assets.cache.get_enabled()) {
			Assets.cache.setBitmapData(id,bitmapData1);
		}
		return bitmapData1;
	}
	return null;
}
Assets.getBytes = function(id) {
	return (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes((lime_utils_Assets().default).getBytes(id));
}
Assets.getFont = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache && Assets.cache.get_enabled() && Assets.cache.hasFont(id)) {
		return Assets.cache.getFont(id);
	}
	var limeFont = (lime_utils_Assets().default).getFont(id,false);
	if(limeFont != null) {
		var font = new (openfl_text_Font().default)();
		font.__fromLimeFont(limeFont);
		if(useCache && Assets.cache.get_enabled()) {
			Assets.cache.setFont(id,font);
		}
		return font;
	}
	return new (openfl_text_Font().default)();
}
Assets.getLibrary = function(name) {
	return (lime_utils_Assets().default).getLibrary(name);
}
Assets.getMovieClip = function(id) {
	var libraryName = id.substring(0,id.indexOf(":"));
	var symbolName = (HxOverrides().default).substr(id,id.indexOf(":") + 1,null);
	var limeLibrary = Assets.getLibrary(libraryName);
	if(limeLibrary != null) {
		if(((limeLibrary) instanceof (openfl_utils_AssetLibrary().default))) {
			var library = limeLibrary;
			if(library.exists(symbolName,"MOVIE_CLIP")) {
				if(library.isLocal(symbolName,"MOVIE_CLIP")) {
					return library.getMovieClip(symbolName);
				} else {
					(lime_utils_Log().default).error("MovieClip asset \"" + id + "\" exists, but only asynchronously",{ fileName : "../src/openfl/utils/Assets.hx", lineNumber : 207, className : "openfl.utils.Assets", methodName : "getMovieClip"});
					return null;
				}
			}
		}
		(lime_utils_Log().default).error("There is no MovieClip asset with an ID of \"" + id + "\"",{ fileName : "../src/openfl/utils/Assets.hx", lineNumber : 213, className : "openfl.utils.Assets", methodName : "getMovieClip"});
	} else {
		(lime_utils_Log().default).error("There is no asset library named \"" + libraryName + "\"",{ fileName : "../src/openfl/utils/Assets.hx", lineNumber : 217, className : "openfl.utils.Assets", methodName : "getMovieClip"});
	}
	return null;
}
Assets.getMusic = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return Assets.getSound(id,useCache);
}
Assets.getPath = function(id) {
	return (lime_utils_Assets().default).getPath(id);
}
Assets.getSound = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache && Assets.cache.get_enabled() && Assets.cache.hasSound(id)) {
		var sound = Assets.cache.getSound(id);
		if(Assets.isValidSound(sound)) {
			return sound;
		}
	}
	var buffer = (lime_utils_Assets().default).getAudioBuffer(id,false);
	if(buffer != null) {
		var sound1 = (openfl_media_Sound().default).fromAudioBuffer(buffer);
		if(useCache && Assets.cache.get_enabled()) {
			Assets.cache.setSound(id,sound1);
		}
		return sound1;
	}
	return null;
}
Assets.getText = function(id) {
	return (lime_utils_Assets().default).getText(id);
}
Assets.hasEventListener = function(type) {
	return Assets.dispatcher.hasEventListener(type);
}
Assets.hasLibrary = function(name) {
	return (lime_utils_Assets().default).hasLibrary(name);
}
Assets.isLocal = function(id,type,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache && Assets.cache.get_enabled()) {
		if(type == "IMAGE" || type == null) {
			if(Assets.cache.hasBitmapData(id)) {
				return true;
			}
		}
		if(type == "FONT" || type == null) {
			if(Assets.cache.hasFont(id)) {
				return true;
			}
		}
		if(type == "SOUND" || type == "MUSIC" || type == null) {
			if(Assets.cache.hasSound(id)) {
				return true;
			}
		}
	}
	var libraryName = id.substring(0,id.indexOf(":"));
	var symbolName = (HxOverrides().default).substr(id,id.indexOf(":") + 1,null);
	var library = Assets.getLibrary(libraryName);
	if(library != null) {
		return library.isLocal(symbolName,type);
	}
	return false;
}
Assets.isValidBitmapData = function(bitmapData) {
	return bitmapData != null && bitmapData.image != null;
}
Assets.isValidSound = function(sound) {
	return true;
}
Assets.list = function(type) {
	return (lime_utils_Assets().default).list(type);
}
Assets.loadBitmapData = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache == null) {
		useCache = true;
	}
	var promise = new (lime_app_Promise().default)();
	if(useCache && Assets.cache.get_enabled() && Assets.cache.hasBitmapData(id)) {
		var bitmapData = Assets.cache.getBitmapData(id);
		if(Assets.isValidBitmapData(bitmapData)) {
			promise.complete(bitmapData);
			return promise.future;
		}
	}
	(lime_utils_Assets().default).loadImage(id,false).onComplete(function(image) {
		if(image != null) {
			var bitmapData1 = (openfl_display_BitmapData().default).fromImage(image);
			if(useCache && Assets.cache.get_enabled()) {
				Assets.cache.setBitmapData(id,bitmapData1);
			}
			promise.complete(bitmapData1);
		} else {
			promise.error("[Assets] Could not load Image \"" + id + "\"");
		}
	}).onError($bind(promise,promise.error)).onProgress($bind(promise,promise.progress));
	return promise.future;
}
Assets.loadBytes = function(id) {
	var promise = new (lime_app_Promise().default)();
	var future = (lime_utils_Assets().default).loadBytes(id);
	future.onComplete(function(bytes) {
		promise.complete((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(bytes));
	});
	future.onProgress(function(progress,total) {
		promise.progress(progress,total);
	});
	future.onError(function(msg) {
		promise.error(msg);
	});
	return promise.future;
}
Assets.loadFont = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache == null) {
		useCache = true;
	}
	var promise = new (lime_app_Promise().default)();
	if(useCache && Assets.cache.get_enabled() && Assets.cache.hasFont(id)) {
		var tmp = Assets.cache.getFont(id);
		promise.complete(tmp);
		return promise.future;
	}
	(lime_utils_Assets().default).loadFont(id).onComplete(function(limeFont) {
		var font = new (openfl_text_Font().default)();
		font.__fromLimeFont(limeFont);
		if(useCache && Assets.cache.get_enabled()) {
			Assets.cache.setFont(id,font);
		}
		promise.complete(font);
	}).onError($bind(promise,promise.error)).onProgress($bind(promise,promise.progress));
	return promise.future;
}
Assets.loadLibrary = function(name) {
	return (lime_utils_Assets().default).loadLibrary(name).then(function(library) {
		var _library = null;
		if(library != null) {
			if(((library) instanceof (openfl_utils_AssetLibrary().default))) {
				_library = library;
			} else {
				_library = new (openfl_utils_AssetLibrary().default)();
				_library.__proxy = library;
				(lime_utils_Assets().default).registerLibrary(name,_library);
			}
		}
		return (lime_app_Future().default).withValue(_library);
	});
}
Assets.loadMusic = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache == null) {
		useCache = true;
	}
	var future = new (lime_app_Future().default)(function() {
		return Assets.getMusic(id,useCache);
	});
	return future;
}
Assets.loadMovieClip = function(id) {
	var promise = new (lime_app_Promise().default)();
	var libraryName = id.substring(0,id.indexOf(":"));
	var symbolName = (HxOverrides().default).substr(id,id.indexOf(":") + 1,null);
	var limeLibrary = Assets.getLibrary(libraryName);
	if(limeLibrary != null) {
		if(((limeLibrary) instanceof (openfl_utils_AssetLibrary().default))) {
			var library = limeLibrary;
			if(library.exists(symbolName,"MOVIE_CLIP")) {
				promise.completeWith(library.loadMovieClip(symbolName));
				return promise.future;
			}
		}
		promise.error("[Assets] There is no MovieClip asset with an ID of \"" + id + "\"");
	} else {
		promise.error("[Assets] There is no asset library named \"" + libraryName + "\"");
	}
	return promise.future;
}
Assets.loadSound = function(id,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	if(useCache == null) {
		useCache = true;
	}
	var promise = new (lime_app_Promise().default)();
	(lime_utils_Assets().default).loadAudioBuffer(id,useCache).onComplete(function(buffer) {
		if(buffer != null) {
			var sound = (openfl_media_Sound().default).fromAudioBuffer(buffer);
			if(useCache && Assets.cache.get_enabled()) {
				Assets.cache.setSound(id,sound);
			}
			promise.complete(sound);
		} else {
			promise.error("[Assets] Could not load Sound \"" + id + "\"");
		}
	}).onError($bind(promise,promise.error)).onProgress($bind(promise,promise.progress));
	return promise.future;
}
Assets.loadText = function(id) {
	var future = (lime_utils_Assets().default).loadText(id);
	return future;
}
Assets.registerLibrary = function(name,library) {
	(lime_utils_Assets().default).registerLibrary(name,library);
}
Assets.removeEventListener = function(type,listener,capture) {
	if(capture == null) {
		capture = false;
	}
	Assets.dispatcher.removeEventListener(type,listener,capture);
}
Assets.resolveClass = function(name) {
	return (Type().default).resolveClass(name);
}
Assets.resolveEnum = function(name) {
	var value = (Type().default).resolveEnum(name);
	return value;
}
Assets.unloadLibrary = function(name) {
	(lime_utils_Assets().default).unloadLibrary(name);
}
Assets.LimeAssets_onChange = function() {
	Assets.dispatchEvent(new (openfl_events_Event().default)("change"));
}
Assets.cache = new (openfl_utils_AssetCache().default)()
Assets.dispatcher = new (openfl_events_EventDispatcher().default)()

// Export

exports.default = Assets;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/ByteArrayData.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/ByteArrayData.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils.ByteArrayData

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
var $extend = __webpack_require__(/*! ./../../extend_stub */ "./node_modules/openfl/lib/_gen/extend_stub.js").default;
function openfl_utils_IDataOutput() {return __webpack_require__(/*! ./../../openfl/utils/IDataOutput */ "./node_modules/openfl/lib/_gen/openfl/utils/IDataOutput.js");}
function openfl_utils_IDataInput() {return __webpack_require__(/*! ./../../openfl/utils/IDataInput */ "./node_modules/openfl/lib/_gen/openfl/utils/IDataInput.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function lime_utils__$Bytes_Bytes_$Impl_$() {return __webpack_require__(/*! ./../../lime/utils/_Bytes/Bytes_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js");}
function lime_utils_CompressionAlgorithm() {return __webpack_require__(/*! ./../../lime/utils/CompressionAlgorithm */ "./node_modules/openfl/lib/_gen/lime/utils/CompressionAlgorithm.js");}
function js__$Boot_HaxeError() {return __webpack_require__(/*! ./../../js/_Boot/HaxeError */ "./node_modules/openfl/lib/_gen/js/_Boot/HaxeError.js");}
function openfl_errors_EOFError() {return __webpack_require__(/*! ./../../openfl/errors/EOFError */ "./node_modules/openfl/lib/_gen/openfl/errors/EOFError.js");}
function haxe_io_FPHelper() {return __webpack_require__(/*! ./../../haxe/io/FPHelper */ "./node_modules/openfl/lib/_gen/haxe/io/FPHelper.js");}
function haxe_io_BytesInput() {return __webpack_require__(/*! ./../../haxe/io/BytesInput */ "./node_modules/openfl/lib/_gen/haxe/io/BytesInput.js");}
function format_amf_Reader() {return __webpack_require__(/*! ./../../format/amf/Reader */ "./node_modules/openfl/lib/_gen/format/amf/Reader.js");}
function format_amf3_Reader() {return __webpack_require__(/*! ./../../format/amf3/Reader */ "./node_modules/openfl/lib/_gen/format/amf3/Reader.js");}
function haxe_Unserializer() {return __webpack_require__(/*! ./../../haxe/Unserializer */ "./node_modules/openfl/lib/_gen/haxe/Unserializer.js");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return __webpack_require__(/*! ./../../openfl/utils/_ByteArray/ByteArray_Impl_ */ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js");}
function format_amf_Tools() {return __webpack_require__(/*! ./../../format/amf/Tools */ "./node_modules/openfl/lib/_gen/format/amf/Tools.js");}
function haxe_io_BytesOutput() {return __webpack_require__(/*! ./../../haxe/io/BytesOutput */ "./node_modules/openfl/lib/_gen/haxe/io/BytesOutput.js");}
function format_amf_Writer() {return __webpack_require__(/*! ./../../format/amf/Writer */ "./node_modules/openfl/lib/_gen/format/amf/Writer.js");}
function format_amf3_Tools() {return __webpack_require__(/*! ./../../format/amf3/Tools */ "./node_modules/openfl/lib/_gen/format/amf3/Tools.js");}
function format_amf3_Writer() {return __webpack_require__(/*! ./../../format/amf3/Writer */ "./node_modules/openfl/lib/_gen/format/amf3/Writer.js");}
function haxe_Serializer() {return __webpack_require__(/*! ./../../haxe/Serializer */ "./node_modules/openfl/lib/_gen/haxe/Serializer.js");}
function Reflect() {return __webpack_require__(/*! ./../../Reflect */ "./node_modules/openfl/lib/_gen/Reflect.js");}
function haxe_ds_IntMap() {return __webpack_require__(/*! ./../../haxe/ds/IntMap */ "./node_modules/openfl/lib/_gen/haxe/ds/IntMap.js");}
function haxe_ds_StringMap() {return __webpack_require__(/*! ./../../haxe/ds/StringMap */ "./node_modules/openfl/lib/_gen/haxe/ds/StringMap.js");}
function haxe_ds_ObjectMap() {return __webpack_require__(/*! ./../../haxe/ds/ObjectMap */ "./node_modules/openfl/lib/_gen/haxe/ds/ObjectMap.js");}
function lime_system_System() {return __webpack_require__(/*! ./../../lime/system/System */ "./node_modules/openfl/lib/_gen/lime/system/System.js");}
function lime_system_Endian() {return __webpack_require__(/*! ./../../lime/system/Endian */ "./node_modules/openfl/lib/_gen/lime/system/Endian.js");}

// Constructor

var ByteArrayData = function(length) {
	if(length == null) {
		length = 0;
	}
	var bytes = (haxe_io_Bytes().default).alloc(length);
	(haxe_io_Bytes().default).call(this,bytes.b.buffer);
	this.__length = length;
	this.set_endian(ByteArrayData.get_defaultEndian());
	this.objectEncoding = ByteArrayData.defaultObjectEncoding;
	this.position = 0;
}

// Meta

ByteArrayData.__name__ = "openfl.utils.ByteArrayData";
ByteArrayData.__isInterface__ = false;
ByteArrayData.__interfaces__ = [(openfl_utils_IDataOutput().default),(openfl_utils_IDataInput().default)];
ByteArrayData.__super__ = (haxe_io_Bytes().default);
ByteArrayData.prototype = $extend((haxe_io_Bytes().default).prototype, {
	clear: function() {
		this.set_length(0);
		this.position = 0;
	},
	compress: function(algorithm) {
		if(algorithm == null) {
			algorithm = "zlib";
		}
		if(this.__length > this.l) {
			var cacheLength = this.l;
			this.l = this.__length;
			var data = (haxe_io_Bytes().default).alloc(cacheLength);
			data.blit(0,this,0,cacheLength);
			this.__setData(data);
			this.l = cacheLength;
		}
		var limeBytes = this;
		var bytes;
		switch(algorithm) {
		case "deflate":
			bytes = (lime_utils__$Bytes_Bytes_$Impl_$().default).compress(limeBytes,(lime_utils_CompressionAlgorithm().default).DEFLATE);
			break;
		case "lzma":
			bytes = (lime_utils__$Bytes_Bytes_$Impl_$().default).compress(limeBytes,(lime_utils_CompressionAlgorithm().default).LZMA);
			break;
		default:
			bytes = (lime_utils__$Bytes_Bytes_$Impl_$().default).compress(limeBytes,(lime_utils_CompressionAlgorithm().default).ZLIB);
		}
		if(bytes != null) {
			this.__setData(bytes);
			this.l = this.__length;
			this.position = this.l;
		}
	},
	deflate: function() {
		this.compress("deflate");
	},
	inflate: function() {
		this.uncompress("deflate");
	},
	readBoolean: function() {
		if(this.position < this.l) {
			return this.get(this.position++) != 0;
		} else {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_EOFError().default)());
		}
	},
	readByte: function() {
		var value = this.readUnsignedByte();
		if((value & 128) != 0) {
			return value - 256;
		} else {
			return value;
		}
	},
	readBytes: function(bytes,offset,length) {
		if(length == null) {
			length = 0;
		}
		if(offset == null) {
			offset = 0;
		}
		if(length == 0) {
			length = this.l - this.position;
		}
		if(this.position + length > this.l) {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_EOFError().default)());
		}
		if(bytes.get_length() < offset + length) {
			bytes.__resize(offset + length);
		}
		bytes.blit(offset,this,this.position,length);
		this.position += length;
	},
	readDouble: function() {
		if(this.get_endian() == "littleEndian") {
			if(this.position + 8 > this.l) {
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_EOFError().default)());
			}
			this.position += 8;
			return this.getDouble(this.position - 8);
		} else {
			var ch1 = this.readInt();
			var ch2 = this.readInt();
			return (haxe_io_FPHelper().default).i64ToDouble(ch2,ch1);
		}
	},
	readFloat: function() {
		if(this.get_endian() == "littleEndian") {
			if(this.position + 4 > this.l) {
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_EOFError().default)());
			}
			this.position += 4;
			return this.getFloat(this.position - 4);
		} else {
			return (haxe_io_FPHelper().default).i32ToFloat(this.readInt());
		}
	},
	readInt: function() {
		var ch1 = this.readUnsignedByte();
		var ch2 = this.readUnsignedByte();
		var ch3 = this.readUnsignedByte();
		var ch4 = this.readUnsignedByte();
		if(this.get_endian() == "littleEndian") {
			return ch4 << 24 | ch3 << 16 | ch2 << 8 | ch1;
		} else {
			return ch1 << 24 | ch2 << 16 | ch3 << 8 | ch4;
		}
	},
	readMultiByte: function(length,charSet) {
		return this.readUTFBytes(length);
	},
	readObject: function() {
		switch(this.objectEncoding) {
		case 0:
			var input = new (haxe_io_BytesInput().default)(this,this.position);
			var reader = new (format_amf_Reader().default)(input);
			var data = ByteArrayData.unwrapAMFValue(reader.read());
			this.position = input.get_position();
			return data;
		case 3:
			var input1 = new (haxe_io_BytesInput().default)(this,this.position);
			var reader1 = new (format_amf3_Reader().default)(input1);
			var data1 = ByteArrayData.unwrapAMF3Value(reader1.read());
			this.position = input1.get_position();
			return data1;
		case 10:
			var data2 = this.readUTF();
			return (haxe_Unserializer().default).run(data2);
		case 12:
			var data3 = this.readUTF();
			return JSON.parse(data3);
		default:
			return null;
		}
	},
	readShort: function() {
		var ch1 = this.readUnsignedByte();
		var ch2 = this.readUnsignedByte();
		var value;
		if(this.get_endian() == "littleEndian") {
			value = ch2 << 8 | ch1;
		} else {
			value = ch1 << 8 | ch2;
		}
		if((value & 32768) != 0) {
			return value - 65536;
		} else {
			return value;
		}
	},
	readUnsignedByte: function() {
		if(this.position < this.l) {
			return this.get(this.position++);
		} else {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_EOFError().default)());
		}
	},
	readUnsignedInt: function() {
		var ch1 = this.readUnsignedByte();
		var ch2 = this.readUnsignedByte();
		var ch3 = this.readUnsignedByte();
		var ch4 = this.readUnsignedByte();
		if(this.get_endian() == "littleEndian") {
			return ch4 << 24 | ch3 << 16 | ch2 << 8 | ch1;
		} else {
			return ch1 << 24 | ch2 << 16 | ch3 << 8 | ch4;
		}
	},
	readUnsignedShort: function() {
		var ch1 = this.readUnsignedByte();
		var ch2 = this.readUnsignedByte();
		if(this.get_endian() == "littleEndian") {
			return (ch2 << 8) + ch1;
		} else {
			return ch1 << 8 | ch2;
		}
	},
	readUTF: function() {
		var bytesCount = this.readUnsignedShort();
		return this.readUTFBytes(bytesCount);
	},
	readUTFBytes: function(length) {
		if(this.position + length > this.l) {
			throw new (js__$Boot_HaxeError().default)(new (openfl_errors_EOFError().default)());
		}
		this.position += length;
		return this.getString(this.position - length,length);
	},
	uncompress: function(algorithm) {
		if(algorithm == null) {
			algorithm = "zlib";
		}
		if(this.__length > this.l) {
			var cacheLength = this.l;
			this.l = this.__length;
			var data = (haxe_io_Bytes().default).alloc(cacheLength);
			data.blit(0,this,0,cacheLength);
			this.__setData(data);
			this.l = cacheLength;
		}
		var limeBytes = this;
		var bytes;
		switch(algorithm) {
		case "deflate":
			bytes = (lime_utils__$Bytes_Bytes_$Impl_$().default).decompress(limeBytes,(lime_utils_CompressionAlgorithm().default).DEFLATE);
			break;
		case "lzma":
			bytes = (lime_utils__$Bytes_Bytes_$Impl_$().default).decompress(limeBytes,(lime_utils_CompressionAlgorithm().default).LZMA);
			break;
		default:
			bytes = (lime_utils__$Bytes_Bytes_$Impl_$().default).decompress(limeBytes,(lime_utils_CompressionAlgorithm().default).ZLIB);
		}
		if(bytes != null) {
			this.__setData(bytes);
			this.l = this.__length;
		}
		this.position = 0;
	},
	writeBoolean: function(value) {
		this.writeByte(value ? 1 : 0);
	},
	writeByte: function(value) {
		this.__resize(this.position + 1);
		this.set(this.position++,value & 255);
	},
	writeBytes: function(bytes,offset,length) {
		if(length == null) {
			length = 0;
		}
		if(offset == null) {
			offset = 0;
		}
		if((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(bytes) == 0) {
			return;
		}
		if(length == 0) {
			length = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).get_length(bytes) - offset;
		}
		this.__resize(this.position + length);
		this.blit(this.position,bytes,offset,length);
		this.position = this.position + length;
	},
	writeDouble: function(value) {
		var int64 = (haxe_io_FPHelper().default).doubleToI64(value);
		if(this.get_endian() == "littleEndian") {
			this.writeInt(int64.low);
			this.writeInt(int64.high);
		} else {
			this.writeInt(int64.high);
			this.writeInt(int64.low);
		}
	},
	writeFloat: function(value) {
		if(this.get_endian() == "littleEndian") {
			this.__resize(this.position + 4);
			this.setFloat(this.position,value);
			this.position += 4;
		} else {
			var int = (haxe_io_FPHelper().default).floatToI32(value);
			this.writeInt(int);
		}
	},
	writeInt: function(value) {
		this.__resize(this.position + 4);
		if(this.get_endian() == "littleEndian") {
			this.set(this.position++,value & 255);
			this.set(this.position++,value >> 8 & 255);
			this.set(this.position++,value >> 16 & 255);
			this.set(this.position++,value >> 24 & 255);
		} else {
			this.set(this.position++,value >> 24 & 255);
			this.set(this.position++,value >> 16 & 255);
			this.set(this.position++,value >> 8 & 255);
			this.set(this.position++,value & 255);
		}
	},
	writeMultiByte: function(value,charSet) {
		this.writeUTFBytes(value);
	},
	writeObject: function(object) {
		switch(this.objectEncoding) {
		case 0:
			var value = (format_amf_Tools().default).encode(object);
			var output = new (haxe_io_BytesOutput().default)();
			var writer = new (format_amf_Writer().default)(output);
			writer.write(value);
			this.writeBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(output.getBytes()));
			break;
		case 3:
			var value1 = (format_amf3_Tools().default).encode(object);
			var output1 = new (haxe_io_BytesOutput().default)();
			var writer1 = new (format_amf3_Writer().default)(output1);
			writer1.write(value1);
			this.writeBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(output1.getBytes()));
			break;
		case 10:
			var value2 = (haxe_Serializer().default).run(object);
			this.writeUTF(value2);
			break;
		case 12:
			var value3 = JSON.stringify(object);
			this.writeUTF(value3);
			break;
		default:
			return;
		}
	},
	writeShort: function(value) {
		this.__resize(this.position + 2);
		if(this.get_endian() == "littleEndian") {
			this.set(this.position++,value);
			this.set(this.position++,value >> 8);
		} else {
			this.set(this.position++,value >> 8);
			this.set(this.position++,value);
		}
	},
	writeUnsignedInt: function(value) {
		this.writeInt(value);
	},
	writeUTF: function(value) {
		var bytes = (haxe_io_Bytes().default).ofString(value);
		this.writeShort(bytes.l);
		this.writeBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(bytes));
	},
	writeUTFBytes: function(value) {
		var bytes = (haxe_io_Bytes().default).ofString(value);
		this.writeBytes((openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(bytes));
	},
	__fromBytes: function(bytes) {
		this.__setData(bytes);
		this.l = bytes.l;
	},
	__resize: function(size) {
		if(size > this.__length) {
			var bytes = (haxe_io_Bytes().default).alloc((size + 1) * 3 >> 1);
			if(this.__length > 0) {
				var cacheLength = this.l;
				this.l = this.__length;
				bytes.blit(0,this,0,this.__length);
				this.l = cacheLength;
			}
			this.__setData(bytes);
		}
		if(this.l < size) {
			this.l = size;
		}
	},
	__setData: function(bytes) {
		this.b = bytes.b;
		this.__length = bytes.l;
		this.data = bytes.data;
	},
	get_bytesAvailable: function() {
		return this.l - this.position;
	},
	get_endian: function() {
		return this.__endian;
	},
	set_endian: function(value) {
		return this.__endian = value;
	},
	set_length: function(value) {
		if(value > 0) {
			this.__resize(value);
			if(value < this.position) {
				this.position = value;
			}
		}
		this.l = value;
		return value;
	}
});
ByteArrayData.prototype.__class__ = ByteArrayData.prototype.constructor = $hxClasses["openfl.utils.ByteArrayData"] = ByteArrayData;

// Init

{
	global.Object.defineProperty(ByteArrayData,"defaultEndian",{ get : function() {
		return ByteArrayData.get_defaultEndian();
	}, set : function(v) {
		return ByteArrayData.set_defaultEndian(v);
	}});
	var tmp = ByteArrayData.prototype;
	var tmp1 = { get : function () { return this.get_bytesAvailable (); }};
	var tmp2 = { get : function () { return this.get_endian (); }, set : function (v) { return this.set_endian (v); }};
	var tmp3 = function () { return this.get_length (); }
	var tmp4 = function (v) { return this.set_length (v); }
	global.Object.defineProperties(tmp,{ bytesAvailable : tmp1, endian : tmp2, length : { get : tmp3, set : tmp4}});
};

// Statics

ByteArrayData.fromArrayBuffer = function(buffer) {
	return (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromArrayBuffer(buffer);
}
ByteArrayData.fromBytes = function(bytes) {
	var result = new ByteArrayData();
	result.__fromBytes(bytes);
	return result;
}
ByteArrayData.loadFromBytes = function(bytes) {
	return (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).loadFromBytes(bytes);
}
ByteArrayData.loadFromFile = function(path) {
	return (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).loadFromFile(path);
}
ByteArrayData.unwrapAMFValue = function(val) {
	switch(val._hx_index) {
	case 0:
		var f = val.f;
		return f;
	case 1:
		var b = val.b;
		return b;
	case 2:
		var s = val.s;
		return s;
	case 3:
		var _g2 = val.size;
		var vmap = val.fields;
		var obj = { };
		var name = vmap.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			(Reflect().default).setField(obj,name1,ByteArrayData.unwrapAMFValue(vmap.get(name1)));
		}
		return obj;
	case 4:
		var d = val.d;
		return d;
	case 5:
		return null;
	case 6:
		return null;
	case 7:
		var vals = val.values;
		var f1 = ByteArrayData.unwrapAMFValue;
		var result = new Array(vals.length);
		var _g = 0;
		var _g1 = vals.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f1(vals[i]);
		}
		return result;
	}
}
ByteArrayData.unwrapAMF3Value = function(val) {
	switch(val._hx_index) {
	case 0:
		return null;
	case 1:
		return null;
	case 2:
		var b = val.b;
		return b;
	case 3:
		var n = val.i;
		return n;
	case 4:
		var f = val.f;
		return f;
	case 5:
		var s = val.s;
		return s;
	case 6:
		var d = val.d;
		return d;
	case 7:
		var _g5 = val.size;
		var vmap = val.fields;
		var obj = { };
		var name = vmap.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			(Reflect().default).setField(obj,name1,ByteArrayData.unwrapAMF3Value(vmap.get(name1)));
		}
		return obj;
	case 8:
		var _g12 = val.extra;
		var vals = val.values;
		var f1 = ByteArrayData.unwrapAMF3Value;
		var result = new Array(vals.length);
		var _g = 0;
		var _g1 = vals.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f1(vals[i]);
		}
		return result;
	case 9:
		var vals1 = val.values;
		var f2 = ByteArrayData.unwrapAMF3Value;
		var length = vals1.length;
		var this1 = new Array(length);
		var r = this1;
		var len = length;
		var _g2 = 0;
		var _g11 = len;
		while(_g2 < _g11) {
			var i1 = _g2++;
			var v = f2(vals1[i1]);
			r[i1] = v;
		}
		return r;
	case 10:
		var xml = val.x;
		return xml;
	case 11:
		var b1 = val.b;
		return (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).fromBytes(b1);
	case 12:
		var vmap1 = val.m;
		var map = null;
		var key = vmap1.keys();
		while(key.hasNext()) {
			var key1 = key.next();
			if(map == null) {
				switch(key1._hx_index) {
				case 3:
					var _g13 = key1.i;
					map = new (haxe_ds_IntMap().default)();
					break;
				case 5:
					var _g3 = key1.s;
					map = new (haxe_ds_StringMap().default)();
					break;
				default:
					map = new (haxe_ds_ObjectMap().default)();
				}
			}
			map.set(ByteArrayData.unwrapAMF3Value(key1),ByteArrayData.unwrapAMF3Value(vmap1.get(key1)));
		}
		if(map == null) {
			map = new (haxe_ds_StringMap().default)();
		}
		return map;
	}
}
ByteArrayData.get_defaultEndian = function() {
	if(ByteArrayData.__defaultEndian == null) {
		if((lime_system_System().default).get_endianness() == (lime_system_Endian().default).LITTLE_ENDIAN) {
			ByteArrayData.__defaultEndian = "littleEndian";
		} else {
			ByteArrayData.__defaultEndian = "bigEndian";
		}
	}
	return ByteArrayData.__defaultEndian;
}
ByteArrayData.set_defaultEndian = function(value) {
	return ByteArrayData.__defaultEndian = value;
}
ByteArrayData.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}
ByteArrayData.defaultObjectEncoding = 10
ByteArrayData.__defaultEndian = null

// Export

exports.default = ByteArrayData;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/IAssetCache.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/IAssetCache.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils.IAssetCache

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IAssetCache = function() {}

// Meta

IAssetCache.__name__ = "openfl.utils.IAssetCache";
IAssetCache.__isInterface__ = true;
IAssetCache.prototype = {
	
};
IAssetCache.prototype.__class__ = IAssetCache.prototype.constructor = $hxClasses["openfl.utils.IAssetCache"] = IAssetCache;

// Init



// Statics




// Export

exports.default = IAssetCache;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/IDataInput.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/IDataInput.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils.IDataInput

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IDataInput = function() {}

// Meta

IDataInput.__name__ = "openfl.utils.IDataInput";
IDataInput.__isInterface__ = true;
IDataInput.prototype = {
	
};
IDataInput.prototype.__class__ = IDataInput.prototype.constructor = $hxClasses["openfl.utils.IDataInput"] = IDataInput;

// Init



// Statics




// Export

exports.default = IDataInput;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/IDataOutput.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/IDataOutput.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils.IDataOutput

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var IDataOutput = function() {}

// Meta

IDataOutput.__name__ = "openfl.utils.IDataOutput";
IDataOutput.__isInterface__ = true;
IDataOutput.prototype = {
	
};
IDataOutput.prototype.__class__ = IDataOutput.prototype.constructor = $hxClasses["openfl.utils.IDataOutput"] = IDataOutput;

// Init



// Statics




// Export

exports.default = IDataOutput;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/OpCode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/OpCode.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils._AGALMiniAssembler.OpCode

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;

// Constructor

var OpCode = function(name,numRegister,emitCode,flags) {
	this.name = name;
	this.numRegister = numRegister;
	this.emitCode = emitCode;
	this.flags = flags;
}

// Meta

OpCode.__name__ = "openfl.utils._AGALMiniAssembler.OpCode";
OpCode.__isInterface__ = false;
OpCode.prototype = {
	toString: function() {
		return "[OpCode name=\"" + this.name + "\", numRegister=" + this.numRegister + ", emitCode=" + this.emitCode + ", flags=" + this.flags + "]";
	}
};
OpCode.prototype.__class__ = OpCode.prototype.constructor = $hxClasses["openfl.utils._AGALMiniAssembler.OpCode"] = OpCode;

// Init



// Statics


OpCode.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = OpCode;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/Register.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/Register.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils._AGALMiniAssembler.Register

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}

// Constructor

var Register = function(name,longName,emitCode,range,flags) {
	this.name = name;
	this.longName = longName;
	this.emitCode = emitCode;
	this.range = range;
	this.flags = flags;
}

// Meta

Register.__name__ = "openfl.utils._AGALMiniAssembler.Register";
Register.__isInterface__ = false;
Register.prototype = {
	toString: function() {
		var this1 = this.emitCode;
		var tmp = "[Register name=\"" + this.name + "\", longName=\"" + this.longName + "\", emitCode=" + (Std().default).string(this1 == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(this1)) + ", range=";
		var this2 = this.range;
		var tmp1 = tmp + (Std().default).string(this2 == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(this2)) + ", flags=";
		var this3 = this.flags;
		return tmp1 + (Std().default).string(this3 == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(this3)) + "]";
	}
};
Register.prototype.__class__ = Register.prototype.constructor = $hxClasses["openfl.utils._AGALMiniAssembler.Register"] = Register;

// Init



// Statics


Register.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Register;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/Sampler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/_AGALMiniAssembler/Sampler.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils._AGALMiniAssembler.Sampler

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function Std() {return __webpack_require__(/*! ./../../../Std */ "./node_modules/openfl/lib/_gen/Std.js");}
function _$UInt_UInt_$Impl_$() {return __webpack_require__(/*! ./../../../_UInt/UInt_Impl_ */ "./node_modules/openfl/lib/_gen/_UInt/UInt_Impl_.js");}

// Constructor

var Sampler = function(name,flag,mask) {
	this.name = name;
	this.flag = flag;
	this.mask = mask;
}

// Meta

Sampler.__name__ = "openfl.utils._AGALMiniAssembler.Sampler";
Sampler.__isInterface__ = false;
Sampler.prototype = {
	toString: function() {
		var this1 = this.flag;
		var tmp = "[Sampler name=\"" + this.name + "\", flag=\"" + (Std().default).string(this1 == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(this1)) + "\", mask=";
		var this2 = this.mask;
		return tmp + (Std().default).string(this2 == null ? null : (_$UInt_UInt_$Impl_$().default).toFloat(this2)) + "]";
	}
};
Sampler.prototype.__class__ = Sampler.prototype.constructor = $hxClasses["openfl.utils._AGALMiniAssembler.Sampler"] = Sampler;

// Init



// Statics


Sampler.__meta__ = { obj : { SuppressWarnings : ["checkstyle:FieldDocComment"]}}

// Export

exports.default = Sampler;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/_ByteArray/ByteArray_Impl_.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils._ByteArray.ByteArray_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_utils_BytePointerData() {return __webpack_require__(/*! ./../../../lime/utils/BytePointerData */ "./node_modules/openfl/lib/_gen/lime/utils/BytePointerData.js");}
function openfl_utils_ByteArrayData() {return __webpack_require__(/*! ./../../../openfl/utils/ByteArrayData */ "./node_modules/openfl/lib/_gen/openfl/utils/ByteArrayData.js");}
function haxe_io_Bytes() {return __webpack_require__(/*! ./../../../haxe/io/Bytes */ "./node_modules/openfl/lib/_gen/haxe/io/Bytes.js");}
function lime_utils__$Bytes_Bytes_$Impl_$() {return __webpack_require__(/*! ./../../../lime/utils/_Bytes/Bytes_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_Bytes/Bytes_Impl_.js");}
function lime_app_Future() {return __webpack_require__(/*! ./../../../lime/app/Future */ "./node_modules/openfl/lib/_gen/lime/app/Future.js");}
function lime_utils__$BytePointer_BytePointer_$Impl_$() {return __webpack_require__(/*! ./../../../lime/utils/_BytePointer/BytePointer_Impl_ */ "./node_modules/openfl/lib/_gen/lime/utils/_BytePointer/BytePointer_Impl_.js");}

// Constructor

var ByteArray_Impl_ = function(){}

// Meta

ByteArray_Impl_.__name__ = "openfl.utils._ByteArray.ByteArray_Impl_";
ByteArray_Impl_.__isInterface__ = false;
ByteArray_Impl_.prototype = {
	
};
ByteArray_Impl_.prototype.__class__ = ByteArray_Impl_.prototype.constructor = $hxClasses["openfl.utils._ByteArray.ByteArray_Impl_"] = ByteArray_Impl_;

// Init



// Statics

ByteArray_Impl_._new = function(length) {
	if(length == null) {
		length = 0;
	}
	var this1 = new (openfl_utils_ByteArrayData().default)(length);
	return this1;
}
ByteArray_Impl_.clear = function(this1) {
	this1.clear();
}
ByteArray_Impl_.compress = function(this1,algorithm) {
	this1.compress(algorithm);
	return;
}
ByteArray_Impl_.deflate = function(this1) {
	this1.deflate();
}
ByteArray_Impl_.fromArrayBuffer = function(buffer) {
	if(buffer == null) {
		return null;
	}
	return (openfl_utils_ByteArrayData().default).fromBytes((haxe_io_Bytes().default).ofData(buffer));
}
ByteArray_Impl_.fromBytes = function(bytes) {
	if(bytes == null) {
		return null;
	}
	if(((bytes) instanceof (openfl_utils_ByteArrayData().default))) {
		return bytes;
	} else {
		return (openfl_utils_ByteArrayData().default).fromBytes(bytes);
	}
}
ByteArray_Impl_.fromBytesData = function(bytesData) {
	if(bytesData == null) {
		return null;
	}
	return (openfl_utils_ByteArrayData().default).fromBytes((haxe_io_Bytes().default).ofData(bytesData));
}
ByteArray_Impl_.fromFile = function(path) {
	return ByteArray_Impl_.fromBytes((lime_utils__$Bytes_Bytes_$Impl_$().default).fromFile(path));
}
ByteArray_Impl_.fromLimeBytes = function(bytes) {
	return ByteArray_Impl_.fromBytes(bytes);
}
ByteArray_Impl_.get = function(this1,index) {
	return this1.get(index);
}
ByteArray_Impl_.inflate = function(this1) {
	this1.inflate();
}
ByteArray_Impl_.loadFromBytes = function(bytes) {
	return (lime_utils__$Bytes_Bytes_$Impl_$().default).loadFromBytes(bytes).then(function(limeBytes) {
		var byteArray = ByteArray_Impl_.fromBytes(limeBytes);
		return (lime_app_Future().default).withValue(byteArray);
	});
}
ByteArray_Impl_.loadFromFile = function(path) {
	return (lime_utils__$Bytes_Bytes_$Impl_$().default).loadFromFile(path).then(function(limeBytes) {
		var byteArray = ByteArray_Impl_.fromBytes(limeBytes);
		return (lime_app_Future().default).withValue(byteArray);
	});
}
ByteArray_Impl_.readBoolean = function(this1) {
	return this1.readBoolean();
}
ByteArray_Impl_.readByte = function(this1) {
	return this1.readByte();
}
ByteArray_Impl_.readBytes = function(this1,bytes,offset,length) {
	if(length == null) {
		length = 0;
	}
	if(offset == null) {
		offset = 0;
	}
	this1.readBytes(bytes,offset,length);
}
ByteArray_Impl_.readDouble = function(this1) {
	return this1.readDouble();
}
ByteArray_Impl_.readFloat = function(this1) {
	return this1.readFloat();
}
ByteArray_Impl_.readInt = function(this1) {
	return this1.readInt();
}
ByteArray_Impl_.readMultiByte = function(this1,length,charSet) {
	return this1.readMultiByte(length,charSet);
}
ByteArray_Impl_.readObject = function(this1) {
	return this1.readObject();
}
ByteArray_Impl_.readShort = function(this1) {
	return this1.readShort();
}
ByteArray_Impl_.readUTF = function(this1) {
	return this1.readUTF();
}
ByteArray_Impl_.readUTFBytes = function(this1,length) {
	return this1.readUTFBytes(length);
}
ByteArray_Impl_.readUnsignedByte = function(this1) {
	return this1.readUnsignedByte();
}
ByteArray_Impl_.readUnsignedInt = function(this1) {
	return this1.readUnsignedInt();
}
ByteArray_Impl_.readUnsignedShort = function(this1) {
	return this1.readUnsignedShort();
}
ByteArray_Impl_.set = function(this1,index,value) {
	this1.__resize(index + 1);
	this1.set(index,value);
	return value;
}
ByteArray_Impl_.toArrayBuffer = function(byteArray) {
	return byteArray.getData();
}
ByteArray_Impl_.toBytePointer = function(byteArray) {
	(lime_utils__$BytePointer_BytePointer_$Impl_$().default).set(ByteArray_Impl_.__bytePointer,byteArray,null,null,byteArray.position);
	return ByteArray_Impl_.__bytePointer;
}
ByteArray_Impl_.toBytes = function(byteArray) {
	return byteArray;
}
ByteArray_Impl_.toBytesData = function(byteArray) {
	return byteArray.getData();
}
ByteArray_Impl_.toLimeBytes = function(byteArray) {
	return ByteArray_Impl_.toBytes(ByteArray_Impl_.fromBytes(ByteArray_Impl_.toBytes(byteArray)));
}
ByteArray_Impl_.toString = function(this1) {
	return this1.toString();
}
ByteArray_Impl_.uncompress = function(this1,algorithm) {
	this1.uncompress(algorithm);
	return;
}
ByteArray_Impl_.writeBoolean = function(this1,value) {
	this1.writeBoolean(value);
}
ByteArray_Impl_.writeByte = function(this1,value) {
	this1.writeByte(value);
}
ByteArray_Impl_.writeBytes = function(this1,bytes,offset,length) {
	if(length == null) {
		length = 0;
	}
	if(offset == null) {
		offset = 0;
	}
	this1.writeBytes(bytes,offset,length);
}
ByteArray_Impl_.writeDouble = function(this1,value) {
	this1.writeDouble(value);
}
ByteArray_Impl_.writeFloat = function(this1,value) {
	this1.writeFloat(value);
}
ByteArray_Impl_.writeInt = function(this1,value) {
	this1.writeInt(value);
}
ByteArray_Impl_.writeMultiByte = function(this1,value,charSet) {
	this1.writeMultiByte(value,charSet);
}
ByteArray_Impl_.writeObject = function(this1,object) {
	this1.writeObject(object);
}
ByteArray_Impl_.writeShort = function(this1,value) {
	this1.writeShort(value);
}
ByteArray_Impl_.writeUTF = function(this1,value) {
	this1.writeUTF(value);
}
ByteArray_Impl_.writeUTFBytes = function(this1,value) {
	this1.writeUTFBytes(value);
}
ByteArray_Impl_.writeUnsignedInt = function(this1,value) {
	this1.writeUnsignedInt(value);
}
ByteArray_Impl_.get_bytesAvailable = function(this1) {
	return this1.get_bytesAvailable();
}
ByteArray_Impl_.get_defaultEndian = function() {
	return (openfl_utils_ByteArrayData().default).get_defaultEndian();
}
ByteArray_Impl_.set_defaultEndian = function(value) {
	return (openfl_utils_ByteArrayData().default).set_defaultEndian(value);
}
ByteArray_Impl_.get_defaultObjectEncoding = function() {
	return (openfl_utils_ByteArrayData().default).defaultObjectEncoding;
}
ByteArray_Impl_.set_defaultObjectEncoding = function(value) {
	return (openfl_utils_ByteArrayData().default).defaultObjectEncoding = value;
}
ByteArray_Impl_.get_endian = function(this1) {
	return this1.get_endian();
}
ByteArray_Impl_.set_endian = function(this1,value) {
	return this1.set_endian(value);
}
ByteArray_Impl_.get_length = function(this1) {
	if(this1 == null) {
		return 0;
	} else {
		return this1.l;
	}
}
ByteArray_Impl_.set_length = function(this1,value) {
	this1.set_length(value);
	return value;
}
ByteArray_Impl_.get_objectEncoding = function(this1) {
	return this1.objectEncoding;
}
ByteArray_Impl_.set_objectEncoding = function(this1,value) {
	return this1.objectEncoding = value;
}
ByteArray_Impl_.get_position = function(this1) {
	return this1.position;
}
ByteArray_Impl_.set_position = function(this1,value) {
	return this1.position = value;
}
ByteArray_Impl_.__bytePointer = (function($this) {
	var $r;
	var this1 = new (lime_utils_BytePointerData().default)(null,0);
	$r = this1;
	return $r;
}(this))

// Export

exports.default = ByteArray_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/_gen/openfl/utils/_Endian/Endian_Impl_.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfl/lib/_gen/openfl/utils/_Endian/Endian_Impl_.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Class: openfl.utils._Endian.Endian_Impl_

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = __webpack_require__(/*! ./../../../hxClasses_stub */ "./node_modules/openfl/lib/_gen/hxClasses_stub.js").default;
var $hxEnums = __webpack_require__(/*! ./../../../hxEnums_stub */ "./node_modules/openfl/lib/_gen/hxEnums_stub.js").default;
var $import = __webpack_require__(/*! ./../../../import_stub */ "./node_modules/openfl/lib/_gen/import_stub.js").default;
function lime_system_Endian() {return __webpack_require__(/*! ./../../../lime/system/Endian */ "./node_modules/openfl/lib/_gen/lime/system/Endian.js");}

// Constructor

var Endian_Impl_ = function(){}

// Meta

Endian_Impl_.__name__ = "openfl.utils._Endian.Endian_Impl_";
Endian_Impl_.__isInterface__ = false;
Endian_Impl_.prototype = {
	
};
Endian_Impl_.prototype.__class__ = Endian_Impl_.prototype.constructor = $hxClasses["openfl.utils._Endian.Endian_Impl_"] = Endian_Impl_;

// Init



// Statics

Endian_Impl_.fromLimeEndian = function(value) {
	switch(value._hx_index) {
	case 0:
		return "littleEndian";
	case 1:
		return "bigEndian";
	}
}
Endian_Impl_.toLimeEndian = function(this1) {
	switch(this1) {
	case "bigEndian":
		return (lime_system_Endian().default).BIG_ENDIAN;
	case "littleEndian":
		return (lime_system_Endian().default).LITTLE_ENDIAN;
	default:
		return null;
	}
}
Endian_Impl_.BIG_ENDIAN = "bigEndian"
Endian_Impl_.LITTLE_ENDIAN = "littleEndian"

// Export

exports.default = Endian_Impl_;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/openfl/lib/openfl/display/DisplayObject.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfl/lib/openfl/display/DisplayObject.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./../../_gen/openfl/display/DisplayObject */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObject.js");

/***/ }),

/***/ "./node_modules/openfl/lib/openfl/display/DisplayObjectContainer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfl/lib/openfl/display/DisplayObjectContainer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./../../_gen/openfl/display/DisplayObjectContainer */ "./node_modules/openfl/lib/_gen/openfl/display/DisplayObjectContainer.js");

/***/ }),

/***/ "./node_modules/openfl/lib/openfl/display/Loader.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/openfl/display/Loader.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./../../_gen/openfl/display/Loader */ "./node_modules/openfl/lib/_gen/openfl/display/Loader.js");

/***/ }),

/***/ "./node_modules/openfl/lib/openfl/display/Sprite.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/openfl/display/Sprite.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./../../_gen/openfl/display/Sprite */ "./node_modules/openfl/lib/_gen/openfl/display/Sprite.js");

/***/ }),

/***/ "./node_modules/openfl/lib/openfl/display/Stage.js":
/*!*********************************************************!*\
  !*** ./node_modules/openfl/lib/openfl/display/Stage.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./../../_gen/openfl/display/Stage */ "./node_modules/openfl/lib/_gen/openfl/display/Stage.js");

/***/ }),

/***/ "./node_modules/openfl/lib/openfl/events/Event.js":
/*!********************************************************!*\
  !*** ./node_modules/openfl/lib/openfl/events/Event.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./../../_gen/openfl/events/Event */ "./node_modules/openfl/lib/_gen/openfl/events/Event.js");

/***/ }),

/***/ "./node_modules/openfl/lib/openfl/events/MouseEvent.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfl/lib/openfl/events/MouseEvent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./../../_gen/openfl/events/MouseEvent */ "./node_modules/openfl/lib/_gen/openfl/events/MouseEvent.js");

/***/ }),

/***/ "./node_modules/openfl/lib/openfl/net/URLRequest.js":
/*!**********************************************************!*\
  !*** ./node_modules/openfl/lib/openfl/net/URLRequest.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./../../_gen/openfl/net/URLRequest */ "./node_modules/openfl/lib/_gen/openfl/net/URLRequest.js");

/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Top level file is just a mixin of submodules & constants


var assign    = __webpack_require__(/*! ./lib/utils/common */ "./node_modules/pako/lib/utils/common.js").assign;

var deflate   = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");
var inflate   = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");
var constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;


/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");
var utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
var strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
var msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;


/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");
var utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
var strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
var c            = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");
var msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");
var GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;


/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);


/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// String encode/decode helpers



var utils = __webpack_require__(/*! ./common */ "./node_modules/pako/lib/utils/common.js");


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");
var trees   = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");
var adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
var crc32   = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
var msg     = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");
var adler32       = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
var crc32         = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
var inflate_fast  = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");
var inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
// ContextView
var IContextView_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/contextView/api/IContextView */ "./src/robotlegs/bender/extensions/contextView/api/IContextView.ts");
exports.IContextView = IContextView_1.IContextView;
var ContextView_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/contextView/impl/ContextView */ "./src/robotlegs/bender/extensions/contextView/impl/ContextView.ts");
exports.ContextView = ContextView_1.ContextView;
var ContextViewListenerConfig_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/contextView/impl/ContextViewListenerConfig */ "./src/robotlegs/bender/extensions/contextView/impl/ContextViewListenerConfig.ts");
exports.ContextViewListenerConfig = ContextViewListenerConfig_1.ContextViewListenerConfig;
var ContextViewExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/contextView/ContextViewExtension */ "./src/robotlegs/bender/extensions/contextView/ContextViewExtension.ts");
exports.ContextViewExtension = ContextViewExtension_1.ContextViewExtension;
var IMediatorMap_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/mediatorMap/api/IMediatorMap */ "./src/robotlegs/bender/extensions/mediatorMap/api/IMediatorMap.ts");
exports.IMediatorMap = IMediatorMap_1.IMediatorMap;
var Mediator_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/mediatorMap/impl/Mediator */ "./src/robotlegs/bender/extensions/mediatorMap/impl/Mediator.ts");
exports.Mediator = Mediator_1.Mediator;
var MediatorMapExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/mediatorMap/MediatorMapExtension */ "./src/robotlegs/bender/extensions/mediatorMap/MediatorMapExtension.ts");
exports.MediatorMapExtension = MediatorMapExtension_1.MediatorMapExtension;
var IViewManager_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/viewManager/api/IViewManager */ "./src/robotlegs/bender/extensions/viewManager/api/IViewManager.ts");
exports.IViewManager = IViewManager_1.IViewManager;
var ManualStageObserverExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/viewManager/ManualStageObserverExtension */ "./src/robotlegs/bender/extensions/viewManager/ManualStageObserverExtension.ts");
exports.ManualStageObserverExtension = ManualStageObserverExtension_1.ManualStageObserverExtension;
var StageCrawlerExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/viewManager/StageCrawlerExtension */ "./src/robotlegs/bender/extensions/viewManager/StageCrawlerExtension.ts");
exports.StageCrawlerExtension = StageCrawlerExtension_1.StageCrawlerExtension;
var StageObserverExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/viewManager/StageObserverExtension */ "./src/robotlegs/bender/extensions/viewManager/StageObserverExtension.ts");
exports.StageObserverExtension = StageObserverExtension_1.StageObserverExtension;
var ViewManagerExtension_1 = __webpack_require__(/*! ./robotlegs/bender/extensions/viewManager/ViewManagerExtension */ "./src/robotlegs/bender/extensions/viewManager/ViewManagerExtension.ts");
exports.ViewManagerExtension = ViewManagerExtension_1.ViewManagerExtension;
/**
 * Bundles
 */
var OpenFLBundle_1 = __webpack_require__(/*! ./robotlegs/bender/bundles/openfl/OpenFLBundle */ "./src/robotlegs/bender/bundles/openfl/OpenFLBundle.ts");
exports.OpenFLBundle = OpenFLBundle_1.OpenFLBundle;


/***/ }),

/***/ "./src/robotlegs/bender/bundles/openfl/OpenFLBundle.ts":
/*!*************************************************************!*\
  !*** ./src/robotlegs/bender/bundles/openfl/OpenFLBundle.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var IContextView_1 = __webpack_require__(/*! ../../extensions/contextView/api/IContextView */ "./src/robotlegs/bender/extensions/contextView/api/IContextView.ts");
var ContextView_1 = __webpack_require__(/*! ../../extensions/contextView/impl/ContextView */ "./src/robotlegs/bender/extensions/contextView/impl/ContextView.ts");
var ContextViewListenerConfig_1 = __webpack_require__(/*! ../../extensions/contextView/impl/ContextViewListenerConfig */ "./src/robotlegs/bender/extensions/contextView/impl/ContextViewListenerConfig.ts");
var ContextViewExtension_1 = __webpack_require__(/*! ../../extensions/contextView/ContextViewExtension */ "./src/robotlegs/bender/extensions/contextView/ContextViewExtension.ts");
var MediatorMapExtension_1 = __webpack_require__(/*! ../../extensions/mediatorMap/MediatorMapExtension */ "./src/robotlegs/bender/extensions/mediatorMap/MediatorMapExtension.ts");
var StageCrawlerExtension_1 = __webpack_require__(/*! ../../extensions/viewManager/StageCrawlerExtension */ "./src/robotlegs/bender/extensions/viewManager/StageCrawlerExtension.ts");
var StageObserverExtension_1 = __webpack_require__(/*! ../../extensions/viewManager/StageObserverExtension */ "./src/robotlegs/bender/extensions/viewManager/StageObserverExtension.ts");
var ViewManagerExtension_1 = __webpack_require__(/*! ../../extensions/viewManager/ViewManagerExtension */ "./src/robotlegs/bender/extensions/viewManager/ViewManagerExtension.ts");
/**
 * For that Classic Robotlegs flavour
 *
 * <p>This bundle installs a number of extensions commonly used
 * in typical Robotlegs applications and modules.</p>
 */
var OpenFLBundle = /** @class */ (function () {
    function OpenFLBundle() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    OpenFLBundle.prototype.extend = function (context) {
        this._context = context;
        this._logger = context.getLogger(this);
        this._context.install(ContextViewExtension_1.ContextViewExtension, ViewManagerExtension_1.ViewManagerExtension, StageObserverExtension_1.StageObserverExtension, MediatorMapExtension_1.MediatorMapExtension, StageCrawlerExtension_1.StageCrawlerExtension);
        this._context.addConfigHandler(core_1.instanceOfType(ContextView_1.ContextView), this.handleContextView.bind(this));
        this._context.whenInitializing(this.whenInitializing.bind(this));
        this._context.afterDestroying(this.afterDestroying.bind(this));
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    OpenFLBundle.prototype.handleContextView = function () {
        this._context.configure(ContextViewListenerConfig_1.ContextViewListenerConfig);
    };
    OpenFLBundle.prototype.whenInitializing = function () {
        if (!this._context.injector.isBound(IContextView_1.IContextView)) {
            this._logger.error("OpenFLBundle requires IContextView.");
        }
    };
    OpenFLBundle.prototype.afterDestroying = function () {
        this._context = null;
        this._logger = null;
    };
    return OpenFLBundle;
}());
exports.OpenFLBundle = OpenFLBundle;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/contextView/ContextViewExtension.ts":
/*!*****************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/contextView/ContextViewExtension.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var IContextView_1 = __webpack_require__(/*! ./api/IContextView */ "./src/robotlegs/bender/extensions/contextView/api/IContextView.ts");
var ContextView_1 = __webpack_require__(/*! ./impl/ContextView */ "./src/robotlegs/bender/extensions/contextView/impl/ContextView.ts");
/**
 * <p>This Extension waits for a ContextView to be added as a configuration
 * and maps it into the context's injector.</p>
 *
 * <p>It should be installed before context initialization.</p>
 */
var ContextViewExtension = /** @class */ (function () {
    function ContextViewExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ContextViewExtension.prototype.extend = function (context) {
        this._injector = context.injector;
        this._logger = context.getLogger(this);
        context.beforeInitializing(this.beforeInitializing.bind(this));
        context.addConfigHandler(core_1.instanceOfType(ContextView_1.ContextView), this.handleContextView.bind(this));
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    ContextViewExtension.prototype.handleContextView = function (contextView) {
        if (this._injector.isBound(IContextView_1.IContextView)) {
            this._logger.warn("A contextView has already been installed, ignoring {0}", [contextView.view]);
        }
        else {
            this._logger.debug("Mapping {0} as contextView", [contextView.view]);
            this._injector.bind(IContextView_1.IContextView).toConstantValue(contextView);
        }
    };
    ContextViewExtension.prototype.beforeInitializing = function () {
        if (!this._injector.isBound(IContextView_1.IContextView)) {
            this._logger.error("A ContextView must be installed if you install the ContextViewExtension.");
        }
    };
    return ContextViewExtension;
}());
exports.ContextViewExtension = ContextViewExtension;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/contextView/api/IContextView.ts":
/*!*************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/contextView/api/IContextView.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
exports.IContextView = Symbol("IContextView");


/***/ }),

/***/ "./src/robotlegs/bender/extensions/contextView/impl/ContextView.ts":
/*!*************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/contextView/impl/ContextView.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The Context View represents the root Container for a Context
 */
var ContextView = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * The Context View represents the root Container for a Context
     * @param view The root Container for this Context
     */
    function ContextView(view) {
        if (view !== null && view !== undefined) {
            this._view = view;
        }
        else {
            throw new Error("View can't be null or undefined");
        }
    }
    /*============================================================================*/
    /* Public Properties                                                          */
    /*============================================================================*/
    /**
     *
     */
    ContextView.prototype.configure = function () { };
    Object.defineProperty(ContextView.prototype, "view", {
        /**
         * The root Container for this Context
         */
        get: function () {
            return this._view;
        },
        enumerable: true,
        configurable: true
    });
    return ContextView;
}());
exports.ContextView = ContextView;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/contextView/impl/ContextViewListenerConfig.ts":
/*!***************************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/contextView/impl/ContextViewListenerConfig.ts ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var IContextView_1 = __webpack_require__(/*! ../api/IContextView */ "./src/robotlegs/bender/extensions/contextView/api/IContextView.ts");
var IViewManager_1 = __webpack_require__(/*! ../../viewManager/api/IViewManager */ "./src/robotlegs/bender/extensions/viewManager/api/IViewManager.ts");
/**
 * This configuration file adds the ContextView to the viewManager.
 *
 * It requires that the ViewManagerExtension, ContextViewExtension
 * and a ContextView have been installed.
 */
var ContextViewListenerConfig = /** @class */ (function () {
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    function ContextViewListenerConfig(contextView, viewManager) {
        this._contextView = contextView;
        this._viewManager = viewManager;
    }
    /**
     * @inheritDoc
     */
    ContextViewListenerConfig.prototype.configure = function () {
        // Adds the Context View to the View Manager at startup
        this._viewManager.addContainer(this._contextView.view);
    };
    ContextViewListenerConfig = __decorate([
        core_1.injectable(),
        __param(0, core_1.inject(IContextView_1.IContextView)), __param(1, core_1.inject(IViewManager_1.IViewManager)),
        __metadata("design:paramtypes", [Object, Object])
    ], ContextViewListenerConfig);
    return ContextViewListenerConfig;
}());
exports.ContextViewListenerConfig = ContextViewListenerConfig;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/MediatorMapExtension.ts":
/*!*****************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/MediatorMapExtension.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var IMediatorMap_1 = __webpack_require__(/*! ./api/IMediatorMap */ "./src/robotlegs/bender/extensions/mediatorMap/api/IMediatorMap.ts");
var MediatorMap_1 = __webpack_require__(/*! ./impl/MediatorMap */ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMap.ts");
var IViewManager_1 = __webpack_require__(/*! ../viewManager/api/IViewManager */ "./src/robotlegs/bender/extensions/viewManager/api/IViewManager.ts");
/**
 * This extension installs a shared IMediatorMap into the context
 */
var MediatorMapExtension = /** @class */ (function () {
    function MediatorMapExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    MediatorMapExtension.prototype.extend = function (context) {
        context
            .beforeInitializing(this.beforeInitializing.bind(this))
            .beforeDestroying(this.beforeDestroying.bind(this))
            .whenDestroying(this.whenDestroying.bind(this));
        this._injector = context.injector;
        this._injector
            .bind(IMediatorMap_1.IMediatorMap)
            .to(MediatorMap_1.MediatorMap)
            .inSingletonScope();
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    MediatorMapExtension.prototype.beforeInitializing = function () {
        this._mediatorMap = this._injector.get(IMediatorMap_1.IMediatorMap);
        if (this._injector.isBound(IViewManager_1.IViewManager)) {
            this._viewManager = this._injector.get(IViewManager_1.IViewManager);
            this._viewManager.addViewHandler(this._mediatorMap);
        }
    };
    MediatorMapExtension.prototype.beforeDestroying = function () {
        this._mediatorMap.unmediateAll();
        if (this._injector.isBound(IViewManager_1.IViewManager)) {
            this._viewManager = this._injector.get(IViewManager_1.IViewManager);
            this._viewManager.removeViewHandler(this._mediatorMap);
        }
    };
    MediatorMapExtension.prototype.whenDestroying = function () {
        if (this._injector.isBound(IMediatorMap_1.IMediatorMap)) {
            this._injector.unbind(IMediatorMap_1.IMediatorMap);
        }
    };
    return MediatorMapExtension;
}());
exports.MediatorMapExtension = MediatorMapExtension;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/api/IMediatorMap.ts":
/*!*************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/api/IMediatorMap.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The Mediator Map allows you to bind Mediators to objects
 */
exports.IMediatorMap = Symbol("IMediatorMap");


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/ConvertToEventDispatcher.ts":
/*!**************************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/ConvertToEventDispatcher.ts ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var Event_1 = __webpack_require__(/*! openfl/events/Event */ "./node_modules/openfl/lib/openfl/events/Event.js");
/**
 * Makes the bridge between the EventDispatcher from OpenFL and IEventDispatcher.
 */
var ConvertToEventDispatcher = /** @class */ (function () {
    function ConvertToEventDispatcher(openflEventDispatcher) {
        this._openflEventDispatcher = openflEventDispatcher;
    }
    ConvertToEventDispatcher.prototype.addEventListener = function (type, listener, thisObject, useCapture, priority) {
        this._openflEventDispatcher.addEventListener(type, listener, useCapture, priority);
    };
    ConvertToEventDispatcher.prototype.once = function (type, listener, thisObject, useCapture, priority) {
        console.warn("unsuported method on OpenFL, the listener will not be removed automatically");
        this._openflEventDispatcher.addEventListener(type, listener, useCapture, priority);
    };
    ConvertToEventDispatcher.prototype.removeEventListener = function (type, listener, thisObject, useCapture) {
        this._openflEventDispatcher.removeEventListener(type, listener, useCapture);
    };
    ConvertToEventDispatcher.prototype.hasEventListener = function (type) {
        return this._openflEventDispatcher.hasEventListener(type);
    };
    ConvertToEventDispatcher.prototype.dispatchEvent = function (event) {
        console.warn("event dispatched may loose reference of target and currentTarget");
        var openEvent = new Event_1.default(event.type, event.bubbles, event.cancelable);
        return this._openflEventDispatcher.dispatchEvent(openEvent);
    };
    ConvertToEventDispatcher.prototype.willTrigger = function (type) {
        return this._openflEventDispatcher.willTrigger(type);
    };
    return ConvertToEventDispatcher;
}());
exports.ConvertToEventDispatcher = ConvertToEventDispatcher;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/Mediator.ts":
/*!**********************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/Mediator.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var ConvertToEventDispatcher_1 = __webpack_require__(/*! ./ConvertToEventDispatcher */ "./src/robotlegs/bender/extensions/mediatorMap/impl/ConvertToEventDispatcher.ts");
/**
 * Classic Robotlegs mediator implementation
 *
 * <p>Override initialize and destroy to hook into the mediator lifecycle.</p>
 */
var Mediator = /** @class */ (function () {
    function Mediator() {
    }
    Object.defineProperty(Mediator.prototype, "view", {
        get: function () {
            return this._viewComponent;
        },
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        set: function (view) {
            this._viewComponent = view;
            this._viewConverted = new ConvertToEventDispatcher_1.ConvertToEventDispatcher(this._viewComponent);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Runs after the mediator has been destroyed.
     * Cleans up listeners mapped through the local EventMap.
     */
    Mediator.prototype.postDestroy = function () {
        this._eventMap.unmapAllListeners();
    };
    /*============================================================================*/
    /* Protected Functions                                                        */
    /*============================================================================*/
    Mediator.prototype.addViewListener = function (eventString, listener, thisObject, eventClass, useCapture, priority) {
        this._eventMap.mapListener(this._viewConverted, eventString, listener, thisObject, eventClass, useCapture, priority);
    };
    Mediator.prototype.addContextListener = function (eventString, listener, thisObject, eventClass, useCapture, priority) {
        this._eventMap.mapListener(this._eventDispatcher, eventString, listener, thisObject, eventClass, useCapture, priority);
    };
    Mediator.prototype.addDomListener = function (eventTarget, eventString, listener, options) {
        this._eventMap.mapDomListener(eventTarget, eventString, listener, options);
    };
    Mediator.prototype.removeViewListener = function (eventString, listener, thisObject, eventClass, useCapture) {
        this._eventMap.unmapListener(this._viewConverted, eventString, listener, thisObject, eventClass, useCapture);
    };
    Mediator.prototype.removeContextListener = function (eventString, listener, thisObject, eventClass, useCapture) {
        this._eventMap.unmapListener(this._eventDispatcher, eventString, listener, thisObject, eventClass, useCapture);
    };
    Mediator.prototype.removeDomListener = function (eventTarget, eventString, listener) {
        this._eventMap.unmapDomListener(eventTarget, eventString, listener);
    };
    Mediator.prototype.dispatch = function (event) {
        if (this._eventDispatcher.hasEventListener(event.type)) {
            this._eventDispatcher.dispatchEvent(event);
        }
    };
    __decorate([
        core_1.inject(core_1.IEventMap),
        __metadata("design:type", Object)
    ], Mediator.prototype, "_eventMap", void 0);
    __decorate([
        core_1.inject(core_1.IEventDispatcher),
        __metadata("design:type", Object)
    ], Mediator.prototype, "_eventDispatcher", void 0);
    Mediator = __decorate([
        core_1.injectable()
    ], Mediator);
    return Mediator;
}());
exports.Mediator = Mediator;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorFactory.ts":
/*!*****************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorFactory.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var MediatorManager_1 = __webpack_require__(/*! ./MediatorManager */ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorManager.ts");
/**
 * @private
 */
var MediatorFactory = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function MediatorFactory(injector, manager) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._mediators = new Map();
        this._injector = injector;
        this._manager = manager || new MediatorManager_1.MediatorManager(this);
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    MediatorFactory.prototype.getMediator = function (item, mapping) {
        return this._mediators.get(item) ? this._mediators.get(item).get(mapping) : null;
    };
    /**
     * @private
     */
    MediatorFactory.prototype.createMediators = function (item, type, mappings) {
        var _this = this;
        var createdMediators = [];
        var mediator;
        mappings.forEach(function (mapping) {
            mediator = _this.getMediator(item, mapping);
            if (!mediator) {
                _this.mapTypeForFilterBinding(mapping.matcher, type, item);
                mediator = _this.createMediator(item, mapping);
                _this.unmapTypeForFilterBinding(mapping.matcher, type, item);
            }
            if (mediator) {
                createdMediators.push(mediator);
            }
        });
        return createdMediators;
    };
    /**
     * @private
     */
    MediatorFactory.prototype.removeMediators = function (item) {
        var _this = this;
        var mediators = this._mediators.get(item);
        if (!mediators) {
            return;
        }
        mediators.forEach(function (value, key) { return _this._manager.removeMediator(value, item, key); });
        this._mediators.delete(item);
    };
    /**
     * @private
     */
    MediatorFactory.prototype.removeAllMediators = function () {
        var _this = this;
        this._mediators.forEach(function (value, key) { return _this.removeMediators(key); });
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    MediatorFactory.prototype.createMediator = function (item, mapping) {
        var mediator = this.getMediator(item, mapping);
        if (mediator) {
            return mediator;
        }
        if (mapping.guards.length === 0 || core_1.guardsApprove(mapping.guards, this._injector)) {
            var mediatorClass = mapping.mediatorClass;
            mediator = core_1.instantiateUnmapped(this._injector, mediatorClass);
            if (mapping.hooks.length > 0) {
                this._injector.bind(mediatorClass).toConstantValue(mediator);
                core_1.applyHooks(mapping.hooks, this._injector);
                this._injector.unbind(mediatorClass);
            }
            this.addMediator(mediator, item, mapping);
        }
        return mediator;
    };
    MediatorFactory.prototype.addMediator = function (mediator, item, mapping) {
        var mediatorMap = this._mediators.get(item) || new Map();
        this._mediators.set(item, mediatorMap);
        mediatorMap.set(mapping, mediator);
        this._manager.addMediator(mediator, item, mapping);
    };
    MediatorFactory.prototype.mapTypeForFilterBinding = function (filter, type, item) {
        var _this = this;
        var requiredTypes = this.requiredTypesFor(filter, type);
        requiredTypes.forEach(function (requiredType) {
            _this._injector.bind(requiredType).toConstantValue(item);
        });
    };
    MediatorFactory.prototype.unmapTypeForFilterBinding = function (filter, type, item) {
        var _this = this;
        var requiredTypes = this.requiredTypesFor(filter, type);
        requiredTypes.forEach(function (requiredType) {
            if (_this._injector.isBound(requiredType)) {
                _this._injector.unbind(requiredType);
            }
        });
    };
    MediatorFactory.prototype.requiredTypesFor = function (filter, type) {
        var requiredTypes = filter.allOfTypes.concat(filter.anyOfTypes);
        if (requiredTypes.indexOf(type) === -1) {
            requiredTypes.push(type);
        }
        return requiredTypes;
    };
    return MediatorFactory;
}());
exports.MediatorFactory = MediatorFactory;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorManager.ts":
/*!*****************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorManager.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var DisplayObject_1 = __webpack_require__(/*! openfl/display/DisplayObject */ "./node_modules/openfl/lib/openfl/display/DisplayObject.js");
var Event_1 = __webpack_require__(/*! openfl/events/Event */ "./node_modules/openfl/lib/openfl/events/Event.js");
/**
 * @private
 */
var MediatorManager = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function MediatorManager(factory) {
        var _this = this;
        /*============================================================================*/
        /* Private Functions                                                          */
        /*============================================================================*/
        this.onRemovedFromStage = function (event) {
            _this._factory.removeMediators(event.target);
        };
        this._factory = factory;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    MediatorManager.prototype.addMediator = function (mediator, item, mapping) {
        // Watch Display Object for removal
        if (item instanceof DisplayObject_1.default && mapping.autoRemoveEnabled) {
            item.addEventListener(Event_1.default.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        }
        // Synchronize with item life-cycle
        this.initializeMediator(mediator, item);
    };
    /**
     * @private
     */
    MediatorManager.prototype.removeMediator = function (mediator, item, mapping) {
        if (item instanceof DisplayObject_1.default) {
            item.removeEventListener(Event_1.default.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        }
        this.destroyMediator(mediator);
    };
    MediatorManager.prototype.initializeMediator = function (mediator, mediatedItem) {
        if ("preInitialize" in mediator) {
            mediator.preInitialize();
        }
        if ("view" in mediator) {
            mediator.view = mediatedItem;
        }
        if ("initialize" in mediator) {
            mediator.initialize();
        }
        if ("postInitialize" in mediator) {
            mediator.postInitialize();
        }
    };
    MediatorManager.prototype.destroyMediator = function (mediator) {
        if ("preDestroy" in mediator) {
            mediator.preDestroy();
        }
        if ("destroy" in mediator) {
            mediator.destroy();
        }
        if ("view" in mediator) {
            mediator.view = null;
        }
        if ("postDestroy" in mediator) {
            mediator.postDestroy();
        }
    };
    return MediatorManager;
}());
exports.MediatorManager = MediatorManager;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMap.ts":
/*!*************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMap.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var MediatorFactory_1 = __webpack_require__(/*! ./MediatorFactory */ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorFactory.ts");
var MediatorViewHandler_1 = __webpack_require__(/*! ./MediatorViewHandler */ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorViewHandler.ts");
var NullMediatorUnmapper_1 = __webpack_require__(/*! ./NullMediatorUnmapper */ "./src/robotlegs/bender/extensions/mediatorMap/impl/NullMediatorUnmapper.ts");
var MediatorMapper_1 = __webpack_require__(/*! ./MediatorMapper */ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMapper.ts");
/**
 * @private
 */
var MediatorMap = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function MediatorMap(context) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._mappers = new Map();
        this.NULL_UNMAPPER = new NullMediatorUnmapper_1.NullMediatorUnmapper();
        this._logger = context.getLogger(this);
        this._factory = new MediatorFactory_1.MediatorFactory(context.injector);
        this._viewHandler = new MediatorViewHandler_1.MediatorViewHandler(this._factory);
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    MediatorMap.prototype.mapMatcher = function (matcher) {
        var desc = matcher.createTypeFilter().descriptor;
        var mapper = this._mappers.get(desc);
        if (mapper) {
            return mapper;
        }
        mapper = this.createMapper(matcher);
        this._mappers.set(desc, mapper);
        return mapper;
    };
    /**
     * @inheritDoc
     */
    MediatorMap.prototype.map = function (type) {
        return this.mapMatcher(new core_1.TypeMatcher().allOf(type));
    };
    /**
     * @inheritDoc
     */
    MediatorMap.prototype.unmapMatcher = function (matcher) {
        return this._mappers.get(matcher.createTypeFilter().descriptor) || this.NULL_UNMAPPER;
    };
    /**
     * @inheritDoc
     */
    MediatorMap.prototype.unmap = function (type) {
        return this.unmapMatcher(new core_1.TypeMatcher().allOf(type));
    };
    /**
     * @inheritDoc
     */
    MediatorMap.prototype.handleView = function (view, type) {
        this._viewHandler.handleView(view, type);
    };
    /**
     * @inheritDoc
     */
    MediatorMap.prototype.mediate = function (item) {
        this._viewHandler.handleItem(item, item.constructor);
    };
    /**
     * @inheritDoc
     */
    MediatorMap.prototype.unmediate = function (item) {
        this._factory.removeMediators(item);
    };
    /**
     * @inheritDoc
     */
    MediatorMap.prototype.unmediateAll = function () {
        this._factory.removeAllMediators();
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    MediatorMap.prototype.createMapper = function (matcher) {
        return new MediatorMapper_1.MediatorMapper(matcher.createTypeFilter(), this._viewHandler, this._logger);
    };
    MediatorMap = __decorate([
        core_1.injectable(),
        __param(0, core_1.inject(core_1.IContext)),
        __metadata("design:paramtypes", [Object])
    ], MediatorMap);
    return MediatorMap;
}());
exports.MediatorMap = MediatorMap;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMapper.ts":
/*!****************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMapper.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var MediatorMapping_1 = __webpack_require__(/*! ./MediatorMapping */ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMapping.ts");
/**
 * @private
 */
var MediatorMapper = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function MediatorMapper(typeFilter, handler, logger) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._mappings = new Map();
        this._typeFilter = typeFilter;
        this._handler = handler;
        this._logger = logger;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    MediatorMapper.prototype.toMediator = function (mediatorClass) {
        var mapping = this._mappings.get(mediatorClass);
        return mapping ? this.overwriteMapping(mapping) : this.createMapping(mediatorClass);
    };
    /**
     * @inheritDoc
     */
    MediatorMapper.prototype.fromMediator = function (mediatorClass) {
        var mapping = this._mappings.get(mediatorClass);
        if (mapping) {
            this.deleteMapping(mapping);
        }
    };
    /**
     * @inheritDoc
     */
    MediatorMapper.prototype.fromAll = function () {
        this._mappings.forEach(this.deleteMapping, this);
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    MediatorMapper.prototype.createMapping = function (mediatorClass) {
        var mapping = new MediatorMapping_1.MediatorMapping(this._typeFilter, mediatorClass);
        this._handler.addMapping(mapping);
        this._mappings.set(mediatorClass, mapping);
        if (this._logger) {
            this._logger.debug("{0} mapped to {1}", [this._typeFilter, mapping]);
        }
        return mapping;
    };
    MediatorMapper.prototype.deleteMapping = function (mapping) {
        this._handler.removeMapping(mapping);
        this._mappings.delete(mapping.mediatorClass);
        if (this._logger) {
            this._logger.debug("{0} unmapped from {1}", [this._typeFilter, mapping]);
        }
    };
    MediatorMapper.prototype.overwriteMapping = function (mapping) {
        if (this._logger) {
            this._logger.warn("{0} already mapped to {1}\n" +
                'If you have overridden this mapping intentionally you can use "unmap()" ' +
                "prior to your replacement mapping in order to avoid seeing this message.\n", [this._typeFilter, mapping]);
        }
        this.deleteMapping(mapping);
        return this.createMapping(mapping.mediatorClass);
    };
    return MediatorMapper;
}());
exports.MediatorMapper = MediatorMapper;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMapping.ts":
/*!*****************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorMapping.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var MediatorMapping = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function MediatorMapping(matcher, mediatorClass) {
        this._guards = [];
        this._hooks = [];
        this._autoRemoveEnabled = true;
        this._matcher = matcher;
        this._mediatorClass = mediatorClass;
    }
    Object.defineProperty(MediatorMapping.prototype, "matcher", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._matcher;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediatorMapping.prototype, "mediatorClass", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._mediatorClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediatorMapping.prototype, "guards", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._guards;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediatorMapping.prototype, "hooks", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._hooks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediatorMapping.prototype, "autoRemoveEnabled", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._autoRemoveEnabled;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    MediatorMapping.prototype.withGuards = function () {
        var guards = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            guards[_i] = arguments[_i];
        }
        this._guards = this._guards.concat.apply(this._guards, guards);
        return this;
    };
    /**
     * @inheritDoc
     */
    MediatorMapping.prototype.withHooks = function () {
        var hooks = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            hooks[_i] = arguments[_i];
        }
        this._hooks = this._hooks.concat.apply(this._hooks, hooks);
        return this;
    };
    /**
     * @inheritDoc
     */
    MediatorMapping.prototype.autoRemove = function (value) {
        if (value === void 0) { value = true; }
        this._autoRemoveEnabled = value;
        return this;
    };
    return MediatorMapping;
}());
exports.MediatorMapping = MediatorMapping;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorViewHandler.ts":
/*!*********************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/MediatorViewHandler.ts ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var MediatorViewHandler = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function MediatorViewHandler(factory) {
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        this._mappings = [];
        this._knownMappings = new Map();
        this._factory = factory;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    MediatorViewHandler.prototype.addMapping = function (mapping) {
        var index = this._mappings.indexOf(mapping);
        if (index > -1) {
            return;
        }
        this._mappings.push(mapping);
        this._knownMappings.clear();
    };
    /**
     * @private
     */
    MediatorViewHandler.prototype.removeMapping = function (mapping) {
        var index = this._mappings.indexOf(mapping);
        if (index === -1) {
            return;
        }
        this._mappings.splice(index, 1);
        this._knownMappings.clear();
    };
    /**
     * @private
     */
    MediatorViewHandler.prototype.handleView = function (view, type) {
        var interestedMappings = this.getInterestedMappingsFor(view, type);
        if (interestedMappings) {
            this._factory.createMediators(view, type, interestedMappings);
        }
    };
    /**
     * @private
     */
    MediatorViewHandler.prototype.handleItem = function (item, type) {
        var interestedMappings = this.getInterestedMappingsFor(item, type);
        if (interestedMappings) {
            this._factory.createMediators(item, type, interestedMappings);
        }
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    MediatorViewHandler.prototype.getInterestedMappingsFor = function (item, type) {
        var _this = this;
        // we've seen this type before and nobody was interested
        if (this._knownMappings.get(type) === false) {
            return null;
        }
        // we haven't seen this type before
        if (this._knownMappings.get(type) === undefined) {
            this._knownMappings.set(type, false);
            this._mappings.forEach(function (mapping) {
                if (mapping.matcher.matches(item)) {
                    if (!_this._knownMappings.get(type)) {
                        _this._knownMappings.set(type, []);
                    }
                    _this._knownMappings.get(type).push(mapping);
                }
            });
            // nobody cares, let's get out of here
            if (this._knownMappings.get(type) === false) {
                return null;
            }
        }
        // these mappings really do care
        return this._knownMappings.get(type);
    };
    return MediatorViewHandler;
}());
exports.MediatorViewHandler = MediatorViewHandler;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/mediatorMap/impl/NullMediatorUnmapper.ts":
/*!**********************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/mediatorMap/impl/NullMediatorUnmapper.ts ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @private
 */
var NullMediatorUnmapper = /** @class */ (function () {
    function NullMediatorUnmapper() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    NullMediatorUnmapper.prototype.fromMediator = function (mediatorClass) { };
    /**
     * @private
     */
    NullMediatorUnmapper.prototype.fromAll = function () { };
    return NullMediatorUnmapper;
}());
exports.NullMediatorUnmapper = NullMediatorUnmapper;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/ManualStageObserverExtension.ts":
/*!*************************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/ManualStageObserverExtension.ts ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var ContainerRegistry_1 = __webpack_require__(/*! ./impl/ContainerRegistry */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistry.ts");
var ManualStageObserver_1 = __webpack_require__(/*! ./impl/ManualStageObserver */ "./src/robotlegs/bender/extensions/viewManager/impl/ManualStageObserver.ts");
var installCount = 0;
/**
 * This extension install a manual Stage Observer
 */
var ManualStageObserverExtension = /** @class */ (function () {
    function ManualStageObserverExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ManualStageObserverExtension.prototype.extend = function (context) {
        context.whenInitializing(this.whenInitializing.bind(this));
        context.whenDestroying(this.whenDestroying.bind(this));
        installCount++;
        this._injector = context.injector;
        this._logger = context.getLogger(this);
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    ManualStageObserverExtension.prototype.whenInitializing = function () {
        // Hark, an actual Singleton!
        if (!ManualStageObserverExtension._manualStageObserver) {
            var containerRegistry = this._injector.get(ContainerRegistry_1.ContainerRegistry);
            this._logger.debug("Creating genuine ManualStageObserver Singleton");
            ManualStageObserverExtension._manualStageObserver = new ManualStageObserver_1.ManualStageObserver(containerRegistry);
        }
    };
    ManualStageObserverExtension.prototype.whenDestroying = function () {
        installCount--;
        if (installCount === 0) {
            this._logger.debug("Destroying genuine ManualStageObserver Singleton");
            ManualStageObserverExtension._manualStageObserver.destroy();
            ManualStageObserverExtension._manualStageObserver = null;
        }
    };
    return ManualStageObserverExtension;
}());
exports.ManualStageObserverExtension = ManualStageObserverExtension;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/StageCrawlerExtension.ts":
/*!******************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/StageCrawlerExtension.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var IContextView_1 = __webpack_require__(/*! ../contextView/api/IContextView */ "./src/robotlegs/bender/extensions/contextView/api/IContextView.ts");
var IViewManager_1 = __webpack_require__(/*! ./api/IViewManager */ "./src/robotlegs/bender/extensions/viewManager/api/IViewManager.ts");
var ContainerRegistry_1 = __webpack_require__(/*! ./impl/ContainerRegistry */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistry.ts");
var StageCrawler_1 = __webpack_require__(/*! ./impl/StageCrawler */ "./src/robotlegs/bender/extensions/viewManager/impl/StageCrawler.ts");
/**
 * View Handlers (like the MediatorMap) handle views as they land on stage.
 *
 * This extension checks for views that might already be on the stage
 * after context initialization and ensures that those views are handled.
 */
var StageCrawlerExtension = /** @class */ (function () {
    function StageCrawlerExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    StageCrawlerExtension.prototype.extend = function (context) {
        this._injector = context.injector;
        this._logger = context.getLogger(this);
        context.afterInitializing(this.afterInitializing.bind(this));
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    StageCrawlerExtension.prototype.afterInitializing = function () {
        this._containerRegistry = this._injector.get(ContainerRegistry_1.ContainerRegistry);
        this._injector.isBound(IViewManager_1.IViewManager) ? this.scanViewManagedContainers() : this.scanContextView();
    };
    StageCrawlerExtension.prototype.scanViewManagedContainers = function () {
        var _this = this;
        this._logger.debug("ViewManager is installed. Checking for managed containers...");
        var viewManager = this._injector.get(IViewManager_1.IViewManager);
        viewManager.containers.forEach(function (container) {
            _this.scanContainer(container);
        });
    };
    StageCrawlerExtension.prototype.scanContextView = function () {
        if (this._injector.isBound(IContextView_1.IContextView)) {
            this._logger.debug("ViewManager is not installed. Checking the ContextView...");
            var contextView = this._injector.get(IContextView_1.IContextView);
            this.scanContainer(contextView.view);
        }
        else {
            this._logger.error("A ContextView must be installed if you install the StageCrawlerExtension.");
        }
    };
    StageCrawlerExtension.prototype.scanContainer = function (container) {
        var binding = this._containerRegistry.getBinding(container);
        this._logger.debug("StageCrawler scanning container {0} ...", [container]);
        new StageCrawler_1.StageCrawler(binding).scan(container);
        this._logger.debug("StageCrawler finished scanning {0}", [container]);
    };
    return StageCrawlerExtension;
}());
exports.StageCrawlerExtension = StageCrawlerExtension;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/StageObserverExtension.ts":
/*!*******************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/StageObserverExtension.ts ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var ContainerRegistry_1 = __webpack_require__(/*! ./impl/ContainerRegistry */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistry.ts");
var StageObserver_1 = __webpack_require__(/*! ./impl/StageObserver */ "./src/robotlegs/bender/extensions/viewManager/impl/StageObserver.ts");
var installCount = 0;
/**
 * This extension install an automatic Stage Observer
 */
var StageObserverExtension = /** @class */ (function () {
    function StageObserverExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    StageObserverExtension.prototype.extend = function (context) {
        context.whenInitializing(this.whenInitializing.bind(this));
        context.whenDestroying(this.whenDestroying.bind(this));
        installCount++;
        this._injector = context.injector;
        this._logger = context.getLogger(this);
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    StageObserverExtension.prototype.whenInitializing = function () {
        // Hark, an actual Singleton!
        if (!StageObserverExtension._stageObserver) {
            var containerRegistry = this._injector.get(ContainerRegistry_1.ContainerRegistry);
            this._logger.debug("Creating genuine StageObserver Singleton");
            StageObserverExtension._stageObserver = new StageObserver_1.StageObserver(containerRegistry);
        }
    };
    StageObserverExtension.prototype.whenDestroying = function () {
        installCount--;
        if (installCount === 0) {
            this._logger.debug("Destroying genuine StageObserver Singleton");
            StageObserverExtension._stageObserver.destroy();
            StageObserverExtension._stageObserver = null;
        }
    };
    /*============================================================================*/
    /* Private Static Properties                                                  */
    /*============================================================================*/
    // Really? Yes, there can be only one.
    StageObserverExtension._stageObserver = null;
    return StageObserverExtension;
}());
exports.StageObserverExtension = StageObserverExtension;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/ViewManagerExtension.ts":
/*!*****************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/ViewManagerExtension.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var IViewManager_1 = __webpack_require__(/*! ./api/IViewManager */ "./src/robotlegs/bender/extensions/viewManager/api/IViewManager.ts");
var ViewManager_1 = __webpack_require__(/*! ./impl/ViewManager */ "./src/robotlegs/bender/extensions/viewManager/impl/ViewManager.ts");
var ContainerRegistry_1 = __webpack_require__(/*! ./impl/ContainerRegistry */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistry.ts");
/**
 * This extension install a View Manager into the context
 */
var ViewManagerExtension = /** @class */ (function () {
    function ViewManagerExtension() {
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ViewManagerExtension.prototype.extend = function (context) {
        context.whenInitializing(this.whenInitializing.bind(this));
        context.whenDestroying(this.whenDestroying.bind(this));
        this._injector = context.injector;
        // Just one Container Registry
        ViewManagerExtension._containerRegistry = ViewManagerExtension._containerRegistry || new ContainerRegistry_1.ContainerRegistry();
        this._injector.bind(ContainerRegistry_1.ContainerRegistry).toConstantValue(ViewManagerExtension._containerRegistry);
        // But you get your own View Manager
        this._injector
            .bind(IViewManager_1.IViewManager)
            .to(ViewManager_1.ViewManager)
            .inSingletonScope();
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    ViewManagerExtension.prototype.whenInitializing = function () {
        this._viewManager = this._injector.get(IViewManager_1.IViewManager);
    };
    ViewManagerExtension.prototype.whenDestroying = function () {
        this._viewManager.removeAllHandlers();
        this._injector.unbind(IViewManager_1.IViewManager);
        this._injector.unbind(ContainerRegistry_1.ContainerRegistry);
    };
    return ViewManagerExtension;
}());
exports.ViewManagerExtension = ViewManagerExtension;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/api/IViewManager.ts":
/*!*************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/api/IViewManager.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
/*[Event(name="containerAdd", type="robotlegs.bender.extensions.viewManager.impl.ViewManagerEvent")]*/
/*[Event(name="containerRemove", type="robotlegs.bender.extensions.viewManager.impl.ViewManagerEvent")]*/
/*[Event(name="handlerAdd", type="robotlegs.bender.extensions.viewManager.impl.ViewManagerEvent")]*/
/*[Event(name="handlerRemove", type="robotlegs.bender.extensions.viewManager.impl.ViewManagerEvent")]*/
/**
 * The View Manager allows you to add multiple "view root" containers to a context
 */
exports.IViewManager = Symbol("IViewManager");


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/ConfigureViewEvent.ts":
/*!********************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/ConfigureViewEvent.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
/**
 * View Configuration Event
 * @private
 */
var ConfigureViewEvent = /** @class */ (function (_super) {
    __extends(ConfigureViewEvent, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a view configuration event
     * @param type The event type
     * @param view The associated view instance
     */
    function ConfigureViewEvent(type, view) {
        var _this = _super.call(this, type, true) || this;
        _this._view = view;
        return _this;
    }
    Object.defineProperty(ConfigureViewEvent.prototype, "view", {
        /**
         * The view instance associated with this event
         */
        get: function () {
            return this._view;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ConfigureViewEvent.prototype.clone = function () {
        return new ConfigureViewEvent(this.type, this._view);
    };
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    ConfigureViewEvent.CONFIGURE_VIEW = "configureView";
    return ConfigureViewEvent;
}(core_1.Event));
exports.ConfigureViewEvent = ConfigureViewEvent;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerBinding.ts":
/*!******************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/ContainerBinding.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var ContainerBindingEvent_1 = __webpack_require__(/*! ./ContainerBindingEvent */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerBindingEvent.ts");
/*[Event(name="bindingEmpty", type="robotlegs.bender.extensions.viewManager.impl.ContainerBindingEvent")]*/
/**
 * @private
 */
var ContainerBinding = /** @class */ (function (_super) {
    __extends(ContainerBinding, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function ContainerBinding(container) {
        var _this = _super.call(this) || this;
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        _this._handlers = [];
        _this._container = container;
        return _this;
    }
    Object.defineProperty(ContainerBinding.prototype, "parent", {
        /**
         * @private
         */
        get: function () {
            return this._parent;
        },
        /**
         * @private
         */
        set: function (value) {
            this._parent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContainerBinding.prototype, "container", {
        /**
         * @private
         */
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    ContainerBinding.prototype.addHandler = function (handler) {
        if (this._handlers.indexOf(handler) > -1) {
            return;
        }
        this._handlers.push(handler);
    };
    /**
     * @private
     */
    ContainerBinding.prototype.removeHandler = function (handler) {
        var index = this._handlers.indexOf(handler);
        if (index > -1) {
            this._handlers.splice(index, 1);
            if (this._handlers.length === 0) {
                this.dispatchEvent(new ContainerBindingEvent_1.ContainerBindingEvent(ContainerBindingEvent_1.ContainerBindingEvent.BINDING_EMPTY));
            }
        }
    };
    /**
     * @private
     */
    ContainerBinding.prototype.handleView = function (view, type) {
        var length = this._handlers.length;
        for (var i = 0; i < length; i++) {
            var handler = this._handlers[i];
            handler.handleView(view, type);
        }
    };
    return ContainerBinding;
}(core_1.EventDispatcher));
exports.ContainerBinding = ContainerBinding;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerBindingEvent.ts":
/*!***********************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/ContainerBindingEvent.ts ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
/**
 * @private
 */
var ContainerBindingEvent = /** @class */ (function (_super) {
    __extends(ContainerBindingEvent, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function ContainerBindingEvent(type) {
        return _super.call(this, type) || this;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ContainerBindingEvent.prototype.clone = function () {
        return new ContainerBindingEvent(this.type);
    };
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    ContainerBindingEvent.BINDING_EMPTY = "bindingEmpty";
    return ContainerBindingEvent;
}(core_1.Event));
exports.ContainerBindingEvent = ContainerBindingEvent;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistry.ts":
/*!*******************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistry.ts ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var ContainerBinding_1 = __webpack_require__(/*! ./ContainerBinding */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerBinding.ts");
var ContainerBindingEvent_1 = __webpack_require__(/*! ./ContainerBindingEvent */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerBindingEvent.ts");
var ContainerRegistryEvent_1 = __webpack_require__(/*! ./ContainerRegistryEvent */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistryEvent.ts");
/*[Event(name="containerAdd", type="robotlegs.bender.extensions.viewManager.impl.ContainerRegistryEvent")]*/
/*[Event(name="containerRemove", type="robotlegs.bender.extensions.viewManager.impl.ContainerRegistryEvent")]*/
/*[Event(name="rootContainerAdd", type="robotlegs.bender.extensions.viewManager.impl.ContainerRegistryEvent")]*/
/*[Event(name="rootContainerRemove", type="robotlegs.bender.extensions.viewManager.impl.ContainerRegistryEvent")]*/
/**
 * @private
 */
var ContainerRegistry = /** @class */ (function (_super) {
    __extends(ContainerRegistry, _super);
    function ContainerRegistry() {
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._bindings = [];
        _this._rootBindings = [];
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        _this._bindingByContainer = new Map();
        return _this;
    }
    Object.defineProperty(ContainerRegistry.prototype, "bindings", {
        /**
         * @private
         */
        get: function () {
            return this._bindings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContainerRegistry.prototype, "rootBindings", {
        /**
         * @private
         */
        get: function () {
            return this._rootBindings;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    ContainerRegistry.prototype.addContainer = function (container) {
        var binding = this._bindingByContainer.get(container);
        if (!binding) {
            binding = this.createBinding(container);
            this._bindingByContainer.set(container, binding);
        }
        return binding;
    };
    /**
     * @private
     */
    ContainerRegistry.prototype.removeContainer = function (container) {
        var binding = this._bindingByContainer.get(container);
        if (binding) {
            this.removeBinding(binding);
        }
        return binding;
    };
    /**
     * Finds the closest parent binding for a given display object
     *
     * @private
     */
    ContainerRegistry.prototype.findParentBinding = function (target) {
        var parent = target.parent;
        while (parent) {
            var binding = this._bindingByContainer.get(parent);
            if (binding) {
                return binding;
            }
            parent = parent.parent;
        }
        return null;
    };
    /**
     * @private
     */
    ContainerRegistry.prototype.getBinding = function (container) {
        return this._bindingByContainer.get(container);
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    ContainerRegistry.prototype.createBinding = function (container) {
        var _this = this;
        var binding = new ContainerBinding_1.ContainerBinding(container);
        this._bindings.push(binding);
        // Add a listener so that we can remove this binding when it has no handlers
        binding.addEventListener(ContainerBindingEvent_1.ContainerBindingEvent.BINDING_EMPTY, this.onBindingEmpty.bind(this));
        // If the new binding doesn't have a parent it is a Root
        binding.parent = this.findParentBinding(container);
        if (binding.parent == null) {
            this.addRootBinding(binding);
        }
        // Reparent any bindings which are contained within the new binding AND
        // A. Don't have a parent, OR
        // B. Have a parent that is not contained within the new binding
        this._bindingByContainer.forEach(function (childBinding) {
            if (container.contains(childBinding.container)) {
                if (!childBinding.parent) {
                    _this.removeRootBinding(childBinding);
                    childBinding.parent = binding;
                }
                else if (!container.contains(childBinding.parent.container)) {
                    childBinding.parent = binding;
                }
            }
        });
        this.dispatchEvent(new ContainerRegistryEvent_1.ContainerRegistryEvent(ContainerRegistryEvent_1.ContainerRegistryEvent.CONTAINER_ADD, binding.container));
        return binding;
    };
    ContainerRegistry.prototype.removeBinding = function (binding) {
        var _this = this;
        // Remove the binding itself
        this._bindingByContainer.delete(binding.container);
        var index = this._bindings.indexOf(binding);
        this._bindings.splice(index, 1);
        // Drop the empty binding listener
        binding.removeEventListener(ContainerBindingEvent_1.ContainerBindingEvent.BINDING_EMPTY, this.onBindingEmpty);
        if (!binding.parent) {
            // This binding didn't have a parent, so it was a Root
            this.removeRootBinding(binding);
        }
        // Re-parent the bindings
        this._bindingByContainer.forEach(function (childBinding) {
            if (childBinding.parent === binding) {
                childBinding.parent = binding.parent;
                if (!childBinding.parent) {
                    // This binding used to have a parent,
                    // but no longer does, so it is now a Root
                    _this.addRootBinding(childBinding);
                }
            }
        });
        this.dispatchEvent(new ContainerRegistryEvent_1.ContainerRegistryEvent(ContainerRegistryEvent_1.ContainerRegistryEvent.CONTAINER_REMOVE, binding.container));
    };
    ContainerRegistry.prototype.addRootBinding = function (binding) {
        this._rootBindings.push(binding);
        this.dispatchEvent(new ContainerRegistryEvent_1.ContainerRegistryEvent(ContainerRegistryEvent_1.ContainerRegistryEvent.ROOT_CONTAINER_ADD, binding.container));
    };
    ContainerRegistry.prototype.removeRootBinding = function (binding) {
        var index = this._rootBindings.indexOf(binding);
        this._rootBindings.splice(index, 1);
        this.dispatchEvent(new ContainerRegistryEvent_1.ContainerRegistryEvent(ContainerRegistryEvent_1.ContainerRegistryEvent.ROOT_CONTAINER_REMOVE, binding.container));
    };
    ContainerRegistry.prototype.onBindingEmpty = function (event) {
        this.removeBinding(event.target);
    };
    return ContainerRegistry;
}(core_1.EventDispatcher));
exports.ContainerRegistry = ContainerRegistry;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistryEvent.ts":
/*!************************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistryEvent.ts ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
/**
 * Container existence event
 * @private
 */
var ContainerRegistryEvent = /** @class */ (function (_super) {
    __extends(ContainerRegistryEvent, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a new container existence event
     * @param type The event type
     * @param container The container associated with this event
     */
    function ContainerRegistryEvent(type, container) {
        var _this = _super.call(this, type) || this;
        _this._container = container;
        return _this;
    }
    Object.defineProperty(ContainerRegistryEvent.prototype, "container", {
        /**
         * The container associated with this event
         */
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ContainerRegistryEvent.prototype.clone = function () {
        return new ContainerRegistryEvent(this.type, this._container);
    };
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    ContainerRegistryEvent.CONTAINER_ADD = "containerAdd";
    ContainerRegistryEvent.CONTAINER_REMOVE = "containerRemove";
    ContainerRegistryEvent.ROOT_CONTAINER_ADD = "rootContainerAdd";
    ContainerRegistryEvent.ROOT_CONTAINER_REMOVE = "rootContainerRemove";
    return ContainerRegistryEvent;
}(core_1.Event));
exports.ContainerRegistryEvent = ContainerRegistryEvent;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/ManualStageObserver.ts":
/*!*********************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/ManualStageObserver.ts ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var ContainerRegistryEvent_1 = __webpack_require__(/*! ./ContainerRegistryEvent */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistryEvent.ts");
var ConfigureViewEvent_1 = __webpack_require__(/*! ./ConfigureViewEvent */ "./src/robotlegs/bender/extensions/viewManager/impl/ConfigureViewEvent.ts");
/**
 * @private
 */
var ManualStageObserver = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function ManualStageObserver(containerRegistry) {
        var _this = this;
        this._registry = containerRegistry;
        // We care about all containers (not just roots)
        this._registry.addEventListener(ContainerRegistryEvent_1.ContainerRegistryEvent.CONTAINER_ADD, this.onContainerAdd, this);
        this._registry.addEventListener(ContainerRegistryEvent_1.ContainerRegistryEvent.CONTAINER_REMOVE, this.onContainerRemove, this);
        // We might have arrived late on the scene
        this._registry.bindings.forEach(function (binding) {
            _this.addContainerListener(binding.container);
        });
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    ManualStageObserver.prototype.destroy = function () {
        var _this = this;
        this._registry.removeEventListener(ContainerRegistryEvent_1.ContainerRegistryEvent.CONTAINER_ADD, this.onContainerAdd, this);
        this._registry.removeEventListener(ContainerRegistryEvent_1.ContainerRegistryEvent.CONTAINER_REMOVE, this.onContainerRemove, this);
        this._registry.rootBindings.forEach(function (binding) {
            _this.removeContainerListener(binding.container);
        });
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    ManualStageObserver.prototype.onContainerAdd = function (event) {
        this.addContainerListener(event.container);
    };
    ManualStageObserver.prototype.onContainerRemove = function (event) {
        this.removeContainerListener(event.container);
    };
    ManualStageObserver.prototype.addContainerListener = function (container) {
        // We're interested in ALL container bindings
        // but just for normal, bubbling events
        this._eventListener = this.onConfigureView.bind(this);
        container.addEventListener(ConfigureViewEvent_1.ConfigureViewEvent.CONFIGURE_VIEW, this._eventListener);
    };
    ManualStageObserver.prototype.removeContainerListener = function (container) {
        container.removeEventListener(ConfigureViewEvent_1.ConfigureViewEvent.CONFIGURE_VIEW, this._eventListener);
    };
    ManualStageObserver.prototype.onConfigureView = function (event) {
        // Stop that event!
        event.stopPropagation();
        var container = event.currentTarget;
        var view = event.target;
        var type = view.constructor;
        this._registry.getBinding(container).handleView(view, type);
    };
    return ManualStageObserver;
}());
exports.ManualStageObserver = ManualStageObserver;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/StageCrawler.ts":
/*!**************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/StageCrawler.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var DisplayObjectContainer_1 = __webpack_require__(/*! openfl/display/DisplayObjectContainer */ "./node_modules/openfl/lib/openfl/display/DisplayObjectContainer.js");
/**
 * @private
 */
var StageCrawler = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function StageCrawler(containerBinding) {
        this._binding = containerBinding;
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    StageCrawler.prototype.scan = function (container) {
        this.scanContainer(container);
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    StageCrawler.prototype.scanContainer = function (container) {
        this.processView(container);
        for (var i = 0; i < container.numChildren; i++) {
            var child = container.getChildAt(i);
            if (child instanceof DisplayObjectContainer_1.default) {
                this.scanContainer(child);
            }
            else {
                this.processView(child);
            }
        }
    };
    StageCrawler.prototype.processView = function (view) {
        this._binding.handleView(view, view.constructor);
    };
    return StageCrawler;
}());
exports.StageCrawler = StageCrawler;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/StageObserver.ts":
/*!***************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/StageObserver.ts ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
var ContainerRegistryEvent_1 = __webpack_require__(/*! ./ContainerRegistryEvent */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistryEvent.ts");
var Event_1 = __webpack_require__(/*! openfl/events/Event */ "./node_modules/openfl/lib/openfl/events/Event.js");
/**
 * @private
 */
var StageObserver = /** @class */ (function () {
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function StageObserver(containerRegistry) {
        var _this = this;
        this.onViewAddedToStage = function (event) {
            var view = event.target;
            var type = view.constructor;
            // Walk upwards from the nearest binding
            var binding = _this._registry.findParentBinding(view);
            while (binding) {
                binding.handleView(view, type);
                binding = binding.parent;
            }
        };
        this._registry = containerRegistry;
        // We only care about roots
        this._registry.addEventListener(ContainerRegistryEvent_1.ContainerRegistryEvent.ROOT_CONTAINER_ADD, this.onRootContainerAdd, this);
        this._registry.addEventListener(ContainerRegistryEvent_1.ContainerRegistryEvent.ROOT_CONTAINER_REMOVE, this.onRootContainerRemove, this);
        // We might have arrived late on the scene
        this._registry.rootBindings.forEach(function (binding) {
            _this.addRootListener(binding.container);
        });
    }
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @private
     */
    StageObserver.prototype.destroy = function () {
        var _this = this;
        this._registry.removeEventListener(ContainerRegistryEvent_1.ContainerRegistryEvent.ROOT_CONTAINER_ADD, this.onRootContainerAdd, this);
        this._registry.removeEventListener(ContainerRegistryEvent_1.ContainerRegistryEvent.ROOT_CONTAINER_REMOVE, this.onRootContainerRemove, this);
        this._registry.rootBindings.forEach(function (binding) {
            _this.removeRootListener(binding.container);
        });
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    StageObserver.prototype.onRootContainerAdd = function (event) {
        this.addRootListener(event.container);
    };
    StageObserver.prototype.onRootContainerRemove = function (event) {
        this.removeRootListener(event.container);
    };
    StageObserver.prototype.addRootListener = function (container) {
        container.addEventListener(Event_1.default.ADDED_TO_STAGE, this.onViewAddedToStage, true);
    };
    StageObserver.prototype.removeRootListener = function (container) {
        container.removeEventListener(Event_1.default.ADDED_TO_STAGE, this.onViewAddedToStage, true);
    };
    return StageObserver;
}());
exports.StageObserver = StageObserver;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/ViewManager.ts":
/*!*************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/ViewManager.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
var ViewManagerEvent_1 = __webpack_require__(/*! ./ViewManagerEvent */ "./src/robotlegs/bender/extensions/viewManager/impl/ViewManagerEvent.ts");
var ContainerRegistry_1 = __webpack_require__(/*! ./ContainerRegistry */ "./src/robotlegs/bender/extensions/viewManager/impl/ContainerRegistry.ts");
/*[Event(name="containerAdd", type="robotlegs.bender.extensions.viewManager.impl.ViewManagerEvent")]*/
/*[Event(name="containerRemove", type="robotlegs.bender.extensions.viewManager.impl.ViewManagerEvent")]*/
/*[Event(name="handlerAdd", type="robotlegs.bender.extensions.viewManager.impl.ViewManagerEvent")]*/
/*[Event(name="handlerRemove", type="robotlegs.bender.extensions.viewManager.impl.ViewManagerEvent")]*/
/**
 * @private
 */
var ViewManager = /** @class */ (function (_super) {
    __extends(ViewManager, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * @private
     */
    function ViewManager(containerRegistry) {
        var _this = _super.call(this) || this;
        /*============================================================================*/
        /* Public Properties                                                          */
        /*============================================================================*/
        _this._containers = [];
        /*============================================================================*/
        /* Private Properties                                                         */
        /*============================================================================*/
        _this._handlers = [];
        _this._registry = containerRegistry;
        return _this;
    }
    Object.defineProperty(ViewManager.prototype, "containers", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._containers;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ViewManager.prototype.addContainer = function (container) {
        var _this = this;
        if (!this.validContainer(container)) {
            return;
        }
        this._containers.push(container);
        this._handlers.forEach(function (handler) {
            _this._registry.addContainer(container).addHandler(handler);
        });
        this.dispatchEvent(new ViewManagerEvent_1.ViewManagerEvent(ViewManagerEvent_1.ViewManagerEvent.CONTAINER_ADD, container));
    };
    /**
     * @inheritDoc
     */
    ViewManager.prototype.removeContainer = function (container) {
        var index = this._containers.indexOf(container);
        if (index === -1) {
            return;
        }
        this._containers.splice(index, 1);
        var binding = this._registry.getBinding(container);
        this._handlers.forEach(function (handler) {
            binding.removeHandler(handler);
        });
        this.dispatchEvent(new ViewManagerEvent_1.ViewManagerEvent(ViewManagerEvent_1.ViewManagerEvent.CONTAINER_REMOVE, container));
    };
    /**
     * @inheritDoc
     */
    ViewManager.prototype.addViewHandler = function (handler) {
        var _this = this;
        if (this._handlers.indexOf(handler) !== -1) {
            return;
        }
        this._handlers.push(handler);
        this._containers.forEach(function (container) {
            _this._registry.addContainer(container).addHandler(handler);
        });
        this.dispatchEvent(new ViewManagerEvent_1.ViewManagerEvent(ViewManagerEvent_1.ViewManagerEvent.HANDLER_ADD, null, handler));
    };
    /**
     * @inheritDoc
     */
    ViewManager.prototype.removeViewHandler = function (handler) {
        var _this = this;
        var index = this._handlers.indexOf(handler);
        if (index === -1) {
            return;
        }
        this._handlers.splice(index, 1);
        this._containers.forEach(function (container) {
            _this._registry.getBinding(container).removeHandler(handler);
        });
        this.dispatchEvent(new ViewManagerEvent_1.ViewManagerEvent(ViewManagerEvent_1.ViewManagerEvent.HANDLER_REMOVE, null, handler));
    };
    /**
     * @inheritDoc
     */
    ViewManager.prototype.removeAllHandlers = function () {
        var _this = this;
        var binding = null;
        this._containers.forEach(function (container) {
            binding = _this._registry.getBinding(container);
            _this._handlers.forEach(function (handler) {
                binding.removeHandler(handler);
            });
        });
    };
    /*============================================================================*/
    /* Private Functions                                                          */
    /*============================================================================*/
    ViewManager.prototype.validContainer = function (container) {
        var isValid = this._containers.indexOf(container) < 0;
        if (isValid) {
            this._containers.forEach(function (registeredContainer) {
                if (registeredContainer.contains(container) || container.contains(registeredContainer)) {
                    throw new Error("Containers can not be nested");
                }
            });
        }
        return isValid;
    };
    ViewManager = __decorate([
        core_1.injectable(),
        __param(0, core_1.inject(ContainerRegistry_1.ContainerRegistry)),
        __metadata("design:paramtypes", [ContainerRegistry_1.ContainerRegistry])
    ], ViewManager);
    return ViewManager;
}(core_1.EventDispatcher));
exports.ViewManager = ViewManager;


/***/ }),

/***/ "./src/robotlegs/bender/extensions/viewManager/impl/ViewManagerEvent.ts":
/*!******************************************************************************!*\
  !*** ./src/robotlegs/bender/extensions/viewManager/impl/ViewManagerEvent.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ------------------------------------------------------------------------------
//  Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
//
//  NOTICE: You are permitted to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
// ------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! @robotlegsjs/core */ "./node_modules/@robotlegsjs/core/lib/index.js");
/**
 * Container existence event
 * @private
 */
var ViewManagerEvent = /** @class */ (function (_super) {
    __extends(ViewManagerEvent, _super);
    /*============================================================================*/
    /* Constructor                                                                */
    /*============================================================================*/
    /**
     * Creates a view manager event
     * @param type The event type
     * @param container The container associated with this event
     * @param handler The view handler associated with this event
     */
    function ViewManagerEvent(type, container, handler) {
        var _this = _super.call(this, type) || this;
        _this._container = container;
        _this._handler = handler;
        return _this;
    }
    Object.defineProperty(ViewManagerEvent.prototype, "container", {
        /**
         * The container associated with this event
         */
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewManagerEvent.prototype, "handler", {
        /**
         * The view handler associated with this event
         */
        get: function () {
            return this._handler;
        },
        enumerable: true,
        configurable: true
    });
    /*============================================================================*/
    /* Public Functions                                                           */
    /*============================================================================*/
    /**
     * @inheritDoc
     */
    ViewManagerEvent.prototype.clone = function () {
        return new ViewManagerEvent(this.type, this._container, this._handler);
    };
    /*============================================================================*/
    /* Public Static Properties                                                   */
    /*============================================================================*/
    ViewManagerEvent.CONTAINER_ADD = "containerAdd";
    ViewManagerEvent.CONTAINER_REMOVE = "containerRemove";
    ViewManagerEvent.HANDLER_ADD = "handlerAdd";
    ViewManagerEvent.HANDLER_REMOVE = "handlerRemove";
    return ViewManagerEvent;
}(core_1.Event));
exports.ViewManagerEvent = ViewManagerEvent;


/***/ })

/******/ });
//# sourceMappingURL=game.95fb1da5c05e5e57495f.js.map